{"config": {"lang": ["pt"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "ai-resources/ai-resources/", "title": "Recursos de IA", "text": "<p>A Tanssi fornece arquivos <code>.txt</code> contendo o conteúdo da documentação e a estrutura de navegação, otimizados para uso com Templates de linguagem (LLMs) e ferramentas de IA. Esses recursos ajudam a criar assistentes de IA, potencializam buscas em código ou permitem ferramentas personalizadas treinadas na documentação da Tanssi.</p> <p>Cada arquivo por categoria inclui o conteúdo básico das categorias Basics e Reference para garantir que os LLMs tenham o contexto necessário.</p>"}, {"location": "ai-resources/ai-resources/#baixar-arquivos-para-llm", "title": "Baixar Arquivos para LLM", "text": "Categoria Descrição Arquivo Ações Índice Índice de navegação de todas as páginas da documentação Tanssi <code>llms.txt</code> Documentação Completa Conteúdo completo de todas as páginas da documentação <code>llms-full.txt</code> Basics Framework, arquitetura e componentes centrais da Tanssi para formar a base de conhecimento geral <code>llms-basics.txt</code> Reference Material de referência, incluindo endpoints de rede, métodos JSON RPC e endereços de contratos ou tokens <code>llms-reference.txt</code> Appchain Como lançar e gerenciar uma appchain via dApp ou portal do desenvolvedor <code>llms-appchain.txt</code> Runtime Personalizado Como personalizar o runtime da sua appchain <code>llms-custom-runtime.txt</code> Template EVM Use o template EVM para lançar appchains compatíveis com Ethereum e conhecer seu tooling associado (carteiras, integrações etc.) <code>llms-evm-template.txt</code> Template Substrate Use o template Substrate básico e o tooling associado (carteiras, integrações etc.) para lançar appchains <code>llms-substrate-template.txt</code> Operators Como configurar e executar um nó para proteger o ecossistema Tanssi <code>llms-operators.txt</code> Sequencers Como executar um sequencer para fornecer serviços de produção de blocos às appchains <code>llms-sequencers.txt</code> <p>Note</p> <p>O arquivo <code>llms-full.txt</code> pode exceder o limite de entrada de alguns Templates de linguagem devido ao seu tamanho. Se você encontrar limitações, considere usar os arquivos por categoria.</p>"}, {"location": "builders/", "title": "Builders", "text": "<p>Explore tudo o que precisa para construir, implementar e gerir redes dentro do ecossistema Tanssi. De ferramentas de desenvolvimento à gestão de contas e conectividade de rede, o conteúdo desta secção permite que avance com confiança do conceito à implementação.</p>"}, {"location": "builders/#construir-uma-rede-com-tanssi", "title": "Construir uma Rede com TanssiPor Onde Começar?Personalizar a Sua Rede", "text": "<ul> <li> <p>  Construir uma rede do zero usando um Template</p> <p> Configurar um runtime existente baseado em Substrate para ser compatível com Tanssi</p> </li> <li> <p>  Utilizar módulos pré-existentes para adicionar funcionalidades</p> <p> Criar o seu próprio módulo personalizado</p> <p> Integrar módulos externos de outros fornecedores</p> </li> </ul>"}, {"location": "builders/#implementar-e-gerir-uma-rede-com-tanssi", "title": "Implementar e Gerir uma Rede com TanssiPronto para Implementar?Ações Pós-Implementação", "text": "<ul> <li> <p>  Implementar a sua rede com a Tanssi dApp</p> </li> <li> <p>  Pagar pelos serviços de produção de blocos</p> <p> Cunhar tokens para a economia da sua rede</p> <p> Gerir a conta Sudo para controlo administrativo</p> </li> </ul>"}, {"location": "builders/#interagir-com-uma-rede-com-tanssi", "title": "Interagir com uma Rede com TanssiReferências de Rede TanssiFerramentas para Desenvolvimento de Rede Tanssi", "text": "<ul> <li> <p>  Aceder aos endpoints da rede</p> </li> <li> <p>  Explorar ferramentas para integração de API Ethereum</p> <p> Utilizar ferramentas Substrate para controlo avançado da rede</p> <p> Melhorar a funcionalidade da sua aplicação com integrações</p> </li> </ul>"}, {"location": "builders/#explore-esta-seccao", "title": "Explore Esta Secção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/account-management/", "title": "Gerenciamento de Contas", "text": "<p>O gerenciamento de contas on-chain oferece aos usuários e desenvolvedores maior flexibilidade e controle sobre como suas contas interagem com uma rede descentralizada. Você pode ajustar suas configurações de conta para uma integração perfeita dentro do ecossistema, gerenciando funções, permissões e identidades diretamente na blockchain.</p> <p>Esta seção descreve algumas das ferramentas e recursos relacionados ao gerenciamento de contas.</p>"}, {"location": "builders/account-management/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/account-management/identity/", "title": "Configurar uma Identidade On-Chain", "text": ""}, {"location": "builders/account-management/identity/#introduction", "title": "Introdução", "text": "<p>O Substrate Identity module é uma solução pronta para uso para adicionar informações pessoais à sua conta on-chain. O estabelecimento de uma identidade torna mais fácil para sua conta ser reconhecida por outros, pois seu nome de exibição preencherá automaticamente quando alguém colar seu endereço em um campo no portal do desenvolvedor.</p> <p>A identidade que você configura vai além de um simples nome de exibição. As informações pessoais podem incluir campos padrão, como seu nome legal, nome de exibição, site, identificador do Twitter, Discord e nome do Riot (agora conhecido como Element). Você também pode usar campos personalizados para incluir quaisquer outras informações relevantes.</p> <p>Este guia demonstrará como configurar uma identidade com um nome de exibição e parâmetros adicionais, aprimorando sua visibilidade e reconhecimento.</p>"}, {"location": "builders/account-management/identity/#general-definitions", "title": "Definições Gerais", "text": "<p>Para armazenar suas informações on-chain, você deve vincular alguns fundos, que, eventualmente, serão devolvidos assim que a identidade for limpa. Existem duas categorias de campos: padrão e personalizado. Uma quantia básica de depósito é reservada após a criação da identidade e um depósito de armazenamento é necessário para cada byte adicional de dados armazenados on-chain.</p> <ul> <li> <p>Campos padrão incluem - seu nome legal, nome de exibição, site, identificador do Twitter, Discord, nome do Riot (agora conhecido como Element)</p> </li> <li> <p>Campos personalizados incluem - quaisquer outras informações relevantes</p> </li> <li> <p>Subcontas - Você pode vincular subcontas sob uma conta primária. Por exemplo, um serviço de Sequencer que está executando vários nós de Sequencer diferentes pode estabelecer subcontas para demonstrar um link oficial entre os nós</p> </li> </ul> Tanssi MainNetDancelight TestNet Variável Definição Valor Depósito básico O valor mantido em depósito para a definição de uma identidade 0.33333333 TANSSI Depósito por byte O valor mantido em depósito por byte de armazenamento on-chain usado na definição de uma identidade 0.0001 TANSSI Campos adicionais máx. Número máximo de campos adicionais que podem ser armazenados em um ID 100 Subcontas máx. Número máximo de subcontas que podem ser definidas sob uma identidade de conta 100 Variável Definição Valor Depósito básico O valor mantido em depósito para a definição de uma identidade 0.33333333 STAR Depósito por byte O valor mantido em depósito por byte de armazenamento on-chain usado na definição de uma identidade 0.0001 STAR Campos adicionais máx. Número máximo de campos adicionais que podem ser armazenados em um ID 100 Subcontas máx. Número máximo de subcontas que podem ser definidas sob uma identidade de conta 100"}, {"location": "builders/account-management/identity/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para acompanhar este guia, você precisará do seguinte:</p> Tanssi MainNetDancelight TestNet <ul> <li>O portal do desenvolvedor aberto e conectado à Tanssi MainNet.</li> <li>Pelo menos uma conta financiada com tokens <code>TANSSI</code>.</li> </ul> <ul> <li>O portal do desenvolvedor aberto e conectado ao Dancelight.</li> <li>Pelo menos uma conta financiada com tokens <code>STAR</code>.</li> </ul> <p>Se precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia Conectando-se ao portal do desenvolvedor.</p>"}, {"location": "builders/account-management/identity/#get-started", "title": "Comece", "text": "<p>Dependendo das informações a serem incluídas, existem algumas maneiras diferentes de definir e limpar uma identidade usando o portal do desenvolvedor. Se você pretende registrar sua identidade usando apenas os campos padrão, pode seguir as instruções da página Gerenciando uma Identidade via Contas. Esta é a Maneira Recomendada de Definir e Gerenciar Sua Identidade.</p> <p>Se você deseja adicionar campos personalizados além dos campos padrão, siga as instruções para a página Gerenciando uma Identidade via Extrinsics.</p> <p>Note</p> <p>Observe que o uso da página Contas no portal do desenvolvedor é recomendado para gerenciar sua identidade, pois ela fornece uma interface fácil de usar que impõe limites de caracteres. Se você usar a página Extrinsics, esteja ciente de que sua entrada para cada campo (ou seja, nome, e-mail, etc.) deve ter 32 caracteres ou menos; caso contrário, suas informações serão cortadas.</p>"}, {"location": "builders/account-management/identity/#manage-via-accounts", "title": "Gerenciar uma Identidade via Contas", "text": ""}, {"location": "builders/account-management/identity/#set-identity-via-accounts", "title": "Definir uma Identidade", "text": "<p>Para começar a definir uma identidade usando a página Contas, vá para a guia Contas do portal do desenvolvedor.</p> <p>Você já deve ter uma conta conectada, então você pode clicar no nome da sua conta para verificar e observar seus saldos. Depois de enviar a transação para definir uma identidade, os depósitos que você enviou serão movidos do seu saldo transferível para seu saldo reservado.</p> <p></p> <p>Para definir sua identidade, você precisará:</p> <ol> <li>Clique nos três pontos verticais ao lado da conta para a qual deseja definir uma identidade</li> <li>Um menu aparecerá. Clique em Set on-chain identity</li> </ol> <p></p> <p>Em seguida, o menu para registrar e definir sua identidade aparecerá e você poderá começar a preencher suas informações. Você não é obrigado a inserir informações para todos os campos; você pode escolher preencher apenas um campo ou todos eles; a escolha é sua. Para este exemplo:</p> <ol> <li>Defina seu nome de exibição</li> <li>Clique no botão include field para e-mail e depois insira seu e-mail</li> <li>Clique no botão include field para web e depois insira a URL do seu site</li> <li>Clique no botão include field para Twitter e depois insira seu identificador do Twitter</li> <li>Reveja os campos de dados anteriores e clique em Set Identity</li> </ol> <p></p> <p>Você será solicitado a assinar a transação. Se tudo estiver correto, assine-a.</p> <p>Você deve ver as notificações de status aparecerem no canto superior direito. Depois que a transação for confirmada, você pode clicar no nome da sua conta novamente, e o painel deslizará para fora no lado direito da página. Seus saldos terão sido alterados e você também verá suas novas informações de identidade.</p> <p></p> <p>Se as informações de identidade corresponderem ao que você inseriu, você definiu com sucesso uma identidade!</p> <p>Depois de limpar sua identidade, o depósito em seu saldo reservado será transferido de volta para seu saldo transferível. Se você precisar alterar sua identidade, pode passar pelo processo de configuração da sua identidade novamente. Observe que você deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles serão substituídos. Você não precisará pagar outro depósito, a menos que campos personalizados sejam usados, mas precisará pagar taxas de gás.</p>"}, {"location": "builders/account-management/identity/#manage-via-extrinsics", "title": "Gerenciar uma Identidade via Extrinsics", "text": ""}, {"location": "builders/account-management/identity/#set-identity-extrinsics", "title": "Definir uma Identidade", "text": "<p>Para registrar uma identidade usando a página de extrínsecos, navegue até a página Extrinsics do portal do desenvolvedor. Certifique-se de que sua entrada não exceda 32 caracteres para cada campo de identidade. Para concluir sua identidade, siga as etapas a seguir:</p> <ol> <li>Selecione sua conta</li> <li>Selecione identidade no menu suspenso enviar o seguinte extrínseco</li> <li>Em seguida, selecione a função setIdentity(info)</li> <li>Selecione Raw como o formato de dados para inserir seu Nome de Exibição</li> <li>Insira os dados para Exibição no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu endereço da web</li> <li>Insira a URL do seu site no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu e-mail</li> <li>Insira seu endereço de e-mail no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu identificador do Twitter</li> <li>Insira seu Twitter no formato selecionado. Insira apenas o nome de usuário, começando com o símbolo <code>@</code></li> <li>Reveja os campos preparados e pressione Enviar Transação </li> </ol> <p>Opcionalmente, se você quiser inserir campos personalizados, siga as seguintes etapas:</p> <ol> <li>Role para o topo e clique em Add item</li> <li>Dois campos aparecerão: o primeiro para o nome do campo e o segundo para o valor. Selecione Raw como o formato de dados para inserir o nome do campo</li> <li>Insira o nome do campo no formato especificado</li> <li>Selecione Raw como o formato de dados para inserir o valor personalizado</li> <li>Insira o valor personalizado no formato especificado</li> </ol> <p></p> <p>Finalmente, depois que todas as informações de identidade forem adicionadas, você pode rolar para a parte inferior da página e clicar em Submit Transaction.</p> <p>Você será solicitado a assinar a transação. Lembre-se, um depósito adicional é necessário para cada campo personalizado adicional. Se tudo estiver correto, assine a transação.</p> <p>Você deve ver as notificações de status aparecerem no canto superior direito confirmando a transação. Se bem-sucedido, você definiu uma identidade! Parabéns! Para garantir que tudo tenha sido concluído e que suas informações de identidade tenham uma boa aparência, você pode verificar sua identidade.</p>"}, {"location": "builders/account-management/identity/#confirm-identity-extrinsics", "title": "Confirmar uma Identidade", "text": "<p>Para verificar a adição de suas informações de identidade, você pode clicar na guia Developer e, em seguida, navegar até o Chain state.</p> <p>Na página Chain State, certifique-se de que Storage esteja selecionado. Em seguida, você pode começar a solicitar suas informações de identidade:</p> <ol> <li>Defina a selected state query como identity</li> <li>Selecione a função identityOf(AccountId)</li> <li>Selecione sua conta</li> <li>Clique no botão + para obter suas informações de identidade</li> </ol> <p></p> <p>Você pode ver agora que você definiu com sucesso uma identidade! Depois de limpar sua identidade, o depósito em seu saldo reservado será transferido de volta para seu saldo transferível. Se você precisar alterar sua identidade, pode passar pelo processo de configuração da sua identidade novamente. Observe que você deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles serão substituídos. Você não precisará pagar outro depósito, a menos que campos personalizados sejam usados, mas precisará pagar taxas de gás.</p>"}, {"location": "builders/account-management/identity/#clear-identity-extrinsics", "title": "Limpar uma Identidade", "text": "<p>Para limpar sua identidade, siga as seguintes etapas na guia Extrinsics do portal do desenvolvedor:</p> <ol> <li>Selecione sua conta no menu suspenso usando a conta selecionada</li> <li>Selecione identity no menu suspenso enviar o seguinte extrínseco</li> <li>Em seguida, selecione a função clearIdentity()</li> <li>Clique em Enviar Transação</li> </ol> <p></p> <p>Você será solicitado a assinar a transação. Se tudo estiver correto, assine-a. Você deve ver as notificações de status no canto superior direito confirmando a transação.</p> <p>Para confirmar se suas informações de identidade foram removidas com sucesso, revise as etapas descritas na seção Confirmar uma Identidade. Desta vez, em vez de exibir seus detalhes de identidade, a resposta deve indicar none, confirmando que nenhuma informação de identidade está atualmente vinculada à sua conta. Além disso, ao verificar seus saldos, você descobrirá que o depósito inicialmente feito para definir sua identidade foi creditado de volta ao seu saldo transferível. Isso conclui o processo de limpeza da sua identidade.</p> <p></p>"}, {"location": "builders/account-management/proxy-accounts/", "title": "Contas Proxy", "text": ""}, {"location": "builders/account-management/proxy-accounts/#introduction", "title": "Introdução", "text": "<p>As contas proxy podem ser configuradas para executar um número limitado de ações em nome das contas primárias e são úteis para manter as contas subjacentes seguras. Sua conta proxy pode atuar como uma \"carteira quente\" para interagir com a rede em nome de sua conta de \"carteira fria\". Para maior segurança, você pode rotacionar regularmente a conta proxy.</p> <p>As contas proxy também podem ajudá-lo a implementar o princípio do privilégio mínimo para controle de acesso. Por exemplo, se você tiver vários membros da equipe, poderá fornecer a eles o nível mínimo de acesso necessário para realizar suas tarefas por meio de um tipo específico de conta proxy.</p> <p>Este tutorial o guiará pela configuração de uma conta proxy no Dancelight, o Tanssi TestNet, especificamente para transferências de saldo. Em seguida, demonstrará como realizar uma transferência de saldo usando o proxy recém-criado.</p>"}, {"location": "builders/account-management/proxy-accounts/#verifying-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisará ter:</p> <ul> <li>Polkadot.js Apps aberto e conectado ao Dancelight.</li> <li>Crie ou tenha duas contas acessíveis no portal do desenvolvedor.</li> <li>Pelo menos uma das contas precisará ser financiada com tokens <code>STAR</code>.</li> </ul> <p>Se precisar de ajuda para importar suas contas para o Polkadot.js Apps, consulte o guia Conectando-se ao Polkadot.js.</p>"}, {"location": "builders/account-management/proxy-accounts/#general-definitions", "title": "Definições Gerais", "text": "<p>Ao configurar uma conta proxy, uma garantia para o proxy é retirada de seu saldo livre e movida para seu saldo reservado. A garantia é necessária, pois a adição de um proxy requer espaço de armazenamento na cadeia e é recalculada para cada proxy que você adiciona ou remove. A garantia é devolvida ao seu saldo livre após a remoção de todos os proxies da sua conta.</p> <p>O depósito é calculado com base em uma base de depósito e um fator de depósito:</p> <ul> <li>Base do depósito - o valor a ser reservado para uma conta ter uma lista de proxies.</li> <li>Fator de depósito - o valor adicional a ser reservado para cada proxy que a conta primária tiver.</li> </ul> <p>A equação para calcular o depósito é:</p> <pre><code>base do depósito + fator de depósito * número de proxies\n</code></pre> <p>Você pode encontrar cada uma das variáveis relevantes abaixo.</p> Tanssi MainNetDancelight TestNet Variável Valor Base do depósito 0.1008 TANSSI Fator de depósito 0.0033 TANSSI Máx. de proxies 32 proxies Variável Valor Base do depósito 0.1008 STAR Fator de depósito 0.0033 STAR Máx. de proxies 32 proxies"}, {"location": "builders/account-management/proxy-accounts/#proxy-types", "title": "Tipos de Proxy", "text": "<p>Ao criar uma conta proxy, você deve escolher um tipo de proxy que definirá como o proxy pode ser usado. As opções disponíveis são:</p> <ul> <li><code>Any</code> - permite que a conta proxy use qualquer função suportada pela palete proxy. Não há filtragem de chamadas.</li> <li><code>NonTransfer</code> - este tipo de conta proxy é permitido para enviar qualquer tipo de transação, com exceção de transferências de saldo.</li> <li><code>Balances</code> - permite que a conta proxy faça apenas transações relacionadas ao envio de fundos.</li> <li><code>Governance</code> - permite que a conta proxy faça apenas transações relacionadas à palete de governança, como votação ou criação de propostas de democracia. Observe que a governança ainda não está habilitada na Tanssi. Você pode criar contas proxy de governança, mas elas não poderão tomar nenhuma ação até que a governança seja habilitada.</li> <li><code>Registrar</code> - permite que a conta proxy faça apenas transações relacionadas à palete do registrador.</li> <li><code>SudoRegistrar</code> - permite que a conta proxy faça apenas transações relacionadas à palete do registrador que precisam ser chamadas por Sudo.</li> <li><code>CancelProxy</code> - permite que a conta proxy rejeite e remova quaisquer chamadas proxy anunciadas.</li> <li><code>Staking</code> - permite que a conta proxy execute transações relacionadas a staking, como funções de Sequencer e <code>session()</code>.</li> <li><code>SessionKeyManagement</code> - permite que a conta proxy faça transações relacionadas ao gerenciamento de chaves incluídas na palete de sessão.</li> </ul> <p>Para este guia, você configurará uma conta proxy usando o tipo de proxy de saldos. Como este tipo permite que o proxy gaste fundos em nome da conta primária, você deve ter cuidado e fornecer acesso apenas a contas em que confia. O proxy terá acesso para transferir todos os fundos dentro da conta primária e, se não for confiável, o proxy poderá drenar a conta primária. Certifique-se de manter a supervisão de suas contas proxy e remover todos os proxies que não forem mais necessários.</p>"}, {"location": "builders/account-management/proxy-accounts/#creating-a-proxy-account", "title": "Criando uma Conta Proxy", "text": "<p>Há algumas maneiras de criar contas proxy no Polkadot.js Apps, seja na página Extrinsics ou na página Accounts. No entanto, para criar um proxy com atraso de tempo, você precisará usar a página Extrinsics. Um atraso de tempo fornece uma camada adicional de segurança para proxies, especificando um período de atraso com base no número de blocos. Isso impedirá que a conta proxy execute uma transação até o final do período de atraso. O atraso permite tempo para a conta primária que controla o proxy revisar as transações pendentes, possivelmente para ações maliciosas, e cancelar, se necessário, antes da execução.</p> <p>A seguinte demonstração mostrará como configurar um proxy Balances, que permite a transferência de fundos, tornando-o perfeito para fins de demonstração. Depois de configurar seu proxy de saldos, você pode tentar transferir fundos da conta primária via proxy.</p> <p>Para começar a criar sua conta proxy, vá para a aba Developer e selecione Extrinsics no menu suspenso. Em seguida, você precisará seguir as seguintes etapas:</p> <ol> <li>Selecione a conta primária.</li> <li>No menu suspenso submit the following extrinsic, selecione proxy.</li> <li>Escolha a extrínseca addProxy.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Selecione a conta delegate para o proxy.</li> <li>No menu suspenso proxyType, escolha Balances.</li> <li>Opcionalmente, você pode adicionar um atraso de tempo usando um número especificado de blocos para adicionar uma camada adicional de segurança para que a conta primária revise a transação pendente.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Você será solicitado a autorizar e assinar a transação. Clique em Sign and Submit para criar o relacionamento proxy. Depois que a transação for enviada com sucesso, você receberá algumas notificações confirmando a transação.</p> <p>Como mencionado anteriormente, você também pode criar um proxy na página Accounts. Para fazer isso, navegue até a página Accounts e siga as seguintes etapas:</p> <ol> <li>Selecione os três pontos verticais ao lado da conta primária.</li> <li>Selecione Add proxy.</li> </ol> <p></p> <p>Note</p> <p>Se a conta já tiver um proxy, Manage proxies será exibido como uma opção em vez de Add proxy.</p> <p>Aparecerá um pop-up e você poderá inserir as informações necessárias, como a conta proxy/primária, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em Add Proxy.</p> <p></p> <p>Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione a conta que deseja definir como proxy.</li> <li>Selecione o tipo de proxy.</li> <li>Clique em Submit e assine a transação.</li> </ol> <p></p> <p>Na próxima seção, você aprenderá como verificar se sua conta proxy foi configurada com sucesso.</p>"}, {"location": "builders/account-management/proxy-accounts/#verifying-your-proxy-account", "title": "Verificando sua Conta Proxy", "text": "<p>Você pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: na página Accounts ou na página Chain state.</p> <p>Para verificar suas contas proxy na página Chain state, você pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso selected state query, selecione proxy.</li> <li>Escolha a extrínseca proxies.</li> <li>Selecione sua conta primária/proxy.</li> <li>Clique no botão + para enviar a consulta.</li> </ol> <p></p> <p>O resultado aparecerá na página, mostrando informações sobre todos os seus proxies, incluindo o endereço da conta delegate/proxy, o tipo de proxy, o período de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.</p> <p>Você também pode verificar suas contas proxy na página Accounts. Para fazer isso, navegue até a página Accounts e deverá haver um símbolo Proxy ao lado da conta primária. Passe o mouse sobre o ícone e clique em Manage proxies para revisar seus proxies.</p> <p></p> <p>Aparecerá um pop-up onde você poderá ver uma visão geral de todas as suas contas proxy.</p> <p></p>"}, {"location": "builders/account-management/proxy-accounts/#executando-uma-transação-proxy", "title": "Executando uma Transação Proxy", "text": "<p>Agora que você criou uma conta proxy e verificou se ela foi configurada com sucesso, você pode executar uma transação usando a conta proxy em nome da conta primária.</p> <p>Para executar uma transação, você pode voltar para a página Extrinsics e seguir as seguintes etapas:</p> <ol> <li>Selecione a conta proxy para enviar a transação pelo menu suspenso using the select account.</li> <li>No menu submit the following extrinsic, selecione proxy.</li> <li>Escolha a extrínseca proxy.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Selecione a conta primária no menu suspenso real.</li> <li>Selecione a chamada balances.</li> <li>Escolha a extrínseca transferKeepAlive.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>No campo dest, insira o endereço para o qual você gostaria de enviar fundos.</li> <li>No campo value, insira a quantidade de tokens <code>STAR</code> para enviar. Para este exemplo, você pode enviar <code>2</code> tokens <code>STAR</code>.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Aparecerá um pop-up para você autorizar e assinar a transação. Insira sua senha para a conta proxy e clique em Sign and Submit.</p> <p>Se a transação for bem-sucedida, você deverá ver alguns pop-ups de notificação. Se você for para a página Accounts, verá que o saldo de sua conta primária diminuiu. Se você verificar o saldo da conta para onde enviou os fundos, notará que o saldo aumentou.</p> <p></p> <p>É isso! Você executou com sucesso uma transação usando uma conta proxy em nome de sua conta primária.</p>"}, {"location": "builders/account-management/proxy-accounts/#removing-a-proxy-account", "title": "Removendo uma Conta Proxy", "text": "<p>Semelhante à adição de uma conta proxy, há algumas maneiras de remover uma conta proxy, seja na página Extrinsics ou na página Accounts. Independentemente de qual página você usar, você pode optar por remover uma única conta proxy ou todos os proxies associados à sua conta primária.</p> <p>Para remover um proxy da página Extrinsics, você pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso using the selected account, selecione sua conta primária.</li> <li>Em seguida, selecione proxy.</li> <li>Escolha removeProxy para remover um único proxy ou removeProxies para remover todos os proxies associados.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Se estiver removendo um único proxy, insira a conta proxy a ser removida no campo delegate.</li> <li>Selecione o proxyType a ser removido, neste caso, escolha Balances.</li> <li>Opcionalmente, selecione um período de atraso em número de blocos.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Aparecerá um pop-up pedindo que você autorize e assine a transação. Você pode assinar e enviar a transação da conta primária ou proxy, mas a chamada para remover o proxy deve ser enviada da conta primária. Insira sua senha e clique em Sign and Submit.</p> <p>Para verificar se o proxy ou as contas proxy foram removidos, siga as etapas na seção Verificando sua Conta Proxy.</p> <p>Como mencionado anteriormente, você também pode remover um proxy da página Accounts. Para fazer isso, na página Accounts, selecione os três pontos verticais ao lado da conta primária e selecione Manage Proxies.</p> <p></p> <p>Aparecerá um pop-up mostrando uma visão geral de suas contas proxy. Para remover todos os proxies, você pode clicar em Clear all, e será automaticamente solicitado que você insira sua senha e envie a transação. Para remover um único proxy, siga as seguintes etapas:</p> <ol> <li>Clique no botão X ao lado do proxy para remover</li> <li>Pressione Submit</li> </ol> <p></p> <p>Na tela de confirmação da transação, siga as seguintes etapas:</p> <ol> <li>Certifique-se de não usar um proxy para esta chamada (como este exemplo é um proxy de saldos, a chamada para remover o proxy precisa vir da conta primária, em vez da conta proxy).</li> <li>Insira sua senha para a conta respectiva.</li> <li>Pressione Sign and Submit.</li> </ol> <p></p> <p>Depois que a transação for enviada com sucesso, você pode revisar seus proxies atuais ou, se removeu todos os proxies, notará que o ícone do proxy não está mais sendo exibido ao lado da conta primária. E é isso! Você criou com sucesso um proxy, revisou todas as contas proxy associadas à sua conta primária, executou uma transação proxy e removeu uma conta proxy!</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/build/", "title": "Construa Sua Rede", "text": "<p>Lançar sua rede powered by Tanssi oferece a flexibilidade de escolher entre Templates pré-configurados ou soluções totalmente personalizadas. Estaja você buscando simplicidade ou controle refinado, a Tanssi fornece as ferramentas e orientações para transformar sua visão em realidade. Esta seção cobre tudo, desde a seleção de um Template até a personalização de módulos, testes e implantação de sua rede.</p>"}, {"location": "builders/build/#o-caminho-para-implantacao", "title": "O Caminho para Implantação", "text": "<p>A implantação de uma rede com Tanssi pode ser direta ou altamente personalizável, dependendo de suas necessidades. O diagrama abaixo fornece uma clara divisão dessas opções para orientar sua decisão.</p> <pre><code>flowchart TD\n    Start[Escolha um Template]\n    Start --&gt; Path1[O Template é suficiente]\n    Start --&gt; Path2[O Template precisa de personalização]\n\n    Path1 --&gt; Deploy1[Implantar via Tanssi dApp]\n\n    Path2 --&gt; Fork[Fork o repositório Tanssi]\n    Fork --&gt; Customize[Personalize sua rede]\n    Customize --&gt; Test[Executar testes]\n    Test --&gt; Deploy2[Implantar via Tanssi dApp]</code></pre> <p>Agora que você explorou os caminhos de implantação, o próximo passo é aprender mais sobre cada Template para que você possa escolher aquele que melhor se adapta às suas necessidades.</p>"}, {"location": "builders/build/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/build/customize/", "title": "Personalize Sua Rede com Tanssi", "text": "<p>Adapte sua rede para atender aos requisitos exclusivos da sua aplicação. Esta seção fornece orientações sobre como modificar e estender a funcionalidade da sua rede, oferecendo instruções e as melhores práticas para ajudá-lo a alinhá-la com os objetivos do seu projeto.</p>"}, {"location": "builders/build/customize/#processo-para-personalizar-sua-rede", "title": "Processo para Personalizar Sua Rede", "text": "<p>O diagrama abaixo fornece um resumo simplificado das etapas essenciais para começar a construir e personalizar sua rede com Tanssi.</p> <pre><code>flowchart LR\n    A[Instale os pré-requisitos de software] --&gt; B[Crie e adicione módulos]\n    B --&gt; C[Personalize e gere as especificações da cadeia]</code></pre> <p>Para prosseguir, consulte a seção a seguir, onde você pode encontrar guias detalhados, passo a passo, para cada uma dessas etapas.</p>"}, {"location": "builders/build/customize/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/build/customize/adding-built-in-module/", "title": "Adicionando um Módulo Embutido", "text": ""}, {"location": "builders/build/customize/adding-built-in-module/#introduction", "title": "Introdução", "text": "<p>Substrate é uma estrutura de desenvolvimento de software poderosa e modular incluída nos SDKs Polkadot para construir blockchains. Ele fornece um conjunto abrangente de ferramentas e bibliotecas que abstraem funcionalidades complexas de blockchain, permitindo que os desenvolvedores se concentrem na construção de recursos e aplicações inovadoras, focando no runtime, que contém a lógica central e as regras da transição de estado para o caso de uso.</p> <p>O que diferencia o Substrate é sua arquitetura modular, que permite a integração perfeita de módulos embutidos e a criação de módulos personalizados, facilitando o desenvolvimento de protocolos de blockchain.</p> <p>Para casos que exigem apenas compatibilidade com EVM (Ethereum Virtual Machine), o template fornecido no repositório Tanssi atende aos requisitos sem outras modificações. No entanto, as equipes que desejam construir uma rede Substrate devem adicionar e configurar módulos embutidos e personalizados dentro do runtime. Isso envolve compilar, gerar a especificação da cadeia e implantar por meio do protocolo Tanssi para transformá-lo em uma rede ao vivo powered by Tanssi.</p> <p>Este artigo enfoca as etapas necessárias para adicionar um módulo embutido ao template EVM.</p>"}, {"location": "builders/build/customize/adding-built-in-module/#verifying-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para seguir as etapas deste guia, você precisará ter o seguinte:</p> <ul> <li>Um ambiente de desenvolvimento saudável com o compilador Rust e o gerenciador de pacotes Cargo</li> <li>O repositório Tanssi, clonado do GitHub</li> </ul> <p>Você pode ler mais sobre como instalar os componentes necessários no artigo de pré-requisitos.</p> <p>Como este artigo é baseado no template EVM, certifique-se de que ele compile corretamente antes de continuar, executando o seguinte comando:</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre>"}, {"location": "builders/build/customize/adding-built-in-module/#adding-builtin-module-to-runtime", "title": "Adicionando um Módulo Embutido ao Runtime", "text": "<p>Como introduzido no artigo de modularidade, o framework Substrate já inclui muitos módulos embutidos que abordam uma ampla gama de funcionalidades, prontos para serem usados em seu runtime.</p> <p>Os módulos são projetados para fornecer a funcionalidade necessária em casos de uso muito diferentes, como DeFi, NFTs ou qualquer outro, e, portanto, são blocos de construção básicos que são inerentemente abstratos e podem ser configurados de acordo com as necessidades específicas da rede powered by Tanssi.</p> <p>Para adicionar um módulo, as seguintes etapas são necessárias:</p> <ol> <li>Tornar a dependência disponível dentro do projeto, declarando-a em Cargo, o gerenciador de pacotes da linguagem Rust</li> <li>Tornar os recursos padrão (<code>std</code>) do módulo disponíveis para o compilador</li> <li>Configurar o módulo</li> <li>Adicionar o módulo ao runtime</li> <li>Adicionar a configuração padrão à especificação da cadeia</li> </ol> <p>No exemplo a seguir, o popular módulo Substrate <code>pallet-assets</code> é adicionado ao runtime do template EVM fornecido, encontrado no repositório Tanssi, especificamente na pasta <code>container-chains/templates/frontier/</code>.</p>"}, {"location": "builders/build/customize/adding-built-in-module/#declare-dependency", "title": "Declarar a Dependência", "text": "<p>Cada pacote contém um arquivo de manifesto chamado <code>Cargo.toml</code> que declara, entre outras coisas, todas as dependências em que o pacote se baseia, e o runtime da rede powered by Tanssi não é exceção.</p> <p>Portanto, a primeira etapa é declarar a dependência e torná-la disponível para o runtime. Abra o arquivo <code>Cargo.toml</code> localizado na pasta <code>container-chains/templates/frontier/runtime</code> com um editor de texto e adicione o módulo, referenciando o código no Polkadot SDK:</p> <pre><code>[dependencies]\n...\npallet-assets = { \n   git = \"https://github.com/moondance-labs/polkadot-sdk\", \n   branch = \"tanssi-polkadot-stable2503\", \n   default-features = false \n}\n...\n</code></pre> <p>Note</p> <p>Nossa equipe de engenharia contribui ativamente para o desenvolvimento do Substrate, corrigindo problemas e aprimorando funcionalidades. Como resultado, o repositório fork Tanssi frequentemente fica à frente do oficial. É por isso que este exemplo faz referência a um módulo embutido de um repositório Tanssi em vez do oficial.</p>"}, {"location": "builders/build/customize/adding-built-in-module/#standard-features", "title": "Tornar os Recursos Padrão Disponíveis para o Compilador", "text": "<p>No Cargo, as flags de “recursos” fornecem um mecanismo para dizer ao compilador para incluir ou omitir determinadas partes do código, o que é um mecanismo útil para otimizar o tempo de compilação, minimizar os tamanhos dos arquivos binários ou desabilitar determinado comportamento (por exemplo, não incluir testes unitários ou funcionalidade de benchmarking no runtime pretendido para produção).</p> <p>Para compilar os recursos padrão para o módulo Assets dentro do runtime, o mesmo arquivo <code>Cargo.toml</code> na pasta <code>runtime</code> deve ser editado, ativando a flag. Tudo o que está listado nesta seção garantirá que esteja disponível para o compilador ao construir o binário do runtime, que é, em última análise, o arquivo que contém todas as informações para executar sua rede powered by Tanssi inicialmente.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-assets/std\",\n   ...\n]\n</code></pre>"}, {"location": "builders/build/customize/adding-built-in-module/#configure-the-module", "title": "Configurar o Módulo", "text": "<p>Com a dependência declarada no projeto, o módulo agora pode ser configurado e adicionado ao runtime. Para fazer isso, você precisa editar o arquivo <code>lib.rs</code> que está localizado em:</p> <pre><code>container-chains/templates/frontier/runtime/src/lib.rs\n</code></pre> <p>A configuração de novos módulos requer a implementação de um <code>trait</code> de configuração para o módulo (neste exemplo, para Assets) no runtime, expresso em Rust da seguinte forma:</p> <pre><code>// Implementa o trait pallet_assets::Config no runtime\nimpl pallet_assets::Config for Runtime { ... }\n</code></pre> <p>Traits são uma forma de definir comportamento compartilhado em Rust e, neste caso, eles permitem que um novo runtime se beneficie da funcionalidade que o módulo Assets fornece apenas implementando seu trait de configuração e parâmetros.</p> <p>Alguns dos parâmetros que o trait precisa definir podem ser valores constantes; nesse caso, eles precisam ser definidos e incluídos na macro <code>parameter_types!</code>, o que nos ajuda a reduzir o esforço de desenvolvimento, expandindo o código e convertendo cada uma das constantes no tipo de struct correto com funções que permitem que o runtime leia seu tipo e valores de forma padronizada.</p> <p>O seguinte trecho de código mostra um exemplo das definições de constantes a serem usadas na configuração do módulo:</p> <pre><code>parameter_types! {\n   // A quantidade de fundos que devem ser reservados para um ativo\n    pub const AssetDeposit: Balance = 100;\n   // A quantidade de fundos que deve ser reservada ao criar \n   // uma nova aprovação de transferência\n    pub const ApprovalDeposit: Balance = 1;\n   // A quantidade básica de fundos que deve ser reservada ao adicionar metadados \n   // ao seu ativo\n    pub const MetadataDepositBase: Balance = 10;\n   // Os fundos adicionais que devem ser reservados para o número de bytes \n   // que você armazena em seus metadados\n    pub const MetadataDepositPerByte: Balance = 1;\n\n   // Comprimento máximo para o símbolo do ativo e nome amigável\n   pub const StringLimit: u32 = 50;\n}\n</code></pre> <p>É importante notar que cada módulo embutido tem um propósito diferente e, portanto, cada um deles tem necessidades diferentes em termos dos parâmetros que devem ser configurados. O seguinte trecho de código implementa o trait e configura o módulo Assets, usando tipos e as constantes definidas anteriormente na macro <code>parameter_types!</code>:</p> <pre><code>// Implementando o trait de configuração de Ativos para o runtime\nimpl pallet_assets::Config for Runtime {\n\n   // Armazena os saldos em um inteiro sem sinal de 128bits\n    type Balance = u128;\n   // O ID de um ativo pode ser definido como um inteiro sem sinal de 64 bits\n    type AssetId = u64;\n   // Usa o módulo Balances como mecanismo para operações de moeda\n    type Currency = Balances;\n\n   // Configurar o módulo referenciando a anteriormente\n   // constantes definidas\n\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n   // Mais configuração\n   ...\n}\n</code></pre> Ver o script completo <pre><code>parameter_types! {\n    // The amount of funds that must be reserved for an asset\n    pub const AssetDeposit: Balance = 100;\n    // The amount of funds that must be reserved when creating \n    // a new transfer approval\n    pub const ApprovalDeposit: Balance = 1;\n    // The basic amount of funds that must be reserved when adding metadata \n    // to your asset\n    pub const MetadataDepositBase: Balance = 10;\n    // The additional funds that must be reserved for the number of bytes \n    // you store in your metadata\n    pub const MetadataDepositPerByte: Balance = 1;\n    // Maximum lenght for the asset symbol and friendly name\n    pub const StringLimit: u32 = 50;\n}\n\n// Implementing the Assets config trait for the runtime\nimpl pallet_assets::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n\n    // Stores the balances in an unsigned integer of 128bits\n    type Balance = u128;\n    // The id of an asset can be defined as an unsigned integer of 64 bits\n    type AssetId = u64;\n    // Uses module Balances as mechanism for currency operations\n    type Currency = Balances;\n\n    // Configure the module by referencing the previously\n    // defined constants\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n    // More configuration\n    type AssetIdParameter = u64;\n    // Defines the allowed origins to create assets\n    type CreateOrigin = \n        frame_support::traits::AsEnsureOriginWithArg&lt;frame_system::EnsureSigned&lt;AccountId&gt;&gt;;\n    // Root can create assets\n    type ForceOrigin = EnsureRoot&lt;AccountId&gt;;\n    type AssetAccountDeposit = frame_support::traits::ConstU128&lt;1&gt;;\n    type Freezer = ();\n    type Extra = ();\n    type WeightInfo = pallet_assets::weights::SubstrateWeight&lt;Runtime&gt;;\n    type RemoveItemsLimit = frame_support::traits::ConstU32&lt;1000&gt;;\n    #[cfg(feature = \"runtime-benchmarks\")]\n    type BenchmarkHelper = ();\n    type CallbackHandle = ();\n}\n</code></pre> <p>A configuração completa do módulo contém mais parâmetros; para ver uma descrição detalhada de cada um deles, consulte o trait de configuração oficial para a documentação do módulo Assets.</p>"}, {"location": "builders/build/customize/adding-built-in-module/#add-module-to-runtime", "title": "Adicionar o Módulo ao Runtime", "text": "<p>In the same <code>lib.rs</code> file referenced in the previous section, there is a segment enclosed in the macro <code>construct_runtime!()</code>. This is where the pallet must be added to be included in the runtime. Since the example is based on the EVM template, the runtime is already configured to include many modules, including the modules for system support, the modules to add the Ethereum compatibility layer, the modules to support the Tanssi protocol, balances, and now also Assets:</p> <pre><code>construct_runtime!(\n   pub enum Runtime where\n      Block = Block,\n      NodeBlock = opaque::Block,\n      UncheckedExtrinsic = UncheckedExtrinsic,\n   {\n      // Coisas de suporte do sistema.\n      System: frame_system = 0,\n      ParachainSystem: cumulus_pallet_parachain_system = 1,\n      Timestamp: pallet_timestamp = 2,\n      ParachainInfo: parachain_info = 3,\n      Sudo: pallet_sudo = 4,\n      Utility: pallet_utility = 5,\n      ...\n      Balances: pallet_balances = 10,\n      // Módulo Assets é adicionado aqui\n      Assets: pallet_assets = 11,\n      ...\n   }\n</code></pre>"}, {"location": "builders/build/customize/adding-built-in-module/#configure-chain-specs", "title": "Configurar o Módulo na Especificação da Cadeia", "text": "<p>Finally, add the configuration in the chain specification for the genesis state in the file <code>chain_spec.rs</code> located at:</p> <pre><code>container-chains/templates/frontier/node/src/`chain_spec.rs`\n</code></pre> <p>A função <code>testnet_genesis</code>, apresentada no seguinte trecho de código, define o estado inicial para os módulos incluídos no runtime (como contas financiadas inicialmente, por exemplo). Depois de adicionar o módulo Assets, é necessário inicializá-lo também e, no exemplo a seguir, seus valores padrão são definidos.</p> <p>Mais detalhes sobre a especificação da cadeia e como configurá-la serão abordados no artigo Personalizando Especificações de Cadeia.</p> <pre><code>fn testnet_genesis(\n   endowed_accounts: Vec&lt;AccountId&gt;,\n   id: ParaId,\n   root_key: AccountId,\n) -&gt; container_chain_template_frontier_runtime::GenesisConfig {\n   container_chain_template_frontier_runtime::GenesisConfig {\n      system: container_chain_template_frontier_runtime::SystemConfig {\n         code: container_chain_template_frontier_runtime::WASM_BINARY\n               .expect(\"O binário WASM não foi construído, por favor, construa-o!\")\n               .to_vec(),\n      },\n      ...\n      // Adicione o estado padrão para este módulo no estado de gênese\n      assets: Default::default()\n      ...\n}\n</code></pre> <p>Com o módulo incluído, esta nova versão do runtime desbloqueou um novo conjunto de funcionalidades prontas para serem compostas com ainda mais dos módulos embutidos do Substrate ou personalizados.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/", "title": "Adicionar um Módulo Personalizado", "text": ""}, {"location": "builders/build/customize/adding-custom-made-module/#introduction", "title": "Introdução", "text": "<p>Ao fornecer uma biblioteca abrangente de módulos pré-construídos que abordam muitos requisitos comuns, a estrutura simplifica enormemente o processo de construção de um blockchain e acelera a implantação e evolução em uma rede powered by Tanssi. No entanto, abordar um caso de uso inovador geralmente exige um esforço de desenvolvimento para atender totalmente aos requisitos e, no Substrate, adicionar lógica personalizada se traduz em escrever e integrar módulos de Runtime.</p> <p>O exemplo apresentado no artigo Modularidade mostra um módulo de loteria simples que expõe duas transações:</p> <ul> <li>Buy tickets - esta função gerencia a entrada de um usuário na loteria. Essencialmente, ela verifica se o participante tem saldo suficiente, não está participando e cuida da transferência de fundos para registrar o usuário na loteria</li> <li>Award prize - esta função que lida com um usuário que entra na loteria. Em alto nível, ela busca um número pseudo-aleatório para obter um vencedor e lida com a distribuição do prêmio</li> </ul> <p>A implementação dessas transações também usa armazenamento, emite eventos, define erros personalizados e depende de outros módulos para lidar com a moeda (para cobrar pelos bilhetes e transferir o valor total para o vencedor) e aleatorizar a seleção do vencedor.</p> <p>Neste artigo, as seguintes etapas, necessárias para construir e adicionar o módulo de exemplo ao Runtime, serão abordadas:</p> <ol> <li>Criar os arquivos do módulo de loteria (pacote).</li> <li>Configurar as dependências do módulo.</li> <li>Adicionar lógica personalizada.</li> <li>Configurar o Runtime com o novo módulo.</li> </ol> <p>É importante ressaltar que nenhum dos códigos apresentados neste artigo se destina ao uso em produção.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para seguir as etapas deste guia, você precisará ter o seguinte:</p> <ul> <li>Clonar o repositório Tanssi do Github</li> <li>Compilador Rust e gerenciador de pacotes Cargo</li> </ul> <p>Você pode ler mais sobre como instalar o Rust e o Cargo no artigo de pré-requisitos.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/#creating-lottery-module-files", "title": "Criando os Arquivos do Módulo de Loteria", "text": "<p>Antes de iniciar seu processo de codificação, é essencial criar os arquivos que contêm sua lógica. Os módulos Substrate são abstratos e destinados ao reaproveitamento em diferentes tempos de execução com várias personalizações. Para conseguir isso, você usará o Cargo, o gerenciador de pacotes do Rust, para criar o módulo como um novo pacote.</p> <p>Como mencionado na seção de pré-requisitos, a primeira etapa é clonar o repositório Tanssi e, na pasta raiz, navegar até <code>pallets</code>, onde o módulo será criado.</p> <pre><code>cd container-chains/pallets\n</code></pre> <p>Em seguida, crie o pacote do módulo com o Cargo:</p> <pre><code>cargo new lottery-example\n</code></pre> <p>Por padrão, o Cargo cria o novo pacote em uma pasta com o nome fornecido (<code>lottery-example</code>, neste caso), contendo um arquivo de manifesto, <code>Cargo.toml</code> e uma pasta <code>src</code> com um arquivo <code>main.rs</code>. Para respeitar a convenção de nomenclatura usada no Substrate, o arquivo <code>main.rs</code> é renomeado para <code>lib.rs</code>:</p> <pre><code>mv lottery-example/src/main.rs lottery-example/src/lib.rs\n</code></pre> <p>Depois de executar todos os comandos, o módulo é criado e está pronto para conter a lógica personalizada que você adicionará nas seções a seguir.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/#configure-module-dependencies", "title": "Configurar as Dependências do Módulo", "text": "<p>Como o módulo funciona como um pacote independente, ele tem seu próprio arquivo Cargo.toml, onde você deve especificar os atributos e dependências do módulo.</p> <p>Por exemplo, você pode usar atributos para especificar detalhes como o nome do módulo, versão, autores e outras informações relevantes. Por exemplo, no módulo <code>lottery-example</code>, o arquivo <code>Cargo.toml</code> pode ser configurado da seguinte forma:</p> <pre><code>#[pallet::storage]\n#[pallet::getter(fn get_participants)]\npub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n    _,\n    BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n    OptionQuery\n&gt;;\n</code></pre> <p>Este arquivo também define as dependências do módulo, como a funcionalidade principal que permite a integração perfeita com o Runtime e outros módulos, acesso ao armazenamento, emissão de eventos e muito mais.</p> <p>O exemplo completo do arquivo <code>Cargo.toml</code> define, além dos atributos, as dependências exigidas pelo Substrate:</p> Ver o arquivo Cargo.toml completo <pre><code>[package]\nname = \"module-lottery-example\"\nversion = \"4.0.0-dev\"\ndescription = \"Simple module example\"\nauthors = [\"\"]\nhomepage = \"\"\nedition = \"2021\"\npublish = false\n\n[package.metadata.docs.rs]\ntargets = [\"x86_64-unknown-linux-gnu\"]\n\n[dependencies]\ncodec = { package = \"parity-scale-codec\", version = \"3.6.1\", default-features = false, features = [\n    \"derive\",\n] }\nscale-info = { version = \"2.5.0\", default-features = false, features = [\"derive\"] }\nframe-benchmarking = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    optional = true, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-support = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-system = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\n\n[dev-dependencies]\nsp-core = { version = \"21.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-io = { version = \"23.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-runtime = { version = \"24.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\n\n[features]\ndefault = [\"std\"]\nstd = [\n    \"codec/std\",\n    \"frame-benchmarking?/std\",\n    \"frame-support/std\",\n    \"frame-system/std\",\n    \"scale-info/std\",\n]\nruntime-benchmarks = [\"frame-benchmarking/runtime-benchmarks\"]\ntry-runtime = [\"frame-support/try-runtime\"]\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#adding-custom-logic", "title": "Adicionando Lógica Personalizada", "text": "<p>Conforme apresentado na seção módulo personalizado do artigo sobre modularidade, a criação de um módulo envolve a implementação das seguintes macros de atributo, das quais as três primeiras são obrigatórias:</p> <ul> <li><code>#[frame_support::pallet]</code> - atributo de entrada que marca o módulo como utilizável no runtime</li> <li><code>#[pallet::pallet]</code> - aplicado a uma estrutura usada para recuperar informações do módulo com facilidade</li> <li><code>#[pallet::config]</code> - atributo obrigatório para definir a configuração dos tipos de dados do módulo</li> <li><code>#[pallet::call]</code> - macro usada para definir funções expostas como transações, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transações e lógica personalizadas</li> <li><code>#[pallet::error]</code> - como transações podem falhar (por exemplo, fundos insuficientes) e, por segurança, um módulo não deve gerar exceções, todos os possíveis erros devem ser identificados e listados em um enum para serem retornados em uma execução malsucedida</li> <li><code>#[pallet::event]</code> - eventos podem ser definidos e usados para fornecer mais informações ao usuário</li> <li><code>#[pallet::storage]</code> - macro usada para definir elementos que serão persistidos em storage; como recursos são escassos em uma blockchain, deve ser usada com parcimônia para armazenar apenas informações essenciais</li> </ul>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-basic-structure", "title": "Implementando a Estrutura Básica do Módulo", "text": "<p>As duas primeiras macros obrigatórias, <code>#[frame_support::pallet]</code> e <code>#[pallet::pallet]</code>, fornecem a estrutura básica do módulo e são necessárias para habilitar o módulo a ser usado em um Runtime Substrate.</p> <p>A seguir, é apresentada a estrutura geral de um módulo Substrate personalizado.</p> <pre><code>#[frame_support::pallet(dev_mode)]\npub mod pallet {\n    ...\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_); \n\n       // Toda a lógica vai aqui\n}\n</code></pre> <p>A próxima etapa seria adicionar a terceira macro obrigatória (<code>#[pallet::config]</code>) e toda a lógica personalizada, conforme mostrado nas seções a seguir.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-module-configuration", "title": "Implementando a Configuração do Módulo", "text": "<p>Para tornar os módulos altamente adaptáveis, sua configuração é abstrata o suficiente para permitir que sejam adaptados aos requisitos específicos do caso de uso que o Runtime implementa.</p> <p>A implementação da macro <code>#[pallet::config]</code> é obrigatória e define a dependência do módulo em outros módulos e os tipos e valores especificados pelas configurações específicas do Runtime.</p> <p>No módulo <code>lottery-example</code> personalizado que você está construindo, o módulo depende de outros módulos para gerenciar a moeda e a função aleatória para selecionar o vencedor. O módulo também lê e usa o preço do bilhete e o número máximo de participantes diretamente das configurações do Runtime. Consequentemente, a configuração precisa incluir essas dependências:</p> <ul> <li>Events - o módulo depende da definição de um evento do Runtime para poder emiti-los</li> <li>Currency - o módulo <code>lottery-example</code> precisa poder transferir fundos, portanto, precisa da definição do sistema monetário do Runtime</li> <li>Randomness - este módulo é usado para selecionar de forma justa o vencedor do prêmio da lista de participantes. Ele gera os números aleatórios usando os hashes de bloco anteriores e o número do bloco atual como semente</li> <li>Ticket coste - o preço a ser cobrado dos compradores que participam da loteria</li> <li>Maximum number of participants - o limite máximo de participantes permitido em cada rodada da loteria</li> <li>Module Id - o identificador exclusivo do módulo é necessário para acessar a conta do módulo para manter os fundos dos participantes até serem transferidos para o vencedor</li> </ul> <p>A implementação da configuração descrita para este exemplo é mostrada no seguinte trecho de código:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n\n    // Definição do evento\n    type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt;\n        + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n    // Moeda\n    type Currency: Currency&lt;Self::AccountId&gt;;\n\n    // Aleatoriedade\n    type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n    // Custo do bilhete\n    #[pallet::constant]\n    type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n    // Número máximo de participantes\n    #[pallet::constant]\n    type MaxParticipants: Get&lt;u32&gt;;\n\n    // ID do módulo\n    #[pallet::constant]\n    type PalletId: Get&lt;PalletId&gt;;\n}\n</code></pre> <p>Esta definição abstrata de dependências é crucial para evitar o acoplamento a um caso de uso específico e para permitir que os módulos sirvam como blocos de construção básicos para as redes Substrate.</p>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-transactions", "title": "Implementando Transações", "text": "<p>Chamadas representam o comportamento que um Runtime expõe na forma de transações que podem ser despachadas para processamento, expondo a lógica personalizada adicionada ao módulo.</p> <p>Cada chamada está incluída na macro <code>#[pallet::call]</code> e apresenta os seguintes elementos:</p> <ul> <li>Call Index - é um identificador exclusivo obrigatório para cada chamada despachável</li> <li>Weight - é uma medida do esforço computacional que uma extrínseca leva ao ser processada. Mais sobre pesos está na documentação do Polkadot</li> <li>Origin - identifica a conta de assinatura que está fazendo a chamada</li> <li>Result - o valor de retorno da chamada, que pode ser um <code>Erro</code> se alguma coisa der errado</li> </ul> <p>A seguinte trecho apresenta a estrutura geral da implementação da macro mencionada e os elementos de chamada:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn one_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn another_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    // Outras chamadas\n}\n</code></pre> <p>Neste módulo <code>lottery-example</code>, definimos duas chamadas com a seguinte lógica:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]    \n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Valida a assinatura de origem\n        // 2. Verifica se o usuário tem saldo suficiente para pagar o preço do bilhete\n        // 3. Verifica se o usuário já não está participando\n        // 4. Adiciona o usuário como um novo participante do prêmio\n        // 5. Transfere o custo do bilhete para a conta do módulo, para ser mantido até ser transferido para o vencedor\n        // 6. Notifica o evento\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n        // 1. Valida a assinatura de origem\n        // 2. Obtém um número aleatório do módulo de aleatoriedade\n        // 3. Seleciona o vencedor da lista de participantes\n        // 4. Transfere o prêmio total para a conta do vencedor\n        // 5. Redefine a lista de participantes e prepara-se para outra rodada da loteria\n    }\n}\n</code></pre> <p>Essas chamadas também emitem eventos para manter o usuário informado e podem retornar erros caso alguma das validações dê errado.</p> <p>Aqui está a implementação completa das chamadas com a lógica da loteria personalizada:</p> Ver o código de chamadas completo <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let buyer = ensure_signed(origin)?;\n\n        // 2. Checks that the user has enough balance to afford the ticket price\n        ensure!(\n            T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n            Error::&lt;T&gt;::NotEnoughCurrency\n        );\n\n        // 3. Checks that the user is not already participating\n        if let Some(participants) = Self::get_participants() {\n            ensure!(\n                !participants.contains(&amp;buyer),\n                Error::&lt;T&gt;::AccountAlreadyParticipating\n            );\n        }\n\n        // 4. Adds the user as a new participant for the prize\n        match Self::get_participants() {\n            Some(mut participants) =&gt; { \n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }, \n            None =&gt; {\n                let mut participants = BoundedVec::new();\n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }\n        };\n\n        // 5. Transfers the ticket cost to the module's account\n        // to be hold until transferred to the winner\n        T::Currency::transfer(\n            &amp;buyer, \n            &amp;Self::get_pallet_account(), \n            T::TicketCost::get(), \n            ExistenceRequirement::KeepAlive)?;\n\n        // 6. Notify the event\n        Self::deposit_event(Event::TicketBought { who: buyer });\n        Ok(())\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let _who = ensure_root(origin)?;\n\n        match Self::get_participants() {\n            Some(participants) =&gt; { \n\n                // 2. Gets a random number from the randomness module\n                let nonce = Self::get_and_increment_nonce();\n                let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                    .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                // 3. Selects the winner from the participants lit\n                let winner_index = random_number as usize % participants.len();\n                let winner = participants.as_slice().get(winner_index).unwrap();\n\n                // 4. Transfers the total prize to the winner's account\n                let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                T::Currency::transfer(\n                    &amp;Self::get_pallet_account(), \n                    &amp;winner, \n                    prize, \n                    ExistenceRequirement::AllowDeath)?;\n\n                // 5. Resets the participants list, and gets ready for another lottery round\n                Participants::&lt;T&gt;::kill();\n\n                // 6. Notify the event\n                Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n            }, \n            None =&gt; {\n                // Notify the event (No participants)\n                Self::deposit_event(Event::ThereAreNoParticipants);\n            }\n        };\n\n        Ok(())\n    }\n}\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-custom-errors", "title": "Implementando Erros Personalizados", "text": "<p>A macro <code>#[pallet::error]</code> é usada para anotar uma enumeração de erros potenciais que poderiam ocorrer durante a execução. É crucial para a segurança garantir que todas as situações de erro sejam tratadas com elegância, sem causar a falha do Runtime.</p> <p>O exemplo a seguir desta implementação de macro mostra os erros que podem ocorrer no módulo da loteria:</p> <pre><code>// Erros informam aos usuários que algo deu errado.\n#[pallet::error]\npub enum `Error`&lt;T&gt; {\n    NotEnoughCurrency,\n    AccountAlreadyParticipating,\n    CanNotAddParticipant,\n}\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-events", "title": "Implementando Eventos", "text": "<p>A macro <code>#[pallet::event]</code> é aplicada a uma enumeração de eventos para informar o usuário sobre quaisquer alterações no estado ou ações importantes que ocorreram durante a execução no Runtime.</p> <p>Como exemplo, para o módulo <code>lottery-example</code>, esta macro pode ser configurada com os seguintes eventos:</p> <pre><code>#[pallet::event]\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\npub enum Event&lt;T: Config&gt; {\n\n    // Evento emitido quando um bilhete é comprado\n    TicketBought { who: T::AccountId },\n    // Evento emitido quando o prêmio é concedido\n    PrizeAwarded { winner: T::AccountId },\n    // Evento emitido quando não há participantes  \n    ThereAreNoParticipants,\n    }\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#implementing-storage", "title": "Implementando o Armazenamento para Persistência de Estado", "text": "<p>A macro <code>#[pallet::storage]</code> inicializa uma estrutura de armazenamento de Runtime. No ambiente altamente restrito de blockchains, decidir o que armazenar e qual estrutura usar pode ser fundamental em termos de desempenho. Mais sobre esse tópico é abordado na documentação Substrate.</p> <p>Neste exemplo, o módulo <code>lottery-example</code> precisa de uma estrutura de armazenamento de valor básica para persistir a lista de participantes em um vetor de capacidade limitada (BoundedVec). Isso pode ser inicializado da seguinte forma:</p> <pre><code>#[pallet::storage]\n#[pallet::getter(fn get_participants)]\npub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n    _,\n    BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n    OptionQuery\n&gt;;\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#complete-module", "title": "O Módulo Completo", "text": "<p>Para juntar todas as peças, após implementar todas as macros necessárias e adicionar a lógica personalizada, o módulo agora está completo e pronto para ser usado no Runtime.</p> Ver o arquivo do módulo completo <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre>"}, {"location": "builders/build/customize/adding-custom-made-module/#configure-runtime", "title": "Configurar o Runtime", "text": "<p>Finalmente, com o módulo finalizado, ele pode ser incluído no Runtime. Ao fazer isso, as transações <code>buy_tickets</code> e <code>award_prize</code> serão chamáveis pelos usuários. Isso também significa que a API Polkadot.js será decorada com este módulo e todas as chamadas disponíveis que ele contém.\\n\\nPara configurar o Runtime, abra o arquivo <code>lib.rs</code>, que contém a definição para o Runtime do Template incluído e está localizado (no caso de usar o compatível com EVM) na pasta:</p> <pre><code>*/container-chains/templates/frontier/runtime/src/\n</code></pre> <p>Para adicionar o módulo da loteria, configure os módulos da seguinte forma:</p> <p><pre><code>// Adicione a configuração para o módulo de aleatoriedade. Nenhum parâmetro necessário.\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {\n}\n\n// // ID de módulo personalizado\n parameter_types! {\n    pub const PalletId: PalletId = PalletId(*b\"loex5678\");\n}\n\n// Adicione a configuração para o módulo da loteria\nimpl pallet_lottery_example::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type Currency = Balances;\n    type TicketCost = ConstU128&lt;1000000000000000&gt;;\n    type PalletId = PalletId;\n    type MaxParticipants = ConstU32&lt;500&gt;;\n    type MyRandomness = RandomCollectiveFlip;\n    }\n</code></pre> Com os módulos configurados, adicione a macro <code>construct_runtime!</code> (que define os módulos que serão incluídos ao construir o Runtime) e os módulos de aleatoriedade e loteria.</p> <pre><code>construct_runtime!(\n    pub struct Runtime {\n        ...\n        // Inclua a lógica personalizada do pallet-template no Runtime.\n        RandomCollectiveFlip: pallet_insecure_randomness_collective_flip,\n        Lottery: pallet_lottery_example,\n        ...\n}\n)\n</code></pre> <p>Com tudo definido, a rede agora tem suporte para uma implementação básica de uma loteria.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/build/customize/adding-external-module/", "title": "Adicionar um Módulo Externo", "text": ""}, {"location": "builders/build/customize/adding-external-module/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores construindo sobre os Templates oferecidos pela Tanssi podem querer adicionar alguns módulos/dependências externos em seu Runtime para expandir certas funcionalidades.</p> <p>O repositório Tanssi e os Templates pegam todas as dependências de um fork do repositório oficial do Polkadot SDK. Este fork é mantido pela equipe de engenharia da Tanssi, que geralmente contribui ativamente para o desenvolvimento da Substrate, corrigindo problemas e aprimorando funcionalidades, e, como resultado, o repositório do fork frequentemente fica temporariamente à frente do oficial.</p> <p>Um problema de dupla referência pode surgir ao adicionar uma dependência externa, como uma pallet de terceiros. Isso acontece se um módulo Tanssi faz referência a uma dependência do repositório fork do Polkadot SDK, e a terceiros faz referência à mesma dependência do repositório oficial do Polkadot SDK. Para resolver esse problema, as referências às dependências devem ser unificadas.</p>"}, {"location": "builders/build/customize/adding-external-module/#solving-dependencies-conflicts-diener", "title": "Resolvendo Conflitos de Dependências com Diener", "text": "<p>Para lidar de forma eficiente com as dependências e suas origens, você pode conferir a ferramenta diener.</p> <p>Se o arquivo executável <code>diener</code>, o repositório do Polkadot SDK clonado e seu fork Tanssi estiverem localizados na mesma pasta, entre na pasta do fork Tanssi e execute o seguinte comando:</p> <pre><code>../diener patch --crates-to-patch ../polkadot-sdk \\\n    --target https://github.com/paritytech/polkadot-sdk \\\n    --point-to-git https://github.com/moondance-labs/polkadot-sdk \\\n    --point-to-git-branch tanssi-polkadot-stable2503\n</code></pre> <p>Este comando aplica as alterações ao arquivo <code>Cargo.toml</code>, corrigindo as dependências e resolvendo os problemas de dupla referência.</p> <p>Você pode visitar a documentação do diener para saber mais sobre a ferramenta e outras funções extras que ela oferece.</p>"}, {"location": "builders/build/customize/adding-external-module/#double-reference-issue", "title": "Exemplo do Problema de Dupla Referência", "text": "<p>Para ilustrar a situação, as seguintes etapas adicionam um módulo externo de demonstração a um Runtime personalizado com base no Template de rede powered by Tanssi de linha de base. Uma maneira de seguir este tutorial é clonar o repositório Tanssi Github, que atuará como o repositório raiz do projeto.</p> <p>Este tutorial gerará um erro de tempo de compilação de referência múltipla. Finalmente, as etapas mostrarão como corrigir o erro de compilação corrigindo as dependências com a ferramenta <code>diener</code>, o Runtime será compilado com sucesso e funcionará conforme o esperado.</p>"}, {"location": "builders/build/customize/adding-external-module/#add-third-party-dependency", "title": "Adicionar uma Dependência de Terceiros", "text": "<p>Semelhante ao que é descrito no artigo módulo embutido, a adição de um módulo de terceiros requer as seguintes etapas:</p> <ol> <li>Declare a dependência no arquivo <code>Cargo.toml</code> raiz</li> <li>Torne as características padrão disponíveis para o compilador</li> <li>Configure e adicione o módulo ao Runtime</li> </ol> <p>Se o módulo de terceiros fizer referência a alguma dependência já referenciada de uma fonte ou versão distinta, a compilação falhará.</p> <p>O diagrama a seguir mostra como duas referências diferentes para a mesma dependência estão sendo incluídas no Runtime, fazendo com que a compilação falhe:</p> <p></p> <p>Para resolver este problema, será necessário aplicar um patch para que as referências para a dependência sejam unificadas:</p> <p></p>"}, {"location": "builders/build/customize/adding-external-module/#declaring-dependency", "title": "Declarando a Dependência", "text": "<p>A primeira etapa para reproduzir o problema de dupla referência é declarar a dependência no arquivo <code>Cargo.toml</code> localizado na pasta raiz do repositório, na seção <code>[dependencies]</code>. Para este exemplo, um simples módulo de alternância é usado.</p> <p>Este módulo <code>toggle</code>, construído para fins de teste e educacionais, adiciona lógica básica ao Runtime, permitindo que os usuários alternem um estado entre verdadeiro e falso.</p> <pre><code>[dependencies]\n...\npallet-toggle = { \n    git = \"https://github.com/papermoonio/pallet-toggle\", \n    default-features = false \n}\n...\n</code></pre>"}, {"location": "builders/build/customize/adding-external-module/#add-standard-features", "title": "Tornando os Recursos Padrão Disponíveis para o Compilador", "text": "<p>Tendo declarado o módulo no arquivo <code>Cargo.toml</code> do espaço de trabalho, a dependência pode agora ser adicionada ao arquivo <code>Cargo.toml</code> do Template específico, que, para este exemplo que usa o repositório Tanssi GitHub, está localizado na pasta <code>container-chains/templates/simple/runtime</code>.</p> <pre><code>[dependencies]\n...\npallet-toggle = { workspace = true }\n...\n</code></pre> <p>No mesmo arquivo <code>Cargo.toml</code>, adicione os seguintes recursos.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-toggle/std\",\n   ...\n]\n...\nruntime-benchmarks = [\n    ...,\n    \"pallet-toggle/runtime-benchmarks\",\n]\n\ntry-runtime = [\n    ...,\n    \"pallet-toggle/try-runtime\",\n]\n</code></pre>"}, {"location": "builders/build/customize/adding-external-module/#configure-module-in-the-runtime", "title": "Configurar e Adicionar o Módulo ao Runtime", "text": "<p>Em seguida, adicione o seguinte snippet ao arquivo <code>lib.rs</code> dentro da pasta de Runtime. Isso configura o módulo e adiciona o módulo dentro da macro <code>construct_runtime!</code>.</p> <pre><code>...\nimpl pallet_toggle::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = pallet_toggle::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n\nconstruct_runtime!(\n    pub enum Runtime\n    {\n        ...\n        ...\n        Toggle: pallet_toggle,\n    }\n);\n</code></pre>"}, {"location": "builders/build/customize/adding-external-module/#compile-runtime", "title": "Compilar o Runtime", "text": "<p>Após concluir as etapas anteriores, o módulo é declarado uma dependência no projeto, configurado e adicionado ao Runtime.</p> <p>Compile o Template usando o seguinte comando:</p> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>A saída do terminal exibirá um erro, semelhante ao seguinte, causado por diferentes módulos referenciando diferentes versões da mesma dependência:</p> <pre><code>error: failed to select a version for `syn`.\n</code></pre>"}, {"location": "builders/build/customize/adding-external-module/#patch-dependencies", "title": "Dependências de Patch", "text": "<p>Finalmente, a execução do comando <code>diener</code> adicionará uma seção <code>patch</code> ao seu arquivo <code>Cargo.toml</code> do espaço de trabalho, substituindo as dependências e unificando as origens e versões.</p> <p>É assim que a execução no terminal se parece:</p> ../diener patch --crates-to-patch ../polkadot-sdk \\      --target https://github.com/paritytech/polkadot-sdk \\      --point-to-git https://github.com/moondance-labs/polkadot-sdk \\      --point-to-git-branch tanssi-polkadot-v1.3.0       [2024-01-10T23:26:27Z INFO diener] Running diener v0.4.7       [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bridge-runtime-common.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-header-chain'      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-runtime'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core-hashing'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api-proc-macro' .      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-debug-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-externalities'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-std'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-storage'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-runtime-interface'.    <p>Como mostrado na saída do terminal, <code>diener</code> adiciona um patch para as dependências, criando uma seção <code>patch</code> em seu <code>toml</code> substituindo sua origem:</p> <pre><code>[patch.\"https://github.com/paritytech/polkadot-sdk\"]\nbridge-runtime-common = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-header-chain = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-runtime = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\n...\n</code></pre> <p>Finalmente, a compilação terá sucesso e o módulo será integrado ao seu Runtime.</p>"}, {"location": "builders/build/customize/customizing-chain-specs/", "title": "Customizando as Especificações da Cadeia", "text": ""}, {"location": "builders/build/customize/customizing-chain-specs/#introduction", "title": "Introdução", "text": "<p>A especificação da cadeia refere-se a um conjunto de parâmetros e configurações que definem as características e o comportamento de uma nova rede powered by Tanssi. Ela define as configurações e o estado iniciais sobre os quais todos os nós participantes da rede devem concordar para alcançar o consenso e produzir blocos. Muitas configurações iniciais não podem ser alteradas após o lançamento da rede sem gerar uma cadeia completamente diferente.</p> <p>A especificação contém duas seções principais:</p> <ul> <li>The client specification - inclui os parâmetros de rede, por exemplo, os nós de inicialização com os quais o cliente se conecta ao ingressar na rede</li> <li>The client specification - representa o estado inicial em que todas as transações e transições de estado ocorrem. Inclui detalhes como as contas registradas iniciais e seus saldos, bem como a conta com privilégios de administrador (sudo, se aplicável), entre outras informações relevantes</li> </ul> <p>Essas informações que a especificação da cadeia contém podem ser armazenadas em um arquivo Rust (que pode ser encontrado nos templates incluídos no repositório Tanssi) ou em um arquivo JSON.</p> <p>Este artigo aborda as seções e atributos dentro de um arquivo de especificação de cadeia e explica como obtê-lo, caso você queira lançar sua rede Tanssi carregando um arquivo de especificações personalizadas.</p> <p>Nota do Editor (Atualização de 2025)</p> <p>Este guia explica como personalizar os arquivos de especificação da cadeia em redes baseadas em Substrate. Alguns campos (por exemplo, cadeia de retransmissão, ID da parachain) vêm do SDK do Substrate e são incluídos para fins de compatibilidade ou Template.</p> <p>Esses atributos não significam que uma rede powered by Tanssi é uma parachain Polkadot. Tanssi é um protocolo de infraestrutura de appchain independente, construído com Substrate e alinhado com a segurança apoiada pelo Ethereum. Você pode encontrar termos relacionados ao Polkadot em arquivos de configuração por causa das origens compartilhadas do Substrate, mas as appchains powered by Tanssi não exigem slots Polkadot ou mecânica de cadeia de retransmissão.</p>"}, {"location": "builders/build/customize/customizing-chain-specs/#client-specification", "title": "A Especificação do Cliente", "text": "<p>A especificação do cliente contém a configuração da rede e outras configurações (excluindo as relacionadas ao estado do Runtime):</p> <ul> <li>Name - nome para as especificações</li> <li>Id - um ID simples exclusivo para a rede usado para definir o caminho de armazenamento no nó</li> <li>Fork ID - parâmetro opcional para um identificador de fork de rede</li> <li>Chain type - um parâmetro que pode ser definido para definir o tipo de cadeia e exibir informações adicionais ou habilitar recursos adicionais (pode ser definido como Desenvolvimento, Local, Live ou um tipo personalizado)</li> <li>Boot Nodes - conjunto de nós de inicialização que serão usados ​​quando o novo nó entrar na rede e sincronizar</li> <li>Telemetry Endpoints - uma lista opcional de endpoints para enviar informações e monitorar a operação da rede</li> <li>Protocol ID - um nome exclusivo que define o protocolo de rede</li> <li>Relay Chain - define a ID da cadeia de orquestração com a qual a rede Tanssi interage</li> <li>Parachain ID - define uma ID exclusiva que identifica a rede Tanssi</li> <li>Code Substitutes - um recurso de emergência para substituir o Runtime quando uma rede Tanssi não consegue executar uma atualização de Runtime</li> <li>Properties - propriedades chave-valor que podem ser personalizadas e são úteis para melhorar a experiência do usuário</li> </ul> <p>No atributo <code>properties</code>, as seguintes configurações são usadas por várias bibliotecas front-end, incluindo a API Polkadot.js:</p> <ul> <li>Símbolo do Token - um nome para o símbolo do token da sua própria rede Tanssi</li> <li>Formato SS58 - um inteiro que identifica exclusivamente as contas em sua rede. A codificação SS58 transforma a conta subjacente de 32 bytes em uma representação específica da rede. Este atributo não se aplica nem interfere nas contas Ethereum ECDSA em redes compatíveis com EVM</li> <li>Decimais do Token - representam o quão divisível um token pode ser e qual é a menor representação do token. Ele é definido como <code>18</code> para redes compatíveis com EVM</li> <li>É Ethereum - um booleano que identifica a rede como compatível com EVM ou não</li> </ul>"}, {"location": "builders/build/customize/customizing-chain-specs/#genesis-state", "title": "O Estado da Gênese", "text": "<p>Todos os Sequencers atribuídos à rede Tanssi devem concordar com o estado inicial para que possam executar as extrínsecas de entrada, chegar aos mesmos resultados e, finalmente, chegar a um consenso sobre o novo estado válido.</p> <p>Este estado da gênese definirá o ponto de partida da rede Tanssi. Ele inclui um valor inicial para os elementos que os módulos incluídos no Runtime precisam persistir e o código Wasm inicial do Runtime, que é armazenado na cadeia.</p> <p>Por exemplo, nos Templates incluídos, a especificação da cadeia define as contas iniciais e os saldos de tokens no módulo <code>Balances</code>. Além disso, o template também tem uma conta sudo (que deve ser modificado) para o módulo <code>Sudo</code>, que fornece privilégios exclusivos à conta fornecida, e que pode ser removido assim que um módulo de democracia na cadeia for conectado.</p>"}, {"location": "builders/build/customize/customizing-chain-specs/#generating-json-chain-specs", "title": "Gerando um Arquivo de Especificação de Cadeia JSON", "text": "<p>Os seguintes comandos construirão e gerarão a especificação da cadeia para o Template compatível com EVM com base na configuração expressa em <code>chain_spec.rs</code>, localizado em <code>*/container-chains/templates/frontier/node/src/chain_spec.rs</code>. Este exemplo pode ser adaptado a qualquer outro Template ou Runtime personalizado.</p> <p>Para construir e gerar as especificações da cadeia, siga estas etapas:</p> <ol> <li> <p>Clone o código Tanssi hospedado no GitHub</p> <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre> </li> <li> <p>Entre na pasta do projeto</p> <pre><code>cd tanssi\n</code></pre> </li> <li> <p>Construa o Template da rede compatível com EVM Tanssi</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> </li> </ol> <p>Esta etapa é bastante detalhada e pode levar um tempo para ser concluída. A captura de tela a seguir mostra o terminal após concluir com sucesso o processo de construção (observe que o tempo de conclusão é superior a 35 minutos):</p> <p></p> <ol> <li> <p>Gerar a especificação da cadeia</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec &gt; chain_spec.json\n</code></pre> </li> </ol> <p>Após executar a última etapa, o terminal exibe apenas uma linha de log:</p> <p></p> <p>E agora o arquivo <code>chain_spec.json</code> contendo a especificação do cliente e o estado da gênese é criado na pasta atual.</p> <p>Note</p> <p>As especificações da cadeia JSON podem ser geradas em duas versões diferentes: a legível por humanos, que é a gerada seguindo as etapas anteriores, e a versão bruta, que é a necessária para implantar a rede por meio da Tanssi. Mais sobre como gerar a versão bruta posteriormente neste artigo.</p>"}, {"location": "builders/build/customize/customizing-chain-specs/#editing-json-chain-specs", "title": "Editando o Arquivo de Especificação da Cadeia JSON", "text": "<p>O arquivo <code>chain_spec.json</code> gerado reflete os parâmetros definidos no arquivo de especificações da cadeia Rust. Sendo um arquivo JSON, é fácil de ler e, caso algum parâmetro precise ser alterado, fácil de editar.</p> <p>Por exemplo, o seguinte trecho de código mostra alguns dos atributos das especificações do cliente:</p> <pre><code>{\n    // Define o nome da especificação desta rede\n    \"name\": \"Rede Frontier 1000\",\n    // Defina um ID para as especificações desta rede\n    \"id\": \"frontier_network_1000\",\n    // A rede estará ativa\n    \"chainType\": \"Live\",\n    \"bootNodes\": [\n        // nós de inicialização serão adicionados automaticamente durante a implantação\n    ],\n    // Atributo opcional, o padrão é nulo\n    \"telemetryEndpoints\": null,\n    // Defina um identificador de protocolo para esta rede\n    \"protocolId\": \"network-chain-1000\",\n    // Defina propriedades para definir o token e a compatibilidade com ethereum\n    \"properties\": {\n        \"isEthereum\": true,\n        \"ss58Format\": 42,\n        \"tokenDecimals\": 18,\n        \"tokenSymbol\": \"UNIT\"\n    },\n    // Defina a cadeia de retransmissão stagenet\n    \"relay_chain\": \"westend_moonbase_relay_stagenet\",\n    // Defina o ID da parachain reservado na cadeia de retransmissão\n    \"para_id\": 3333,\n    // Sem necessidade\n    \"codeSubstitutes\": {},\n    \"genesis\": { \n        ... \n    }\n}\n</code></pre> <p>A outra seção importante do arquivo está dentro do atributo <code>genesis</code>, que contém o estado da gênese. No seguinte trecho JSON, os valores e a configuração padrão para alguns módulos são apresentados como exemplo:</p> <pre><code>{\n    ...\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            // Define a conta que terá privilégios sudo\n            \"sudo\": {\n                \"key\": \"0xf24ff3a9cf04c71dbc94d0b566cac\"\n            },\n            // Define os saldos iniciais para algumas contas\n            \"balances\": {\n                \"balances\": [\n                [\n                    \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x773539d4ac0e786233d90a233654ccee26a613d9\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0xf24ff3a9cf04c71dbc94d0b566cac\",\n                    1208925819614629174706176\n                ]\n                ]\n            },\n            // Define os saldos para as contas EVM\n            \"evm\": {\n                \"accounts\": {\n                \"0x1000000000000000000000000000000000000001\": {\n                    \"nonce\": \"0x1\",\n                    \"balance\": \"0xd3c21bcecceda1000000\",\n                    \"storage\": {},\n                    \"code\": [\n                    0\n                    ]\n                },\n                \"0x6be02d1d3665660d22ff9624b7be0551ee1ac91b\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                },\n                \"0xd43593c715fdd31c61141abd04a99fd6822c8558\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                }\n                }\n            },\n        }\n    }\n    ...\n}\n</code></pre> <p>Um exemplo de um atributo não editável manualmente é o Runtime Wasm (na seção de estado da gênese), que é uma representação hexadecimal de um blob binário gerado pelo compilador. Ainda assim, além disso, a maioria das propriedades são fáceis de editar antes de iniciar a rede.</p>"}, {"location": "builders/build/customize/customizing-chain-specs/#generating-raw-specs-file", "title": "Gerando um Arquivo de Especificação de Cadeia JSON Bruto", "text": "<p>Uma etapa final antes de implantar a rede Tanssi é converter o arquivo de especificação JSON em um formato bruto, que é uma versão compacta e menos legível do mesmo arquivo, necessária para inicializar um nó.</p> <p>Depois de passar pelas etapas para gerar o arquivo de especificação da cadeia JSON e editar seus valores, o seguinte comando converterá o arquivo de especificações da cadeia no formato bruto necessário:</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec --chain=chain_spec.json --raw &gt; raw_chain_spec.json\n</code></pre> <p>Agora que este arquivo foi configurado e personalizado e está no formato JSON bruto correto, ele pode ser carregado para inicializar uma nova rede na Tanssi.</p>"}, {"location": "builders/build/customize/prerequisites/", "title": "Pré-requisitos para a Construção de uma Rede", "text": ""}, {"location": "builders/build/customize/prerequisites/#introduction", "title": "Introdução", "text": "<p>A implantação de uma rede através da Tanssi é um passo bastante simples, onde o único requisito é ter uma especificação de cadeia válida para fazer upload.</p> <p>Embora a Tanssi forneça especificações de cadeia para os Templates disponíveis, pode ser necessário gerar uma nova para corresponder a quaisquer alterações que o caso de uso possa precisar ser implementado no Runtime.</p> <p>As seções a seguir deste artigo cobrirão o software mínimo necessário e seu processo de instalação para obter um ambiente de desenvolvimento adequado para compilar um nó Substrate e gerar a especificação da cadeia.</p>"}, {"location": "builders/build/customize/prerequisites/#installing-rust", "title": "Instalação do Rust", "text": "<p>Rust é uma linguagem de programação moderna, portátil e de alto desempenho que é a base da estrutura de desenvolvimento de blockchain Substrate.</p> <p>Para compilar a rede Tanssi, o compilador rust, <code>rustc</code>, e o gerenciador de pacotes, <code>cargo</code>, devem ser instalados no sistema.</p> <p>De acordo com as instruções na documentação oficial do Rust, para sistemas Linux ou macOS, execute o seguinte comando:</p> LinuxMacOS <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Quando o processo de instalação for concluído, executar o seguinte comando verifica se o compilador recém-instalado funciona corretamente, mostrando o número da versão:</p> LinuxMacOS <pre><code>rustc --version\n</code></pre> <pre><code>rustc --version\n</code></pre> <p>Há outros métodos para instalar o Rust, como usar um gerenciador de pacotes. Outras opções podem ser encontradas no site oficial do Rust.</p>"}, {"location": "builders/build/customize/prerequisites/#installing-git", "title": "Instalação do Git", "text": "<p>Git é recomendado para clonar o repositório de código da Tanssi, onde os Templates de nó podem ser encontrados. O Git provavelmente é fornecido na configuração de instalação padrão do sistema operacional ou incluído em outras ferramentas, como o Xcode no MacOS.</p> <p>Se o Git não estiver presente no sistema, o seguinte comando o instalará usando um gerenciador de pacotes:</p> LinuxMacOS <pre><code>apt-get install git\n</code></pre> <pre><code>brew install git\n</code></pre> <p>Para verificar a instalação correta do Git, executar o seguinte comando em um terminal deve exibir a versão do Git:</p> LinuxMacOS <pre><code>git --version\n</code></pre> <pre><code>git --version\n</code></pre>"}, {"location": "builders/build/customize/prerequisites/#building-tanssi-template", "title": "Construindo um Template Tanssi", "text": "<p>Para construir um nó Substrate, como os Templates incluídos no repositório Tanssi, é necessário instalar componentes de desenvolvimento adicionais no sistema:</p> LinuxMacOS <pre><code>apt-get install -y build-essential protobuf-compiler clang libssl-dev pkg-config\n</code></pre> <pre><code>brew install protobuf openssl\n</code></pre> <ol> <li> <p>Clone the Tanssi code hosted on GitHub <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre></p> </li> <li> <p>Entre na pasta do projeto <pre><code>cd tanssi\n</code></pre></p> </li> <li> <p>Construa o Template de rede Tanssi</p> </li> </ol> Baseline EVMBaseline Substrate <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>Ter um ambiente de desenvolvimento saudável será necessário para construir um Runtime personalizado e, finalmente, gerar o arquivo de especificação da cadeia que será usado para implantar sua rede Tanssi.</p>"}, {"location": "builders/build/templates/", "title": "Templates de Rede", "text": "<p>Comece o desenvolvimento de sua rede com nossos Templates abrangentes. Projetados para implantação rápida, esses Templates fornecem uma base sólida para soluções EVM e não-EVM, acelerando a sua jornada de produção.</p>"}, {"location": "builders/build/templates/#escolha-um-template", "title": "Escolha um Template", "text": "<p>A Tanssi oferece dois Templates para dar início ao processo de desenvolvimento:</p> <ul> <li> <p>Template de rede Tanssi Básico - um Template que fornece a plataforma básica para começar a adicionar lógica personalizada     </p> <p> Saiba mais sobre o que este Template fornece</p> <p> Comece a construir com este Template</p> </li> <li> <p>Template de Rede EVM (Máquina Virtual Ethereum) Tanssi Básico - um Template que fornece compatibilidade total com o Ethereum     </p> <p> Saiba mais sobre o que este Template fornece</p> <p> Comece a construir com este Template</p> </li> </ul> <p>Para saber mais sobre os requisitos mínimos para que sua cadeia funcione na Tanssi e quais módulos são incluídos automaticamente, consulte a página Visão geral do Template.</p>"}, {"location": "builders/build/templates/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/build/templates/custom-runtime/", "title": "Runtime Personalizado", "text": ""}, {"location": "builders/build/templates/custom-runtime/#introduction", "title": "Introdução", "text": "<p>Para as equipes que trabalham em um projeto de framework Substrate existente, será necessário incluir alguns módulos e configurações obrigatórias no runtime. Isso garantirá que o runtime existente possa se tornar um runtime de rede Tanssi sem problemas, alinhando-se com as regras do protocolo.</p> <p>A falha em fazê-lo pode levar à interoperabilidade reduzida e exposição desnecessária a vulnerabilidades.</p>"}, {"location": "builders/build/templates/custom-runtime/#requisitos-minimos", "title": "Requisitos Mínimos", "text": "<p>Runtimes Substrate já existentes precisam implementar pelo menos o framework para se comunicar dentro do ecossistema Tanssi, juntamente com os módulos específicos da Tanssi.</p> <p>No entanto, as equipes podem já ter implementado certos módulos que podem colidir com algumas funcionalidades relacionadas à Tanssi, por exemplo, produção de blocos, atribuição de autoridade de bloco e consenso.</p> <p>Os seguintes módulos são incluídos por padrão em muitos Templates populares e devem ser removidos junto com sua configuração:</p> <pre><code>Authorship: pallet_authorship = 20,\nCollatorSelection: pallet_collator_selection = 21,\nSession: pallet_session = 22,\nAura: pallet_aura = 23,\nAuraExt: cumulus_pallet_aura_ext = 24,\n</code></pre> <p>Em qualquer caso, certifique-se de verificar seu runtime e remover todos os módulos que podem interferir na produção de blocos como um recurso de serviço antes de iniciar o processo de registro.</p>"}, {"location": "builders/build/templates/custom-runtime/#adding-cumulus-support", "title": "Integrando Sua Cadeia Stand-Alone", "text": "<p>Se seu runtime existente estiver configurado como uma cadeia stand-alone, você precisará adicionar um mecanismo de consenso para integrar no ecossistema Tanssi. Verifique qualquer um dos Templates disponíveis no repositório Tanssi para uma configuração de referência ou a documentação do framework.</p>"}, {"location": "builders/build/templates/custom-runtime/#adding-tanssi-support", "title": "Adicionando Suporte ao Protocolo Tanssi", "text": "<p>Para suportar o protocolo Tanssi, será necessário adicionar dois módulos através das seguintes etapas:</p> <ol> <li> <p>Inclua as dependências no manifesto <code>Cargo.toml</code> (geralmente localizado na pasta raiz). Abra o arquivo <code>Cargo.toml</code> e adicione os módulos na seção <code>dependencies</code></p> <pre><code>[dependencies]\n...\npallet-cc-authorities-noting = { \n    git = \"https://github.com/moondance-labs/tanssi\", \n    branch = \"master\", default-features = false \n}\npallet_authorities_noting = {\n    git = \"https://github.com/moondance-labs/moonkit\",\n    branch = \"tanssi-polkadot-v0.9.43\", default-features = false\n}\n...\n</code></pre> </li> <li> <p>Configure os módulos. Abra o arquivo <code>lib.rs</code> localizado na pasta <code>*/runtime/src</code> e adicione a configuração para ambos os módulos:</p> <pre><code>    impl pallet_author_inherent::Config for Runtime {\n        type AuthorId = NimbusId;\n        type AccountLookup = tp_consensus::NimbusLookUp;\n        type CanAuthor = pallet_cc_authorities_noting::CanAuthor&lt;Runtime&gt;;\n        type SlotBeacon = tp_consensus::AuraDigestSlotBeacon&lt;Runtime&gt;;\n        type WeightInfo = \n            pallet_author_inherent::weights::SubstrateWeight&lt;Runtime&gt;;\n    }\n\n    impl pallet_cc_authorities_noting::Config for Runtime {\n        type RuntimeEvent = RuntimeEvent;\n        type SelfParaId = parachain_info::Pallet&lt;Runtime&gt;;\n        type RelayChainStateProvider = \n            cumulus_pallet_parachain_system::RelaychainDataProvider&lt;Self&gt;;\n        type AuthorityId = NimbusId;\n        type WeightInfo = \n            pallet_cc_authorities_noting::weights::SubstrateWeight&lt;Runtime&gt;;\n    }\n</code></pre> <p>Observe que essa configuração é agnóstica do caso de uso</p> </li> <li> <p>Declare os módulos como parte do runtime. No mesmo arquivo <code>lib.rs</code>, localizado na pasta <code>*/runtime/src</code>, adicione os módulos à construção do runtime:</p> <pre><code>        construct_runtime!(\n        pub enum Runtime where\n            Block = Block,\n            NodeBlock = opaque::Block,\n            UncheckedExtrinsic = UncheckedExtrinsic,\n        {\n            ...\n            // Tanssi network\n            AuthoritiesNoting: pallet_cc_authorities_noting = 50,\n            AuthorInherent: pallet_author_inherent = 51,\n            ...\n        }\n        );\n</code></pre> </li> <li> <p>Certifique-se de que seu cabeçalho está configurado da seguinte forma:</p> <pre><code>type Header = generic::Header&lt;BlockNumber, BlakeTwo256&gt;;\n/// An index to a block.\npub type BlockNumber = u32; \n</code></pre> </li> <li> <p>Adicione o executor do bloco, para permitir que os operators na rede Tanssi validem que os autores são os Sequencers atribuídos pela Tanssi (e não um ator mal-intencionado)</p> </li> </ol> <p><code>rust     cumulus_pallet_parachain_system::register_validate_block! {         Runtime = Runtime,         BlockExecutor = pallet_author_inherent::BlockExecutor::&lt;Runtime, Executive&gt;         CheckInherents = CheckInherents,     }</code></p>"}, {"location": "builders/build/templates/evm/", "title": "Template EVM Base", "text": ""}, {"location": "builders/build/templates/evm/#introduction", "title": "Introdução", "text": "<p>O Template de rede EVM (Ethereum Virtual Machine) da Tanssi foi projetado para equipes que desenvolvem suas aplicações em cima de contratos inteligentes EVM. Ele inclui todos os componentes essenciais necessários para uma rede totalmente compatível com o Ethereum:</p> <ul> <li>EVM - adiciona uma camada de execução da Ethereum Virtual Machine para aplicações de contratos inteligentes baseados em EVM</li> <li>Suporte Etherum JSON RPC - as redes EVM da Tanssi são totalmente compatíveis com Ethereum JSON RPC. Consequentemente, todas as ferramentas baseadas em Ethereum como MetaMask, Ethers.js, Viem, Hardhat, Foundry e muito mais, funcionam perfeitamente</li> <li>Contas Unificadas - permite que as redes EVM da Tanssi apresentem contas ECDSA no estilo Ethereum</li> </ul>"}, {"location": "builders/build/templates/evm/#evm-network-template", "title": "EVM Network Template", "text": "<p>O Template já inclui a configuração necessária para integração perfeita com o protocolo Tanssi e o provedor de segurança escolhido, por exemplo, Symbiotic no Ethereum. Portanto, este Template não requer alterações adicionais no Runtime se o aplicativo for construído em cima do EVM.</p> <p>Isso significa que este Template está pronto para ser implantado como está através da Tanssi, desbloqueando muitos recursos, como:</p> <ul> <li>Utilizar a produção de blocos como serviço da Tanssi</li> <li>Obter finalidade de transação determinística em segundos</li> <li>Escolher o provedor de segurança que melhor se adapta às suas necessidades. Por exemplo, aproveitar a segurança de nível Ethereum do Symbiotic</li> <li>Construir dApps interagindo com sua rede através de uma API</li> <li>Conectar qualquer carteira Ethereum, como Metamask e Ledger</li> <li>Usar bibliotecas Ethereum bem conhecidas como Ethers.js, Web3.js, Web3.py, e mais</li> <li>Implantar contratos inteligentes EVM com ferramentas como Remix, Hardhat, Foundry, e mais</li> </ul>"}, {"location": "builders/build/templates/evm/#included-modules", "title": "Módulos Incluídos", "text": "<p>Alem dos módulos e configurações que tornam o Template de rede Tanssi EVM compatível com o protocolo Tanssi, ele também inclui muitos módulos para fornecer funcionalidades básicas.</p> <p>Para atingir a compatibilidade total com o Ethereum, esses módulos específicos também estão incluídos:</p> <ul> <li>EVM - adiciona suporte para execução de bytecode EVM não modificado em uma rede powered by Tanssi. Ele usa o SputnikVM baseado em Rust como o mecanismo EVM subjacente</li> <li>Ethereum - funciona em conjunto com o módulo EVM para fornecer emulação completa para o processamento de blocos Ethereum. Entre muitas outras tarefas, é responsável por criar blocos Ethereum emulados para componentes específicos do Ethereum, como logs EVM</li> </ul> <p>Ambos os módulos fazem parte do projeto Frontier, que é a espinha dorsal das redes powered by Tanssi compatíveis com Ethereum.</p>"}, {"location": "builders/build/templates/overview/", "title": "Visão Geral dos Templates", "text": ""}, {"location": "builders/build/templates/overview/#introduction", "title": "Introdução", "text": "<p>As redes implantadas através da Tanssi são blockchains totalmente personalizáveis, beneficiando-se de um conjunto compartilhado de Sequencers e da segurança de um provedor de sua escolha. Os Templates apresentados neste artigo implementam as funcionalidades e configurações necessárias para suportar o protocolo Tanssi, tornando o desenvolvimento mais fácil.</p>"}, {"location": "builders/build/templates/overview/#base-setup-supporting-tanssi", "title": "Configuração Base para Suportar o Protocolo Tanssi", "text": "<p>As redes Tanssi devem implementar os seguintes módulos para suportar o protocolo e se beneficiar com segurança da produção de blocos da Tanssi como um serviço:</p> <ul> <li>Author Noting - registra o conjunto de Sequencers atribuídos à rede pela Tanssi</li> <li>Author Inherent - permite que o Sequencer que está criando o bloco inclua sua identidade para ser validado e recompensado</li> </ul> <p>Se você não incluir esses módulos no Runtime da rede Tanssi, não haverá um método para confirmar que os blocos estão sendo gerados por Sequencers confiáveis designados pelo orquestrador Tanssi. Isso poderia criar uma vulnerabilidade para que atores mal-intencionados explorem e comprometam a rede. Para obter mais informações sobre a produção de blocos da Tanssi como um serviço, consulte o artigo Serviços de Produção de Blocos.</p> <p>Além da produção de blocos, há outros aspectos essenciais para qualquer rede coberta nos Templates, como:</p> <ul> <li>Consenso - as redes têm a funcionalidade necessária para permitir que os Sequencers produzam blocos, fofoquem e validem-nos e coordenem com o provedor de segurança para serem notificados sobre a finalidade do bloco</li> <li>Interoperabilidade de Redes - lida com a ingestão e envio de mensagens descendentes e laterais de entrada, permitindo que uma rede Tanssi se comunique e interaja com as outras cadeias dentro do ecossistema</li> <li>Atualizações de Runtime - uma atualização de Runtime em uma rede Tanssi deve ser informada aos operators do provedor de segurança para permitir que eles verifiquem os blocos produzidos pelos Sequencers das redes Tanssi</li> </ul>"}, {"location": "builders/build/templates/overview/#included-modules", "title": "Módulos Incluídos", "text": "<p>Além dos módulos necessários para suportar a operação de uma rede Tanssi, muitos outros módulos fornecem comportamento funcional com o qual os usuários podem interagir.</p> <p>Estes são alguns dos módulos funcionais que expõem um comportamento aos usuários que estão incluídos nos Templates e prontos para uso:</p> <ul> <li>Balances - o módulo Balances fornece funções para lidar com contas e saldos para a moeda nativa da rede Tanssi</li> <li>Utility - o módulo Utility fornece funções para executar várias chamadas em um único despacho. Além dos lotes de transações, este módulo também permite a execução de uma chamada de uma origem alternativa assinada</li> <li>Proxy - o módulo Proxy fornece funções para delegar a outras contas (proxies) a permissão para despachar chamadas de uma origem proxy</li> <li>Modo de Manutenção - o módulo Modo de Manutenção permite que a rede Tanssi seja definida para um modo em que não executa transferências de saldo/ativos ou outras transações. Isso pode ser útil ao atualizar o Runtime em uma emergência, ao executar grandes migrações de armazenamento ou quando uma vulnerabilidade de segurança é descoberta</li> <li>Tx Pause - o módulo Tx Pause permite que uma origem válida (normalmente Root) pause (e cancele a pausa) um módulo inteiro ou uma única transação. Uma transação em pausa (ou todas as transações incluídas em um módulo em pausa) falhará quando chamada até que seja despausada. Este módulo fornece um grau maior de granularidade em comparação com o modo de manutenção, tornando-o particularmente útil quando uma transação defeituosa ou vulnerável é identificada no Runtime</li> <li>Multisig - o módulo Multisig permite despachos de transações que exigem -tipicamente- mais de uma assinatura. Uma transação multisig define um conjunto de contas autorizadas e um limite para sua aprovação, exigindo consenso entre várias partes</li> </ul>"}, {"location": "builders/build/templates/overview/#getting-started", "title": "Comece a Construir", "text": "<p>Para começar a construir sobre os Templates fornecidos, seja o Template de rede Tanssi base ou o Template EVM (Ethereum Virtual Machine) base, a abordagem recomendada é bifurcar o repositório Tanssi e começar a adicionar módulos integrados ou módulos personalizados sobre a tag versão mais recente.</p> <p>Esta abordagem tem algumas vantagens, como:</p> <ul> <li>Construir sobre a versão mais recente e estável</li> <li>Obter o protocolo Tanssi já configurado e incluído no Runtime do Template</li> <li>Mantenha sua bifurcação atualizada sincronizando com o repositório upstream da Tanssi</li> <li>Execute os testes incluídos, garantindo que a produção de blocos em sua rede Tanssi funcione conforme o esperado</li> <li>Execute um ambiente local completo com a configuração Zombienet incluída</li> </ul> <p>Se os Templates já cobrem as necessidades do seu caso de uso ou após construir e testar sua cadeia, você pode continuar com o artigo Implantar sua rede via o Tanssi DApp para saber como usar o Tanssi dApp para registrar e colocar sua cadeia em funcionamento.</p>"}, {"location": "builders/build/templates/substrate/", "title": "Template de Rede de Base", "text": ""}, {"location": "builders/build/templates/substrate/#introduction", "title": "Introdução", "text": "<p>O repositório Tanssi inclui um Template mínimo que fornece a configuração necessária para suportar o protocolo Tanssi e alguns módulos essenciais, como o que permite lidar com a moeda da rede Tanssi.</p> <p>Esta seção aborda este Template básico, o que ele inclui e alguns aspectos a serem considerados ao adicionar dependências externas.</p>"}, {"location": "builders/build/templates/substrate/#baseline-network-template", "title": "Template de Rede de Base", "text": "<p>Desenvolver um Runtime de rede normalmente envolve duas etapas principais:</p> <ol> <li>Incorporar módulos internos pré-existentes no Runtime</li> <li>Criar módulos personalizados adaptados às necessidades específicas do seu aplicativo</li> </ol> <p>Como o Template fornecido já inclui as configurações essenciais para uma integração perfeita com o protocolo Tanssi e o provedor de segurança (por exemplo, Symbiotic no Ethereum), as equipes interessadas em construir uma rede inovadora powered by Tanssi podem usar este Template como ponto de partida para adicionar sua lógica personalizada.</p> <p>Aqui estão alguns dos recursos que vêm com este Template:</p> <ul> <li>Utilize da Tanssi produção de blocos como serviço</li> <li>Escolha o provedor de segurança que melhor se adapta às suas necessidades. Por exemplo, aproveite a segurança de nível Ethereum do Symbiotic</li> <li>Obtenha a finalidade determinística da transação em segundos</li> <li>Crie dApps que interagem com sua rede por meio de uma API</li> </ul> <p>Aproveitando esses recursos no Template, você pode iniciar o desenvolvimento da sua rede Tanssi e personalizá-la para atender aos seus requisitos e inovações específicos.</p>"}, {"location": "builders/build/templates/substrate/#adding-extra-dependencies", "title": "Adicionando Dependências Extras", "text": "<p>O Template de rede Substrate inclui todos os módulos e configurações necessários que o tornam compatível com o protocolo Tanssi e também muitos outros módulos que fornecem funcionalidades básicas.</p> <p>Este Template foi projetado para servir como base para construir, pois a maioria dos casos de uso requer capacidades expandidas, adicionando módulos existentes ou personalizados. Para saber como adicionar novas funcionalidades ao seu Runtime, consulte a seção personalizar Runtime.</p>"}, {"location": "builders/deploy/", "title": "Implante Sua Appchain em Minutos", "text": "<p>Com o Tanssi, lançar sua appchain é simples e eficiente. A plataforma simplifica o processo, para que você possa se concentrar na construção de seu aplicativo.</p>"}, {"location": "builders/deploy/#visao-geral-rapida-da-implantacao-via-tanssi-dapp", "title": "Visão Geral Rápida da Implantação via Tanssi DApp", "text": "<p>A implantação de uma appchain powered by Tanssi via Tanssi dApp é realizada como um fluxo único e simplificado, consistindo em cinco etapas distintas:</p> <ol> <li>Selecione um template e configure-o</li> <li>Atender aos saldos mínimos exigidos de tokens</li> <li>Reserve seu Tanssi appchain ID</li> <li>Gere seus arquivos de appchain personalizados</li> <li>Registre sua appchain na Tanssi</li> </ol> <p></p> <p>Note</p> <p>Para implantações de appchains de Teste Rápido e appchains Dedicadas na TestNet da Tanssi, a verificação é realizada manualmente pela equipe da Tanssi. Após a aprovação, uma appchain de teste rápido fica pronta em cerca de 10 minutos, enquanto uma appchain dedicada leva aproximadamente 2 horas. Na MainNet da Tanssi, todo o processo será totalmente descentralizado e permissionless, garantindo autonomia e escalabilidade desde o primeiro dia”</p> <p>Para começar, visite Usando o Tanssi DApp.</p>"}, {"location": "builders/deploy/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/deploy/dapp/", "title": "Implemente Sua Appchain Através da Tanssi DApp", "text": ""}, {"location": "builders/deploy/dapp/#introduction", "title": "Introdução", "text": "<p>A Tanssi tem como objetivo reduzir a barreira de entrada para a construção de appchains descentralizadas, simplificando o processo de integração e abstraindo os detalhes técnicos do lançamento de uma appchain powered by Tanssi. O Tanssi dApp permite que você inicie uma appchain em apenas alguns minutos. Este guia mostra as etapas necessárias para lançar uma appchain na Dancelight, a Tanssi TestNet, usando o Tanssi dApp.</p>"}, {"location": "builders/deploy/dapp/#quick-trial-vs-dedicated-appchains", "title": "Testes Rápidos vs. Appchains Dedicadas", "text": "<p>O Tanssi dApp suporta a criação de dois tipos de appchains:</p> <ul> <li>Teste rápido: uma appchain temporária que se autodestrói após 48 horas</li> <li>Dedicada: uma appchain de longa duração para builders do ecossistema Tanssi</li> </ul> <p>Ambos os tipos se comportam de forma idêntica; a diferença é a natureza temporária do teste rápido. Em geral, o teste rápido é o melhor para quem quer experimentar uma appchain powered by Tanssi. Se precisar de um ambiente de teste de longa duração, a equipe Tanssi pode ajudar a configurar uma appchain dedicada.</p> <p>As capturas de tela e o conteúdo deste guia usam appchains de teste rápido, mas o processo é o mesmo para configurar uma appchain dedicada.</p> <p></p>"}, {"location": "builders/deploy/dapp/#prerequisites", "title": "Pré-requisitos", "text": ""}, {"location": "builders/deploy/dapp/#supported-wallets", "title": "Carteiras suportadas", "text": "<p>Como a Tanssi é construída com Substrate, você precisará de uma carteira compatível com Substrate para implantar e gerenciar sua appchain Tanssi. Carteiras suportadas:</p> <ul> <li>Talisman</li> <li>SubWallet</li> <li>Enkrypt</li> <li>Extensão Polkadot.js</li> </ul> <p>Se você implantar uma appchain EVM powered by Tanssi, os usuários poderão usar carteiras Ethereum, como MetaMask, sem precisar de carteira Substrate.</p> <p></p>"}, {"location": "builders/deploy/dapp/#connect-wallet", "title": "Conecte Sua Carteira ao DApp", "text": "<p>Para conectar sua carteira à Tanssi dApp, clique em Connect Wallet no canto superior direito e escolha o tipo de carteira. Depois:</p> <ol> <li>Escolha sua conta no menu suspenso</li> <li>Assine a mensagem solicitada para fazer login na Tanssi dApp</li> </ol> <p></p> <p>Após conectar, seu endereço aparecerá no canto superior direito. Se tiver várias contas conectadas, clique no endereço para trocar.</p>"}, {"location": "builders/deploy/dapp/#configure-your-appchain", "title": "Configure Sua Appchain", "text": "<p>Na página inicial do dApp, clique em Start Building no bloco Launch Network para configurar sua appchain imediatamente. Escolha entre Quick Trial ou Dedicated. Veja as diferenças em Testes rápidos vs. appchains dedicadas.</p> <p></p> <p>Em seguida, selecione o template que melhor atende ao seu caso de uso e configure as propriedades da appchain. Você pode escolher o template EVM ou Substrate ou enviar um arquivo de especificação bruta. Consulte Templates para detalhes.</p>"}, {"location": "builders/deploy/dapp/#evm-template", "title": "Template EVM", "text": "<p>O template EVM adiciona a camada de compatibilidade Ethereum à sua appchain Tanssi.</p> <p>Você precisará de um ID de cadeia EVM exclusivo (EIP-155). Verifique se o ID está livre em Chainlist. Ao lançar em produção, abra um PR para reservar o ID no repositório <code>ethereum-lists/chains</code> assim que o endpoint RPC estiver ativo.</p> <p>Note</p> <p>Um ID de cadeia EVM registrado é necessário apenas na MainNet. Para testes na TestNet, use qualquer ID disponível.</p> <p>Para configurar:</p> <ol> <li>Em Network Details, informe o nome do projeto, o ID de cadeia EVM e a categoria</li> <li>Em Gas Token, informe o símbolo do token nativo (18 casas decimais fixas)</li> <li>Opcional: ajuste configurações EIP-1559 em Advanced (base fee e variação máxima)</li> <li>Em Accounts, forneça o endereço (estilo Ethereum) da conta sudo e o saldo inicial. Só existe uma conta sudo por vez; ela pode ser trocada depois e a rede pode migrar para um Template descentralizado</li> <li>Opcional: em Advanced, clique em Add para adicionar contas e saldos de gênese</li> <li>Opcional: em Genesis Smart Contracts, clique em Add para incluir contratos gênese (remova <code>0x</code> do bytecode)</li> <li>Ao finalizar o template, clique em Continue e siga para Checar saldos</li> </ol> <p></p>"}, {"location": "builders/deploy/dapp/#substrate-template", "title": "Template Substrate", "text": "<p>O template Substrate traz as configurações básicas para integrar com a Tanssi e pode servir como base para uma appchain personalizada.</p> <p>Para configurar:</p> <ol> <li>Em Network Details, informe o nome do projeto e a categoria</li> <li>Em Gas Token, informe decimais, símbolo e formato SS58</li> <li>Em Accounts, informe o endereço (estilo Substrate) da conta sudo e o saldo inicial. Só existe uma conta sudo por vez; pode ser trocada depois e a rede pode migrar para governança descentralizada</li> <li>Opcional: em Advanced, clique em Add para adicionar contas e saldos de gênese</li> <li>Clique em Continue para seguir para Checar saldos</li> </ol> <p></p>"}, {"location": "builders/deploy/dapp/#custom", "title": "Personalizado", "text": "<p>Se você já possui um runtime Substrate e vai enviar um arquivo de especificação personalizado, garanta que ele possa evoluir para uma appchain Tanssi.</p> <p>Seu runtime deve implementar o seguinte:</p> <ul> <li>Inclua o SDK Cumulus conforme Base Setup to Connect to Polkadot</li> <li>Inclua os módulos Tanssi de produção de blocos conforme Base Setup to Support the Tanssi Protocol</li> </ul> <p>Outras exigências no runtime:</p> <ul> <li> <p>No módulo <code>timestamp</code>, defina <code>OnTimestampSet</code> conforme o snippet:</p> <pre><code>type OnTimestampSet = tp_consensus::OnTimestampSet&lt;\n    &lt;Self as pallet_author_inherent::Config&gt;::SlotBeacon,\n    ConstU64&lt;{ SLOT_DURATION }&gt;,\n&gt;;\n</code></pre> </li> <li> <p>Remova módulos de produção de blocos/consenso (Aura, Grandpa etc.), deixando a Tanssi assumir. Por exemplo, removendo:</p> <pre><code>// Suporte a collators. A ordem destes 4 é importante e não deve mudar.\n#[runtime::pallet_index(20)]\npub type Authorship = pallet_authorship;\n#[runtime::pallet_index(21)]\npub type CollatorSelection = pallet_collator_selection;\n#[runtime::pallet_index(22)]\npub type Session = pallet_session;\n#[runtime::pallet_index(23)]\npub type Aura = pallet_aura;\n#[runtime::pallet_index(24)]\npub type AuraExt = cumulus_pallet_aura_ext;\n</code></pre> </li> </ul> <p>Por fim, gere e edite a especificação da cadeia, prestando atenção especial a:</p> <ul> <li><code>para_id</code>: você precisa de um ID pré-registrado; obtenha-o no passo Reserve your Network ID e retorne para prosseguir</li> <li><code>is_ethereum</code>: defina como <code>true</code> se precisar expor RPCs compatíveis com Ethereum</li> </ul> <p>Ajuste também conforme o tipo de appchain:</p> Quick Trial AppchainDedicated Appchain <pre><code>{\n    ...\n    \"relay_chain\": \"rococo_flashbox_relay_testnet\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 1000\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <pre><code>{\n    ...\n    \"relay_chain\": \"rococo-local\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 0\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <p>Depois, selecione o template Custom e envie o arquivo JSON de especificação bruta.</p> <p></p> <p>Note</p> <p>O arquivo de especificação bruta não deve exceder 2 MB.</p>"}, {"location": "builders/deploy/dapp/#check-balances", "title": "Checar Saldos", "text": "<p>Verifique se você tem saldo suficiente. Caso não tenha, clique em Request Tokens e faça login com GitHub ou Google, responda às perguntas rápidas e solicite os tokens para a carteira conectada.</p> <p></p> <p>Para appchains dedicadas, preencha o formulário de inscrição; a equipe enviará os tokens em até um dia útil.</p> <p>Saldos mínimos para lançar:</p> Quick Trial AppchainDedicated Appchain Chain Balance Required Orchestration layer 70 UNIT Tanssi TestNet 100 SNAP Chain Balance Required Tanssi TestNet 100 STAR <p>Note</p> <p>Appchains de teste rápido usam uma camada adicional de orquestração e, portanto, requerem SNAP e UNIT. Para appchains dedicadas, apenas STAR é necessário.</p>"}, {"location": "builders/deploy/dapp/#reserve-appchain-id", "title": "Reserve Seu ID de Appchain", "text": "<p>Se ainda não fez isso, você precisa reservar o seu ID de appchain Tanssi, que identificará sua cadeia dentro do ecossistema Tanssi.</p> <p>Para reservar o seu ID de appchain Tanssi, será necessário enviar uma transação. Certifique-se de usar a conta com a qual pretende lançar sua appchain Tanssi ao enviar a transação.</p> <ol> <li>Clique em Reserve Network ID</li> <li>Assine a transação na sua carteira</li> </ol> <p></p> <p>Após a transação, o ID aparecerá no dApp; clique em Continue. Parte dos tokens UNIT (ou STAR, para appchain dedicada) ficará reservada.</p> <p></p>"}, {"location": "builders/deploy/dapp/#generate-appchain-files", "title": "Gere Seus Arquivos de Appchain", "text": "<p>Antes de implantar, gere três arquivos:</p> <ul> <li>A especificação da cadeia bruta - uma versão compacta do arquivo de especificação JSON, que define as configurações iniciais e o estado que todos os nós participantes da rede devem concordar para alcançar consenso e produzir blocos</li> <li>O cabeçalho do estado gênese - define o estado inicial sobre o qual todas as transações e transições de estado são executadas</li> <li>O Gênesis Wasm - um objeto WebAssembly (Wasm) que define a lógica de Runtime. Eles são gerados automaticamente com base no seu ID e configurações. Clique em Generate.</li> </ul> <p></p> <p>Quando prontos, clique em Continue para o passo final.</p>"}, {"location": "builders/deploy/dapp/#deploy-your-appchain", "title": "Faça o Deploy da Sua Appchain", "text": "<p>No caso de teste rápido, são duas transações: registrar na camada de orquestração e na Tanssi TestNet.</p> <p>Para registrar na camada de orquestração:</p> <ol> <li>Clique em Register em Register Network in Relay</li> <li>Confirme a transação na carteira</li> </ol> <p></p> <p>Quando a transação for concluída com sucesso, o dApp será atualizado para mostrar que você registrou sua appchain Tanssi na seção Register Network in Relay.</p> <p>Por fim, para registrar sua appchain na Tanssi, siga estas etapas:</p> <ol> <li>Clique em Register em Register Network in Tanssi</li> <li>Confirme a transação</li> </ol> <p></p> <p>Quando a transação for concluída, o dApp exibirá o registro da appchain. No painel, você poderá acompanhar o status, blocos, endpoints RPC/WS e outras informações.</p> <p></p> <p>E pronto! Você registrou sua appchain Tanssi. O processo de lançamento iniciará automaticamente após a verificação da equipe Tanssi. Depois de ativa, volte ao Dashboard para ver o RPC e demais dados da rede.</p>"}, {"location": "builders/interoperability/", "title": "Interoperabilidade", "text": "<p>Explore as soluções cross-chain integradas disponíveis no ecossistema Tanssi, permitindo transferências de ativos e comunicação entre Tanssi e Ethereum.</p>"}, {"location": "builders/interoperability/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/interoperability/built-in-bridge/", "title": "Usando a Ponte Tanssi Integrada", "text": ""}, {"location": "builders/interoperability/built-in-bridge/#introduction", "title": "Introdução", "text": "<p>O protocolo Tanssi orquestra componentes de infraestrutura, permitindo que os desenvolvedores lancem seus appchains personalizados em minutos e fornecendo a eles segurança econômica de nível Ethereum pronta para uso. Para facilitar todo o processo para os desenvolvedores, uma arquitetura de primeira classe foi projetada e implementada.</p> <p>O token TANSSI é o motor que permite a integração de diferentes componentes de infraestrutura com provedores de segurança externos e alinha incentivos entre vários atores, incluindo detentores de tokens, node operators e builders de appchain. Para atender a diferentes casos de uso, o token tem duas versões: a moeda nativa da rede Tanssi, TANSSI (Substrate), e sua versão ERC-20, no Ethereum.</p> <p>Os usuários podem converter de uma versão para outra do token usando uma ponte sem confiança integrada da Tanssi.</p> <p>Neste guia, você aprenderá como mover seus ativos de Tanssi para Ethereum e vice-versa por meio de uma interface web segura e fácil de usar disponível no Tanssi dApp, tornando as transferências entre cadeias acessíveis a todos.</p>"}, {"location": "builders/interoperability/built-in-bridge/#prerequisites", "title": "Pré-requisitos", "text": "<p>Antes de usar a ponte Tanssi, certifique-se de ter:</p> <p>Para fazer a ponte de Tanssi para Ethereum:</p> <ul> <li>Uma carteira compatível com Substrate, como Talisman.</li> <li>Saldo TANSSI (Substrate) para transferir e pagar as taxas de ponte.</li> <li>A conta de destino do tipo Ethereum.</li> </ul> <p>Para fazer a ponte de Ethereum para Tanssi:</p> <ul> <li>Uma carteira compatível com Ethereum, como MetaMask.</li> <li>Saldo TANSSI (ERC-20) para transferir.</li> <li>Saldo ETH para pagar as taxas de ponte.</li> <li>A conta de destino do tipo Substrate.</li> </ul>"}, {"location": "builders/interoperability/built-in-bridge/#bridge-to-ethereum", "title": "Fazendo a Ponte de Tokens TANSSI para Ethereum", "text": "<p>Se você deseja converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) no Ethereum, acesse o Tanssi dApp, abra a seção da ponte e siga estas etapas:</p> <ol> <li>Selecione Mainnet no menu suspenso From.</li> <li>Clique em Connect Wallet. Uma janela pop-up aparecerá, permitindo que você selecione sua carteira Substrate preferida e escolha a conta correspondente.</li> </ol> <p></p> <p>Agora, com sua carteira conectada:</p> <ol> <li>Selecione a conta de destino no menu suspenso Select recipient address ou escolha o item Enter a custom address e insira manualmente a conta para onde deseja receber os tokens ERC-20.</li> <li>Insira o valor a ser transferido no campo Balance. As taxas estimadas de ponte e transação serão exibidas junto com o valor que a conta de destino receberá.</li> <li>Clique em Send e assine a transação.</li> </ol> <p></p> <p>E é isso! Seus tokens serão transferidos quando a próxima sessão começar. Você pode ver quanto tempo resta na sessão atual na barra de progresso.</p> <p>Note</p> <ul> <li>Você pode adicionar facilmente o endereço do contrato TANSSI ERC-20 à sua carteira clicando no ícone + mostrado ao lado do seu saldo.</li> <li>As taxas para converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) podem flutuar ao longo do tempo e devem ser pagas usando TANSSI.</li> </ul>"}, {"location": "builders/interoperability/built-in-bridge/#bridge-to-tanssi", "title": "Fazendo a Ponte de ERC-20 TANSSI para a Rede Tanssi", "text": "<p>Se você deseja converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi, acesse o Tanssi dApp, abra a seção da ponte e siga estas etapas:</p> <ol> <li>Selecione Ethereum no menu suspenso From.</li> <li>Clique em Connect Wallet, selecione sua carteira Ethereum preferida e escolha a conta.</li> </ol> <p></p> <p>Agora, com sua carteira conectada:</p> <ol> <li>Insira a conta de destino Substrate no campo Recipient.</li> <li>Insira o valor a ser transferido no campo Balance. As taxas estimadas de ponte e transação serão exibidas junto com o valor que a conta de destino receberá.</li> <li>Clique em Send e assine a transação.</li> </ol> <p></p> <p>E é isso! Seus tokens serão transferidos quando a próxima sessão começar. Você pode ver quanto tempo resta na sessão atual na barra de progresso.</p> <p>Note</p> <p>As taxas para converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi podem flutuar ao longo do tempo e devem ser pagas usando ETH.</p>"}, {"location": "builders/manage/", "title": "Gerenciando sua Rede powered by Tanssi", "text": "<p>A Tanssi dApp e o portal do desenvolvedor servem a propósitos diferentes ao gerenciar sua rede, oferecendo benefícios exclusivos adaptados às suas necessidades:</p> <ul> <li> <p>Tanssi dApp - simplifica todo o ciclo de vida da rede, desde a implantação até o gerenciamento básico. Ao remover as complexidades técnicas, ela permite uma experiência mais rápida e simplificada para criar e gerenciar redes. Algumas ações que podem ser executadas via dApp incluem:</p> </li> <li> <p>Pagamento por serviços de produção de blocos</p> </li> <li> <p>Gerenciamento de tokens (cunhagem e transferência de tokens, atualização de saldos e muito mais)</p> </li> <li> <p>Developer portal - construído sobre Polkadot.js Apps, o portal do desenvolvedor fornece ferramentas avançadas para gerenciamento de rede, sendo ideal para tarefas que exigem controle e personalização. Algumas ações que podem ser executadas através do portal do desenvolvedor incluem:</p> </li> <li> <p>Gerenciamento da conta Sudo</p> </li> <li>Envio de atualizações de runtime</li> <li>Cunhagem de tokens</li> <li>Pausar transações ou habilitar modo de manutenção em emergências</li> </ul> <p>Passe para as seções abaixo para explorar como cada ferramenta ajuda você a gerenciar sua rede powered by Tanssi de forma eficiente.</p>"}, {"location": "builders/manage/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/manage/dapp/", "title": "Usando o DApp Tanssi para Gerenciar Sua Rede", "text": "<p>O Tanssi dApp é a sua plataforma de referência para lidar com os aspectos operacionais da sua rede dentro do ecossistema Tanssi. Projetado para facilitar o uso, o dApp permite que os desenvolvedores agilizem tarefas diárias como gerenciar tokens, pagar por serviços de produção de blocos e supervisionar as operações essenciais da rede sem precisar de conhecimento técnico profundo ou configurações avançadas.</p>"}, {"location": "builders/manage/dapp/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/manage/dapp/manage-tokens/", "title": "Gerenciar Tokens", "text": ""}, {"location": "builders/manage/dapp/manage-tokens/#introduction", "title": "Introdução", "text": "<p>Qualquer rede implantada através da Tanssi é soberana e livre para definir o Template de governança que melhor se adapta ao seu caso de uso. O governador da rede tem superpoderes sobre a administração da cadeia. Consequentemente, eles podem chamar funções privilegiadas, como atualizar o Runtime e gerenciar operações relacionadas a tokens nativos, entre outras ações.</p> <p>Existem algumas ações relacionadas ao gerenciamento de tokens nativos que estão disponíveis para o governador da rede na Tanssi dApp:</p> <ul> <li>Mint tokens - cunha novos tokens, aumentando a oferta total</li> <li>Update balances - aumenta ou diminui o saldo de uma conta, afetando a oferta total</li> <li>Transfer tokens - executa uma transferência forçada de tokens de uma conta para outra</li> <li>Configure gas dynamic - disponível apenas em redes compatíveis com EVM, esta ação altera a configuração EIP-1559, afetando o mecanismo de precificação da transação</li> </ul> <p>Neste guia, você aprenderá como executar as ações listadas anteriormente usando o Tanssi dApp.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos neste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Teste Rápido ou Dedicado)</li> <li>A conta que você usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, também importada em qualquer uma das carteiras suportadas</li> </ul> <p>Note</p> <p>A conta de registro da rede é sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatível com EVM, a conta Sudo será do tipo Ethereum; caso contrário, será do tipo Substrate.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#retrieving-registration-account", "title": "Recuperando a conta de registro", "text": "<p>Se você não souber qual é a sua conta de registro, pode consultá‑la diretamente na cadeia orquestradora do Tanssi, que mantém os registros de todas as redes cadastradas. Para isso, acesse a seção Chain state no Polkadot.js Apps conectado à cadeia orquestradora para redes de teste rápidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o módulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no ícone +</li> </ol> <p>A conta de registro aparecerá na parte inferior.</p> <p></p> <p>Note</p> <p>O dApp exibirá sua rede no painel somente se a conta de registro estiver configurada corretamente.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#retrieving-sudo-account", "title": "Recuperando a conta Sudo", "text": "<p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#accesing-token-management-panel", "title": "Acessando o Painel de Gerenciamento de Tokens", "text": "<p>O Tanssi dApp implementa uma interface suave, permitindo que o governador da rede acesse e execute funções privilegiadas. Para fazer isso, vá para o Tanssi dApp e, em seguida:</p> <ol> <li>Clique no botão Manage</li> <li>Clique no botão Token Management.</li> </ol> <p></p> <p>Agora você tem acesso direto às ações apresentadas na introdução:</p> <ol> <li>Mint Tokens</li> <li>Update Balances</li> <li>Transfer Tokens</li> <li>Configurar Gas Dynamics</li> </ol> <p></p> <p>Note</p> <p>Se você não vir os detalhes da sua rede no painel, certifique-se de cumprir os pré-requisitos.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#minting-tokens", "title": "Minting Tokens", "text": "<p>O governador da rede pode cunhar novos tokens, aumentando sua oferta total. Para fazer isso, no painel Token Management, clique no botão Mint tokens e, em seguida:</p> <ol> <li> <p>Insira o endereço que conterá os tokens recém-cunhados</p> <p>Note</p> <p>O endereço de destino deve ser do tipo Ethereum se a cadeia for compatível com EVM e do tipo Substrate caso contrário.</p> </li> <li> <p>Insira a quantidade de tokens a serem cunhados</p> </li> <li>Clique em Mint</li> </ol> <p></p> <p>Você será solicitado a assinar a transação com a conta do governador da rede. Depois que a transação for concluída, o saldo da conta de destino terá sido aumentado pela quantia desejada.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#updating-balances", "title": "Updating Balances", "text": "<p>O governador da rede pode aumentar ou diminuir o saldo de qualquer conta, afetando, assim, a oferta total. Para fazer isso, no painel Token Management, clique no botão Update Balances e, em seguida:</p> <ol> <li> <p>Insira o endereço que conterá os tokens recém-cunhados. Depois de inserir o endereço, seu saldo atual será exibido</p> <p>Note</p> <p>O endereço de destino deve ser do tipo Ethereum se a cadeia for compatível com EVM e do tipo Substrate caso contrário.</p> </li> <li> <p>Insira o novo saldo que o endereço conterá</p> </li> <li>Clique em Update</li> </ol> <p></p> <p>Você será solicitado a assinar a transação com a conta do governador da rede. Depois que a transação for concluída, o saldo da conta de destino refletirá exatamente a quantia desejada, independentemente das participações anteriores.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#forced-transfers", "title": "Executando Transferências Forçadas", "text": "<p>O governador da rede pode reatribuir saldos, forçando uma transferência de tokens de uma conta para outra. Para fazer isso, no painel Token Management, clique no botão Transfer Tokens e, em seguida:</p> <ol> <li>Insira o endereço de origem que transferirá seus tokens</li> <li> <p>Insira o endereço de destino que receberá os tokens</p> <p>Note</p> <p>Os endereços de origem e destino devem ser do tipo Ethereum se a cadeia for compatível com EVM e do tipo Substrate caso contrário.</p> </li> <li> <p>Insira a quantidade de tokens a serem transferidos</p> </li> <li>Clique em Transfer</li> </ol> <p></p> <p>Você será solicitado a assinar a transação com a conta do governador da rede. Depois que a transação for concluída, a conta de destino terá recebido o número de tokens do endereço de origem.</p>"}, {"location": "builders/manage/dapp/manage-tokens/#definindo-a-gas-dynamics-setting-gas", "title": "Definindo a Gas Dynamics{: #setting-gas }", "text": "<p>Note</p> <p>Esta opção se aplica apenas a redes compatíveis com EVM.</p> <p>O governador de uma rede compatível com EVM powered by Tanssi pode alterar sua configuração EIP-1559, afetando o mecanismo de precificação da transação. Para fazer isso, no painel Token Management, clique no botão Gas Dynamics e, em seguida:</p> <ol> <li>Insira a nova taxa base, expressa em unidades Wei (10<sup>-18</sup>)</li> <li>Insira o valor da elasticidade</li> <li>Clique em Update Dynamics</li> </ol> <p></p> <p>Você será solicitado a assinar a transação com a conta do governador da rede. Depois que a transação for concluída, o mecanismo de taxas da rede será executado com os novos parâmetros de precificação da transação.</p>"}, {"location": "builders/manage/dapp/register-external-assets/", "title": "Registrar Ativos Externos", "text": ""}, {"location": "builders/manage/dapp/register-external-assets/#introduction", "title": "Introdução", "text": "<p>A transferência de ativos entre cadeias é crucial porque permite a movimentação contínua de ativos digitais em diferentes redes, aprimorando a interoperabilidade, a liquidez e a experiência do usuário. Para permitir transferências de ativos de e para duas redes, primeiro, um canal bidirecional deve ser aberto entre elas. Graças ao dApp Tanssi, abrir um canal é uma tarefa fácil e rápida. Consulte o artigo Gerenciar Canais de Comunicação Cross-Chain para saber como fazer isso.</p> <p>Note</p> <p>Abrir um canal de comunicação bidirecional requer aprovação dos governadores de ambas as redes.</p> <p>Depois que os canais de comunicação da sua rede forem estabelecidos, você pode registrar os ativos de outras cadeias (ativos externos) para começar a operar. Este guia irá guiá-lo pelo processo de registro de ativos externos usando o Tanssi dApp.</p>"}, {"location": "builders/manage/dapp/register-external-assets/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Dedicada) executando runtime 500 ou superior</li> <li>A conta que você usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, também importada em qualquer uma das carteiras suportadas</li> </ul> <p>!!! note       A conta de registro da rede é sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatível com EVM, a conta Sudo será do tipo Ethereum; caso contrário, será do tipo Substrate.</p> <p>### Recuperando a conta de registro {: #retrieving-registration-account }</p> <p>Se você não souber qual é a sua conta de registro, pode consultá‑la diretamente na cadeia orquestradora do Tanssi, que mantém os registros de todas as redes cadastradas. Para isso, acesse a seção Chain state no Polkadot.js Apps conectado à cadeia orquestradora para redes de teste rápidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o módulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no ícone +</li> </ol> <p>A conta de registro aparecerá na parte inferior.</p> <p></p> <p>!!! note       O dApp exibirá sua rede no painel somente se a conta de registro estiver configurada corretamente.</p> <p>### Recuperando a conta Sudo {: #retrieving-sudo-account }</p> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>!!! warning       É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/dapp/register-external-assets/#accesing-external-assets-management-panel", "title": "Acessando o Painel de Registro de Ativos Externos", "text": "<p>O dApp do Tanssi facilita para o responsável pela rede gerenciar as configurações de comunicação entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gestão de cross‑chain, acesse o Tanssi dApp e:</p> <ol> <li>Clique em Manage</li> <li>Clique em XCM</li> </ol> <p></p> <p>Note</p> <p>Se os detalhes da sua rede não aparecerem no dashboard, verifique se você cumpriu os pré-requisitos.</p> <p>O painel mostrará a configuração cross-chain da sua rede, juntamente com várias ações disponíveis. Em relação aos ativos externos, os elementos relevantes que são apresentados a você são:</p> <ol> <li>Registered Assets panel - esta seção irá agrupar e apresentar a você todos os ativos registrados que sua rede já tem disponíveis</li> <li>Registered Assets List - os ativos externos já registrados serão exibidos nesta seção, juntamente com suas informações associadas, como nome do ativo, símbolo, ID, oferta total e ID da rede onde é nativo</li> <li>Asset Registration - esta opção permite que você selecione outros ativos externos disponíveis e registre-os. A seção a seguir explica como fazê-lo</li> </ol> <p></p>"}, {"location": "builders/manage/dapp/register-external-assets/#register-external-asset", "title": "Registrar um Ativo Externo", "text": "<p>Desde que sua rede já tenha estabelecido canais de comunicação bidirecionais com outra rede, o governador da rede pode registrar ativos externos.</p> <p>Para fazer isso, clique em Asset Registration e depois:</p> <ol> <li>Selecione pelo menos um dos ativos disponíveis na lista</li> <li>Clique em Register</li> </ol> <p>Você será solicitado a assinar a transação e, assim que ela for concluída, o ativo externo estará disponível localmente.</p> <p></p> <p>Note</p> <p>O dApp apresenta apenas ativos conhecidos de redes conhecidas do ecossistema. Se o ativo que você precisa registrar não estiver listado, você terá que fazê-lo usando o portal do desenvolvedor.</p>"}, {"location": "builders/manage/dapp/services-payment/", "title": "Pagamento dos Serviços de Produção de Blocos", "text": ""}, {"location": "builders/manage/dapp/services-payment/#introduction", "title": "Introdução", "text": "<p>Como apresentado no artigo Produção de Blocos como Serviço, existem dois custos principais associados que o governador da rede deve cobrir:</p> <ul> <li>Sequencers assignment - para a atribuição de Sequencers pelo protocolo Tanssi, que acontece uma vez por sessão</li> <li>Block production - para cada bloco que é produzido em nome da rede</li> </ul> <p>Neste guia, você aprenderá como usar o Tanssi dApp para recarregar sua conta e manter a atividade da sua rede.</p>"}, {"location": "builders/manage/dapp/services-payment/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para os exemplos neste guia, você precisará do seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Teste Rápido ou Dedicado)</li> <li>A conta que você usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> </ul> <p>Se você não souber qual é a sua conta de registro, pode consultá‑la diretamente na cadeia orquestradora do Tanssi, que mantém os registros de todas as redes cadastradas. Para isso, acesse a seção Chain state no Polkadot.js Apps conectado à cadeia orquestradora para redes de teste rápidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o módulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no ícone +</li> </ol> <p>A conta de registro aparecerá na parte inferior.</p> <p></p> <p>Note</p> <p>O dApp exibirá sua rede no painel somente se a conta de registro estiver configurada corretamente.</p>"}, {"location": "builders/manage/dapp/services-payment/#topping-up", "title": "Topping-Up os Créditos da Sua Rede", "text": "<p>Seguindo um Template de pagamento conforme o uso, as redes devem ter fundos alocados para pagar pelos serviços, que, ao longo do tempo, serão deduzidos e queimados pelo protocolo Tanssi a cada mudança de sessão para o custo da atribuição do Sequencer e para cada bloco pelo custo de produção do bloco.</p> <p>Você pode verificar o saldo atual da sua rede e recarregá-lo usando o Tanssi dApp. Para fazer isso, acesse o Tanssi dApp e conecte a conta de registro da rede ao dApp. O site exibirá um cartão mostrando o status da sua rede. Este cartão inclui a previsão de atividade projetada abaixo da seção Block Production e o botão Top Up.</p> <p></p> <p>Clicar no botão Top Up exibe uma barra lateral onde as seguintes informações podem ser vistas:</p> <ul> <li>Current balance - o saldo atual alocado para o serviço de produção de blocos da rede</li> <li>Available balance - o saldo disponível na conta de registro da rede, que está conectada ao dApp</li> <li>Current cost - custo atual por atribuição de Sequencer e custo por bloco</li> <li>Projected forecast - o dia estimado em que a rede ficará sem fundos e deixará de ser atendida</li> </ul> <p>Para estender o horizonte projetado da rede, execute as seguintes ações:</p> <ol> <li>Insira a quantidade de tokens para comprar serviços de produção de blocos</li> <li>Clique em Top Up</li> </ol> <p></p> <p>Você será solicitado a assinar a transação e, depois que ela for concluída, sua rede se beneficiará de um horizonte de atividade estendida.</p> <p>Warning</p> <p>Se sua rede não tiver fundos suficientes para cobrir a atribuição do Sequencer e o valor de blocos de uma sessão, ela travará.</p>"}, {"location": "builders/manage/dapp/xcm-channels/", "title": "Gerenciar Canais de Comunicação Cross-Chain", "text": ""}, {"location": "builders/manage/dapp/xcm-channels/#introduction", "title": "Introdução", "text": "<p>Conforme apresentado no artigo Comunicação Cross-Chain Nativa da seção Aprenda, todas as redes Tanssi têm uma capacidade inerente de se comunicar e interoperar com qualquer outra rede no ecossistema. Esse recurso de comunicação cross-chain nativo é possível graças à infraestrutura única em que as redes são construídas, aproveitando o formato Cross-Consensus Message (XCM para abreviar), que facilita a comunicação entre diferentes sistemas de consenso.</p> <p>A primeira etapa para habilitar a comunicação entre as redes é abrir um canal. O processo de abertura de um canal começa enviando uma solicitação para a rede com a qual você deseja estabelecer comunicações. Depois que a solicitação for aceita pelo governador da cadeia de destino, um canal será aberto.</p> <p>Neste guia, você aprenderá como usar o Tanssi dApp para gerenciar os canais de comunicação cross-chain da sua rede.</p>"}, {"location": "builders/manage/dapp/xcm-channels/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede Tanssi (Dedicada) executando o runtime 500 ou superior</li> <li>A conta que você usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, também importada em qualquer uma das carteiras suportadas</li> </ul> <p>!!! note       A conta de registro da rede é sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatível com EVM, a conta Sudo será do tipo Ethereum; caso contrário, será do tipo Substrate.</p> <p>### Recuperando a conta de registro {: #retrieving-registration-account }</p> <p>Se você não souber qual é a sua conta de registro, pode consultá‑la diretamente na cadeia orquestradora do Tanssi, que mantém os registros de todas as redes cadastradas. Para isso, acesse a seção Chain state no Polkadot.js Apps conectado à cadeia orquestradora para redes de teste rápidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o módulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no ícone +</li> </ol> <p>A conta de registro aparecerá na parte inferior.</p> <p></p> <p>!!! note       O dApp exibirá sua rede no painel somente se a conta de registro estiver configurada corretamente.</p> <p>### Recuperando a conta Sudo {: #retrieving-sudo-account }</p> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>!!! warning       É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/dapp/xcm-channels/#accesing-channel-management-panel", "title": "Acessando o Painel de Gerenciamento de Canais", "text": "<p>O dApp do Tanssi facilita para o responsável pela rede gerenciar as configurações de comunicação entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gestão de cross‑chain, acesse o Tanssi dApp e:</p> <ol> <li>Clique em Manage</li> <li>Clique em XCM</li> </ol> <p></p> <p>Note</p> <p>Se os detalhes da sua rede não aparecerem no dashboard, verifique se você cumpriu os pré-requisitos.</p> <p>O painel mostrará o status dos canais de comunicação da sua rede, juntamente com várias ações disponíveis. Os elementos que você recebe são:</p> <ol> <li>Sovereign account - é uma conta sem chave que pertence à rede em um sistema de consenso diferente, a cadeia de retransmissão neste caso. Ela só pode ser usada pelo governador da rede.</li> </ol> <p>Antes de abrir um novo canal, a conta soberana da rede na cadeia de retransmissão deve ser financiada com tokens suficientes para serem bloqueados como um depósito de canal.</p> <p>Nesta seção, você pode ver o saldo da conta soberana da sua rede, copiar seu endereço e depositar tokens</p> <ol> <li>Incoming/Outgoing channel requests - toda solicitação de canal precisa ser aceita pela contraparte antes que qualquer mensagem possa ser enviada.</li> </ol> <p>Nesta seção, você pode ver a lista de solicitações de saída pendentes e cancelá-las. Você também pode ver quaisquer solicitações de canal de entrada que sua rede possa ter recebido e aceitar o canal</p> <ol> <li>Established channels - Depois que o governador da cadeia de destino aceitar a solicitação do canal, o canal se torna aberto e disponível para transmissão de mensagens.</li> </ol> <p>Nesta seção, você pode ver a lista de canais aceitos que sua rede possui, a direção em que as mensagens fluem pelo canal e cancelar o canal</p> <ol> <li>Request to open new channels - esta opção permite que você selecione uma rede existente no ecossistema e solicite a abertura de um canal. A próxima seção explica como fazer isso</li> </ol> <p></p>"}, {"location": "builders/manage/dapp/xcm-channels/#request-new-channel", "title": "Solicitação para Abrir Novo Canal", "text": "<p>Desde que sua rede tenha fundos suficientes para o depósito na conta soberana da cadeia de retransmissão, o governador da rede pode solicitar a abertura de um novo canal com qualquer outra rede.</p> <p>Para fazer isso, clique em HRMP Channels e, em seguida:</p> <ol> <li>Selecione a rede com a qual você deseja estabelecer um canal</li> <li>Clique em Request Channel</li> </ol> <p>Você será solicitado a assinar a transação e, assim que ela for concluída, a cadeia de destino receberá a solicitação.</p> <p></p>"}, {"location": "builders/manage/developer-portal/", "title": "Usando o Portal do Desenvolvedor", "text": "<p>O portal do desenvolvedor permite que você gerencie com eficiência suas operações de rede, segurança e personalização Powered by Tanssi. Com ferramentas intuitivas à sua disposição, você pode garantir um gerenciamento tranquilo e adaptar sua rede para atender aos requisitos exclusivos do seu projeto.</p>"}, {"location": "builders/manage/developer-portal/#como-conectar-ao-portal-do-desenvolvedor", "title": "Como Conectar ao Portal do Desenvolvedor", "text": "<p>Antes de começar, você precisa recuperar a WS URL da sua rede. Esta informação está disponível no Dashboard da sua rede no dApp Tanssi, na seção Properties.</p> <p></p> <p>Agora você está pronto para conectar sua rede Powered by Tanssi ao portal do desenvolvedor. Navegue até Polkadot.js Apps e clique nas informações da chain no canto superior esquerdo para mudar para a sua rede.</p> <p></p> <p>Para configurar sua rede, siga estes passos:</p> <ol> <li>Role para baixo no menu do lado esquerdo até ver Development (Desenvolvimento). Clique nisso para expandir as opções</li> <li>Clique em Local Node (Nó Local)</li> <li>Insira sua URL RPC no campo de entrada do custom endpoint (ponto de extremidade personalizado)</li> <li>Clique no botão salvar. O portal será recarregado e você deverá estar conectado à sua rede</li> </ol> <p></p> <p>Agora que você tem sua rede carregada no portal do desenvolvedor, você pode mergulhar nos seguintes guias para começar a gerenciar sua rede.</p>"}, {"location": "builders/manage/developer-portal/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/manage/developer-portal/impersonate/", "title": "Usando Sudo para Personificar Outras Contas", "text": ""}, {"location": "builders/manage/developer-portal/impersonate/#introduction", "title": "Introdução", "text": "<p>Sudo é um módulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo é, por vezes, referido coloquialmente como um superutilizador ou conta semelhante a um deus. Isto permite-lhe executar ações privilegiadas ao gerir a sua rede, como personificar outras contas.</p> <p>Neste guia, aprenderá como usar Sudo para personificar outras contas. Por exemplo, este guia usará a conta Sudo para se apresentar como uma conta arbitrária e transferir fundos dessa conta.</p> <p>Warning</p> <p>A transferência de saldo demonstrada neste guia é duvidosa e é mostrada apenas como um exemplo de uso do Sudo.</p>"}, {"location": "builders/manage/developer-portal/impersonate/#checking-prerequisites", "title": "Verificação de Pré-requisitos", "text": "<p>Para os exemplos neste guia, precisará do seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada aos Polkadot.js Apps da sua rede. Pode consultar o Guia de Gerenciamento do Sudo para obter instruções sobre como injetar a sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/impersonate/#using-sudo-and-the-dispatch-as-utility", "title": "Usando Sudo e o Dispatch como Utilitário", "text": "<p>Como sabe, a conta Sudo pode executar funções privilegiadas, incluindo a personificação de outras contas. Ao enviar uma chamada através de <code>sudoAs</code>, o Runtime primeiro autenticará a chave Sudo e, em seguida, despachará a chamada de função desejada com a origem <code>Signed</code> de uma determinada conta. No exemplo a seguir, o método <code>sudoAs</code> orquestrará o envio de alguns tokens para outra conta. Embora o resultado seja semelhante ao uso do Sudo com uma chamada <code>forceBalanceTransfer</code>, o exemplo a seguir usa uma chamada de transferência de saldo regular, onde a origem é a conta do remetente e não a conta Sudo.</p> <p>Para fazer uma chamada <code>sudoAs</code> para personificar outra conta, navegue para o separador Developer (Desenvolvedor) dos Polkadot.js Apps para a sua rede powered by Tanssi e clique em Sudo. Se não vir Sudo neste menu, não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua conta Sudo está injetada pela sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga os seguintes passos:</p> <ol> <li>Selecione a paleta Sudo</li> <li>Selecione o método sudoAs</li> <li>Selecione ou cole a conta desejada para personificar</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, é a paleta balances (saldos)</li> <li>Selecione o método transferAllowDeath</li> <li>Especifique a conta de destino para a transferência de saldo</li> <li>Especifique o número de tokens a enviar</li> <li>Pressione SubmitSudo e confirme o pop-up resultante</li> </ol> <p></p> <p>A outra conta tinha um saldo inicial de <code>1.000</code> tokens antes da chamada e, subsequentemente, caiu para <code>995</code>, como esperado.</p> <p></p>"}, {"location": "builders/manage/developer-portal/impersonate/#using-sudo-and-the-dispatch-as-utility", "title": "Usando Sudo e o Dispatch como Utilitário", "text": "<p>A secção a seguir demonstrará o uso do Sudo para despachar chamadas de uma origem arbitrária. Ao enviar uma chamada desta forma, o Runtime primeiro autenticará a chave Sudo e, em seguida, despachará a chamada usando a paleta <code>utility</code> e a função <code>dispatchAs</code>, permitindo que a origem da transação seja exatamente o que deseja.</p> <p>Para fazer isso, navegue para o separador Developer (Desenvolvedor) dos Polkadot.js Apps para a sua rede powered by Tanssi e clique em Sudo. Se não vir Sudo neste menu, não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua conta Sudo está injetada pela sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga os seguintes passos:</p> <ol> <li>Selecione a paleta Sudo</li> <li>Selecione o método Sudo</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, é a paleta utility (utilidade)</li> <li>Selecione o método dispatchAs</li> <li>Selecione system (sistema) no menu pendente</li> <li>Selecione a origem signed (assinada), que define a origem da transação para ser a conta especificada em vez de root (raiz)</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, é a paleta balances (saldos)</li> <li>Selecione o método transferAllowDeath</li> <li>Especifique a conta de destino para a transferência de saldo</li> <li>Especifique o número de tokens a enviar</li> <li>Pressione SubmitSudo e confirme o pop-up resultante </li> </ol> <p>A outra conta tinha um saldo inicial de <code>995</code> tokens antes da chamada e caiu para <code>990</code>, como esperado.</p> <p></p> <p>E é isso! A secção Developer Portal tem muitos mais guias sobre como gerir a sua rede Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/manage/developer-portal/maintenance/", "title": "Habilitando o Modo de Manutenção", "text": ""}, {"location": "builders/manage/developer-portal/maintenance/#introduction", "title": "Introdução", "text": "<p>A paleta de Manutenção é um módulo projetado para uso apenas em emergências que representam ameaças existenciais à rede. Habilitar o modo de manutenção em sua rede suspenderá o processamento de todas as transações regulares, incluindo interações com a EVM. A produção de blocos continua em uma cadência regular e permite que as funções de governança e staking continuem.</p> <p>O modo de manutenção filtra (ignora) todas as chamadas fora da governança e staking. Uma vez que o modo de manutenção é encerrado, sua cadeia processará quaisquer transações pendentes que foram enfileiradas enquanto sua cadeia estava no modo de manutenção. O modo de manutenção destina-se a ser usado apenas como uma medida temporária de emergência.</p> <p>Por exemplo, imagine descobrir uma exploração crítica em sua rede que poderia resultar em perdas financeiras significativas se atores mal-intencionados a explorassem. Embora você possa resolver o problema implementando uma atualização de Runtime, o processo leva tempo - tempo precioso durante o qual sua rede permanece vulnerável a ataques. Uma solução potencial é ativar o modo de manutenção em sua rede, concluir a atualização do Runtime e sair do modo de manutenção assim que a correção for verificada.</p> <p>Warning</p> <p>Habilitar o modo de manutenção em uma rede de produção pode impactar significativamente os contratos em sua cadeia. Enquanto o modo de manutenção estiver ativado, nenhuma transação de contrato inteligente é processada, por isso é fundamental considerar as possíveis ramificações antes de ativá-lo.</p>"}, {"location": "builders/manage/developer-portal/maintenance/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Teste Rápido ou Dedicado)</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Você pode consultar o guia de Gerenciamento do Sudo para obter instruções sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/maintenance/#enabling-maintenance-mode", "title": "Habilitando o Modo de Manutenção", "text": "<p>Ainda, a conta Sudo pode realizar funções privilegiadas, como habilitar e desabilitar o modo de manutenção. Para entrar no modo de manutenção e interromper o processamento regular de transações, navegue até a guia Developer do Polkadot.js Apps para sua rede powered by Tanssi e clique em Sudo. Se você não vir Sudo neste menu, você não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps. Então, siga os seguintes passos:</p> <ol> <li>Selecione a paleta maintenanceMode</li> <li>Selecione o método enterMaintenanceMode</li> <li>Pressione Submit Sudo e confirme a transação no pop-up resultante</li> </ol> <p></p> <p>Para verificar se o modo de manutenção foi habilitado, você pode verificar a seção Explorer na guia Rede e revisar os eventos recentes.</p> <p></p>"}, {"location": "builders/manage/developer-portal/maintenance/#exiting-maintenance-mode", "title": "Saída do Modo de Manutenção", "text": "<p>Para sair do modo de manutenção e retornar sua rede à operação normal, navegue até a guia Developer do Polkadot.js Apps para sua rede powered by Tanssi e clique em Sudo. Se você não vir Sudo neste menu, você não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps. Siga os seguintes passos:</p> <ol> <li>Selecione a paleta maintenanceMode</li> <li>Selecione o método resumeNormalOperation</li> <li>Pressione Submit Sudo e confirme a transação no pop-up resultante </li> </ol> <p>Para verificar se o modo de manutenção foi desabilitado, você pode verificar na seção Explorer na guia Network e revisar os eventos recentes.</p> <p></p> <p>Lembre-se que o uso do modo de manutenção é uma ação de emergência que só deve ser ativada quando sua cadeia estiver em risco extremo. Pode valer a pena estabelecer uma política para sua rede que defina gatilhos específicos de disjuntor para determinar quando o modo de manutenção será habilitado. O estabelecimento de uma política com antecedência também simplificará a tomada de decisões durante uma potencial emergência.</p> <p>E é isso! A seção Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede powered by Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/manage/developer-portal/minting/", "title": "Usando Sudo para Cunhar Tokens Nativos", "text": ""}, {"location": "builders/manage/developer-portal/minting/#introduction", "title": "Introdução", "text": "<p>Sudo é um módulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo é, por vezes, referido coloquialmente como um superusuário ou uma conta semelhante a um deus. Isso permite que você realize ações privilegiadas no curso do gerenciamento de sua rede, como cunhar novos tokens nativos.</p> <p>Neste guia, você aprenderá como usar Sudo para cunhar corretamente novos tokens nativos. Este guia abrangente mostra como verificar o saldo de uma conta existente antes de atribuir a ela um novo saldo com acesso Sudo.</p>"}, {"location": "builders/manage/developer-portal/minting/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará do seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps. Você pode consultar o guia de gerenciamento do Sudo para obter instruções sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/minting/#minting-tokens", "title": "Cunhagem de Tokens", "text": "<p>Como você sabe, a conta Sudo tem a capacidade de realizar funções privilegiadas, incluindo a cunhagem de tokens adicionais. Ao configurar sua rede no Tanssi dApp, você pode especificar os saldos da conta genesis. Em outras palavras, você tem a capacidade de dotar as contas com saldos iniciais ao iniciar sua rede Tanssi. No entanto, você também pode cunhar novos tokens após o lançamento com a ajuda da conta Sudo.</p> <p>Note</p> <p>Este tutorial demonstra a atribuição de saldos de tokens arbitrários em uma rede TestNet que não tem valor. Você deve considerar cuidadosamente as ramificações de criar tokens adicionais em sua própria rede powered by Tanssi.</p>"}, {"location": "builders/manage/developer-portal/minting/#checking-existing-account-balance", "title": "Verificando o Saldo da Conta Existente", "text": "<p>A próxima seção demonstrará como atribuir saldos de tokens arbitrários a contas usando a conta Sudo. Este processo substituirá o saldo existente da conta especificada, portanto, verificar se a conta está vazia é uma boa prática antes de continuar. Para verificar o saldo de uma conta, siga estas etapas:</p> <ol> <li>Navegue até a guia Desenvolvedor do Polkadot.js Apps e clique em Chain State (Estado da Cadeia)</li> <li>Selecione o pallet system para consultar</li> <li>Selecione account (conta)</li> <li>Cole o endereço da conta ou selecione-o no menu suspenso</li> <li>Pressione o ícone +</li> <li>Você verá as informações do saldo retornadas na parte inferior, incluindo saldos livres, reservados e congelados </li> </ol>"}, {"location": "builders/manage/developer-portal/minting/#assigning-balances-with-sudo", "title": "Atribuindo Saldos com Sudo", "text": "<p>Para atribuir um saldo de conta a uma conta, certifique-se de ter sua conta Sudo acessível no Polkadot.js Apps. Em seguida, siga estas etapas:</p> <ol> <li>Navegue até a guia Developer dos Polkadot.js Apps para sua rede Tanssi</li> <li>Clique em Sudo. Se você não vir Sudo neste menu, você não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps</li> <li>Selecione o pallet balances</li> <li>Selecione o método forceSetBalance</li> <li>Cole o endereço da conta para dotar com tokens ou selecione-o no menu suspenso</li> <li>Insira a quantidade de tokens para dotar a conta. Neste exemplo, especificamos <code>9000000000000000000</code> para nove tokens nativos. Lembre-se que as redes EVM powered by Tanssi têm 18 decimais, enquanto as redes Substrate ou personalizadas configuram os decimais ao lançar a cadeia. Se você não tiver certeza de quantos decimais sua rede tem, navegue até a guia Settings e clique em Metadata</li> <li>Pressione Submit Sudo (Enviar Sudo) e confirme a transação em sua carteira</li> </ol> <p></p> <p>E é isso! A seção Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/manage/developer-portal/pause-transactions/", "title": "Pausando Transações", "text": ""}, {"location": "builders/manage/developer-portal/pause-transactions/#introduction", "title": "Introdução", "text": "<p>O módulo de Pausa de Transação é um dos módulos embutidos incluídos no Polkadot SDK, e está disponível em qualquer rede Powered by Tanssi baseada nos Templates oficiais versão 400 ou superior.</p> <p>Este módulo permite que um governador de rede evite temporariamente a execução de um conjunto de transações selecionadas, enquanto o restante das transações continua normalmente. Esse recurso é útil em vários cenários, como desabilitar uma funcionalidade em que uma ameaça à segurança foi descoberta, habilitar uma funcionalidade sazonal somente quando necessário e habilitar um conjunto de transações exatamente na data de lançamento.</p> <p>Em um cenário de emergência, quando um exploit crítico é descoberto, este módulo permite que a rede isole e pare apenas a funcionalidade afetada, minimizando efetivamente o impacto geral.</p> <p>Warning</p> <p>No momento em que este artigo foi escrito, este módulo ainda não foi auditado; portanto, não é recomendado para uso em produção.</p>"}, {"location": "builders/manage/developer-portal/pause-transactions/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede Powered by Tanssi (Quick Trial ou Dedicada) com o módulo Pausa de Transação. Qualquer nova implantação de rede baseada em um dos Templates servirá; caso contrário, certifique-se de incluir o módulo em seu runtime de rede personalizado</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Você pode consultar o guia Managing Sudo para obter instruções sobre como injetar sua conta Sudo no Polkadot.js Apps</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/pause-transactions/#modules-transaction-names", "title": "Nomes de Módulo e Transação", "text": "<p>O módulo Pausa de Transação funciona filtrando a execução de transações específicas contidas nos módulos incluídos no Runtime da rede. Para fazer isso, ele mantém uma lista interna das transações banidas, identificadas por nome de módulo e transação. Esta lista diferencia maiúsculas de minúsculas e só funciona quando há uma correspondência exata entre um item na lista de transações pausadas e a transação que está sendo processada. Portanto, o uso dos nomes exatos dos módulos e das transações é crucial.</p> <p>Para descobrir os nomes dos módulos disponíveis em seu Runtime, você precisa ler a seção <code>construct_runtime!()</code> no arquivo <code>lib.rs</code> do seu Runtime de rede no repositório do seu projeto. Se sua rede for baseada em um dos Templates oficiais, você encontrará o arquivo no repositório Tanssi:</p> <ul> <li>Para redes baseadas no Template EVM: o arquivo lib.rs</li> <li>Para redes baseadas no Template Substrate: o arquivo lib.rs</li> </ul> <p>O snippet a seguir é um exemplo de como a seção <code>construct_runtime!()</code> se parece. Os nomes dos módulos são os localizados à esquerda dos dois pontos.</p> <pre><code>    pub enum Runtime\n    {\n        ...\n        Migrations: pallet_migrations = 7,\n        MaintenanceMode: pallet_maintenance_mode = 8,\n        TxPause: pallet_tx_pause = 9,\n        Balances: pallet_balances = 10,\n        Multisig: pallet_multisig = 16,      \n        ...\n   }\n</code></pre> <p>Para identificar os nomes das transações incluídas em um módulo, você precisa consultar seu código-fonte. Os módulos integrados no Substrate identificam suas transações usando uma macro <code>#[pallet::call_index(INDEX)]</code>, onde <code>INDEX</code> é um número. No caso de um módulo embutido, o código está localizado na pasta FRAME do repositório Polkadot-SDK. Por exemplo, se você quiser saber sobre os nomes das transações no módulo <code>Balances</code>, consulte seu arquivo lib.rs e procure os nomes das funções abaixo das macros <code>#[pallet::call_index(INDEX)]</code>. O snippet a seguir é a transação <code>transfer_allow_death</code> do módulo <code>Balances</code>, que é o usado como exemplo neste guia:</p> <pre><code>pub fn transfer_allow_death(\n    origin: OriginFor&lt;T&gt;,\n    dest: AccountIdLookupOf&lt;T&gt;,\n    #[pallet::compact] value: T::Balance,\n) -&gt; DispatchResult {\n    // Code\n    Ok(())\n}\n</code></pre>"}, {"location": "builders/manage/developer-portal/pause-transactions/#frequently-used-modules-transactions", "title": "Alguns Módulos e Transações Usados com Frequência", "text": "<p>Ao usar qualquer um dos módulos Substrate embutidos, o nome com o qual ele é referenciado no Runtime é totalmente de responsabilidade do desenvolvedor, mas os nomes das transações não são personalizáveis. Aqui está uma lista de alguns dos módulos mais comumente usados com as transações mais comumente usadas que eles contêm. Esses são os nomes das transações a serem usados neste módulo Pausa de Transação.</p> pallet-ethereum — Este módulo, junto com o módulo EVM, fornece compatibilidade total com o Ethereum para a rede Nome da Transação Descrição <code>transact</code> Executa uma chamada Ethereum pallet_balances — Este módulo fornece funcionalidade para lidar com contas e saldos para a moeda nativa da rede Nome da Transação Descrição <code>transfer_allow_death</code> Executa uma transferência de saldo, excluindo a conta do remetente quando seu saldo final fica abaixo do requisito mínimo de existência <code>transfer_keep_alive</code> Executa uma transferência de saldo, mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito mínimo de existência <code>transfer_all</code> Transfere todos os saldos não bloqueados para um destino <code>burn</code> Queima o saldo da conta de origem, reduzindo a emissão total pallet_assets — Este módulo fornece funcionalidade para lidar com tokens fungíveis Nome da Transação Descrição <code>create</code> Emite uma nova classe de ativos fungíveis <code>start_destroy</code> Inicia o processo de destruição de uma classe de ativos fungíveis <code>destroy_accounts</code> Destrói todas as contas associadas a um determinado ativo para as quais o processo de destruição foi iniciado <code>destroy_approvals</code> Destrói todas as aprovações associadas a um determinado ativo para o qual o processo de destruição foi iniciado <code>finish_destroy</code> Conclui o processo de destruição de um determinado ativo para o qual o processo de destruição foi iniciado <code>mint</code> Cria ativos <code>burn</code> Queima ativos <code>transfer</code> Executa uma transferência de ativos excluindo a conta do remetente quando seu saldo final fica abaixo do requisito mínimo de existência <code>transfer_keep_alive</code> Executa uma transferência de ativos mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito mínimo de existência <code>freeze</code> Não permite transferências de um ativo de uma conta específica <code>thaw</code> Permite novamente transferências de um ativo de uma conta específica <code>freeze_asset</code> Não permite transferências de um ativo <code>thaw_asset</code> Permite novamente transferências de um ativo <code>set_metadata</code> Define os metadados para um ativo <code>clear_metadata</code> Limpa os metadados para um ativo pallet_nfts — Este módulo fornece funções para lidar com tokens não fungíveis Nome da Transação Descrição <code>create</code> Emite uma nova coleção de itens não fungíveis <code>destroy</code> Destrói uma coleção de itens não fungíveis <code>mint</code> Cria um item em uma coleção NFT <code>burn</code> Destrói um item de uma coleção NFT <code>transfer</code> Transfere um NFT <code>lock_item_transfer</code> Não permite a transferência de um item <code>unlock_item_transfer</code> Permite novamente a transferência de um item bloqueado <code>set_attribute</code> Define um atributo para uma coleção NFT ou um item <code>clear_attribute</code> Limpa um atributo para uma coleção NFT ou um item <code>set_metadata</code> Define os metadados para um item <code>clear_metadata</code> Limpa os metadados para um item <code>set_collection_metadata</code> Define os metadados para uma coleção de itens não fungíveis <code>clear_collection_metadata</code> Limpa os metadados para uma coleção de itens não fungíveis <code>set_price</code> Define o preço de um item <code>buy_item</code> Compre um item, desde que esteja à venda pallet_multisig — Este módulo fornece funções para lidar com esquemas de múltiplas assinaturas Nome da Transação Descrição <code>as_multi_threshold_1</code> Registra uma chamada de múltiplas assinaturas com uma única aprovação <code>as_multi</code> Registra uma chamada de múltiplas assinaturas a ser feita de uma conta composta, se aprovada pelo limite mínimo especificado dos outros signatários <code>approve_as_multi</code> Registra a aprovação de uma chamada de múltiplas assinaturas e despacha a chamada quando o limite de signatários é atingido <code>cancel_as_multi</code> Cancela uma transação de múltiplas assinaturas pré-existente e em andamento"}, {"location": "builders/manage/developer-portal/pause-transactions/#pausing-transactions", "title": "Pausando Transações", "text": "<p>Como você sabe, a conta Sudo pode executar ações privilegiadas, como atualizações de rede, criação de novos tokens e, neste caso, pausar e despausar transações.</p> <p>Para pausar uma transação, navegue até a guia Desenvolvedor do Polkadot.js Apps para sua rede Powered by Tanssi e clique em Sudo. Se você não vir Sudo neste menu, não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione o módulo txPause</li> <li>Selecione o método pause</li> <li>Insira o nome do módulo que contém a transação que será pausada</li> <li>Insira o nome da transação que será pausada</li> <li>Pressione Submit Sudo e confirme a transação no pop-up resultante</li> </ol> <p>Neste exemplo, a transação pausada é <code>transfer_allow_death</code> do módulo <code>Balances</code>:</p> <p></p> <p>Para verificar se a transação foi efetivamente pausada, tente executá-la. Você deve obter um erro.</p> <p></p> <p>Warning</p> <p>A transação <code>pause</code> não verifica os nomes dos módulos ou transações e diferencia maiúsculas de minúsculas, portanto, qualquer erro de digitação passará despercebido e a transação será executada com sucesso. Você sempre deve verificar se a transação foi efetivamente pausada.</p>"}, {"location": "builders/manage/developer-portal/pause-transactions/#unpausing-transactions", "title": "Despausando Transações", "text": "<p>Para despausar uma transação e retorná-la à operação normal, navegue até a guia Desenvolvedor do Polkadot.js Apps para sua rede Powered by Tanssi e clique em Sudo. Se você não vir Sudo neste menu, você não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione o módulo txPause</li> <li>Selecione o método unpause</li> <li>Insira o nome do módulo que contém a transação que será despausada</li> <li>Insira o nome da transação que será despausada</li> <li>Pressione Submit Sudo e confirme a transação no pop-up resultante</li> </ol> <p>Neste exemplo, a transação a ser despausada é <code>transfer_allow_death</code> do módulo <code>Balances</code>:</p> <p></p> <p>A transação <code>unpause</code> é executada com sucesso somente se os parâmetros do módulo e da transação tiverem sido pausados ​​anteriormente; caso contrário, ela falha. Após o despausamento bem-sucedido, a transação pode ser chamada e executada novamente.</p> <p>E é isso! A seção Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/", "title": "Smart EVM - Implantações de Contratos Whitelistados", "text": ""}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#introduction", "title": "Introdução", "text": "<p>Redes powered by Tanssi compatíveis com EVM se beneficiam de um recurso exclusivo: o governador da rede pode definir quais contas estão autorizadas a implantar contratos inteligentes, proibindo a ação para qualquer outra conta não whitelistada.</p> <p>Este recurso traz vários benefícios importantes que podem ser uma ótima opção para diferentes casos de uso ou contextos. Alguns desses benefícios são:</p> <ul> <li>Segurança aprimorada - ao restringir a implantação a contas confiáveis, o risco de implantar contratos inteligentes maliciosos ou vulneráveis é reduzido</li> <li>Garantia de qualidade - contas conhecidas e verificadas podem ser obrigadas a seguir padrões de codificação específicos e passar por testes completos antes da implantação</li> <li>Conformidade regulatória - os casos de uso que são altamente regulamentados podem limitar a implantação para garantir que os contratos inteligentes atendam aos requisitos legais e de conformidade</li> <li>Prevenção de spam e abuso - impedir que maus atores implantem um grande número de contratos desnecessários ou prejudiciais</li> </ul> <p>Neste guia, você aprenderá como usar a conta Sudo para gerenciar as contas whitelistadas que podem implantar contratos inteligentes em sua rede.</p>"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede powered by Tanssi compatível com EVM (Teste Rápido ou Dedicado) executando o runtime 700 ou superior. Qualquer nova implantação de rede baseada no Template EVM servirá</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Você pode consultar o Guia de Gerenciamento de Sudo para obter instruções sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#getting-started", "title": "Começando", "text": "<p>Para seguir as próximas seções deste guia, acesse os Polkadot.js Apps para sua rede Tanssi. O link para os Polkadot.js Apps para sua rede Tanssi pode ser encontrado em seu Painel Tanssi na seção Tooling.</p> <p></p> <p>Depois de acessar os Polkadot.js Apps, navegue até a guia Developer e clique em Sudo.</p> <p>Note</p> <p>Se você não vir Sudo neste menu, não associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps.</p>"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#whitelist-accounts", "title": "Contas Whitelistadas", "text": "<p>Para definir as contas que terão autorização para implantar contratos inteligentes, comece a usar seus Polkadot.js Apps e siga as etapas a seguir:</p> <ol> <li>Selecione a paleta parameters. setParameter será selecionado automaticamente no seletor de funções e ContractDeployFilter no parâmetro keyValue</li> <li>Duas opções estarão disponíveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a opção AllowedAddressesToCreate se quiser whitelistar as contas para implantações de contratos inteligentes e a última para whitelistar as contas para implantações indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Alterne a chave Include option</li> <li>Selecione a opção Whitelisted</li> <li>Insira a conta whitelistada</li> <li>Se você precisar inserir mais de uma conta, clique em Add item</li> <li>Pressione Submit Sudo e confirme a transação em sua carteira</li> </ol> <p></p> <p>Essas mesmas etapas podem ser repetidas a qualquer momento para remover uma conta da whitelist ou para adicionar novas.</p>"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#restoring-permission", "title": "Restaurando Permissões para Implantar Contratos Inteligentes", "text": "<p>Se você autorizou anteriormente algumas contas a implantar contratos inteligentes e deseja permitir que qualquer conta implante contratos inteligentes (desde que possam cobrir taxas de transação regulares), comece a usar seus Polkadot.js Apps e siga as etapas a seguir:</p> <ol> <li>Selecione a paleta parameters. setParameter será selecionado automaticamente no seletor de funções e ContractDeployFilter no parâmetro keyValue</li> <li>Duas opções estarão disponíveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a opção AllowedAddressesToCreate se quiser limpar a whitelist para implantações de contratos inteligentes e a última para limpar a whitelist para implantações indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Alterne a chave Include option</li> <li>Selecione a opção All</li> <li>Pressione Submit Sudo e confirme a transação em sua carteira</li> </ol> <p></p>"}, {"location": "builders/manage/developer-portal/smart-contracts-creation-filter/#query-whitelisted-accounts", "title": "Consultando as Contas Whitelistadas", "text": "<p>Para obter a configuração atual contendo as contas whitelistadas que podem implantar contratos inteligentes, acesse os Polkadot.js Apps (conforme explicado na seção Começando), navegue até a guia Developer, clique em Chain state e siga as etapas a seguir:</p> <ol> <li>Selecione o armazenamento parameters</li> <li>Selecione a opção parameters(ContainerChainTemplateFrontierRuntimeParametersKey)</li> <li>Certifique-se de que a chave Include option está ligada</li> <li>Certifique-se de que a opção ContractDeployFilter está selecionada</li> <li>Duas opções estarão disponíveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a opção AllowedAddressesToCreate se quiser consultar a whitelist para implantações de contratos inteligentes e a última para consultar a whitelist para implantações indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Clique no botão +</li> <li>A configuração atual será exibida</li> </ol> <p></p>"}, {"location": "builders/manage/developer-portal/sudo/", "title": "Gerenciando a Conta Sudo da Sua Rede", "text": ""}, {"location": "builders/manage/developer-portal/sudo/#introduction", "title": "Introdução", "text": "<p>Sudo é um módulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo é, por vezes, coloquialmente referido como um superusuário ou uma conta semelhante a um deus. Só pode haver uma única conta Sudo de cada vez. No entanto, as chaves Sudo podem ser rodadas para dar privilégios Sudo a uma nova conta.</p> <p>Todas as redes powered by Tanssi vêm com a paleta Sudo por padrão, e você é obrigado a designar uma conta como o endereço Sudo ao lançar sua rede. Isso permite que você execute ações privilegiadas para gerenciar sua cadeia, como atualizar seu Runtime ou cunhar novos tokens nativos. Embora a paleta Sudo seja necessária para lançar sua rede Tanssi no TestNet, você pode desativar a paleta Sudo e fazer a transição para a governança descentralizada após o lançamento do MainNet.</p> <p>No guia a seguir, você aprenderá como visualizar a conta Sudo atual da sua rede e como alterá-la, além de importá-la para o Polkadot.js Apps. Existem guias semelhantes nesta seção explicando como usar a conta Sudo para realizar ações privilegiadas, como atualizar seu Runtime e cunhar tokens nativos.</p>"}, {"location": "builders/manage/developer-portal/sudo/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará ter o seguinte:</p> <ul> <li>Uma rede powered by Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada ao Polkadot.js Apps da sua rede</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps", "title": "Configurando o Polkadot.js Apps", "text": "<p>Depois de navegar para o Polkadot.js Apps da sua rede, você precisará adicionar sua conta Sudo. Injetar sua conta Sudo no Polkadot.js Apps a partir de uma extensão do navegador é considerado mais seguro do que armazenar contas diretamente no navegador. No entanto, você ainda pode importar sua conta Sudo diretamente para o cache do navegador. Esse método não requer o uso de nenhuma extensão. Para importar uma conta para o Polkadot.js dessa maneira, siga as etapas:</p> <ol> <li>Clique em Configurações</li> <li>Em criação de conta no navegador, selecione Permitir a criação de conta local no navegador</li> <li>Pressione Salvar</li> </ol> <p></p> <p>Em seguida, volte para a guia contas e pressione Conta. Você poderá substituir a chave privada pré-gerada pela da sua conta Sudo.</p> <p></p> <p>Warning</p> <p>O armazenamento de chaves no navegador não é adequado para ambientes de produção. Este exemplo é fornecido apenas para fins de demonstração em um ambiente TestNet.</p>"}, {"location": "builders/manage/developer-portal/sudo/#changing-the-sudo-account", "title": "Alterando a Conta Sudo", "text": "<p>A alteração da conta Sudo da sua rede powered by Tanssi é um processo simples. Também conhecido como rotação de suas chaves Sudo, esse processo removerá o acesso Sudo da conta Sudo existente e concederá à nova conta. Só pode haver uma conta Sudo a qualquer momento. No entanto, você é livre para alterar a conta Sudo quantas vezes quiser.</p> <p>Antes de começar, certifique-se de ter sua conta Sudo existente acessível no Polkadot.js Apps. Em seguida, siga as etapas:</p> <ol> <li>Navegue até a guia Desenvolvedor do Polkadot.js Apps da sua rede</li> <li>Clique em Sudo. Se você não vir Sudo neste menu, não associou a conta Sudo ao Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada ao Polkadot.js Apps</li> <li>Selecione o título Definir chave Sudo</li> <li>Selecione a nova conta para a qual você transferirá os privilégios Sudo</li> <li>Pressione Reatribuir e confirme a transação em sua carteira</li> </ol> <p></p> <p>Note</p> <p>Certifique-se de ter acesso à nova conta Sudo. Assim que o Sudo for transferido, ele não poderá ser desfeito sem acesso à chave Sudo atual.</p> <p>E é isso! A seção Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/manage/developer-portal/upgrade/", "title": "Atualizando o Runtime da Sua Appchain com Sudo", "text": ""}, {"location": "builders/manage/developer-portal/upgrade/#introduction", "title": "Introdução", "text": "<p>Sudo é um módulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo é por vezes coloquialmente referido como um superusuário ou uma conta semelhante a um deus. Isso permite que você realize ações privilegiadas no curso do gerenciamento da sua appchain, como a atualização do Runtime da sua appchain powered by Tanssi.</p> <p>Neste guia, você aprenderá como usar o Sudo para atualizar o runtime da sua appchain. Com acesso Sudo, atualizar sua cadeia é um processo rápido e fácil. Observe que as equipas de appchain em produção terão a opção de eliminar gradualmente o acesso Sudo e confiar na governança para processar as atualizações de Runtime.</p>"}, {"location": "builders/manage/developer-portal/upgrade/#checking-prerequisites", "title": "Verificando os Pré-Requisitos", "text": "<p>Para o exemplo neste guia, você precisará ter o seguinte:</p> <ul> <li>Uma appchain powered by Tanssi (Quick Trial, Dedicated ou MainNet).</li> <li>A conta Sudo da sua appchain conectada ao portal do desenvolvedor da sua appchain. Você pode consultar o guia de Gerenciamento do Sudo para obter instruções sobre como injetar a sua conta Sudo no portal do desenvolvedor.</li> <li>O novo ficheiro binário de runtime Wasm, compilado com uma versão superior à atual.</li> </ul> <p>Se você não souber qual é a conta Sudo da sua rede Tanssi, é possível encontrá‑la no Tanssi Dashboard na seção Properties.</p> <p></p> <p>Warning</p> <p>É fundamental proteger a chave da sua conta Sudo com o máximo de cuidado, pois ela concede acesso privilegiado à sua rede Tanssi.</p>"}, {"location": "builders/manage/developer-portal/upgrade/#obtaining-wasm-runtime", "title": "Obtendo o Runtime Wasm", "text": "<p>Se a sua cadeia for baseada em um dos Templates oficiais, você pode baixar o arquivo binário oficial de runtime Wasm na tabela abaixo. Os lançamentos oficiais são publicados na seção de lançamentos no repositório Tanssi.</p> Versão Template EVM Template Substrate 1400 Download EVM V1400 Wasm file Download Substrate V1400 Wasm file 1300 Download EVM V1300 Wasm file Download Substrate V1300 Wasm file 1201 Download EVM V1201 Wasm file Download Substrate V1201 Wasm file 1100 Download EVM V1100 Wasm file Download Substrate V1100 Wasm file 1000 Download EVM V1000 Wasm file Download Substrate V1000 Wasm file 900 Download EVM V900 Wasm file Download Substrate V900 Wasm file 800 Download EVM V800 Wasm file Download Substrate V800 Wasm file 700 Download EVM V700 Wasm file Download Substrate V700 Wasm file 600 Download EVM V600 Wasm file Download Substrate V600 Wasm file 500 Download EVM V500 Wasm file Download Substrate V500 Wasm file 400 Download EVM V400 Wasm file Download Substrate V400 Wasm file 300 Download EVM V300 Wasm file Download Substrate V300 Wasm file 200 Download EVM V200 Wasm file Download Substrate V200 Wasm file 101 Download EVM V101 Wasm file Download Substrate V101 Wasm file 100 Download EVM V100 Wasm file Download Substrate V100 Wasm file <p>Você deve sempre atualizar o Runtime seguindo as versões de forma ordenada, aplicando uma versão após a outra sem pular nenhuma delas. Para isso, você precisa saber a versão atual do Runtime da sua appchain, que você encontrará no seu Tanssi Dashboard na seção Propriedades. Por exemplo, se a versão do seu Runtime for <code>1000</code>, você deverá atualizar primeiro para <code>1100</code>, depois para <code>1201</code>, depois para <code>1300</code> e assim por diante até a versão mais recente disponível.</p> <p>Warning</p> <p>Aplicar as atualizações em ordem garante que as alterações (migrações) nas estruturas de dados internas sejam aplicadas, preservando a consistência dos dados. Caso contrário, pode paralisar sua appchain.</p> <p>Note</p> <p>Se estiver compilando o Runtime manualmente, certifique-se de usar a versão Wasm <code>compact</code> e <code>compressed</code>, que é otimizada e mais leve.</p>"}, {"location": "builders/manage/developer-portal/upgrade/#upgrading-your-runtime", "title": "Atualizando Seu Runtime", "text": "<p>Para começar, acesse o portal do desenvolvedor da sua appchain Tanssi, que pode ser encontrado no seu Tanssi Dashboard na seção Ferramentas.</p> <p></p> <p>Warning</p> <p>Se a sua appchain foi implantada usando um Template oficial e a atualização pretendida é um runtime personalizado, certifique-se de ter alterado o nome padrão da especificação (frontier-template ou container-chain-template) para um diferente antes de construir o arquivo Wasm. Você também precisará executar a extrínseca <code>setCodeWithoutChecks</code> em vez de <code>setCode</code>.</p> <p>Com o seu Runtime Wasm pronto para ser carregado e a sua conta Sudo acessível no portal do desenvolvedor, siga as seguintes etapas:</p> <ol> <li>Navegue até a aba Desenvolvedor do portal do desenvolvedor da sua appchain Tanssi.</li> <li>Clique em Sudo. Se você não vir Sudo neste menu, é porque você não associou a conta Sudo ao portal do desenvolvedor. Certifique-se de que a sua conta Sudo está injetada pela sua carteira e conectada ao portal do desenvolvedor.</li> <li>Selecione o pallet system.</li> <li>Selecione setCode.</li> <li>Alterne a chave fileUpload para habilitar o upload do seu arquivo de runtime Wasm.</li> <li>Faça o upload do seu runtime Wasm.</li> <li>Pressione Enviar Sudo e confirme a transação na sua carteira. </li> </ol> <p>Você pode verificar se a atualização do seu runtime foi bem-sucedida verificando a versão do runtime no canto superior esquerdo. Nesse caso, você pode ver que o runtime da appchain powered by Tanssi foi atualizado com sucesso para a versão <code>400</code>.</p> <p></p> <p>E é isso! A seção portal do desenvolvedor tem muitos outros guias sobre como gerenciar sua appchain Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/tanssi-network/", "title": "Fundamentos da Rede", "text": "<p>Conheça a rede Tanssi, as TestNets disponíveis e as principais funcionalidades e aspectos essenciais para começar a desenvolver e interagir com o ecossistema.</p>"}, {"location": "builders/tanssi-network/#visao-geral-da-rede", "title": "Visão Geral da Rede", "text": "<ul> <li>Token TANSSI: o token utilitário nativo das redes Tanssi e sua representação ERC-20.</li> <li>Dancelight: a TestNet oficial da Tanssi para implantação e experimentação rápidas de rede.</li> <li>Redes powered by Tanssi: redes construídas na plataforma Tanssi, alavancando seus recursos para criar blockchains personalizadas.</li> <li>Rede Demo EVM: uma rede compatível com Ethereum que exemplifica uma rede totalmente operacional impulsionada pela Tanssi.</li> </ul>"}, {"location": "builders/tanssi-network/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/tanssi-network/#recursos-adicionais", "title": "Recursos AdicionaisNetwork Toolkit", "text": "<p>Mergulhe em ferramentas e recursos projetados para simplificar o processo de desenvolvimento ao construir dApps nas redes Tanssi e powered by Tanssi.</p>"}, {"location": "builders/tanssi-network/endpoints/", "title": "Endpoints da Rede", "text": ""}, {"location": "builders/tanssi-network/endpoints/#pontos-finais-da-rede", "title": "Pontos Finais da Rede", "text": "<p>As redes Tanssi têm dois pontos finais disponíveis para os utilizadores se conectarem: um para HTTPS e outro para WSS.</p>"}, {"location": "builders/tanssi-network/endpoints/#mainnet-tanssi", "title": "MainNet Tanssi", "text": "<p>Os pontos finais HTTPS e WSS da Tanssi Network MainNet são os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"}, {"location": "builders/tanssi-network/endpoints/#dancelight", "title": "Dancelight", "text": "<p>Os pontos finais HTTPS e WSS da Tanssi TestNet são os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"}, {"location": "builders/tanssi-network/endpoints/#rede-demo-evm", "title": "Rede Demo EVM", "text": "<p>Os pontos finais HTTPS e WSS da rede Demo EVM são os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"}, {"location": "builders/tanssi-network/mainnet/", "title": "Comece a Usar a Tanssi Network MainNet", "text": ""}, {"location": "builders/tanssi-network/mainnet/#introduction", "title": "Introdução", "text": "<p>A Tanssi Network MainNet está ativa, permitindo que os desenvolvedores embarquem e lancem rapidamente suas appchains em questão de minutos.</p> <p>Esta página de referência rápida oferece todos os elementos essenciais que você precisa para começar na Rede Tanssi.</p>"}, {"location": "builders/tanssi-network/mainnet/#tanssi-token", "title": "TANSSI Token", "text": "<p>Os tokens TANSSI servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implantação de uma rede na Tanssi, você precisará obter tokens TANSSI.</p>"}, {"location": "builders/tanssi-network/mainnet/#tanssi-network-endpoints", "title": "Endpoints de Rede", "text": "<p>A Tanssi MainNet possui dois tipos de endpoints disponíveis para os usuários se conectarem: um para HTTPS e outro para WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi/\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"}, {"location": "builders/tanssi-network/mainnet/#tanssi-block-explorers", "title": "Exploradores de Blocos", "text": "<p>Para a Tanssi MainNet, você pode usar o seguinte explorador de blocos:</p> <ul> <li>Tanssi Network Subscan</li> <li>Polkadot.js Apps</li> </ul> <p>O suporte para exploradores de blocos adicionais está em andamento e, à medida que mais exploradores suportarem a Tanssi MainNet, esta seção será atualizada de acordo.</p>"}, {"location": "builders/tanssi-network/tanssi-token/", "title": "Token TANSSI", "text": ""}, {"location": "builders/tanssi-network/tanssi-token/#introduction", "title": "Introdução", "text": "<p>O token da rede Tanssi é o token de utilidade que alimenta o protocolo Tanssi. Considerando a arquitetura da Tanssi, o token existe em duas representações distintas, mas interconectadas: Substrate nativo e ERC-20 Ethereum. As duas versões podem ser interligadas através da ponte Tanssi-Ethereum.</p> <p>Neste guia, a utilidade do token e as diferenças entre suas duas representações são abordadas, o que é crucial para operators de rede, stakers, gerentes de appchain e usuários em geral que desejam participar do ecossistema Tanssi.</p>"}, {"location": "builders/tanssi-network/tanssi-token/#token-utility", "title": "Utilidade do Token", "text": "<p>A Tanssi é um protocolo de infraestrutura descentralizado que facilita a implantação de appchains com lógica personalizada. Ele permite que os desenvolvedores se concentrem no caso de uso, em vez de desviar tempo e energia para gerenciar os vários componentes necessários para que uma rede funcione sem problemas.</p> <p>A execução de um protocolo descentralizado saudável não só requer um mecanismo de governança robusto para garantir que as decisões sejam tomadas de forma transparente, mas também o alinhamento de incentivos e coordenação entre vários atores do ecossistema, incluindo desenvolvedores de appchain, node operators, operators de Sequencers, disponibilidade de dados e provedores de RPC, bem como usuários em geral. O token Tanssi serve como a espinha dorsal, fornecendo os mecanismos econômicos necessários para coordenar, incentivar o comportamento adequado e proteger todo o ecossistema. Ele permite uma evolução de protocolo verificável e imposta por código por meio de um processo de tomada de decisão totalmente na cadeia.</p> <p>O token tem várias utilidades:</p> <ul> <li>Governança on-chain: os detentores de tokens podem usar o token para propor e votar em decisões de governança, como atualizações de software, como gastar fundos do tesouro, alterar regras de protocolo e muito mais.</li> <li>Implantação de Appchain: use o token para registrar e lançar seu appchain em minutos.</li> <li>Pagamento do serviço de sequenciamento: use o token para manter seu appchain ativo.</li> <li>Recompensa de serviços de sequenciamento e operator: obtenha tokens como recompensas pelos serviços de seus nós.</li> <li>Staking em Sequencers: os detentores de tokens podem apostar em Sequencers, recebendo recompensas sem risco de corte.</li> <li>Staking em operators: os detentores de tokens podem apostar em operators, recebendo recompensas por seus serviços de validação.</li> <li>Pagamento de taxas: use o token para pagar as taxas de interação com a rede Tanssi.</li> </ul> <p>Note</p> <p>Todas as taxas de transação na Tanssi são pagas usando o token, com o valor total indo diretamente para financiar a conta do tesouro do protocolo. Esses fundos só podem ser gastos via governança.</p>"}, {"location": "builders/tanssi-network/tanssi-token/#token-representations", "title": "Representações de Token", "text": "<p>A rede Tanssi é construída usando a estrutura Substrate, aproveitando sua arquitetura modular e alto desempenho. Portanto, o token nativo é do tipo Substrate. Os mecanismos de cunhagem e queima do protocolo acontecem na rede Tanssi, ou, em outras palavras, acontecem na representação do token Substrate.</p> <p>Além disso, o protocolo Tanssi conta com provedores de segurança externos, como o Symbiotic, para proteger o ecossistema por meio de ativos reapostados. Esse mecanismo de reaposta é implementado no Ethereum; portanto, uma versão ERC-20 do token também existe para cobrir casos de uso no lado Ethereum.</p> <p>Aproveitando os recursos de bridging integrados à Tanssi, o token pode ser convertido para (e de) a representação ERC-20 no Ethereum. Quando o token é ponteado para Ethereum, os tokens são travados na conta soberana da ponte, e uma mensagem é enviada ao contrato Ethereum para cunhar a quantia equivalente em ERC-20. Esse mecanismo de travamento e cunhagem garante que a versão ERC-20 seja criada por meio de um mecanismo de bridging sem confiança, mantendo um relacionamento 1:1 com o token nativo.</p> <pre><code>flowchart LR\n    subgraph Tanssi_Network [\"Rede Tanssi\"]\n        Tanssi_Substrate[\"$TANSSI (Substrate)\"]\n        Tanssi_Substrate_Utility[\"✓ Governança on-chain\n        ✓ Implantação de Appchain\n        ✓ Recompensas de Sequencers\n        ✓ Staking em Sequencers\n        ✓ Pagamento de taxas\n        \"]\n        Tanssi_Substrate --&gt; Tanssi_Substrate_Utility\n    end\n\n    subgraph Ethereum_Network [\"Ethereum\"]\n        Tanssi_ERC20[\"$TANSSI (ERC-20)\"]\n        Tanssi_ERC20_Utility[\"✓ Recompensa de serviços de operator\n        ✓ Staking em operators\n        &lt;pre&gt; &lt;/pre&gt;\n        \"]\n        Tanssi_ERC20 --&gt; Tanssi_ERC20_Utility\n    end\n\n    Bridge[\"Trustless Bridge\"]\n\n    Tanssi_Network &lt;--&gt; Bridge &lt;--&gt; Ethereum_Network\n\n    %% Apply custom style to utility nodes\n    classDef utility_style fill: transparent, stroke: transparent, text-align: start;\n    class Tanssi_Substrate_Utility,Tanssi_ERC20_Utility utility_style;\n    %% Make utility arrows transparent\n    linkStyle 0 stroke:transparent,fill:transparent;\n    linkStyle 1 stroke:transparent,fill:transparent;</code></pre>"}, {"location": "builders/tanssi-network/tanssi-token/#tanssi-substrate", "title": "Tanssi (Substrate) - Token Nativo", "text": "<p>O token Tanssi nativo existe na rede Tanssi como um ativo baseado em Substrate e é a forma original do token que alimenta as operações principais do protocolo.</p> <p>Este token usa como conta do tipo Substrate Sr25519, então requer uma carteira como a Talisman ou qualquer outra carteira compatível com Substrate.</p> <p>Note</p> <p>O token nativo Tanssi (Substrate) tem doze (12) casas decimais.</p>"}, {"location": "builders/tanssi-network/tanssi-token/#tanssi-erc-20", "title": "Tanssi (ERC-20) - Representação Ethereum", "text": "<p>A versão ERC-20 da Tanssi é um token Ethereum padrão que representa o token nativo na rede Ethereum. Essa versão é criada por meio do mecanismo de ponte sem confiança, utilizando uma estratégia de bloqueio e cunhagem, mantendo assim um relacionamento 1:1 com o token nativo.</p> <p>Este token, como qualquer outro ativo Ethereum, usa uma conta ECDSA, então requer uma carteira como Metamask ou qualquer outra carteira compatível com Ethereum.</p> <p>Note</p> <p>O Tanssi (ERC-20) tem doze (12) casas decimais.</p>"}, {"location": "builders/tanssi-network/tanssi-token/#substrate-erc-20-comparison", "title": "Comparação Tanssi (Substrate) e Tanssi (ERC-20)", "text": "<p>Para entender melhor as diferenças entre as duas representações de token, a tabela a seguir fornece um resumo de seus principais recursos:</p> Recurso Tanssi (Substrate) Tanssi (ERC-20) Rede Rede Tanssi Ethereum MainNet Padrão de Token Ativo Substrate nativo Token padrão ERC-20 Casas Decimais Doze (12) decimais Doze (12) decimais Tipo de Conta Sr25519 ECDSA Carteiras Compatíveis Talisman, SubWallet e outros MetaMask, Talisman e outras carteiras compatíveis com Ethereum Principais Utilidades - Participação na governança on-chain- Registro e implantação de Appchain- Pagamento de serviços de sequenciamento- Taxas de transação na rede Tanssi- Staking em Sequencers- Recompensas de operação do Sequencer - Recompensas de validação do operator- Staking em operators Opções de Staking Staking de Sequencer (para manter a atividade da appchain) Staking de operator (para validar/proteger todo o ecossistema Tanssi) Conversão de Ponte Pode ser ponteado para ERC-20, pagando taxas em $TANSSI (Substrate) Pode ser ponteado para Substrate, pagando taxas em $ETH"}, {"location": "builders/tanssi-network/testnet/", "title": "TestNet", "text": "<p>Dancelight, a TestNet oficial da Tanssi, permite que os desenvolvedores experimentem aplicações blockchain em um ambiente controlado antes de entrar em operação. Ele fornece as ferramentas para configurar redes, interagir com versões de teste de protocolos e solucionar problemas para garantir uma transição mais suave para a produção.</p> <p>Quando estiver pronto para ver como seu projeto pode prosperar em um ambiente do mundo real, experimente o ambiente EVM de demonstração. Totalmente compatível com o Ethereum, esta configuração powered by Tanssi apresenta os principais recursos e oferece uma experiência imersiva, dando-lhe um vislumbre do potencial total da sua solução personalizada.</p>"}, {"location": "builders/tanssi-network/testnet/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/tanssi-network/testnet/dancelight/", "title": "Começar a Usar o Dancelight", "text": ""}, {"location": "builders/tanssi-network/testnet/dancelight/#introduction", "title": "Introdução", "text": "<p>Dancelight é a primeira Tanssi TestNet pública e foi projetada para otimizar a implantação de redes descentralizadas. Ela permite que as equipes embarquem e lancem rapidamente suas appchains em questão de minutos, fornecendo um ambiente robusto para testes e desenvolvimento.</p> <p>Esta página de referência rápida oferece todos os elementos essenciais que você precisa para começar a usar o Dancelight.</p>"}, {"location": "builders/tanssi-network/testnet/dancelight/#testnet-tokens", "title": "Tokens da TestNet", "text": "<p>Os tokens STAR servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implantação de uma rede no Dancelight, você precisará obter tokens STAR. Siga estas etapas:</p> <ol> <li>Visite o site Tanssi Network.</li> <li>Preencha o formulário, fornecendo informações básicas e seu endereço baseado em Substrate.</li> <li>Em até um dia útil após o envio do formulário, você receberá tokens STAR para testes.</li> </ol> <p>Note</p> <p>Os tokens STAR não têm valor. Por favor, não envie solicitações desnecessárias.</p>"}, {"location": "builders/tanssi-network/testnet/dancelight/#dancelight-network-endpoints", "title": "Pontos de Extremidade da Rede", "text": "<p>Dancelight tem dois tipos de pontos de extremidade disponíveis para os usuários se conectarem: um para HTTPS e outro para WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"}, {"location": "builders/tanssi-network/testnet/dancelight/#dancelight-block-explorers", "title": "Exploradores de Blocos", "text": "<p>Para o Dancelight, você pode usar os seguintes exploradores de blocos:</p> <ul> <li>Subscan.</li> <li>O portal do desenvolvedor.</li> </ul> <p>O suporte para exploradores de blocos adicionais está em andamento e, à medida que mais exploradores suportarem o Dancelight, esta seção será atualizada de acordo.</p>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/", "title": "Rede de Demonstração EVM Tanssi", "text": ""}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#introduction", "title": "Introdução", "text": "<p>Explore as funcionalidades de uma rede totalmente compatível com Ethereum, implantada através da Tanssi, interagindo com a rede EVM de demonstração em Dancelight.</p> <p>Esta página de referência rápida oferece todos os elementos essenciais de que você precisa para interagir com esta rede de demonstração.</p>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#faucet", "title": "Faucet para Tokens TestNet", "text": "<p>Você pode acessar tokens TANGO, a moeda nativa da rede de demonstração EVM, na faucet no Tanssi dApp. Você pode receber até 100 tokens TANGO a cada 12 horas.</p> <p>Para solicitar tokens da faucet, acesse o Tanssi dApp e pressione Adicionar ao MetaMask.</p> <p></p> <p>Em seguida, siga estas etapas:</p> <ol> <li>Pressione Solicitar Tokens</li> <li>Selecione a conta que você gostaria de receber tokens TANGO e pressione Avançar</li> <li>Pressione Conectar</li> </ol> <p></p> <p>Note</p> <p>Tokens TANGO não têm valor. Por favor, não envie spam para a faucet com solicitações desnecessárias.</p> <p>Seus tokens serão distribuídos em breve, e você pode verificar seu saldo de tokens TANGO pesquisando seu endereço no [explorador](https://dancelight-2001-blockscout.tanssi-chains.network/){target=_blank}.</p>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#network-endpoints", "title": "Endpoints de Rede", "text": "<p>Os endpoints HTTPS e WSS da rede EVM de demonstração são os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#block-explorers", "title": "Exploradores de Blocos", "text": "<p>Para a rede EVM de demonstração, você pode usar qualquer um dos seguintes exploradores:</p> <ul> <li>Polkadot.js Apps (API Substrate)</li> <li>Blockscout (API Ethereum)</li> <li>Expedition (API Ethereum)</li> </ul>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#chain-id", "title": "ID da Cadeia", "text": "<p>A rede EVM de demonstração tem um ID de cadeia de: <code>5678</code>, que é <code>0x162E</code> em hexadecimal.</p>"}, {"location": "builders/tanssi-network/testnet/demo-evm-network/#quick-start", "title": "Início Rápido", "text": "<p>Você pode interagir com uma rede EVM Powered by Tanssi usando bibliotecas Ethereum padrão, como Ethers.js, Web3.js e Web3.py. Para começar rapidamente, você precisará criar um provedor conectado a uma rede EVM Tanssi: // Insira sua URL RPC aqui</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from \"ethers\";\n\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insira sua URL RPC aqui\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/', \n    chainId: 5678, // 0x162E em hexadecimal,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <pre><code>const Web3 = require('web3');\n\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <pre><code>from web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/')) \n</code></pre>"}, {"location": "builders/toolkit/", "title": "Kit de Ferramentas", "text": "<p>A seção Toolkit é o seu centro de recursos completo para construir, implantar e gerenciar redes baseadas em Tanssi. Ela reúne ferramentas Ethereum e Substrate, como bibliotecas, ambientes de desenvolvimento, precompiles, métodos JSON-RPC e muito mais. Seja aprimorando uma rede existente ou implementando novos recursos, este kit de ferramentas oferece tudo o que você precisa para simplificar o desenvolvimento e a operação da sua rede.</p> <p>Tip</p> <p>Se você estiver trabalhando com uma rede compatível com EVM, pode usar as ferramentas Substrate para interagir com as funcionalidades de baixo nível da sua rede. Com isso, você pode interagir com módulos de Runtime personalizados, consultar o armazenamento, gerenciar a governança ou trabalhar com recursos exclusivos do Substrate.</p>"}, {"location": "builders/toolkit/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/", "title": "Ferramentas Ethereum", "text": "<p>Desenvolver em cadeias compatíveis com EVM baseadas em Tanssi requer a compreensão de como interagir com o blockchain de forma eficaz. Seja você construindo aplicativos descentralizados (dApps), implantando contratos inteligentes ou consultando dados de blockchain, o uso das ferramentas e fluxos de trabalho corretos é essencial.</p> <p>Esta seção oferece uma visão geral das principais ferramentas e fluxos de trabalho que os desenvolvedores usam para interagir com essas redes, ajudando a aprimorar seu fluxo de trabalho de desenvolvimento.</p> <p>Pronto para mergulhar? Confira algumas das seguintes ferramentas:</p> <ul> <li>Ambientes de desenvolvimento - Remix, Foundry e Hardhat</li> <li>Bibliotecas - Ethers.js, viem e Web3.js</li> <li>Carteiras - MetaMask, SubWallet e Talisman</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/rpc/", "title": "Métodos da API JSON-RPC", "text": ""}, {"location": "builders/toolkit/ethereum-api/rpc/#standard-rpc-methods", "title": "Métodos Ethereum Padrão", "text": "<p>A compatibilidade EVM da Tanssi é derivada do Frontier e segue de perto a compatibilidade Ethereum do Moonbeam. Os nós da Tanssi suportam uma ampla variedade de métodos JSON-RPC padrão do Ethereum.</p> <p>Nem todos os métodos são suportados; alguns retornam valores padrão (especialmente os ligados ao PoW). Abaixo está a lista dos métodos Ethereum JSON-RPC suportados na Tanssi para que os desenvolvedores saibam o que está disponível ao interagir com redes EVM da Tanssi.</p> <p>Métodos básicos da API Ethereum suportados:</p> <ul> <li>eth_protocolVersion — retorna <code>1</code> por padrão</li> <li>eth_syncing — retorna um objeto com o status de sincronização ou <code>false</code></li> <li>eth_hashrate — retorna <code>\"0x0\"</code> por padrão</li> <li>eth_coinbase — retorna o autor do último bloco (não necessariamente finalizado)</li> <li>eth_mining — retorna <code>false</code> por padrão</li> <li>eth_chainId — retorna o chain ID usado para assinar no bloco atual</li> <li>eth_gasPrice — retorna a base fee por unidade de gas. Atualmente é o gas price mínimo da rede</li> <li>eth_accounts — lista de endereços do cliente</li> <li>eth_blockNumber — maior número de bloco disponível</li> <li>eth_getBalance — saldo do endereço fornecido</li> <li>eth_getStorageAt — conteúdo do storage em um endereço</li> <li>eth_getBlockByHash — informações do bloco por hash, incluindo <code>baseFeePerGas</code> em blocos pós-London</li> <li>eth_getBlockByNumber — informações do bloco por número, incluindo <code>baseFeePerGas</code> em blocos pós-London</li> <li>eth_getBlockReceipts — todos os receipts de transações de um bloco</li> <li>eth_getTransactionCount — número de transações (nonce) enviadas pelo endereço</li> <li>eth_getBlockTransactionCountByHash — número de transações em um bloco por hash</li> <li>eth_getBlockTransactionCountByNumber — número de transações em um bloco por número</li> <li>eth_getUncleCountByBlockHash — retorna <code>\"0x0\"</code> por padrão</li> <li>eth_getUncleCountByBlockNumber — retorna <code>\"0x0\"</code> por padrão</li> <li>eth_getCode — código no endereço informado e bloco informado</li> <li>eth_sendTransaction — cria transação de chamada ou criação de contrato (se houver código em <code>data</code>). Retorna o hash da transação ou zero hash se ainda não disponível</li> <li>eth_sendRawTransaction — cria transação de chamada ou criação para transações assinadas. Retorna hash ou zero hash se ainda não disponível</li> <li>eth_call — executa chamada sem criar transação, retornando o valor da execução</li> <li>eth_estimateGas — estima o gas necessário para uma transação. Pode receber <code>gasPrice</code> ou <code>maxFeePerGas</code> e <code>maxPriorityFeePerGas</code></li> <li>eth_feeHistory — retorna <code>baseFeePerGas</code>, <code>gasUsedRatio</code>, <code>oldestBlock</code> e <code>reward</code> para um intervalo de até 1024 blocos</li> <li>eth_getTransactionByHash — informações de uma transação por hash; transações EIP-1559 incluem <code>maxPriorityFeePerGas</code> e <code>maxFeePerGas</code></li> <li>eth_getTransactionByBlockHashAndIndex — informações de uma transação por hash do bloco e índice; inclui campos EIP-1559</li> <li>eth_getTransactionByBlockNumberAndIndex — informações de uma transação por número do bloco e índice; inclui campos EIP-1559</li> <li>eth_getTransactionReceipt — receipt de uma transação por hash</li> <li>eth_getUncleByBlockHashAndIndex — retorna <code>null</code> por padrão</li> <li>eth_getUncleByBlockNumberAndIndex — retorna <code>null</code> por padrão</li> <li>eth_getLogs — array de logs que correspondem ao filtro</li> <li>eth_newFilter — cria filtro com base nos parâmetros fornecidos; retorna o ID do filtro</li> <li>eth_newBlockFilter — cria filtro para avisar quando chegar um novo bloco; retorna ID</li> <li>eth_getFilterChanges — método de polling para filtros; retorna logs desde o último poll</li> <li>eth_getFilterLogs — array de logs que correspondem ao filtro com ID fornecido</li> <li>eth_uninstallFilter — remove um filtro pelo ID; use quando o polling não for mais necessário (filtros expiram se não forem consultados)</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/rpc/#custom-json-rpc-methods", "title": "Métodos JSON-RPC Personalizados", "text": "<p>Os nós da Tanssi expõem dois endpoints personalizados: <code>frnt_isBlockFinalized</code> e <code>frnt_isTxFinalized</code>. Como a Tanssi tem finalização determinística, é possível saber com certeza se um bloco ou transação está finalizado ou não. Esses endpoints ajudam a verificar a finalização de eventos on-chain.</p> frnt_isBlockFinalized - verifica a finalização do bloco pelo hash ParâmetrosRetornoExemplo <ul> <li><code>block_hash</code> string - hash do bloco (aceita hash estilo Substrate ou Ethereum)</li> </ul> <p>boolean - <code>true</code> se o bloco estiver finalizado; <code>false</code> se não estiver finalizado ou não encontrado</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> frnt_isTxFinalized - verifica a finalização de uma transação pelo hash EVM ParâmetrosRetornoExemplo <ul> <li><code>tx_hash</code> string - hash EVM da transação</li> </ul> <p>boolean - <code>true</code> se a transação estiver finalizada; <code>false</code> se não estiver finalizada ou não encontrada</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/", "title": "Ambientes de Desenvolvimento", "text": "<p>Estabelecer um ambiente de desenvolvimento eficaz é crucial para construir, testar e implantar contratos inteligentes de forma eficiente. Os ambientes de desenvolvimento simplificam o processo de construção de aplicações blockchain, abstraindo muitas das complexidades subjacentes envolvidas na interação com as redes blockchain. Eles fornecem as ferramentas e estruturas necessárias para:</p> <ul> <li>Escrever, compilar, testar e implantar contratos inteligentes Solidity</li> <li>Simular interações blockchain localmente para teste e depuração</li> <li>Automatizar fluxos de trabalho para implantações mais rápidas</li> </ul> <p>Cada ambiente de desenvolvimento ajuda você a alcançar o mesmo objetivo, construir e implantar aplicações blockchain, mas eles o fazem de maneiras únicas. Por exemplo, IDEs baseadas em navegador como Remix fornecem uma maneira rápida e acessível de começar a codificar, enquanto ferramentas como Foundry e Hardhat atendem aos desenvolvedores que preferem fluxos de trabalho específicos, como uma abordagem Solidity-first ou integrada ao JavaScript. Escolha aquele que melhor se alinha às suas necessidades e estilo de desenvolvimento.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/", "title": "Usando Foundry para Implantar na Sua Rede EVM", "text": ""}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#introduction", "title": "Introdução", "text": "<p>Foundry é um ambiente de desenvolvimento Ethereum escrito em Rust que ajuda a gerenciar dependências, compilar projetos, executar testes, implantar contratos e interagir com blockchains pela linha de comando. O Foundry pode interagir diretamente com a API Ethereum de redes EVM powered by Tanssi, portanto pode ser usado para implantar e interagir com contratos inteligentes na sua rede Tanssi.</p> <p>Quatro ferramentas compõem o Foundry:</p> <ul> <li>Forge – compila, testa e implanta contratos</li> <li>Cast – interface de linha de comando para interagir com contratos</li> <li>Anvil – nó local de TestNet para desenvolvimento que pode bifurcar redes existentes</li> <li>Chisel – REPL Solidity para testar rapidamente trechos de código</li> </ul> <p>Este guia mostra como usar o Foundry para compilar, implantar e depurar contratos Ethereum na rede EVM de demonstração. Você pode seguir os mesmos passos na sua rede EVM da Tanssi trocando a URL RPC e o Chain ID dos exemplos.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para começar, você precisará de:</p> <ul> <li>Uma conta com fundos</li> <li>Foundry instalado</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#creating-a-foundry-project", "title": "Criando um Projeto Foundry", "text": "<p>Você precisa criar um projeto Foundry se ainda não tiver um. Siga os passos:</p> <ol> <li> <p>Instale o Foundry com os comandos abaixo. No Windows, é necessário instalar o Rust e compilar o Foundry a partir do código-fonte:</p> UbuntuMacOSWindows <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> <p>Após instalar, talvez seja necessário reiniciar o terminal ou adicionar <code>foundryup</code> ao PATH.</p> </li> <li> <p>Crie o projeto (será criada uma pasta com três subpastas):</p> <pre><code>forge init foundry\n</code></pre> </li> </ol> <p>Você pode receber um erro como <code>The target directory is a part of or on its own an already initialized git repository, and it requires clean working and staging areas, including no untracked files.</code> Para resolver, adicione arquivos e faça um commit se estiver mantendo o projeto em um repositório GitHub. Caso contrário, faça um commit fictício sem enviar. Se executar <code>forge init foundry</code> novamente, o erro não aparecerá.</p> <p>Com o projeto padrão criado, você verá três pastas:</p> <ul> <li><code>lib</code> – dependências do projeto como submódulos git</li> <li><code>src</code> – onde colocar seus contratos inteligentes (com funcionalidade)</li> <li><code>test</code> – onde colocar os testes do Forge em Solidity</li> </ul> <p>Além dessas três pastas, um repositório git será criado com um <code>.gitignore</code> pré-preenchido ignorando tipos de arquivo e pastas relevantes.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#the-src-folder", "title": "A Pasta <code>src</code>", "text": "<p>O repositório <code>foundry</code> pré-configurado inclui <code>Counter.sol</code> em <code>src</code>, <code>Counter.s.sol</code> em <code>script</code> e <code>Counter.t.sol</code> em <code>test</code>. Exclua esses arquivos para evitar erros ao compilar e implantar <code>MyToken.sol</code>. Você pode fazer isso com:</p> <pre><code>rm src/Counter.sol script/Counter.s.sol test/Counter.t.sol\n</code></pre> <p>Nas etapas seguintes, você implantará um contrato ERC-20. No diretório <code>src</code>, crie o arquivo <code>MyToken.sol</code>:</p> <pre><code>cd src\ntouch MyToken.sol\n</code></pre> <p>Abra o arquivo e adicione o contrato:</p> <pre><code>pragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p>Antes de compilar, instale os contratos OpenZeppelin como dependência. Você pode ter que fazer commit das mudanças anteriores antes. Por padrão, o Foundry usa submódulos git em vez de pacotes npm, então o caminho e comando tradicionais do npm não são usados. Em vez disso, use o nome do repositório do OpenZeppelin no GitHub:</p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#compiling-solidity", "title": "Compilando Solidity", "text": "<p>Com todas as dependências instaladas, compile o contrato:</p> <pre><code>forge build\n</code></pre> <p></p> <p>Após a compilação, duas pastas serão criadas: <code>out</code> e <code>cache</code>. A ABI e o bytecode dos contratos ficam em <code>out</code>. Essas duas pastas já estão ignoradas no <code>.gitignore</code> incluído na inicialização padrão do projeto Foundry.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#deploying-the-contract", "title": "Implantando o Contrato", "text": "<p>Implantar o contrato com Forge exige apenas um comando, mas você precisa incluir um endpoint RPC, uma chave privada financiada e argumentos do builder. <code>MyToken.sol</code> pede uma oferta inicial de tokens em seu builder, portanto o comando inclui 100 como argumento do builder. Você pode implantar o contrato <code>MyToken.sol</code> usando o comando abaixo (ajuste para a rede correta):</p> <pre><code>forge create --rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--constructor-args 100 \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <p>Depois de alguns segundos, o contrato é implantado e você verá o endereço no terminal.</p> <p></p> <p>Parabéns, seu contrato está ativo! Salve o endereço, pois o usará para interagir com esta instância no próximo passo.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#interacting-with-the-contract", "title": "Interagindo com o Contrato", "text": "<p>O Foundry inclui o Cast, uma CLI para realizar chamadas RPC Ethereum.</p> <p>Recupere o nome do token usando o Cast, onde <code>INSERT_YOUR_CONTRACT_ADDRESS</code> é o endereço do contrato implantado na seção anterior:</p> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Você deve obter os dados em hexadecimal:</p> <pre><code>0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>Isso não é legível, mas você pode usar o Cast para converter para o formato desejado. Neste caso, o dado é texto, então converta para ASCII para ver \"My Token\":</p> <p></p> <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>Você também pode alterar dados com o Cast. Tente queimar tokens enviando-os para o endereço zero.</p> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--chain 5678 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <p>A transação será assinada pela sua conta EVM e transmitida à rede. A saída deve se parecer com:</p> <p></p> <p>Parabéns, você implantou e interagiu com um contrato usando Foundry!</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#forking-with-anvil", "title": "Bifurcando com Anvil", "text": "<p>Como mencionado, o Anvil é um nó local de TestNet para desenvolvimento que pode bifurcar redes existentes. Bifurcar a rede demo EVM permite interagir com contratos vivos implantados na rede.</p> <p>Para bifurcar a rede demo EVM na linha de comando, execute o seguinte comando no diretório do projeto Foundry. Você também pode substituir a URL RPC pela URL RPC da sua rede EVM da Tanssi:</p> <pre><code>anvil --fork-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>A instância bifurcada terá 10 contas de desenvolvimento pré-financiadas com 10.000 tokens de teste. A instância fica disponível em <code>http://127.0.0.1:8545/</code>. A saída no terminal deve ser semelhante a:</p> <p></p> <p>Para verificar se você bifurcou a rede, consulte o último número do bloco e compare com o número atual da rede demo EVM.</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>Se converter o <code>result</code> de hex para decimal, você deve obter o número mais recente do bloco do momento em que bifurcou.</p> <p>A partir daqui, você pode implantar novos contratos na instância bifurcada da rede demo EVM (ou qualquer outra rede EVM com Tanssi) ou interagir com contratos já implantados. Seguindo o exemplo anterior, você pode fazer uma chamada com o Cast para verificar o saldo de tokens MYTOK cunhados na conta que implantou o contrato:</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS  \"balanceOf(address)(uint256)\" \\\n INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#using-chisel", "title": "Usando Chisel", "text": "<p>O Chisel é um REPL ou shell Solidity. Ele permite escrever Solidity diretamente no console para testar trechos pequenos de código, permitindo pular a configuração de projeto e implantação de contrato para processos rápidos.</p> <p>Como o Chisel é útil para testes rápidos, ele pode ser usado fora de um projeto Foundry. Mas, se for executado dentro de um projeto Foundry, ele mantém as configurações do <code>foundry.toml</code>.</p> <p>Neste exemplo, você testará alguns recursos do <code>abi</code> em Solidity para demonstrar como o Chisel pode ser útil. Para começar a usar o Chisel, execute no terminal para iniciar o shell:</p> <pre><code>chisel\n</code></pre> <p>No shell, escreva código Solidity como se estivesse dentro de uma função:</p> <pre><code>bytes memory myData = abi.encode(100, true, \"Build with Tanssi\");\n</code></pre> <p>Suponha que você esteja interessado em como o <code>abi</code> codifica dados porque quer armazenar dados de forma mais eficiente no blockchain e economizar gás. Para ver como <code>myData</code> é armazenado em memória, use o comando a seguir no shell do Chisel:</p> <pre><code>!memdump\n</code></pre> <p><code>memdump</code> despejará todos os dados da sessão atual. Você verá algo como abaixo. Se não souber ler hexadecimal ou não souber como funciona a codificação ABI, talvez não consiga encontrar onde a variável <code>myData</code> foi armazenada.</p> <p></p> <p>Felizmente, o Chisel permite descobrir facilmente onde a informação está armazenada. Usando o comando <code>!rawstack</code>, é possível encontrar a posição na pilha onde o valor de uma variável está:</p> <pre><code>!rawstack myData\n</code></pre> <p>Nesse caso, como <code>myData</code> tem mais de 32 bytes, o ponteiro de memória é exibido. Mas é exatamente o que precisamos, já que você já conhece toda a pilha pelo comando <code>!memdump</code>.</p> <p></p> <p>O comando <code>!rawstack</code> mostra que a variável <code>myData</code> está em <code>0x80</code>; comparando com o dump de memória do <code>!memdump</code>, parece que <code>myData</code> está armazenado assim:</p> <pre><code>[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0\n[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064\n[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001\n[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060\n[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000011\n[0x120:0x140]: 0x4275696c6420776974682054616e737369000000000000000000000000000000\n</code></pre> <p>A princípio, isso faz sentido, pois <code>0xa0</code> tem valor <code>0x64</code> (igual a 100) e <code>0xc0</code> tem valor <code>0x01</code> (igual a true). Para saber mais sobre a codificação ABI, veja a documentação de Solidity para ABI. Neste caso, há muitos zeros nesse tipo de empacotamento de dados, então, como desenvolvedor de smart contracts, você pode tentar usar structs ou empacotar os dados de forma mais eficiente com código bitwise.</p> <p>Quando terminar com esse código, limpe o estado do Chisel para não interferir em qualquer lógica futura que queira testar (mantendo a mesma instância do Chisel):</p> <pre><code>!clear\n</code></pre> <p>Há um jeito ainda mais fácil de testar com o Chisel. Quando você escreve código terminando com ponto e vírgula <code>;</code>, o Chisel executa como uma instrução, armazenando o valor no estado de runtime do Chisel. Mas, se você só precisa ver como os dados ABI codificados aparecem, pode rodar o código como uma expressão. Para testar com o mesmo exemplo de <code>abi</code>, escreva no shell do Chisel:</p> <pre><code>abi.encode(100, true, \"Build with Tanssi\")\n</code></pre> <p>Você verá algo como:</p> <p></p> <p>Embora não exiba os dados do mesmo jeito, você ainda vê o conteúdo e ele quebra mais detalhes, como informar que o valor <code>0xa0</code> define o comprimento dos dados.</p> <p>Por padrão, ao sair do shell do Chisel, nenhum dado persiste. Mas você pode instruir o Chisel a persistir. Por exemplo, siga estes passos para armazenar uma variável:</p> <ol> <li> <p>Armazene um <code>uint256</code> no Chisel</p> <pre><code>uint256 myNumber = 101;\n</code></pre> </li> <li> <p>Armazene a sessão com <code>!save</code>. Neste exemplo, use o número <code>1</code> como ID de salvamento</p> <pre><code>!save 1\n</code></pre> </li> <li> <p>Saia da sessão <pre><code>!quit\n</code></pre></p> </li> </ol> <p>Para visualizar e interagir com os estados do Chisel salvos, siga estes passos:</p> <ol> <li> <p>Veja a lista de estados salvos do Chisel</p> <pre><code>chisel list\n</code></pre> </li> <li> <p>Carregue seu estado salvo fornecendo o comando <code>chisel load</code> seguido do ID do estado</p> <pre><code>chisel load 1\n</code></pre> </li> <li> <p>Visualize o <code>uint256</code> salvo no Chisel a partir do conjunto de passos anterior</p> <pre><code>!rawstack myNumber\n</code></pre> </li> </ol> <p></p> <p>Você pode até bifurcar redes enquanto usa o Chisel:</p> <pre><code>!fork https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Então, por exemplo, você pode consultar o saldo da conta Alice na rede demo EVM:</p> <pre><code>0x44236223aB4291b93EEd10E4B511B37a398DEE55.balance\n</code></pre> <p></p> <p>Se quiser saber mais sobre o Chisel, baixe o Foundry e consulte a página de referência oficial.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/foundry/#foundry-with-hardhat", "title": "Foundry com Hardhat", "text": "<p>Muitas vezes, um projeto que você quer integrar tem toda a configuração em Hardhat, tornando penosa a tarefa de converter tudo para Foundry. Esse trabalho extra é evitável criando um projeto híbrido que use recursos do Hardhat e do Foundry juntos, o que é possível com o plugin hardhat-foundry.  </p> <p>Para converter seu projeto Foundry pré-existente em híbrido, essencialmente você vai instalar um projeto Hardhat na mesma pasta:</p> <pre><code>npm init\nnpm install --save-dev hardhat @nomicfoundation/hardhat-foundry\nnpx hardhat init\n</code></pre> <p>Para mais informações, consulte nossa documentação sobre Criando um Projeto Hardhat.</p> <p>Após inicializar o novo projeto Hardhat, algumas pastas e arquivos novos devem aparecer: <code>contracts</code>, <code>hardhat.config.js</code>, <code>scripts</code> e <code>test/Lock.js</code>. Você precisará fazer algumas modificações para criar o projeto híbrido:</p> <ol> <li> <p>Edite o arquivo <code>hardhat.config.js</code> dentro do repositório. Abra-o e, no topo, adicione:</p> <pre><code>require('@nomicfoundation/hardhat-foundry');\n</code></pre> <p>Após adicionar o plugin <code>hardhat-foundry</code>, as pastas <code>contracts</code> típicas do Hardhat não funcionarão porque agora o Hardhat espera que todos os contratos inteligentes estejam na pasta <code>src</code> do Foundry</p> </li> <li> <p>Mova todos os contratos da pasta <code>contracts</code> para a pasta <code>src</code> e então apague a pasta <code>contracts</code></p> </li> <li> <p>Edite o arquivo <code>foundry.toml</code> para garantir que dependências instaladas via submódulos Git e npm possam ser compiladas pela ferramenta Forge. Edite o <code>profile.default</code> para garantir que a entrada <code>libs</code> contenha <code>lib</code> e <code>node_modules</code>:</p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', 'node_modules']\nsolc = '0.8.20'\nevm_version = 'london'\n</code></pre> </li> </ol> <p>Agora tanto <code>forge build</code> quanto <code>npx hardhat compile</code> devem funcionar independentemente das dependências.  </p> <p>Tanto <code>forge test</code> quanto <code>npx hardhat test</code> conseguem acessar todos os contratos e dependências. O <code>forge test</code> testará apenas os testes em Solidity, enquanto <code>npx hardhat test</code> testará apenas os testes em JavaScript. Se quiser usá-los em conjunto, você pode criar um novo script no arquivo <code>package.json</code>:</p> <pre><code>\"scripts\": {\n    \"test\": \"npx hardhat test &amp;&amp; forge test\"\n}\n</code></pre> <p>Você pode executar este comando com:</p> <pre><code>npm run test\n</code></pre> <p>Por fim, embora não seja necessário, pode valer a pena mover todos os scripts JavaScript da pasta <code>scripts</code> para a pasta <code>script</code> do Foundry e apagar a pasta <code>scripts</code> para não ter duas pastas com o mesmo propósito.</p> <p>Parabéns, você implantou e interagiu com contratos inteligentes na sua rede EVM Tanssi usando Foundry! Para mais informações, consulte o Foundry Book.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/", "title": "Usando Hardhat para Implantar na Sua Rede EVM", "text": ""}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#introduction", "title": "Introdução", "text": "<p>Hardhat é um ambiente de desenvolvimento Ethereum que ajuda a gerenciar e automatizar as tarefas recorrentes inerentes à criação de contratos inteligentes e dApps. Ele funciona com qualquer rede EVM, incluindo as redes compatíveis com a Tanssi, para compilar e implantar contratos de forma transparente.</p> <p>Este guia mostra como compilar, implantar e interagir com contratos inteligentes Ethereum na rede EVM de demonstração da Tanssi. Você pode adaptar para sua própria rede Tanssi adicionando a URL RPC dela à sua carteira EVM e alternando para essa rede.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para este guia, você precisará do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. Você pode seguir este guia para configurar o MetaMask para a rede EVM de demonstração.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project", "title": "Criando um Projeto Hardhat", "text": "<p>Se ainda não tiver um projeto Hardhat, crie um seguindo os passos:</p> <ol> <li> <p>Crie um diretório para o projeto</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>Inicialize o projeto, o que criará um <code>package.json</code></p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Instale o Hardhat</p> <pre><code>npm install hardhat\n</code></pre> </li> <li> <p>Crie o projeto</p> <pre><code>npx hardhat init\n</code></pre> <p>Note</p> <p><code>npx</code> executa binários instalados localmente no projeto. Embora seja possível instalar o Hardhat globalmente, é recomendável instalá-lo localmente para controlar a versão por projeto.</p> </li> <li> <p>Um menu aparecerá permitindo criar um novo projeto ou usar um exemplo. Para este guia, escolha Create an empty hardhat.config.js</p> </li> </ol> npx hardhat init 888    888                      888 888               888 888    888                      888 888               888 888    888                      888 888               888 8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888 888    888     \"88b 888P\"  d88\" 888 888 \"88b     \"88b 888 888    888 .d888888 888    888  888 888  888 .d888888 888 888    888 888  888 888    Y88b 888 888  888 888  888 Y88b. 888    888 \"Y888888 888     \"Y88888 888  888 \"Y888888  \"Y888 👷 Welcome to Hardhat v2.22.2 👷‍  What do you want to do? …   Create a JavaScript project    Create a TypeScript project    Create a TypeScript project (with Viem)    Quit  <p>Isso criará um arquivo de configuração Hardhat (<code>hardhat.config.js</code>) no diretório do projeto.</p> <p>Quando o projeto estiver pronto, instale também o plugin Ethers para usar a biblioteca Ethers.js com a rede:</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers\n</code></pre> <p>Além disso, instale o plugin <code>hardhat-ignition-ethers</code> para implantar contratos com o Hardhat Ignition:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ignition-ethers\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#the-contract-file", "title": "O Arquivo do Contrato", "text": "<p>Com o projeto vazio criado, crie o diretório <code>contracts</code>:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts\n</code></pre> <p>O contrato de exemplo que será implantado se chama <code>Box</code> e armazena um valor recuperável depois. No diretório <code>contracts</code>, crie o arquivo <code>Box.sol</code>:</p> <pre><code>touch Box.sol\n</code></pre> <p>Abra o arquivo e adicione o contrato:</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitido quando o valor armazenado é alterado\n    event ValueChanged(uint256 newValue);\n\n    // Armazena um novo valor no contrato\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // Lê o último valor armazenado\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#hardhat-configuration-file", "title": "O Arquivo de Configuração do Hardhat", "text": "<p>Antes de implantar na sua rede Tanssi, ajuste o <code>hardhat.config.js</code> e crie um arquivo seguro para armazenar sua chave privada.</p> <p>Exemplo de configuração para usar a rede EVM de demonstração ou a sua rede Tanssi:</p> <pre><code>// 1. Importe os plugins Ethers e Hardhat Ignition necessários para interagir com o contrato\nrequire('@nomicfoundation/hardhat-ethers');\nrequire('@nomicfoundation/hardhat-ignition-ethers');\n\n// 2. Adicione sua chave privada com tokens da sua rede Tanssi\n// Isto é apenas para exemplo — **nunca armazene suas chaves privadas em um arquivo JavaScript**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\nmodule.exports = {\n  // 3. Especifique a versão do Solidity\n  solidity: '0.8.1',\n  networks: {\n    // 4. Adicione a especificação da sua rede EVM da Tanssi\n    dancelight: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Preencha o ChainID EVM da sua rede Tanssi\n      accounts: [privateKey]\n    }\n  }\n};\n</code></pre> <p>Pronto para implantar!</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#compiling-solidity", "title": "Compilando Solidity", "text": "<p>Compile o contrato com:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 8 Solidity files successfully (evm target: paris). <p>Após a compilação, o diretório <code>artifacts</code> é criado com bytecode e metadados (<code>.json</code>). Considere adicioná-lo ao <code>.gitignore</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#deploying-the-contract", "title": "Implantando o Contrato", "text": "<p>A implantação usará o Hardhat Ignition, um framework declarativo para implantações. Saiba mais na documentação do Ignition.</p> <p>Crie a estrutura para o módulo Ignition:</p> <pre><code>mkdir ignition ignition/modules &amp;&amp; touch ignition/modules/Box.js\n</code></pre> <p>Depois, escreva o módulo do Ignition seguindo estes passos:</p> <ol> <li>Importe <code>buildModule</code> do Hardhat Ignition</li> <li>Exporte um módulo usando <code>buildModule</code></li> <li>Use <code>getAccount</code> para selecionar a conta de deploy</li> <li>Defina gas price e gas limit customizados, se necessário</li> <li>Faça o deploy do contrato <code>Box</code></li> <li>Retorne um objeto com o contrato para usá-lo em testes e scripts</li> </ol> <pre><code>// 1.  Import the `buildModule` function from the Hardhat Ignition module\nconst { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');\n\n// 2. Export a module using `buildModule`\nmodule.exports = buildModule('BoxModule', (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Specify custom gas price and gas limit settings for the deployment\n  const customGasPrice = 50000000000n;\n  const customGasLimit = 1000000;\n\n  // 5. Deploy the `Box` contract using the selected deployer account and custom gas settings\n  const box = m.contract('Box', [], {\n    from: deployer,\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // 6. Return an object from the module including references to deployed contracts. This makes the deployed `Box` contract accessible for interaction in tests and scripts\n  return { box };\n});\n</code></pre> <p>Para executar o script e implantar o <code>Box.sol</code>, especifique o nome da rede conforme definido em <code>hardhat.config.js</code>. Sem rede, o Hardhat usa a rede local por padrão.</p> <pre><code>npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight\n</code></pre> <p>Confirme a rede quando solicitado. Em alguns segundos, o contrato será implantado e o endereço aparecerá no terminal. Se for outra rede Tanssi, ajuste o nome da rede para combinar com o <code>hardhat.config.js</code>.</p>  npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight ✅ Confirm deploy to network dancelight (5678)? … yes Hardhat Ignition 🚀 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed 🚀 Deployed Addresses BoxModule#Box - 0xa84caB60db6541573a091e5C622fB79e175E17be <p>Parabéns, o contrato está ativo! Guarde o endereço para interagir na próxima etapa.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/hardhat/#interacting-with-the-contract", "title": "Interagindo com o contrato", "text": "<p>Para interagir com o contrato implantado, abra o <code>console</code> do Hardhat:</p> <pre><code>npx hardhat console --network dancelight\n</code></pre> <p>Execute, linha a linha:</p> <ol> <li> <p>Crie uma instância local de <code>Box.sol</code></p> <pre><code>const Box = await ethers.getContractFactory('Box');\n</code></pre> </li> <li> <p>Conecte a instância ao contrato implantado usando o endereço</p> <pre><code>const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');\n</code></pre> </li> <li> <p>Interaja com o contrato; por exemplo, chame <code>store</code> e salve um valor simples</p> <pre><code>await box.store(5);\n</code></pre> </li> </ol> <p>Sua conta EVM assinará a transação e a transmitirá. A saída se parecerá com:</p> npx hardhat console --network dancelight Welcome to Node.js v20.9.0. Type \".help\" for more information.  const Box = await ethers.getContractFactory('Box'); undefined  const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be'); undefined  await box.store(5); ContractTransactionResponse {     provider: HardhatEthersProvider { ... },     blockNumber: null,     blockHash: null,     index: undefined,     hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',     type: 2,     to: '0xa84caB60db6541573a091e5C622fB79e175E17be',     from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',     nonce: 87,     gasLimit: 45881n,     gasPrice: 1107421875n,     maxPriorityFeePerGas: 1n,     maxFeePerGas: 1107421875n,     data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',     value: 0n,     chainId: 5678n,     signature: Signature { r: \"0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc\", s: \"0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d\", yParity: 0, networkV: null },     accessList: [],     blobVersionedHashes: null     }  await box.retrieve(); 5n <p>Note seu endereço em <code>from</code>, o endereço do contrato e os dados enviados. Para recuperar o valor:</p> <pre><code>await box.retrieve();\n</code></pre> <p>Você deverá ver <code>5</code> ou o valor armazenado.</p> <p>Note</p> <p>Se executar o retrieve imediatamente após armazenar, pode ver o valor antigo. Tente novamente após alguns instantes.</p> <p>Parabéns, você implantou e interagiu com um contrato usando o Hardhat!</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/", "title": "Usando Remix para Implantar na sua Rede EVM da Tanssi", "text": ""}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores de dApps em redes EVM baseadas na Tanssi podem usar o Remix, um dos ambientes de desenvolvimento Ethereum mais populares, para criar, compilar e implantar contratos inteligentes. O Remix funciona com qualquer rede EVM graças à compatibilidade das redes EVM da Tanssi.</p> <p>Este guia mostra como criar e implantar um contrato Solidity na rede EVM de demonstração da Tanssi usando a IDE Remix. Para sua própria rede Tanssi, basta adicionar a URL RPC dela à sua carteira EVM e alternar para essa rede.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Você precisará do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. Siga este guia para configurar o MetaMask para a rede EVM de demonstração.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/#getting-started-with-remix", "title": "Começando com o Remix", "text": "<p>Acesse o Remix e vá para a aba File Explorer.</p> <p></p> <p>Crie um novo arquivo para o contrato Solidity:</p> <ol> <li>Clique em Create New File no File Explorer</li> <li>Nomeie, por exemplo, <code>MyToken.sol</code></li> </ol> <p></p> <p>Cole o contrato abaixo no editor:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/audit/2023-03/contracts/token/ERC20/ERC20.sol';\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator.\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p></p> <p>É um ERC-20 simples baseado no Template atual do OpenZeppelin. Cria <code>MyToken</code> com símbolo <code>MYTOK</code> e cunha todo o fornecimento inicial para o criador.</p> <p>Para compilar:</p> <ol> <li>Abra a aba Solidity compiler</li> <li>Clique em Compile MyToken.sol</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/#deploying-a-contract-to-your-network-using-remix", "title": "Implantando um Contrato com Remix", "text": "<p>Vá para Deployment, mude ENVIRONMENT de JavaScript VM para Injected Web3 para usar o provedor do MetaMask apontando para sua rede Tanssi.</p> <p></p> <p>Permita que o Remix se conecte ao MetaMask:</p> <ol> <li>Selecione a(s) conta(s)</li> <li>Clique em Next</li> <li>Clique em Connect</li> </ol> <p></p> <p>Para implantar o token:</p> <ol> <li>Ao lado de Deploy, informe o fornecimento inicial <code>8000000000000000000000000</code> (8 milhões com 18 decimais) e clique em Deploy</li> <li>Confirme a transação no MetaMask</li> </ol> <p></p> <p>Após a confirmação, o contrato aparece em Deployed Contracts. Copie o endereço se precisar.</p> <p></p> <p>Para interagir:</p> <ol> <li>Expanda o contrato em Deployed Contracts</li> <li>Em balanceOf, cole seu endereço e clique balanceOf para ver o saldo</li> <li>Veja Decimals, Name, Symbol e Initial Supply</li> <li>Copie o endereço do contrato (botão ao lado do nome)</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/remix/#interacting-with-an-erc-20-on-your-network-from-metamask", "title": "Interagindo com o ERC-20 no MetaMask", "text": "<p>Abra o MetaMask na conta que implantou o contrato e adicione o token:</p> <ol> <li>Aba Tokens → Import tokens</li> </ol> <p></p> <ol> <li>Cole o endereço do contrato em Token contract address (símbolo e decimais preenchem automaticamente) → Next</li> </ol> <p></p> <p>Confirme em Import; você verá 8 milhões de MyTokens.</p> <p></p> <p>Envie 500 MyTokens para outra conta (Send), escolha o destinatário e confirme.</p> <p></p> <p>Após a conclusão, o saldo é reduzido.</p> <p></p> <p>Você pode verificar a transação no explorador da sua rede Tanssi.</p> <p></p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/", "title": "Usando thirdweb na Tanssi", "text": ""}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#introduction", "title": "Introdução", "text": "<p>thirdweb é um framework completo de desenvolvimento Web3 que fornece tudo o que você precisa para criar smart contracts, desenvolver dApps e muito mais.</p> <p>Com o thirdweb, você acessa ferramentas para todas as fases do ciclo de desenvolvimento de dApps. É possível criar seus próprios contratos personalizados ou usar qualquer um dos contratos predefinidos do thirdweb para começar rapidamente. Em seguida, use a CLI do thirdweb para implantar seus smart contracts. Depois, interaja com eles criando uma aplicação Web3 na linguagem de sua escolha, incluindo, entre outras, React e TypeScript.</p> <p>Este guia mostra alguns recursos do thirdweb que você pode usar para desenvolver smart contracts e dApps em redes EVM da Tanssi. Para ver todos os recursos que o thirdweb oferece, consulte o site de documentação do thirdweb.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#create-contract", "title": "Criar Contrato", "text": "<p>Para criar um novo smart contract usando a CLI do thirdweb, siga estes passos:</p> <ol> <li> <p>No terminal, execute:</p> <pre><code>npx thirdweb create contract\n</code></pre> </li> <li> <p>Informe suas preferências nos prompts da linha de comando:</p> <ol> <li>Dê um nome ao projeto</li> <li>Escolha o framework: Hardhat ou Foundry</li> <li>Nomeie seu smart contract</li> <li>Escolha o tipo de contrato base: Empty, ERC20, ERC721 ou ERC1155</li> <li>Adicione as extensões desejadas</li> </ol> </li> <li>Após criar, navegue até o diretório do projeto e abra-o no editor de código de sua preferência</li> <li> <p>Ao abrir a pasta <code>contracts</code>, você encontrará seu smart contract escrito em Solidity</p> <p>O código a seguir é de um contrato <code>ERC721Base</code> sem extensões especificadas. Ele implementa toda a lógica contida no contrato <code>ERC721Base.sol</code>, que por sua vez implementa o padrão <code>ERC721A</code>.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@thirdweb-dev/contracts/base/ERC721Base.sol';\n\ncontract Contract is ERC721Base {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps\n    ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}\n}\n</code></pre> <p>Este contrato herda a funcionalidade de <code>ERC721Base</code> pelas etapas:</p> <ul> <li>Importar o contrato <code>ERC721Base</code></li> <li>Declarar que seu contrato herda <code>ERC721Base</code></li> <li>Implementar os métodos necessários, como o builder</li> </ul> </li> <li> <p>Depois de ajustar seu contrato com a lógica desejada, você pode implantá-lo em uma rede EVM da Tanssi usando o Deploy. Isso é coberto na próxima seção!</p> </li> </ol> <p>Como alternativa, é possível implantar um contrato predefinido para NFTs, tokens ou marketplace diretamente na página Explore do thirdweb:</p> <ol> <li> <p>Acesse a página Explore do thirdweb</p> <p></p> </li> <li> <p>Escolha o tipo de contrato que deseja implantar entre as opções disponíveis: NFTs, tokens, marketplace e mais</p> </li> <li>Siga os prompts na tela para configurar e implantar seu contrato</li> </ol> <p>Para mais informações sobre os diferentes contratos disponíveis no Explore, consulte a documentação do thirdweb sobre contratos predefinidos.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#deploy-contract", "title": "Implantar Contrato", "text": "<p>O Deploy é a ferramenta do thirdweb que permite implantar um smart contract em qualquer rede compatível com EVM sem configurar URLs RPC, expor chaves privadas, escrever scripts ou outras etapas adicionais como verificação do contrato.</p> <ol> <li> <p>Para implantar seu smart contract usando o Deploy, navegue até o diretório <code>contracts</code> do projeto e execute:</p> <pre><code>npx thirdweb deploy\n</code></pre> <p>Executar este comando aciona as seguintes ações:</p> <ul> <li>Compila todos os contratos no diretório atual</li> <li>Oferece a opção de escolher quais contratos você deseja implantar</li> <li>Envia o código-fonte (ABI) do seu contrato para o IPFS</li> </ul> </li> <li> <p>Ao concluir, abrirá um dashboard para preencher os parâmetros:</p> <ul> <li><code>_name</code> - nome do contrato</li> <li><code>_symbol</code> - símbolo ou “ticker”</li> <li><code>_royaltyRecipient</code> - endereço da carteira que receberá royalties de vendas secundárias</li> <li><code>_royaltyBps</code> - basis points (bps) que serão pagos ao beneficiário a cada venda secundária, ex.: 500 = 5%</li> </ul> </li> <li> <p>Selecione a rede desejada, por exemplo, a rede EVM de demonstração da Tanssi ou sua própria rede</p> </li> <li> <p>Gerencie configurações adicionais no dashboard do contrato conforme necessário, como fazer upload de NFTs, configurar permissões e mais</p> <p></p> </li> </ol> <p>Para informações adicionais sobre o Deploy, consulte a documentação do thirdweb.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#create-application", "title": "Criar Aplicação", "text": "<p>O thirdweb oferece SDKs para várias linguagens, como React, React Native, TypeScript e Unity. Você começará criando uma aplicação e depois poderá escolher qual SDK usar:</p> <ol> <li> <p>No terminal, execute:</p> <pre><code>npx thirdweb create --app\n</code></pre> </li> <li> <p>Informe suas preferências nos prompts:</p> <ol> <li>Dê um nome ao projeto</li> <li>Escolha o framework: Next.js, Vite ou React Native. Para este exemplo, selecione Vite</li> </ol> </li> <li> <p>Use o SDK de React ou TypeScript para interagir com as funções da sua aplicação. Isso será abordado na próxima seção sobre interação com contratos</p> </li> </ol>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#specify-client-id", "title": "Especificar o Client ID", "text": "<p>Antes de lançar seu dApp (localmente ou em produção), você deve ter um Client ID do thirdweb associado ao projeto. O Client ID do thirdweb equivale a uma chave de API. Você pode criar uma chave de API gratuita fazendo login na sua conta do thirdweb, indo em Settings e clicando em API Keys.</p> <p>Clique em Create API Key e siga estes passos:</p> <ol> <li>Dê um nome para sua chave de API</li> <li>Informe os domínios permitidos para receber requisições. É recomendado permitir apenas os domínios necessários; para desenvolvimento, pode selecionar Allow all domains</li> <li>Clique em Next e confirme o prompt na página seguinte</li> </ol> <p></p> <p>Note</p> <p>O nome da variável do Client ID varia conforme o framework escolhido; por exemplo, no Vite será <code>VITE_TEMPLATE_CLIENT_ID</code>, no Next.js será <code>NEXT_PUBLIC_TEMPLATE_CLIENT_ID</code> e no React Native será <code>EXPO_PUBLIC_THIRDWEB_CLIENT_ID</code>.</p> <p>Por fim, informe seu Client ID (API Key) no arquivo <code>.env</code>. O <code>.env</code> deve estar no diretório raiz do projeto (por exemplo, não na pasta <code>src</code>).</p> <p>Se você gerou o app thirdweb com Vite, terá um arquivo <code>client.ts</code> parecido com o abaixo. Se você criou o <code>.env</code> com a chave de API do thirdweb definida em <code>VITE_TEMPLATE_CLIENT_ID</code>, pode deixar o <code>client.ts</code> como está e seguir para a próxima seção.</p> client.ts<pre><code>import { createThirdwebClient } from 'thirdweb';\n\n// Substitua pela sua string de client ID.\n// Consulte https://portal.thirdweb.com/typescript/v5/client para obter um client ID\nconst clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;\n\nexport const client = createThirdwebClient({\n  clientId: clientId,\n});\n</code></pre> <p>Note</p> <p>Se você não criar um Client ID e não o especificar corretamente no <code>.env</code>, verá uma tela em branco ao tentar gerar o app. Não aparece mensagem de erro sem abrir o console, então certifique-se de configurar o Client ID corretamente.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#run-locally", "title": "Executar Localmente", "text": "<p>Para executar seu dApp localmente para testes e depuração, use:</p> <pre><code>yarn dev\n</code></pre> <p>O app será compilado e mostrará o host e a porta para acessar no navegador.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#configure-chain", "title": "Configurar Rede", "text": "<p>O thirdweb oferece poucas redes em <code>@thirdweb/chains</code> e não inclui as redes Tanssi, então você precisa especificar os detalhes da rede, como Chain ID e URL RPC. Crie uma rede personalizada com <code>defineChain</code>:</p> chains.ts<pre><code>    import { defineChain } from 'thirdweb';\n    const tanssi = defineChain({\n      id: 5678,\n      rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n    });\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#thirdweb-sdk", "title": "thirdweb SDK", "text": "<p>As seções a seguir dão uma visão geral de métodos fundamentais do SDK do thirdweb e como interagir com eles. Cada trecho de código mostra os imports relevantes e demonstra o uso em um cenário típico. Este guia serve como referência rápida para os métodos mais comuns do thirdweb usados por desenvolvedores de dApps. Para detalhes de todos os recursos do thirdweb, visite o site de documentação.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#accounts-and-wallets", "title": "Contas e Carteiras", "text": "<p>O thirdweb diferencia contas e carteiras no SDK. Para o SDK, uma conta sempre tem um endereço de blockchain e pode assinar mensagens, transações e dados tipados, mas não pode ser “conectada” ou “desconectada”. Já uma carteira contém uma ou mais contas, pode ser conectada ou desconectada e delega a assinatura às contas.</p> <p>O snippet abaixo mostra como inicializar e conectar uma carteira MetaMask com o SDK do thirdweb, depois assinar e enviar uma transação recuperando o hash. Esse processo se aplica a qualquer um dos mais de 300 conectores de carteira suportados pelo SDK.</p> initialize.ts <pre><code>import { sendTransaction } from 'thirdweb';\n// MetaMask wallet used for example, the pattern is the same for all wallets\nimport { createWallet } from 'thirdweb/wallets';\n\n// Initialize the wallet. thirdweb supports 300+ wallet connectors\nconst wallet = createWallet('io.metamask');\n\n// Connect the wallet. This returns a promise that resolves to the connected account\nconst account = await wallet.connect({\n  // Pass the client you created with `createThirdwebClient()`\n  client,\n});\n\n// Sign and send a transaction with the account. Returns the transaction hash\nconst { transactionHash } = await sendTransaction({\n  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send\n  transaction,\n  // Pass the account to sign the transaction with\n  account,\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#get-contract", "title": "Obter contrato", "text": "<p>Para conectar ao seu contrato, use o método <code>getContract</code> do SDK. Por exemplo, você pode buscar dados de um contrato incrementer na rede EVM de demonstração da Tanssi.</p> <pre><code>import { getContract } from 'thirdweb';\nimport { client } from './client';\n\nconst myContract = getContract({\n  client,\n  chain: tanssi,\n  address: 0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D, // Endereço do contrato Incrementer na demo EVM\n  abi: '[{\\\"inputs\\\":[],\\\"name\\\":\\\"increment\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"number\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"timestamp\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"}]';\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#calling-contract-functions", "title": "Chamar funções do contrato", "text": "<p>Para chamar um contrato na versão mais recente do SDK, use <code>prepareContractCall</code>.</p> <pre><code>import { prepareContractCall, toWei } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Assine a função que deseja chamar\n  method: 'function mintTo(address to, uint256 amount)',\n  // Passe os parâmetros para o método.\n  // Os tipos são inferidos automaticamente pela assinatura\n  params: ['0x123...', toWei('100')],\n});\n</code></pre> <p>Voltando ao contrato incrementer, preparar uma chamada para incrementar o contrato fica assim:</p> <pre><code>import { prepareContractCall } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Assine a função que deseja chamar\n  method: 'function increment()',\n  // Increment não recebe parâmetros, então deixe um array vazio\n  params: [],\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#preparing-raw-transactions", "title": "Preparar transações brutas", "text": "<p>Você também pode preparar uma transação diretamente com dados codificados. Para isso, use o método <code>prepareTransaction</code> do thirdweb e especifique diretamente <code>to</code>, <code>value</code>, <code>chain</code> e <code>client</code>.</p> <pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  // Conta que receberá\n  to: '0x456...',\n  // Valor em ether a enviar na transação\n  value: toWei('1'),\n  // Rede onde a transação será executada. Assume que você já configurou\n  // a rede EVM demo da Tanssi como chain personalizada, conforme mostrado na seção de configuração\n  chain: tanssi,\n  // Seu client thirdweb\n  client,\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#read-contract-state", "title": "Ler Estado do Contrato", "text": "<p>Use a função <code>readContract</code> para chamar funções de leitura do contrato informando a assinatura do método Solidity e eventuais parâmetros.</p> <pre><code>import { readContract } from 'thirdweb';\n\nconst balance = await readContract({\n  contract: contract,\n  method: 'function balanceOf(address) view returns (uint256)',\n  params: ['0x123...'],\n});\n</code></pre> <p>Para uma função sem parâmetros, como <code>number</code>, que retorna o número atual armazenado no contrato incrementer, basta informar o nome da função:</p> <pre><code>import { readContract } from 'thirdweb';\n\nconst number = await readContract({\n  contract: contract,\n  method: 'number',\n  params: [],\n});\n</code></pre> <p>Você sabia? Com a CLI do thirdweb, você gera facilmente funções para todas as chamadas possíveis de um contrato. Para isso, execute:</p> <pre><code>npx thirdweb generate INSERT_CHAIN_ID/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>Chain ID e endereço do contrato são obrigatórios. Por exemplo, para gerar funções do contrato incrementer na demo EVM da Tanssi, use:</p> <pre><code>npx thirdweb generate 5678/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D\n</code></pre> <p>O arquivo gerado com todos os métodos correspondentes ficará em <code>thirdweb/CHAIN_ID/CONTRACT_ADDRESS</code>. No exemplo acima, o arquivo de saída fica em <code>thirdweb/5678/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D.ts</code>. Para mais informações, veja a documentação do thirdweb sobre a CLI.</p>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#sending-a-transaction", "title": "Enviar uma Transação", "text": "<p>Toda transação enviada com o SDK precisa ser preparada primeiro. Essa preparação é síncrona e leve, sem requisições de rede. Além disso, fornece definições type-safe para as chamadas de contrato.</p> <p>Você pode preparar uma transação assim:</p> Prepare uma transação<pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  to: '0x1234567890123456789012345678901234567890',\n  chain: tanssi,\n  client: thirdwebClient,\n  value: toWei('1.0'),\n  gasPrice: 150n,\n});\n</code></pre> <p>Depois de preparada, envie a transação assim:</p> Enviar uma transação<pre><code>import { sendTransaction } from 'thirdweb';\n\nconst { transactionHash } = await sendTransaction({\n  account,\n  transaction,\n});\n</code></pre> <p>Opcionalmente, use <code>sendAndConfirmTransaction</code> para aguardar a mineração. Isso é útil se você quiser bloquear o usuário até a confirmação.</p> Enviar e confirmar uma transação<pre><code>import { sendAndConfirmTransaction } from 'thirdweb';\nimport { createWallet } from 'thirdweb/wallets';\n\nconst wallet = createWallet('io.metamask');\nconst account = await wallet.connect({ client });\n\nconst receipt = await sendAndConfirmTransaction({\n  transaction,\n  account,\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#transaction-utilites", "title": "Utilidades de Transação", "text": "<p>O thirdweb fornece diversos utilitários para preparar e enviar transações.</p> <p>Você pode estimar o gas usado por uma transação:</p> Estimando gas<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasEstimate = await estimateGas({ transaction });\nconsole.log('gas estimado', gasEstimate);\n</code></pre> <p>Também é possível estimar o custo em Ether e Wei:</p> Estimando custo de gas<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasCost = await estimateGasCost({ transaction });\nconsole.log('custo em ether', gasCost.ether);\n</code></pre> <p>O thirdweb também oferece uma forma prática de simular transações e verificar a integridade antes de submetê-las. Você pode simular uma transação assim:</p> Simular uma transação<pre><code>import { simulateTransaction } from 'thirdweb';\n\nconst result = await simulateTransaction({ transaction });\nconsole.log('resultado da simulação', result);\n</code></pre> <p>Você pode codificar dados da transação para usar depois:</p> Codificar dados da transação<pre><code>import { encode } from 'thirdweb';\n\nconst data = await encode(transaction);\nconsole.log('dados codificados', data);\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#connect-button", "title": "ConnectButton", "text": "<p>Provavelmente a primeira interação do usuário com seu dApp será conectar a carteira. O thirdweb fornece uma maneira fácil e altamente personalizável de habilitar isso. O <code>ConnectButton</code> pode ser adaptado às carteiras desejadas. O <code>ConnectButton</code> aceita um parâmetro opcional <code>wallets</code> com um array de carteiras. Você pode adicionar ou remover carteiras do array para alterar as opções disponíveis aos usuários. O thirdweb também oferece um Playground do ConnectButton para personalizar e ver as alterações em tempo real, dada a alta flexibilidade do botão.</p> ConnectButton<pre><code>import { ConnectButton } from 'thirdweb/react';\nimport { createWallet, inAppWallet } from 'thirdweb/wallets';\n\nconst wallets = [\n  inAppWallet(),\n  createWallet('io.metamask'),\n  createWallet('com.coinbase.wallet'),\n  createWallet('me.rainbow'),\n];\n\nfunction Example() {\n  return (\n    &lt;div&gt;\n      &lt;ConnectButton client={client} wallets={wallets} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/dev-env/thirdweb/#deploy-application", "title": "Implantar a Aplicação", "text": "<p>Relembrando, você pode compilar o projeto de exemplo localmente executando:</p> <pre><code>yarn dev\n</code></pre> <p>Para hospedar sua aplicação web estática em armazenamento descentralizado, execute:</p> <pre><code>npx thirdweb deploy --app\n</code></pre> <p>Executar esse comando cria a build de produção e armazena usando o Storage, a solução descentralizada de arquivos do thirdweb. Ele envia a aplicação construída para o IPFS, uma rede de armazenamento descentralizada, e gera uma URL única que fornece um local persistente para hospedar sua aplicação na web.</p> <p>Se tiver dúvidas ou encontrar problemas durante o processo, contate o suporte do thirdweb em support.thirdweb.com.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/libraries/", "title": "Bibliotecas", "text": "<p>As bibliotecas são ferramentas essenciais para interagir com redes blockchain. Elas fornecem funções e abstrações pré-construídas que simplificam tarefas como leitura e escrita de dados de cadeia. Essas bibliotecas eliminam a necessidade de lidar com solicitações brutas da blockchain, tornando mais fácil para os desenvolvedores construírem e implantarem aplicativos descentralizados, garantindo a compatibilidade com o Ethereum e outras redes compatíveis com EVM.</p> <p>Algumas das principais capacidades de trabalhar com bibliotecas incluem:</p> <ul> <li>Gerenciamento de transações - criar, assinar e transmitir transações</li> <li>Interações com contratos inteligentes - simplificar a chamada de funções de contrato, decodificar respostas e lidar com eventos de contrato</li> <li>Integração de carteira - facilitar integrações de carteira seguras para transacionar com a rede</li> <li>Análise de dados de blockchain - decodificar e interpretar estruturas de dados complexas retornadas por contratos inteligentes</li> <li>Monitoramento de eventos - ouvir eventos emitidos por contratos e acionar ações específicas do aplicativo</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/libraries/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/", "title": "Biblioteca JavaScript Ethers.js", "text": ""}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#introduction", "title": "Introdução", "text": "<p>A biblioteca Ethers.js fornece ferramentas para interagir com nós Ethereum usando JavaScript, semelhante à Web3.js. As redes EVM Powered by Tanssi oferecem uma API compatível com Ethereum/JSON-RPC, então você pode usar Ethers.js para interagir com uma rede EVM da Tanssi como faria no Ethereum. Para mais detalhes, consulte a documentação oficial.</p> <p>Neste guia você aprenderá a usar Ethers.js na sua rede EVM da Tanssi. Para demonstrar, enviaremos uma transação e implantaremos um contrato em uma appchain EVM de demonstração rodando no Dancelight. Para sua própria appchain Tanssi, basta trocar o endpoint.</p> <p>Se preferir vídeo, veja os tutoriais no topo desta página sobre Enviar transações com Ethers.js e Implantar contratos com Ethers.js.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia você precisará:</p> <ul> <li>De uma conta com fundos na rede EVM da Tanssi que estiver usando para testes</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#install-ethersjs", "title": "Instalando Ethers.js", "text": "<p>Instale a biblioteca Ethers.js e o compilador Solidity:</p> npmyarn <pre><code>npm install ethers solc@0.8.0\n</code></pre> <pre><code>yarn add ethers solc@0.8.0\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#setting-up-the-ethers-provider", "title": "Configurando o Provedor Ethers", "text": "<p>Os scripts a seguir usam um provedor Ethers para falar com a rede.</p> <ol> <li>Importe <code>ethers</code></li> <li>Defina <code>providerRPC</code> com <code>name</code>, <code>rpc</code> e <code>chainId</code> da rede</li> <li>Crie o <code>provider</code> com <code>ethers.JsonRpcProvider</code></li> </ol> <pre><code>// 1. Importe ethers\nimport { ethers } from \"ethers\";\n\n// 2. Defina as configurações da rede\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insira aqui sua URL RPC\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n    chainId: 5678, // 0x162E em hexadecimal,\n  },\n};\n// 3. Crie o provider do ethers\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <p>Guarde este trecho; ele é reutilizado nos scripts abaixo.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#send-a-transaction", "title": "Enviar uma Transação", "text": "<p>Criaremos dois scripts: um para consultar saldos e outro para enviar a transação.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#check-balances-script", "title": "Script de Saldos", "text": "<p>Crie o arquivo:</p> <pre><code>touch balances.js\n</code></pre> <p>Depois monte o script:</p> <ol> <li>Inclua o provedor</li> <li>Defina <code>addressFrom</code> e <code>addressTo</code></li> <li>Crie a função <code>balances</code></li> <li>Use <code>provider.getBalance</code> e <code>ethers.formatEther</code> para exibir os saldos</li> <li>Chame <code>balances()</code></li> </ol> <pre><code>// 1. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 2. Crie as variáveis de endereço\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Crie a função de saldos\nconst balances = async () =&gt; {\n  // 4. Busque os saldos\n  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 5. Chamar a função de saldos\nbalances();\n</code></pre> Ver o script completo <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define addresses\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balances\n  const balanceFrom = ethers.formatEther(\n    await provider.getBalance(addressFrom)\n  );\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call the balances function\nbalances();\n</code></pre> <p>Execute:</p> <pre><code>node balances.js\n</code></pre> <p>Saldos serão exibidos em TANGO.</p> node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 20.0 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 1.0 TANGO"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#send-transaction-script", "title": "Script de Envio de Transação", "text": "<p>Crie o arquivo:</p> <pre><code>touch transaction.js\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> e <code>addressTo</code> (não armazene chaves reais em arquivos JS)</li> <li>Crie a wallet com <code>privateKey</code> e <code>provider</code></li> <li>Crie a função <code>send</code></li> <li>Monte o objeto de transação (<code>to</code>, <code>value</code> com <code>ethers.parseEther</code>)</li> <li>Envie com <code>wallet.sendTransaction</code> e aguarde o recibo</li> <li>Chame <code>send()</code></li> </ol> <pre><code>// 1. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 2. Crie as variáveis da conta\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 4. Crie a função de envio\nconst send = async () =&gt; {\n  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);\n\n  // 5. Crie o objeto da tx\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // 6. Assine e envie a tx — aguarde o recibo\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// 7. Chame a função de envio\nsend();\n</code></pre> Ver o script completo <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\nconst wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${wallet.address} to ${addressTo}`\n  );\n\n  // Create transaction\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // Send transaction and get hash\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the send function\nsend();\n</code></pre> <p>Rode com:</p> <pre><code>node transaction.js\n</code></pre> <p>O hash será exibido. Use <code>balances.js</code> antes/depois para confirmar a mudança de saldo.</p> node transaction.js Attempting to send transaction from 0x44236223aB4291b93EEd10E4B511B37a398DEE55 to 0x8841701 Dba3639B254D9CEe712E49D188A1e941e      Transaction successful with hash: 0x29d87c00704b949cb4cc04fdc6c98d53b3c0ec4fb3ffe0c52864a73 b586f563c    node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 18.999958 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 2.0 TANGO"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-a-contract", "title": "Implantar um Contrato", "text": "<p>O contrato que você irá compilar e implantar nas próximas seções é um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o código Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A função <code>constructor</code>, executada quando o contrato é implantado, define o valor inicial da variável <code>number</code> armazenada on-chain (padrão é 0). A função <code>increment</code> soma o <code>_value</code> informado ao número atual, mas exige uma transação, pois modifica o dado armazenado. Por fim, a função <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato é apenas um exemplo simples para fins ilustrativos.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#compile-contract-script", "title": "Script de Compilação", "text": "<p>Nesta seção, você criará um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para começar, crie o arquivo <code>compile.js</code> executando:</p> <pre><code>touch compile.js\n</code></pre> <p>Em seguida, escreva o script e conclua estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conteúdo de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato usando <code>solc.compile</code> com o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implantação</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-contract-script", "title": "Script de Deploy", "text": "<p>Compile <code>Incrementer.sol</code> e depois crie <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe o contrato de <code>compile.js</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> (não salve chaves reais em JS)</li> <li>Guarde <code>bytecode</code> e <code>abi</code></li> <li>Crie a wallet</li> <li>Crie a <code>ContractFactory</code></li> <li>Crie a função <code>deploy</code></li> <li>Use <code>incrementer.deploy(5)</code> e aguarde o recibo</li> <li>Chame <code>deploy()</code></li> </ol> <pre><code>// 1. Importe o arquivo do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 3. Crie as variáveis da conta\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Salve o bytecode e o ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 6. Crie a instância do contrato com o assinante\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Crie a função de deploy\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Envie a tx (valor inicial definido como 5) e aguarde o recibo\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Chame a função de deploy\ndeploy();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Load contract info\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// Call the deploy function\ndeploy();\n</code></pre> <p>Execute:</p> <pre><code>node deploy.js\n</code></pre> <p>O endereço do contrato será exibido.</p> node deploy.js Attempting to deploy from account: 0x44236223aB4291b93EEd10E4B511B37a398DEE55      Contract deployed at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#read-contract-data", "title": "Ler Dados do Contrato (Calls)", "text": "<p>Calls não alteram estado; nenhuma transação é enviada. Crie <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe o <code>contractFile</code> de <code>compile.js</code></li> <li>Inclua o provedor</li> <li>Defina <code>contractAddress</code></li> <li>Crie a instância com <code>ethers.Contract</code></li> <li>Crie a função <code>get</code></li> <li>Chame <code>incrementer.number()</code> e exiba o valor</li> <li>Chame <code>get()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 3. Variável do endereço do contrato\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Crie a instância do contrato\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// 5. Crie a função get\nconst get = async () =&gt; {\n  console.log(`Fazendo uma chamada para o contrato no endereço: ${contractAddress}`);\n\n  // 6. Chame o contrato \n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Chame a função get\nget();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>Rode com:</p> <pre><code>node get.js\n</code></pre> node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 5"}, {"location": "builders/toolkit/ethereum-api/libraries/ethersjs/#interact-with-contract", "title": "Interagir com o Contrato (Send)", "text": "<p>Sends alteram estado e exigem transação. Crie <code>increment.js</code> e <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p><code>increment.js</code>:</p> <ol> <li>Importe <code>contractFile</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code>, <code>contractAddress</code>, <code>_value</code> (não salve chaves reais em JS)</li> <li>Crie a wallet</li> <li>Crie a instância do contrato com signer</li> <li>Crie a função <code>increment</code></li> <li>Chame <code>incrementer.increment(_value)</code> e aguarde recibo</li> <li>Chame <code>increment()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 3. Crie as variáveis\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Crie a instância do contrato com o assinante\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Crie a função de incremento\nconst increment = async () =&gt; {\n  console.log(\n    `Chamando a função de incremento por ${_value} no contrato no endereço: ${contractAddress}`\n  );\n\n  // 7. Assine e envie a tx e aguarde o recibo\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Chame a função de incremento\nincrement();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the increment function\nincrement();\n</code></pre> node increment.js Calling the increment by 3 function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2      Tx successful with hash: 0x8aa7ccb4613ac92713bcc6ff064f1b0c978e24b3f6acb6d6bfa730a10af522bb    node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 8    <p><code>reset.js</code>:</p> <ol> <li>Importe <code>contractFile</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> e <code>contractAddress</code></li> <li>Crie a wallet</li> <li>Crie a instância do contrato com signer</li> <li>Crie a função <code>reset</code></li> <li>Chame <code>incrementer.reset()</code> e aguarde recibo</li> <li>Chame <code>reset()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a lógica do provider do Ethers:\n// {...}\n\n// 3. Crie as variáveis\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Crie a instância do contrato com o assinante\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Crie a função de reset\nconst reset = async () =&gt; {\n  console.log(`Chamando a função de reset no contrato no endereço: ${contractAddress}`);\n\n  // 7. Assine e envie a tx e aguarde o recibo\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Chame a função de reset\nreset();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>Rode:</p> <pre><code>node increment.js\nnode reset.js\n</code></pre> <p>Use <code>get.js</code> junto para confirmar a mudança de valor.</p> node increment.js Calling the reset function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2      Tx successful with hash: 0xb689da50a43e98b5a83ff64757afbf100be12e2db6ff4d0504168f262cc08fb0    node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 0       {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/", "title": "Biblioteca viem TypeScript Ethereum", "text": ""}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#introduction", "title": "Introdução", "text": "<p>viem é uma biblioteca TypeScript modular que fornece abstrações sobre a API JSON-RPC, facilitando a interação com nós Ethereum. Como as redes EVM da Tanssi expõem uma API compatível com Ethereum/JSON-RPC, você pode usar viem para interagir com qualquer rede EVM Tanssi. Veja a documentação do viem para mais detalhes.</p> <p>Neste guia, você verá como usar viem para enviar uma transação e implantar um contrato na rede EVM de demonstração. O mesmo fluxo se aplica a qualquer rede EVM da Tanssi.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos, você precisará de:</p> <ul> <li>Uma conta com fundos na rede EVM Tanssi que estiver usando</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#installing-viem", "title": "Instalando viem", "text": "<p>Crie um projeto TypeScript básico e instale dependências:</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>Instale viem e o compilador Solidity:</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.0\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.0\n</code></pre> <p>Gere o <code>tsconfig</code>:</p> <pre><code>npx tsc --init\n</code></pre> <p>Note</p> <p>Tutorial criado usando Node.js v18.18.0.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#setting-up-a-viem-provider", "title": "Configurar um Cliente viem (Provedor)", "text": "<p>Você pode criar: - um cliente de leitura com <code>createPublicClient</code>, para saldos/dados; ou - um cliente de escrita com <code>createWalletClient</code>, para enviar transações.</p> <p>Primeiro defina a cadeia com <code>defineChain</code>, informando todos os campos (incluindo <code>public</code> e <code>default</code> RPC).</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#for-reading-chain-data", "title": "Para Ler Dados da Cadeia", "text": "<p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code> e <code>defineChain</code> de <code>viem</code>.</li> <li>Defina os detalhes da cadeia (inclua URLs <code>public</code> e <code>default</code>).</li> <li>Crie o <code>client</code> com <code>createPublicClient</code>, passando rede e RPC HTTP.</li> </ol> <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#for-writing-chain-data", "title": "Para Gravar Dados da Cadeia", "text": "<p>Passos:</p> <ol> <li>Importe <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code> de <code>viem</code> e <code>privateKeyToAccount</code> de <code>viem/accounts</code>.</li> <li>Defina os detalhes da cadeia (inclua URLs <code>public</code> e <code>default</code>).</li> <li>Crie a conta com <code>privateKeyToAccount</code>.</li> <li>Crie o <code>client</code> com <code>createWalletClient</code>, passando conta, rede e RPC HTTP.</li> </ol> <p>Remember</p> <p>Demonstração apenas. Nunca salve chave privada em arquivo TypeScript.</p> <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport { createWalletClient, http, defineChain } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create your account using the privateKeyToAccount function\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\n\n//4. Create a wallet client for writing chain data\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Note</p> <p>Para carteiras de navegador, veja este exemplo (onde <code>demo</code> é a rede definida em <code>defineChain</code>): <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: demo,\n  transport: custom(window.ethereum),\n});\n</code></pre></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#send-transaction", "title": "Enviar uma Transação", "text": "<p>Criaremos dois scripts: um para saldos e outro para enviar a transação.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#check-balances-script", "title": "Script de Saldos", "text": "<p>Crie o arquivo:</p> <pre><code>touch balances.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code>, <code>formatEther</code>, <code>defineChain</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente público.</li> <li>Defina <code>addressFrom</code> e <code>addressTo</code>.</li> <li>Crie a função <code>balances</code> usando <code>publicClient.getBalance</code>.</li> <li>Formate com <code>formatEther</code> e exiba.</li> <li>Chame <code>balances()</code>.</li> </ol> Ver balances.ts <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, formatEther, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'UNIT',\n    symbol: 'UNIT',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 5. Create balances function\nconst balances = async () =&gt; {\n  // 6. Fetch balances\n  const balanceFrom = formatEther(\n    await publicClient.getBalance({ address: addressFrom })\n  );\n  const balanceTo = formatEther(\n    await publicClient.getBalance({ address: addressTo })\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 7. Call the balances function\nbalances();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>Saldos em TANGO serão exibidos.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#send-transaction-script", "title": "Script de Envio", "text": "<p>Crie o arquivo:</p> <pre><code>touch transaction.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>parseEther</code>, <code>defineChain</code> e <code>privateKeyToAccount</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) com sua chave (não salve chaves reais em TS).</li> <li>Configure o cliente público (leitura) para aguardar recibo.</li> <li>Defina <code>addressTo</code>.</li> <li>Crie <code>send()</code> com o objeto da transação.</li> <li>Envie com <code>walletClient.sendTransaction</code> e aguarde o hash.</li> <li>Aguarde o recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>send()</code>.</li> </ol> Ver transaction.ts <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  parseEther,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create to address variable\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 6. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${account.address} to ${addressTo}`\n  );\n\n  // 7. Sign and send transaction\n  const hash = await walletClient.sendTransaction({\n    to: addressTo,\n    value: parseEther('1'),\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call the send function\nsend();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node transaction.ts\n</code></pre> <p>Você verá o hash; use <code>balances.ts</code> antes/depois para confirmar saldos.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#deploy-contract", "title": "Implantar um Contrato", "text": "<p>O contrato que você irá compilar e implantar nas próximas seções é um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o código Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A função <code>constructor</code>, executada quando o contrato é implantado, define o valor inicial da variável <code>number</code> armazenada on-chain (padrão é 0). A função <code>increment</code> soma o <code>_value</code> informado ao número atual, mas exige uma transação, pois modifica o dado armazenado. Por fim, a função <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato é apenas um exemplo simples para fins ilustrativos.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#compile-contract-script", "title": "Script de Compilação", "text": "<p>Nesta seção, você criará um script em TypeScript que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para começar, crie o arquivo <code>compile.ts</code> executando:</p> <pre><code>touch compile.ts\n</code></pre> <p>Depois, escreva o script seguindo estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conteúdo de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato com <code>solc.compile</code> usando o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implantação</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#deploy-contract-script", "title": "Script de Deploy", "text": "<p>Compile <code>Incrementer.sol</code> e crie <code>deploy.ts</code>:</p> <pre><code>touch deploy.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code>, <code>privateKeyToAccount</code> e o <code>contractFile</code> de <code>compile.ts</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) para implantar (não salve chaves reais em TS).</li> <li>Configure o cliente público (leitura) para obter recibo.</li> <li>Carregue <code>bytecode</code> e <code>abi</code>.</li> <li>Crie a função <code>deploy</code>.</li> <li>Use <code>walletClient.deployContract</code> com ABI, bytecode, conta e valor inicial.</li> <li>Aguarde recibo/leitura conforme necessário.</li> <li>Chame <code>deploy()</code>.</li> </ol> Ver deploy.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\nconst _initialNumber = 5;\n\n// 6. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${account.address}`);\n\n  // 7. Send transaction (initial value set to 5)\n  const contract = await walletClient.deployContract({\n    abi,\n    account,\n    bytecode,\n    args: [_initialNumber],\n  });\n\n  // 8. Get the transaction receipt for the deployment\n  const transaction = await publicClient.waitForTransactionReceipt({\n    hash: contract,\n  });\n\n  console.log(`Contract deployed at address: ${transaction.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>O endereço do contrato será exibido.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#read-contract-data", "title": "Ler Dados do Contrato (Calls)", "text": "<p>Calls não alteram estado; não precisam de transação. Crie <code>get.ts</code>:</p> <pre><code>touch get.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code>, <code>defineChain</code> e <code>contractFile</code> de <code>compile.ts</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente público.</li> <li>Defina <code>contractAddress</code> e <code>abi</code>.</li> <li>Crie a função <code>get</code>.</li> <li>Chame <code>publicClient.readContract</code> (função <code>number</code>) e exiba o valor.</li> <li>Chame <code>get()</code>.</li> </ol> Ver get.ts <pre><code>// 1. Update import\nimport { createPublicClient, http, defineChain } from 'viem';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await publicClient.readContract({\n    abi,\n    functionName: 'number',\n    address: contractAddress,\n    args: [],\n  });\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node get.ts\n</code></pre> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/viem/#interact-with-contract", "title": "Interagir com o Contrato (Sends)", "text": "<p>Sends alteram estado e exigem transação. Crie <code>increment.ts</code> e <code>reset.ts</code>:</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p><code>increment.ts</code>:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code>, <code>privateKeyToAccount</code> e <code>contractFile</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) (não salve chaves reais em TS).</li> <li>Configure o cliente público (leitura) para recibo.</li> <li>Defina <code>contractAddress</code>, <code>abi</code>, <code>_value</code>.</li> <li>Crie <code>increment()</code>.</li> <li>Chame <code>walletClient.writeContract</code> com <code>_value</code> e aguarde hash.</li> <li>Aguarde recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>increment()</code>.</li> </ol> Ver increment.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\nconst _value = 3;\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'increment',\n    address: contractAddress,\n    args: [_value],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p></p> <p><code>reset.ts</code>:</p> <ol> <li>Importe as mesmas dependências de <code>increment.ts</code>.</li> <li>Defina a cadeia.</li> <li>Configure clientes de carteira e público.</li> <li>Defina <code>contractAddress</code> e <code>abi</code>.</li> <li>Crie <code>reset()</code>.</li> <li>Chame <code>walletClient.writeContract</code> (função <code>reset</code>) e aguarde hash.</li> <li>Aguarde recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>reset()</code>.</li> </ol> Ver reset.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'reset',\n    address: contractAddress,\n    args: [],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p></p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/", "title": "Biblioteca JavaScript Web3.js", "text": ""}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#introduction", "title": "Introdução", "text": "<p>Web3.js é um conjunto de bibliotecas que permite que desenvolvedores interajam com nós Ethereum usando os protocolos HTTP, IPC ou WebSocket em JavaScript. As redes EVM powered by Tanssi têm uma API semelhante à do Ethereum, totalmente compatível com chamadas JSON RPC no estilo Ethereum. Portanto, os desenvolvedores podem aproveitar essa compatibilidade e usar a biblioteca Web3.js para interagir com um nó EVM da Tanssi como se estivessem no Ethereum. Para saber mais sobre Web3.js, consulte o site de documentação.</p> <p>Neste guia, você aprenderá a configurar a biblioteca Web3.js para sua rede EVM da Tanssi. Em seguida, para mostrar a biblioteca em ação, você usará Web3.js para enviar uma transação e implantar um contrato em uma rede EVM de demonstração da Tanssi executando no Dancelight. Este guia pode ser adaptado para sua própria rede EVM da Tanssi simplesmente trocando o endpoint.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você precisará de:</p> <ul> <li>Uma conta com fundos na rede EVM da Tanssi que estiver usando nos testes</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#installing-web3js", "title": "Instalando Web3Js", "text": "<p>Para este guia, instale a biblioteca Web3.js e o compilador Solidity. Para instalar ambos os pacotes NPM, execute:</p> npmyarn <pre><code>npm install web3 solc@0.8.0\n</code></pre> <pre><code>yarn add web3 solc@0.8.0\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#setting-up-the-web3-provider", "title": "Configurando o Provedor Web3", "text": "<p>Ao longo deste guia, você criará vários scripts com funções diferentes, como enviar uma transação, implantar um contrato e interagir com um contrato implantado. Na maioria desses scripts, você precisará criar um provedor Web3.js para interagir com a rede.</p> <p>Para configurar um provedor Web3, siga estes passos:</p> <ol> <li>Importe a biblioteca <code>Web3</code>.</li> <li>Crie o provedor Web3 e defina a URL RPC. Você pode configurar Web3.js para funcionar com a rede EVM de demonstração da Tanssi executando no Dancelight ou com sua própria rede EVM da Tanssi apenas alterando o endpoint.</li> </ol> <pre><code>// 1. Importe o Web3\nconst Web3 = require('web3');\n\n// 2. Crie o provider do Web3 e insira sua URL RPC\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <p>Guarde este snippet, pois ele será necessário nos scripts usados nas seções a seguir.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#send-a-transaction", "title": "Enviar uma Transação", "text": "<p>Nesta seção, você criará alguns scripts. O primeiro verificará os saldos de suas contas antes de tentar enviar uma transação. O segundo script enviará a transação.</p> <p>Você também pode usar o script de saldo para verificar os saldos após a transação ser enviada.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#check-balances-script", "title": "Script para verificar saldos", "text": "<p>Basta um arquivo para verificar os saldos dos dois endereços antes e depois da transação. Para começar, crie o arquivo <code>balances.js</code> executando:</p> <pre><code>touch balances.js\n</code></pre> <p>Em seguida, crie o script deste arquivo seguindo estes passos:</p> <ol> <li>Configure o provedor Web3</li> <li>Defina as variáveis <code>addressFrom</code> e <code>addressTo</code></li> <li>Crie a função assíncrona <code>balances</code>, que envolve o método <code>web3.eth.getBalance</code></li> <li>Use a função <code>web3.eth.getBalance</code> para buscar os saldos dos endereços <code>addressFrom</code> e <code>addressTo</code>. Você também pode usar <code>web3.utils.fromWei</code> para transformar o saldo em um número mais legível em <code>TANGO</code></li> <li>Por fim, execute a função <code>balances</code></li> </ol> <pre><code>// 1. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 2. Crie as variáveis de endereço\nconst addressFrom = 'INSERIR_ENDERECO_DE';\nconst addressTo = 'INSERIR_ENDERECO_PARA';\n\n// 3. Crie a função de saldos\nconst balances = async () =&gt; {\n  // 4. Busque as informações de saldo\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`O saldo de ${addressFrom} é: ${balanceFrom} TANGO`);\n  console.log(`O saldo de ${addressTo} é: ${balanceTo} TANGO`);\n};\n\n// 5. Chamar a função de saldos\nbalances();\n</code></pre> Ver o script completo <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balance info\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call balances function\nbalances();\n</code></pre> <p>Para executar o script e buscar os saldos das contas, rode:</p> <pre><code>node balances.js\n</code></pre> <p>Se funcionar, os saldos dos endereços de origem e destino serão exibidos no terminal em ETH.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#send-transaction-script", "title": "Script para Enviar Transação", "text": "<p>Você só precisa de um arquivo para executar uma transação entre contas. Neste exemplo, você transferirá 1 token TANGO de um endereço de origem (do qual você possui a chave privada) para outro endereço. Para começar, crie o arquivo <code>transaction.js</code> executando:</p> <pre><code>touch transaction.js\n</code></pre> <p>Em seguida, crie o script deste arquivo seguindo estes passos:</p> <ol> <li>Configure o provedor Web3</li> <li>Defina <code>addressFrom</code>, incluindo a <code>privateKey</code>, e a variável <code>addressTo</code>. A chave privada é necessária para criar uma instância de carteira. Nota: isto é apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript</li> <li>Crie a função assíncrona <code>send</code>, que encapsula o objeto de transação e as funções de assinar e enviar a transação</li> <li>Crie e assine a transação usando a função <code>web3.eth.accounts.signTransaction</code>. Informe o <code>gas</code>, o <code>addressTo</code> e o <code>value</code> da transação, além da <code>privateKey</code> do remetente</li> <li>Envie a transação assinada usando o método <code>web3.eth.sendSignedTransaction</code> e passe a transação bruta. Em seguida, use <code>await</code> para aguardar o processamento e o retorno do recibo da transação</li> <li>Por fim, execute a função <code>send</code></li> </ol> <pre><code>// 1. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 2. Crie as variáveis de conta\nconst accountFrom = {\n  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',\n  address: 'INSIRA_O_ENDERECO_PUBLICO_DA_CHAVE',\n};\nconst addressTo = 'INSERIR_ENDERECO_PARA'; // Alterar para o endereço desejado\n\n// 3. Crie a função send\nconst send = async () =&gt; {\n  console.log(\n    `Tentando enviar transação de ${accountFrom.address} para ${addressTo}`\n  );\n\n  // 4. Assine a transação com a chave privada\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // 5. Envie a transação e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transação bem-sucedida com hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// 6. Chame a função send\nsend();\n</code></pre> Ver o script completo <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// Call send function\nsend();\n</code></pre> <p>Para executar o script, rode o seguinte comando no terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>Se a transação for bem-sucedida, o hash será exibido no terminal.</p> <p>Você também pode usar o script <code>balances.js</code> para verificar se os saldos das contas de origem e destino mudaram. O fluxo completo ficaria assim:</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#deploy-a-contract", "title": "Implantar um Contrato", "text": "<p>O contrato que você irá compilar e implantar nas próximas seções é um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o código Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A função <code>constructor</code>, executada quando o contrato é implantado, define o valor inicial da variável <code>number</code> armazenada on-chain (padrão é 0). A função <code>increment</code> soma o <code>_value</code> informado ao número atual, mas exige uma transação, pois modifica o dado armazenado. Por fim, a função <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato é apenas um exemplo simples para fins ilustrativos.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#compile-contract-script", "title": "Script para Compilar o Contrato", "text": "<p>Nesta seção, você criará um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para começar, crie o arquivo <code>compile.js</code> executando:</p> <pre><code>touch compile.js\n</code></pre> <p>Em seguida, escreva o script e conclua estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conteúdo de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato usando <code>solc.compile</code> com o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implantação</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#deploy-contract-script", "title": "Script para Implantar o Contrato", "text": "<p>Com o script para compilar o contrato <code>Incrementer.sol</code> pronto, você pode usar os resultados para enviar uma transação assinada que o implanta. Para isso, crie um arquivo para o script de implantação chamado <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Em seguida, crie o script deste arquivo seguindo estes passos:</p> <ol> <li>Importe o arquivo do contrato a partir de <code>compile.js</code></li> <li>Configure o provedor Web3</li> <li>Defina as variáveis <code>addressFrom</code>, incluindo a <code>privateKey</code>, e <code>addressTo</code>. A chave privada é necessária para criar uma instância de carteira. Nota: isto é apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript</li> <li>Salve o <code>bytecode</code> e o <code>abi</code> do contrato compilado</li> <li>Crie a função assíncrona <code>deploy</code> que será usada para implantar o contrato</li> <li>Crie a instância do contrato usando a função <code>web3.eth.Contract</code></li> <li>Crie o builder e passe o <code>bytecode</code> e o valor inicial do incrementer. Neste exemplo, defina o valor inicial como <code>5</code></li> <li>Crie e assine a transação usando a função <code>web3.eth.accounts.signTransaction</code>. Informe o <code>data</code> e o <code>gas</code> da transação, além da <code>privateKey</code> do remetente</li> <li>Envie a transação assinada usando o método <code>web3.eth.sendSignedTransaction</code> e passe a transação bruta. Em seguida, use <code>await</code> para aguardar o processamento e o retorno do recibo</li> <li>Por fim, execute a função <code>deploy</code></li> </ol> <pre><code>// 1. Importe o arquivo do contrato\nconst contractFile = require('./compile');\n\n// 2. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 3. Crie as variáveis de endereço\nconst accountFrom = {\n  privateKey: 'INSERIR_CHAVE_PRIVADA',\n  address: 'INSERIR_ENDERECO_PUBLICO_DA_CHAVE',\n};\n\n// 4. Obtenha o bytecode e o ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Crie a função deploy\nconst deploy = async () =&gt; {\n  console.log(`Tentando implantar a partir da conta ${accountFrom.address}`);\n\n  // 6. Crie a instância do contrato\n  const incrementer = new web3.eth.Contract(abi);\n\n  // 7. Crie a transação do builder\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // 8. Assine a transação e envie\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 9. Envie a transação e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contrato implantado no endereço: ${createReceipt.contractAddress}`);\n};\n\n// 10. Chame a função deploy\ndeploy();\n</code></pre> Ver o script completo <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst contractFile = require('./compile');\n\n// Add the Web3 provider logic here\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// Get the bytecode and API\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // Create constructor tx with initial value of 5\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // Sign transacation and send\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// Call deploy function\ndeploy();\n</code></pre> <p>Para executar o script, digite o seguinte comando no terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>Se der certo, o endereço do contrato será exibido no terminal.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#read-contract-data", "title": "Ler Dados do Contrato (métodos de chamada)", "text": "<p>Métodos de chamada são interações que não modificam o armazenamento do contrato (não alteram variáveis), portanto nenhuma transação precisa ser enviada. Eles simplesmente leem variáveis de armazenamento do contrato implantado.</p> <p>Para começar, crie um arquivo chamado <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Depois, siga estes passos para criar o script:</p> <ol> <li>Importe o <code>abi</code> do arquivo <code>compile.js</code></li> <li>Configure o provedor Web3</li> <li>Crie a variável <code>contractAddress</code> usando o endereço do contrato implantado</li> <li>Crie uma instância do contrato usando a função <code>web3.eth.Contract</code> e passando o <code>abi</code> e o <code>contractAddress</code></li> <li>Crie a função assíncrona <code>get</code></li> <li>Use a instância do contrato para chamar um dos métodos do contrato e passe os inputs necessários. Neste exemplo, você chamará o método <code>number</code>, que não requer entradas. Use <code>await</code>, que retornará o valor solicitado quando a promessa for resolvida</li> <li>Por fim, chame a função <code>get</code></li> </ol> <pre><code>// 1. Importe o abi do contrato\nconst { abi } = require('./compile');\n\n// 2. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 3. Crie as variáveis de endereço\nconst contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';\n\n// 4. Crie a instância do contrato\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Crie a função get\nconst get = async () =&gt; {\n  console.log(`Fazendo uma chamada ao contrato no endereço: ${contractAddress}`);\n\n  // 6. Chame o contrato\n  const data = await incrementer.methods.number().call();\n\n  console.log(`O número armazenado atualmente é: ${data}`);\n};\n\n// 7. Chame a função get\nget();\n</code></pre> Ver o script completo <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>Para executar o script, digite o seguinte comando no terminal:</p> <pre><code>node get.js\n</code></pre> <p>Se der certo, o valor será exibido no terminal.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3js/#interact-with-contract", "title": "Interagir com o Contrato (métodos de envio)", "text": "<p>Métodos de envio são interações que modificam o armazenamento do contrato (alteram variáveis), portanto uma transação precisa ser assinada e enviada. Nesta seção, você criará dois scripts: um para incrementar e outro para resetar o incrementer. Para começar, crie um arquivo para cada script e nomeie-os <code>increment.js</code> e <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Abra o arquivo <code>increment.js</code> e siga estes passos para criar o script:</p> <ol> <li>Importe o <code>abi</code> do arquivo <code>compile.js</code></li> <li>Configure o provedor Web3</li> <li>Defina a <code>privateKey</code> da conta de origem, o <code>contractAddress</code> do contrato implantado e o <code>_value</code> pelo qual incrementar. A chave privada é necessária para criar uma instância de carteira. Nota: isto é apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript</li> <li>Crie uma instância do contrato usando a função <code>web3.eth.Contract</code> e passando o <code>abi</code> e o <code>contractAddress</code></li> <li>Use a instância do contrato para construir a transação de incremento usando a função <code>methods.increment</code> e passando <code>_value</code> como entrada</li> <li>Crie a função assíncrona <code>increment</code></li> <li>Use a instância do contrato e a transação de incremento criada para assinar a transação com a chave privada do remetente. Use a função <code>web3.eth.accounts.signTransaction</code> e especifique o endereço <code>to</code>, o <code>data</code> e o <code>gas</code> da transação</li> <li>Envie a transação assinada usando o método <code>web3.eth.sendSignedTransaction</code> e passe a transação bruta. Em seguida, use <code>await</code> para aguardar o processamento e o retorno do recibo</li> <li>Por fim, chame a função <code>increment</code></li> </ol> <pre><code>// 1. Importe o abi do contrato\nconst { abi } = require('./compile');\n\n// 2. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 3. Crie as variáveis\nconst accountFrom = {\n  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',\n};\nconst contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';\nconst _value = 3;\n\n// 4. Crie a instância do contrato\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Monte a transação de incremento\nconst incrementTx = incrementer.methods.increment(_value);\n\n// 6. Crie a função increment\nconst increment = async () =&gt; {\n  console.log(\n    `Chamando a função increment de ${_value} no contrato no endereço: ${contractAddress}`\n  );\n\n  // 7. Assine a transação com a chave privada\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Envie a transação e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Transação bem-sucedida com hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Chame a função increment\nincrement();\n</code></pre> Ver o script completo <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build increment tx\nconst incrementTx = incrementer.methods.increment(_value);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign Tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send Tx and Wait for Receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call increment function\nincrement();\n</code></pre> <p>Para executar o script, digite o seguinte comando no terminal:</p> <pre><code>node increment.js\n</code></pre> <p>Se der certo, o hash da transação será exibido no terminal. Você pode usar o script <code>get.js</code> junto com o <code>increment.js</code> para garantir que o valor esteja mudando como esperado.</p> <p></p> <p>Em seguida, abra o arquivo <code>reset.js</code> e siga estes passos para criar o script:</p> <ol> <li>Importe o <code>abi</code> do arquivo <code>compile.js</code></li> <li>Configure o provedor Web3</li> <li>Defina a <code>privateKey</code> da conta de origem e o <code>contractAddress</code> do contrato implantado. A chave privada é necessária para criar uma instância de carteira. Nota: isto é apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript</li> <li>Crie uma instância do contrato usando a função <code>web3.eth.Contract</code> e passando o <code>abi</code> e o <code>contractAddress</code></li> <li>Use a instância do contrato para montar a transação de reset usando a função <code>methods.reset</code></li> <li>Crie a função assíncrona <code>reset</code></li> <li>Use a instância do contrato e a transação de reset criada para assinar a transação com a chave privada do remetente. Use a função <code>web3.eth.accounts.signTransaction</code> e especifique o endereço <code>to</code>, o <code>data</code> e o <code>gas</code> da transação</li> <li>Envie a transação assinada usando o método <code>web3.eth.sendSignedTransaction</code> e passe a transação bruta. Em seguida, use <code>await</code> para aguardar o processamento e o retorno do recibo</li> <li>Por fim, chame a função <code>reset</code></li> </ol> <pre><code>// 1. Importe o abi do contrato\nconst { abi } = require('./compile');\n\n// 2. Adicione aqui a lógica do provider do Web3:\n// {...}\n\n// 3. Crie as variáveis\nconst accountFrom = {\n  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',\n};\nconst contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';\n\n// 4. Crie a instância do contrato\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Monte a transação de reset\nconst resetTx = incrementer.methods.reset();\n\n// 6. Crie a função reset\nconst reset = async () =&gt; {\n  console.log(\n    `Chamando a função reset no contrato no endereço: ${contractAddress}`\n  );\n\n  // 7. Assine a transação com a chave privada\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Envie a transação e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Transação bem-sucedida com hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Chame a função reset\nreset();\n</code></pre> Ver o script completo <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create Contract Instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build reset tx\nconst resetTx = incrementer.methods.reset();\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call reset function\nreset();\n</code></pre> <p>Para executar o script, digite o seguinte comando no terminal:</p> <pre><code>node reset.js\n</code></pre> <p>Se der certo, o hash da transação será exibido no terminal. Você pode usar o script <code>get.js</code> junto com o <code>reset.js</code> para garantir que o valor esteja mudando como esperado.</p> <p></p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/", "title": "Biblioteca Python Web3.py", "text": ""}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#introduction", "title": "Introdução", "text": "<p>Web3.py é um conjunto de bibliotecas que permite interagir com nós Ethereum via HTTP, IPC ou WebSocket em Python. As redes EVM da Tanssi expõem uma API compatível com Ethereum/JSON-RPC, então você pode usar Web3.py para falar com um nó EVM da Tanssi como se estivesse no Ethereum. Veja a documentação para mais detalhes.</p> <p>Neste guia, você configurará o Web3.py para sua rede EVM da Tanssi e usará a biblioteca para enviar uma transação e implantar um contrato em uma appchain de demonstração executando no Dancelight. Para sua rede, basta trocar o endpoint.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Além disso, certifique-se de ter o Python 3 e um gerenciador de pacotes como o pip instalados.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Você precisará:</p> <ul> <li>De uma conta com fundos na rede EVM Tanssi usada nos testes</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#install-web3py", "title": "Instalando Web3.py", "text": "<p>Instale Web3.py e o compilador Solidity:</p> <pre><code>pip3 install web3 py-solc-x\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#setting-up-the-web3py-provider", "title": "Configurando o Provedor Web3.py", "text": "<p>Os scripts a seguir usam um provedor Web3.py para se conectar à rede.</p> <ol> <li>Importe <code>web3</code>.</li> <li>Crie o provedor HTTP com a URL RPC da rede.</li> </ol> <pre><code># 1. Importe web3.py\nfrom web3 import Web3\n\n# 2. Crie o provedor web3.py\n# Insira sua URL RPC aqui\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/'))\n</code></pre> <p>Guarde este trecho; ele é reutilizado nos scripts seguintes.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#send-a-transaction", "title": "Enviar uma Transação", "text": "<p>Dois scripts: um para saldos e outro para enviar.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#check-balances-script", "title": "Script de Saldos", "text": "<p>Crie o arquivo:</p> <pre><code>touch balances.py\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor Web3.</li> <li>Defina <code>address_from</code> e <code>address_to</code>.</li> <li>Use <code>web3.eth.get_balance</code> e <code>web3.from_wei</code> para exibir em TANGO.</li> </ol> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 2. Create address variables\naddress_from = \"INSERT_ADDRESS_FROM\"\naddress_to = \"INSERT_ADDRESS_TO\"\n\n# 4. Fetch balance data\nbalance_from = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\"\n)\nbalance_to = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\"\n)\n\nprint(f\"The balance of { address_from } is: { balance_from } TANGO\")\nprint(f\"The balance of { address_to } is: { balance_to } TANGO\")\n</code></pre> <p>Execute:</p> <pre><code>python3 balances.py\n</code></pre> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#send-transaction-script", "title": "Script de Envio", "text": "<p>Crie o arquivo:</p> <pre><code>touch transaction.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py e <code>rpc_gas_price_strategy</code>.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code> (com <code>private_key</code>) e <code>address_to</code>. Não armazene chaves reais em arquivos Python.</li> <li>Defina a estratégia de gas price com <code>rpc_gas_price_strategy</code>.</li> <li>Monte e assine a transação com <code>sign_transaction</code> (nonce, gas, gasPrice, to, value). Use <code>get_transaction_count</code> para nonce, <code>generate_gas_price</code> para gasPrice e <code>to_wei</code> para valor.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo com <code>wait_for_transaction_receipt</code>.</li> </ol> <pre><code># 1. Add imports\nfrom web3 import Web3\nfrom web3.gas_strategies.rpc import rpc_gas_price_strategy\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variables\naccount_from = {\n    \"private_key\": \"INSERT_ YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_ PUBLIC_ADDRESS_OF_PK\",\n}\naddress_to = \"INSERT_ ADDRESS_TO\"\n\nprint(\n    f'Attempting to send transaction from { account_from[\"address\"] } to { address_to }'\n)\n\n# 4. Set the gas price strategy\nweb3.eth.set_gas_price_strategy(rpc_gas_price_strategy)\n\n# 5. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    {\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n        \"gasPrice\": web3.eth.generate_gas_price(),\n        \"gas\": 21000,\n        \"to\": Web3.to_checksum_address(address_to),\n        \"value\": web3.to_wei(\"1\", \"ether\"),\n    },\n    account_from[\"private_key\"],\n)\n\n# 6. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Transaction successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 transaction.py\n</code></pre> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#deploy-a-contract", "title": "Implantar um Contrato", "text": "<p>O contrato que você irá compilar e implantar nas próximas seções é um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o código Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A função <code>constructor</code>, executada quando o contrato é implantado, define o valor inicial da variável <code>number</code> armazenada on-chain (padrão é 0). A função <code>increment</code> soma o <code>_value</code> informado ao número atual, mas exige uma transação, pois modifica o dado armazenado. Por fim, a função <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato é apenas um exemplo simples para fins ilustrativos.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#compile-contract-script", "title": "Script de Compilação", "text": "<p>Crie <code>compile.py</code>:</p> <pre><code>touch compile.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>solcx</code>.</li> <li>(Opcional) Instale o solc com <code>solcx.install_solc</code>.</li> <li>Compile <code>Incrementer.sol</code> com <code>solcx.compile_files</code>.</li> <li>Exporte ABI e bytecode.</li> </ol> <pre><code># 1. Import solcx\nimport solcx\n\n# 2. If you haven't already installed the Solidity compiler, uncomment the following line\n# solcx.install_solc()\n\n# 3. Compile contract\ntemp_file = solcx.compile_files(\n    \"Incrementer.sol\",\n    output_values=[\"abi\", \"bin\"],\n    # solc_version='0.8.19'\n)\n\n# 4. Export contract data\nabi = temp_file[\"Incrementer.sol:Incrementer\"][\"abi\"]\nbytecode = temp_file[\"Incrementer.sol:Incrementer\"][\"bin\"]\n</code></pre> <p>Note</p> <p>Se aparecer erro de solc não instalado, descomente a etapa 2 no snippet.</p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#deploy-contract-script", "title": "Script de Deploy", "text": "<p>Compile primeiro; depois crie <code>deploy.py</code>:</p> <pre><code>touch deploy.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py, ABI e bytecode.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code>/<code>private_key</code> (não salve chaves reais em Python).</li> <li>Crie instância do contrato com ABI/bytecode.</li> <li>Construa a tx do builder (valor inicial 5) com <code>build_transaction</code>, incluindo <code>from</code> e <code>nonce</code>.</li> <li>Assine com <code>sign_transaction</code>.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo com <code>wait_for_transaction_receipt</code>.</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi, bytecode\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\n\nprint(f'Attempting to deploy from account: { account_from[\"address\"] }')\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# 5. Build constructor tx\nconstruct_txn = Incrementer.constructor(5).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    construct_txn, account_from[\"private_key\"]\n)\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Contract deployed at address: { tx_receipt.contractAddress }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 deploy.py\n</code></pre> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#read-contract-data", "title": "Ler Dados do Contrato (Calls)", "text": "<p>Calls não mudam estado; não precisam de transação. Crie <code>get.py</code>:</p> <pre><code>touch get.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py e o ABI.</li> <li>Inclua o provedor.</li> <li>Defina <code>contract_address</code>.</li> <li>Instancie o contrato com ABI/endereço.</li> <li>Chame <code>number()</code> e exiba.</li> </ol> <pre><code># 1. Import the ABI\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Making a call to contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Call Contract\nnumber = Incrementer.functions.number().call()\nprint(f\"The current number stored is: { number } \")\n</code></pre> <p>Execute:</p> <pre><code>python3 get.py\n</code></pre> <p></p>"}, {"location": "builders/toolkit/ethereum-api/libraries/web3py/#interact-with-contract", "title": "Interagir com o Contrato (Sends)", "text": "<p>Sends alteram estado; exigem transação. Crie <code>increment.py</code> e <code>reset.py</code>:</p> <pre><code>touch increment.py reset.py\n</code></pre> <p><code>increment.py</code>:</p> <ol> <li>Importe Web3.py e ABI.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code>/<code>private_key</code>, <code>contract_address</code>, <code>value</code> (não salve chaves reais em Python).</li> <li>Instancie o contrato.</li> <li>Construa a tx de incremento com <code>build_transaction</code> (from, nonce).</li> <li>Assine com <code>sign_transaction</code>.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo.</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\nvalue = 3\n\nprint(\n    f\"Calling the increment by { value } function in contract at address: { contract_address }\"\n)\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build increment tx\nincrement_tx = Incrementer.functions.increment(value).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 increment.py\n</code></pre> <p></p> <p><code>reset.py</code> segue o mesmo padrão chamando <code>reset()</code> sem argumentos:</p> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Calling the reset function in contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build reset tx\nreset_tx = Incrementer.functions.reset().build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 reset.py\n</code></pre> <p></p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/", "title": "Precompiles", "text": "<p>Precompiles são módulos de blockchain integrados, projetados para lidar com tarefas específicas de forma mais eficiente do que contratos inteligentes padrão. Esses módulos são pré-implantados em endereços fixos e fornecem soluções otimizadas para operações como funções criptográficas, processamento de transações em lote e gerenciamento de tokens.</p> <p>Como as redes Powered by Tanssi são baseadas em Substrate, os contratos precompilados podem suportar funções compatíveis com Ethereum e operações específicas para a cadeia Substrate subjacente. Essa abordagem dupla garante que os desenvolvedores possam interagir com ferramentas Ethereum familiares, ao mesmo tempo em que aproveitam o desempenho e a flexibilidade exclusivos oferecidos pelo Substrate.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/#fluxo-de-interacao-com-precompiles", "title": "Fluxo de Interação com Precompiles", "text": "<p>O fluxo abaixo ilustra como as solicitações do usuário passam pela interface Ethereum, interagem com precompiles e, por fim, acessam a funcionalidade Substrate, simplificando operações complexas para uma integração perfeita.</p> <pre><code>graph LR\n\n    A[Usuário]\n    B[Interface Ethereum]\n    C[Precompile]\n    D[Interface Substrate]\n\n    A --&gt;|Interage através de| B\n    B --&gt;|Chama| C\n    C --&gt;|Acessa| D</code></pre>"}, {"location": "builders/toolkit/ethereum-api/precompiles/#referencia-rapida-de-enderecos-precompile", "title": "Referência Rápida de Endereços Precompile", "text": "Precompile Endereço Native Token ERC-20 <pre><code>0x0000000000000000000000000000000000000800</code></pre> Call Permit <pre><code>0x0000000000000000000000000000000000000802</code></pre> Proxy <pre><code>0x0000000000000000000000000000000000000805</code></pre> Batch Transactions <pre><code>0x0000000000000000000000000000000000000801</code></pre> <p>Para saber mais sobre cada precompile, confira os guias listados na seção a seguir.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/#explore-esta-secao", "title": "Explore esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/", "title": "Interagindo com o Batch Precompile", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#introduction", "title": "Introdução", "text": "<p>O contrato Batch Precompile em redes EVM powered by Tanssi permite agrupar várias chamadas EVM em uma só.</p> <p>Normalmente, fazer o usuário interagir com vários contratos exige várias confirmações de transação na carteira. Um exemplo seria aprovar o acesso de um contrato a um token e logo em seguida transferi-lo. Com o Batch Precompile, você melhora a experiência do usuário com transações em lote, pois reduz o número de confirmações necessárias. Além disso, as taxas de gás podem diminuir, já que o batching evita múltiplas taxas base (as 21000 unidades iniciais de gás de cada transação).</p> <p>O precompile interage diretamente com o pallet EVM do Substrate. Quem chama a função em lote tem seu endereço agindo como <code>msg.sender</code> para todas as subtransações, mas, diferente de delegate calls, o contrato de destino ainda altera o próprio armazenamento. É como se o usuário assinasse várias transações, mas com apenas uma confirmação.</p> <p>O Batch Precompile está localizado neste endereço:</p> <pre><code>0x0000000000000000000000000000000000000801\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#the-batch-interface", "title": "A Interface Solidity em Lote", "text": "<p><code>Batch.sol</code> é uma interface Solidity que permite interagir com os três métodos do precompile.</p> Batch.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Batch contract's address.\naddress constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000801;\n\n/// @dev The Batch contract's instance.\nBatch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Batch precompile\n/// @dev Allows to perform multiple calls throught one call to the precompile.\n/// Can be used by EOA to do multiple calls in a single transaction.\n/// @custom:address 0x0000000000000000000000000000000000000801\ninterface Batch {\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting following subcalls will still be attempted.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 79df4b9c\n    function batchSome(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, no more subcalls will be executed but\n    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector cf0491c7\n    function batchSomeUntilFailure(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, the entire batch will revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 96e292b8\n    function batchAll(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// Emitted when a subcall succeeds.\n    event SubcallSucceeded(uint256 index);\n\n    /// Emitted when a subcall fails.\n    event SubcallFailed(uint256 index);\n}\n</code></pre> <p>A interface inclui as seguintes funções:</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) — executa várias chamadas, combinando os mesmos índices dos arrays para formar cada subchamada. Se uma subchamada reverter, as seguintes ainda serão tentadas Parâmetros <ul> <li><code>to</code> - array de endereços para direcionar as subtransações, em que cada entrada é uma subtransação</li> <li><code>value</code> - array de valores em moeda nativa para enviar nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes terão valor 0</li> <li><code>callData</code> - array de dados de chamada para incluir nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes não terão dados de chamada</li> <li><code>gasLimit</code> - array de limites de gás nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Valores 0 são interpretados como ilimitados e encaminham todo o gás restante da transação em lote. Se este array for menor que o array to, todas as subtransações seguintes encaminharão todo o gás restante</li> </ul> batchSomeUntilFailure(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) — executa várias chamadas, combinando os mesmos índices dos arrays para formar cada subchamada. Se uma subchamada reverter, nenhuma subchamada seguinte será executada Parâmetros <ul> <li><code>to</code> - array de endereços para direcionar as subtransações, em que cada entrada é uma subtransação</li> <li><code>value</code> - array de valores em moeda nativa para enviar nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes terão valor 0</li> <li><code>callData</code> - array de dados de chamada para incluir nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes não terão dados de chamada</li> <li><code>gasLimit</code> - array de limites de gás nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Valores 0 são interpretados como ilimitados e encaminham todo o gás restante da transação em lote. Se este array for menor que o array to, todas as subtransações seguintes encaminharão todo o gás restante</li> </ul> batchAll(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) — executa várias chamadas de forma atômica, combinando os mesmos índices dos arrays para formar cada subchamada. Se uma subchamada reverter, todas as subchamadas irão reverter Parâmetros <ul> <li><code>to</code> - array de endereços para direcionar as subtransações, em que cada entrada é uma subtransação</li> <li><code>value</code> - array de valores em moeda nativa para enviar nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes terão valor 0</li> <li><code>callData</code> - array de dados de chamada para incluir nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Se este array for menor que o array to, todas as subtransações seguintes não terão dados de chamada</li> <li><code>gasLimit</code> - array de limites de gás nas subtransações, em que o índice corresponde à subtransação no mesmo índice em to. Valores 0 são interpretados como ilimitados e encaminham todo o gás restante da transação em lote. Se este array for menor que o array to, todas as subtransações seguintes encaminharão todo o gás restante</li> </ul> <p>A interface também inclui os seguintes eventos:</p> <ul> <li>SubcallSucceeded(uint256 index) - emitido quando uma subchamada do índice informado é bem-sucedida</li> <li>SubcallFailed(uint256 index) - emitido quando uma subchamada do índice informado falha</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#interact-with-the-solidity-interface", "title": "Interaja com a Interface Solidity", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisa ter a carteira configurada para sua rede EVM e uma conta com tokens nativos. Você pode adicionar sua rede EVM à MetaMask com um clique no Tanssi dApp. Ou configurar a MetaMask para a Tanssi com a rede EVM de demonstração.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#example-contract", "title": "Contrato de Exemplo", "text": "<p>O contrato <code>SimpleContract.sol</code> será usado como exemplo de interação em lote, mas, na prática, qualquer contrato pode ser usado.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode interagir com o Batch Precompile usando o Remix. Tenha uma cópia de <code>Batch.sol</code> e de <code>SimpleContract.sol</code>. Para adicionar o precompile no Remix e seguir o tutorial:</p> <ol> <li>Clique na aba File explorer</li> <li>Cole o contrato <code>Batch.sol</code> em um arquivo do Remix chamado Batch.sol</li> <li>Cole o contrato <code>SimpleContract.sol</code> em um arquivo do Remix chamado SimpleContract.sol</li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#compile-the-contract", "title": "Compile o Contrato", "text": "<p>Em seguida, compile os dois arquivos no Remix:</p> <ol> <li>Certifique-se de que o arquivo Batch.sol está aberto</li> <li>Clique na aba Compile, a segunda de cima</li> <li>Para compilar, clique em Compile Batch.sol</li> </ol> <p></p> <p>Se a interface foi compilada com sucesso, você verá um check verde ao lado da aba Compile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#access-the-precompile", "title": "Acesse o Precompile", "text": "<p>Em vez de implantar o Batch Precompile, acesse a interface informando o endereço do contrato pré-compilado:</p> <ol> <li>Clique na aba Deploy and Run logo abaixo da aba Compile no Remix. Observe que o contrato pré-compilado já está implantado</li> <li>Certifique-se de que Injected Provider - MetaMask está selecionado no menu ENVIRONMENT. Ao selecionar, a MetaMask pode solicitar que você conecte sua conta ao Remix</li> <li>Confirme que a conta correta aparece em ACCOUNT</li> <li>Garanta que Batch.sol está selecionado no menu CONTRACT. Como é um contrato pré-compilado, não é necessário implantar código. Vamos apenas fornecer o endereço do precompile no campo At Address</li> <li>Informe o endereço do Batch Precompile: <code>0x0000000000000000000000000000000000000801</code> e clique em At Address</li> </ol> <p></p> <p>O precompile BATCH aparecerá na lista de Deployed Contracts.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#deploy-example-contract", "title": "Implemente o Contrato de Exemplo", "text": "<p>Por outro lado, <code>SimpleContract.sol</code> será implantado como um novo contrato. Antes de começar esta seção, repita a etapa de compilação com o arquivo <code>SimpleContract.sol</code>.</p> <ol> <li>Clique na aba Deploy and Run logo abaixo da aba Compile no Remix</li> <li>Certifique-se de que Injected Provider - MetaMask está selecionado em ENVIRONMENT. Ao selecionar, a MetaMask pode solicitar que você conecte sua conta ao Remix</li> <li>Confirme que a conta correta aparece em ACCOUNT</li> <li>Garanta que SimpleContract está selecionado no menu CONTRACT</li> <li>Clique em Deploy</li> <li>Confirme a transação que aparecerá na MetaMask clicando em Confirm</li> </ol> <p></p> <p>O contrato SIMPLECONTRACT aparecerá na lista de Deployed Contracts.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#send-native-currency-via-precompile", "title": "Envie moeda nativa via precompile", "text": "<p>Enviar moeda nativa com o Batch Precompile exige mais do que alguns cliques no Remix ou na MetaMask. Neste exemplo, você usará a função batchAll para enviar moeda nativa de forma atômica.</p> <p>Transações têm um campo <code>value</code> para indicar o valor de moeda nativa a enviar. No Remix, isso é definido pelo input VALUE na aba DEPLOY &amp; RUN TRANSACTIONS. Porém, para o Batch Precompile, esses valores são fornecidos no array value das funções em lote.</p> <p>Tente transferir o token nativo da sua rede para duas carteiras usando o Batch Precompile:</p> <ol> <li>Expanda o contrato do batch em Deployed Contracts</li> <li>Expanda a função batchAll</li> <li>No campo to, insira os endereços neste formato: <code>[\"INSERIR_ENDERECO_1\", \"INSERIR_ENDERECO_2\"]</code>, onde o primeiro endereço corresponde à primeira carteira e o segundo à segunda carteira</li> <li>No campo value, insira o valor que deseja transferir em Wei para cada endereço. Por exemplo, <code>[\"1000000000000000000\", \"2000000000000000000\"]</code> transferirá 1 token nativo para o primeiro endereço e 2 tokens para o segundo</li> <li>Para callData, insira <code>[]</code>. Não há dados de chamada para uma simples transferência de token nativo</li> <li>Para gasLimit, insira <code>[]</code></li> <li>Clique em transact</li> <li>Clique em Confirm na MetaMask para confirmar a transação</li> </ol> <p></p> <p>Quando a transação for concluída, você pode conferir os saldos das duas contas na MetaMask ou no explorador da sua rede (link no Tanssi dApp). Parabéns! Você enviou uma transferência em lote via Batch Precompile.</p> <p>Note</p> <p>Normalmente, para enviar moeda nativa para ou através de um contrato, seria preciso definir o <code>value</code> no objeto geral da transação e interagir com uma função payable. Contudo, como o Batch Precompile interage diretamente com o código Substrate, esta não é uma transação Ethereum típica, então isso não é necessário.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#find-a-contract-interactions-call-data", "title": "Descubra o call data de uma interação de contrato", "text": "<p>Interfaces visuais como o Remix e bibliotecas como Ethers.js ocultam como transações Ethereum interagem com contratos Solidity. O nome e os tipos de entrada de uma função são transformados em um seletor de função e os dados de entrada são codificados. Esses dois elementos são combinados e enviados como o call data da transação. Para enviar uma subtransação dentro de uma transação em lote, o remetente precisa conhecer previamente esse call data.</p> <p>Tente encontrar o call data de uma transação usando o Remix:</p> <ol> <li>Expanda o contrato <code>SimpleContract.sol</code> em Deployed Contracts</li> <li>Expanda a função setMessage</li> <li>Insira o id desejado, como <code>1</code></li> <li>Insira a message desejada, como <code>\"tanssi\"</code></li> <li>Em vez de enviar a transação, clique no botão de copiar ao lado de transact para copiar o call data</li> </ol> <p></p> <p>Agora você tem o call data da transação! Considerando os valores de exemplo <code>1</code> e <code>\"tanssi\"</code>, podemos observar seus valores codificados no call data:</p> <pre><code>0x648345c8                                                        // function selector\n0000000000000000000000000000000000000000000000000000000000000001  // 1 id\n0000000000000000000000000000000000000000000000000000000000000040  // 32 byte offset\n000000000000000000000000000000000000000000000000000000000000000   // 32 byte length\n674616e7373690000000000000000000000000000000000000000000000000000 // \"tanssi\" em bytes\n</code></pre> <p>O call data pode ser dividido em cinco linhas em que:</p> <ul> <li>A primeira linha é o seletor de função</li> <li>A segunda linha é igual a 1, que é o id fornecido</li> <li>O restante envolve o input message. Essas três últimas linhas são mais complexas, pois strings são um tipo dinâmico com tamanho variável. A terceira linha se refere ao offset que define onde os dados da string começam. A quarta linha se refere ao comprimento da mensagem na linha seguinte, que é de 32 bytes no total — a mensagem \"tanssi\" mais o preenchimento</li> </ul> <p>Você pode repetir as etapas acima para capturar o call data para os valores <code>2</code> e <code>\"hello\"</code> e enviar várias subchamadas de forma atômica com o Batch Precompile na próxima seção.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#function-interaction-via-precompile", "title": "Interação de Função via Precompile", "text": "<p>O exemplo desta seção usará a função batchAll, que garante a resolução atômica das transações. Lembre-se de que há outras duas funções em lote que podem continuar subtransações apesar de erros ou parar subtransações seguintes sem reverter as anteriores.</p> <p>Interagir com uma função é muito semelhante a enviar moeda nativa, já que ambas são transações. Entretanto, é necessário call data para fornecer entradas às funções corretamente, e o remetente pode querer limitar o gás gasto em cada subtransação.</p> <p>Os campos <code>callData</code> e <code>gasLimit</code> são mais relevantes para subtransações que interagem com contratos. Para cada função da interface em lote, <code>callData</code> é um array em que cada índice corresponde ao call data de cada destinatário da subtransação, ou seja, cada entrada em <code>to</code>. Se o tamanho do array <code>callData</code> for menor que o array <code>to</code>, as subtransações restantes não terão call data (funções sem entradas). O <code>gasLimit</code> é um array que define quanto gás cada subtransação pode gastar. Se o valor em um índice for 0 ou o índice estiver fora do tamanho do array (mas ainda menor que o tamanho de <code>to</code>), todo o gás restante da transação anterior é encaminhado.</p> <p>Para usar o precompile e enviar uma transação em lote atômica combinando duas interações de contrato, faça o seguinte:</p> <ol> <li>Copie o endereço do contrato <code>SimpleContract.sol</code> com o botão de copiar à direita do cabeçalho. Tenha também o call data da seção anterior</li> <li>Expanda o contrato do batch em Deployed Contracts</li> <li>Expanda a função batchAll</li> <li>Para o campo to, cole o endereço de <code>SimpleContract.sol</code> assim: <code>[\"INSERIR_ENDERECO_SIMPLE_CONTRACT\",\"INSERIR_ENDERECO_SIMPLE_CONTRACT\"]</code>. Observe que é preciso repetir o endereço para cada transação em lote, mesmo que o contrato seja o mesmo</li> <li>Para o campo value, como <code>SimpleContract.sol</code> não requer moeda nativa, insira <code>[0,0]</code> para 0 Wei</li> <li>Para o campo callData, insira os call data da seção anterior neste formato: <code>[\"INSERIR_PRIMEIRO_CALL_DATA\",\"INSERIR_SEGUNDO_CALL_DATA\"]</code></li> <li>Para o campo gasLimit, insira <code>[]</code>. Você pode definir um valor de gás para cada subchamada ou deixar como array vazio</li> <li>Clique em transact</li> <li>Clique em Confirm na MetaMask para confirmar a transação</li> </ol> <p></p> <p>Se você usou o mesmo call data do tutorial, pode verificar se a transação deu certo assim:</p> <ol> <li>Expanda o contrato <code>SimpleContract.sol</code> em Deployed Contracts</li> <li>À direita do botão messages, insira <code>1</code></li> <li>Clique no botão azul messages</li> </ol> <p></p> <p>A frase \"tanssi\" deve aparecer embaixo. Você pode repetir com o id \"2\" e verá \"hello\". Parabéns! Você interagiu com uma função usando o Batch Precompile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#combinando-subtransacoes", "title": "Combinando Subtransações", "text": "<p>Até aqui, transferir moeda nativa e interagir com funções foram ações separadas, mas elas podem ser combinadas.</p> <p>As quatro strings a seguir podem ser usadas como inputs de uma transação em lote. Elas enviam 1 token nativo para a conta pública Gerald (<code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code>) e interagem com um contrato <code>SimpleContract.sol</code> pré-implantado duas vezes. Eis o detalhamento:</p> <p>Há três subtransações que correspondem a três endereços no array <code>to</code>. O primeiro é a conta pública Gerald e os dois seguintes são um contrato <code>SimpleContract.sol</code>. Você pode substituir os dois últimos pelo seu próprio contrato <code>SimpleContract.sol</code> se quiser. Ou substituir apenas um: é possível interagir com múltiplos contratos em uma única mensagem.</p> <pre><code>[\n  \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\",\n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\", \n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\"\n]\n</code></pre> <p>Também haverá três valores para o array <code>value</code>. O primeiro endereço em <code>to</code> indica <code>1000000000000000000</code> wei ou <code>1</code> UNIT do token nativo. Lembre que os tokens nativos de redes EVM powered by Tanssi têm 18 casas decimais, assim como no Ethereum. Os dois valores seguintes são <code>0</code> porque a função com que suas subtransações interagem não aceita nem exige moeda nativa.  </p> <pre><code>[\"1000000000000000000\", \"0\", \"0\"]\n</code></pre> <p>Você precisará de três valores para o array <code>callData</code>. Como transferir moeda nativa não requer call data, a string fica vazia. O segundo e o terceiro valores correspondem a chamadas de setMessage que definem mensagens para os IDs 5 e 6.</p> <pre><code>[\n  \"0x\", \n  \"0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000\", \n  \"0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000\"\n]\n</code></pre> <p>O input final é para <code>gas_input</code>. Este array ficará vazio para encaminhar todo o gás restante a cada subtransação.</p> <pre><code>[]\n</code></pre> <p>Tente enviar uma transação em lote com esses inputs no Remix da mesma forma que você agrupou uma chamada de função.</p> <p>E é isso! Você interagiu com o precompile de batching usando MetaMask e Remix!</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/batch/#ethereum-development-libraries", "title": "Bibliotecas de Desenvolvimento Ethereum", "text": "<p>Se você seguiu o tutorial de Ethers.js, pode ser difícil encontrar o call data de uma função. A resposta está escondida no objeto <code>Interface</code> do Ethers, onde a função encodeFunctionData permite informar o nome da função e os inputs para obter o call data resultante. O Web3.js tem função semelhante, encodeFunctionCall.</p> <p>Note</p> <p>Os trechos de código a seguir não são destinados a ambientes de produção. Adapte-os conforme cada caso de uso.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Use ABI to create an interface\nconst yourContractInterface = new ethers.Interface(abi);\n\n// Find call data for the setMessage function\nconst callData = yourContractInterface.encodeFunctionData(\n  'INSERT_FUNCTION_NAME',\n  [\n    'INSERT_INPUT_1',\n    'INSERT_INPUT_2',\n    // ...\n  ]\n);\n</code></pre> <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Find call data for the setMessage function\nconst callData = web3.eth.abi.encodeFunctionCall(abi, [\n  'INSERT_INPUT_1',\n  'INSERT_INPUT_2',\n  // ...\n]);\n</code></pre> <pre><code># Import the ABI and bytecode\nfrom compile import abi, bytecode\n\n# Create contract instance\nyour_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# Encode the contract call\ncall_data = your_contract.encodeABI(\n    fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n)\n</code></pre> <p>Depois disso, você estará pronto para interagir com o Batch Precompile como faria normalmente com um contrato no Ethers.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/", "title": "Interagindo com o Call Permit Precompile", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#introduction", "title": "Introdução", "text": "<p>O Call Permit Precompile em redes EVM powered by Tanssi permite que um usuário assine um permit, uma mensagem assinada EIP-712, para qualquer chamada EVM, podendo ser despachada por qualquer pessoa ou contrato inteligente. É semelhante ao Permit Signing das aprovações ERC-20 introduzidas no EIP-2612, exceto que se aplica a qualquer chamada EVM em vez de apenas aprovações.</p> <p>Quando o call permit é despachado, isso é feito em nome do usuário que assinou o permit e o usuário ou contrato que despacha o permit é responsável por pagar as taxas de transação. Assim, o precompile pode ser usado para realizar transações sem gás para o signatário.</p> <p>Por exemplo, Alice assina um call permit e Bob o despacha, executando a chamada em nome de Alice. Bob paga as taxas de transação; portanto, Alice não precisa ter moeda nativa para pagar a transação, a menos que a chamada inclua uma transferência.</p> <p>O Call Permit Precompile está localizado no seguinte endereço:</p> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#the-call-permit-interface", "title": "Interface Solidity do Call Permit", "text": "<p><code>CallPermit.sol</code> é uma interface Solidity que permite interagir com três métodos do precompile.</p> CallPermit.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The CallPermit contract's address.\naddress constant CALL_PERMIT_ADDRESS = 0x0000000000000000000000000000000000000802;\n\n/// @dev The CallPermit contract's instance.\nCallPermit constant CALL_PERMIT_CONTRACT = CallPermit(CALL_PERMIT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Call Permit Interface\n/// @dev The interface aims to be a general-purpose tool to perform gas-less transactions. It uses the EIP-712 standard,\n/// and signed messages can be dispatched by another network participant with a transaction\n/// @custom:address 0x0000000000000000000000000000000000000802\ninterface CallPermit {\n    /// @dev Dispatch a call on the behalf of an other user with a EIP712 permit.\n    /// Will revert if the permit is not valid or if the dispatched call reverts or errors (such as\n    /// out of gas).\n    /// If successful the EIP712 nonce is increased to prevent this permit to be replayed.\n    /// @param from Who made the permit and want its call to be dispatched on their behalf.\n    /// @param to Which address the call is made to.\n    /// @param value Value being transferred from the \"from\" account.\n    /// @param data Call data\n    /// @param gaslimit Gaslimit the dispatched call requires.\n    ///     Providing it prevents the dispatcher to manipulate the gaslimit.\n    /// @param deadline Deadline in UNIX seconds after which the permit will no longer be valid.\n    /// @param v V part of the signature.\n    /// @param r R part of the signature.\n    /// @param s S part of the signature.\n    /// @return output Output of the call.\n    /// @custom:selector b5ea0966\n    function dispatch(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint64 gaslimit,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (bytes memory output);\n\n    /// @dev Returns the current nonce for given owner.\n    /// A permit must have this nonce to be consumed, which will\n    /// increase the nonce by one.\n    /// @custom:selector 7ecebe00\n    function nonces(address owner) external view returns (uint256);\n\n    /// @dev Returns the EIP712 domain separator. It is used to avoid replay\n    /// attacks across assets or other similar EIP712 message structures.\n    /// @custom:selector 3644e515\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n</code></pre> <p>A interface inclui as seguintes funções:</p> dispatch(address from, address to, uint256 value, bytes data, uint64[] gaslimit, uint256 deadline, uint8 v, bytes32 r, bytes32 s) — despacha uma chamada em nome de outro usuário com um permit EIP-712. Qualquer pessoa ou contrato pode chamar. A transação reverte se o permit for inválido ou se a chamada despachada reverter/errar (por exemplo, out of gas). Se for bem-sucedida, o nonce do signatário é incrementado para evitar replay Parâmetros <ul> <li><code>from</code> - signatário do permit. A chamada será despachada em nome deste endereço</li> <li><code>to</code> - endereço para o qual a chamada é feita</li> <li><code>value</code> - valor transferido da conta <code>from</code></li> <li><code>data</code> - call data, ou ação a executar</li> <li><code>value</code> - valor transferido da conta <code>from</code></li> <li><code>gasLimit</code> - limite de gás exigido pela chamada despachada. Informar este parâmetro evita que o despachante manipule o gas limit</li> <li><code>deadline</code> - tempo em segundos UNIX após o qual o permit não será mais válido. Em JavaScript, você pode obter o tempo UNIX atual executando <code>console.log(Date.now())</code> em um script ou no console do navegador</li> <li><code>v</code> - recovery ID da assinatura (1 byte final da assinatura concatenada)</li> <li><code>r</code> - primeiros 32 bytes da assinatura concatenada</li> <li><code>s</code> - segundos 32 bytes da assinatura concatenada</li> </ul> nonces(address owner) — retorna o nonce atual para o owner informado Parâmetros <ul> <li><code>owner</code> - endereço da conta a verificar</li> </ul> DOMAIN_SEPARATOR() — retorna o separador de domínio EIP-712 usado para evitar ataques de replay. Segue a implementação do EIP-2612 ParâmetrosRetorno <p>Nenhum</p> <p>O separador de domínio EIP-712 usado para evitar ataques de replay.</p> <p>O separador de domínio é definido no padrão EIP-712 e calculado como:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>Os parâmetros do hash podem ser decompostos assim:</p> <ul> <li>PERMIT_DOMAIN - é o <code>keccak256</code> de <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - é o nome do domínio de assinatura e deve ser exatamente <code>'Call Permit Precompile'</code></li> <li>version - é a versão do domínio de assinatura. Aqui, version é <code>1</code></li> <li>chainId - é o Chain ID da sua rede</li> <li>verifyingContract - é o endereço do contrato que verificará a assinatura. Neste caso, o endereço do Call Permit Precompile</li> </ul> <p>Quando <code>dispatch</code> é chamado, o permit precisa ser verificado antes de despachar a chamada. O primeiro passo é calcular o separador de domínio. O cálculo pode ser visto na implementação do Moonbeam ou em um exemplo prático no contrato EIP712 do OpenZeppelin.</p> <p>A partir daí, um hash da assinatura e dos argumentos é gerado, garantindo que a assinatura só possa ser usada para o call permit. Ele usa um nonce para evitar replay. É semelhante ao contrato <code>ERC20Permit</code> do OpenZeppelin, exceto que o <code>PERMIT_TYPEHASH</code> é para call permit e os argumentos correspondem aos da função dispatch mais o nonce.</p> <p>O separador de domínio e o hash struct podem ser usados para construir o hash final da mensagem totalmente codificada. Um exemplo prático está no contrato EIP712 do OpenZeppelin.</p> <p>Com o hash final e os valores v, r e s, a assinatura pode ser verificada e recuperada. Se verificada com sucesso, o nonce é incrementado em um e a chamada é despachada.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#setup-the-example-contract", "title": "Preparar os contratos", "text": "<p>Neste exemplo, você aprenderá a assinar um call permit que atualiza uma mensagem em um contrato simples, <code>SetMessage.sol</code>. Antes de gerar a assinatura do call permit, é preciso implantar o contrato e definir os argumentos da função <code>dispatch</code> para o permit.</p> <p>Depois de configurar o contrato de exemplo, você poderá configurar o contrato do Call Permit Precompile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, configure sua carteira para sua rede EVM e tenha uma conta com tokens nativos. Você pode adicionar sua rede EVM à MetaMask com um clique no Tanssi dApp. Ou configurar a MetaMask para a Tanssi com a rede EVM de demonstração.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#example-contract", "title": "Contrato de Exemplo", "text": "<p>O contrato <code>SetMessage.sol</code> é perfeito para demonstrar o uso do Call Permit Precompile.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode usar o Remix para compilar e implantar o contrato de exemplo. Tenha uma cópia de <code>SetMessage.sol</code> e de <code>CallPermit.sol</code>. Para adicioná-los ao Remix:</p> <ol> <li>Clique na aba File explorer </li> <li>Cole o contrato <code>CallPermit.sol</code> em um arquivo do Remix chamado <code>CallPermit.sol</code></li> <li>Cole o contrato <code>SetMessage.sol</code> em um arquivo do Remix chamado <code>SetMessage.sol</code></li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#compile-deploy-example-contract", "title": "Compile e implante o contrato de exemplo", "text": "<p>Primeiro, compile o contrato de exemplo:</p> <ol> <li>Clique na aba Compile</li> <li>Para compilar a interface, clique em Compile SetMessage.sol</li> </ol> <p></p> <p>Em seguida, implante-o:</p> <ol> <li>Clique na aba Deploy and Run, logo abaixo da aba Compile no Remix. Observação: aqui você está implantando um contrato</li> <li>Certifique-se de que Injected Provider - Metamask está selecionado no menu ENVIRONMENT</li> <li>Garanta que SetMessage.sol esteja selecionado no menu CONTRACT</li> <li>Clique em Deploy</li> <li>A MetaMask aparecerá e você deverá Confirmar a transação</li> </ol> <p></p> <p>O contrato aparecerá na lista de Deployed Contracts no painel à esquerda. Copie o endereço do contrato, pois você precisará dele para gerar a assinatura do call permit na próxima seção.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#compile-access-call-permit", "title": "Compile e acesse o Call Permit Precompile", "text": "<p>Primeiro, compile o contrato Call Permit Precompile:</p> <ol> <li>Clique na aba Compile</li> <li>Para compilar a interface, clique em Compile CallPermit.sol</li> </ol> <p></p> <p>Depois, em vez de implantar o contrato, basta acessá-lo informando o endereço do precompile:</p> <ol> <li>Clique na aba Deploy and Run, logo abaixo da aba Compile no Remix. Observação: aqui você não implanta um contrato; apenas acessa um contrato pré-compilado já implantado</li> <li>Certifique-se de que Injected Provider - Metamask está selecionado no menu ENVIRONMENT</li> <li>Garanta que CallPermit.sol esteja selecionado no menu CONTRACT. Como é um contrato pré-compilado, não há etapa de deployment. Forneça o endereço do precompile no campo At Address</li> <li>Forneça o endereço do Call Permit Precompile para redes EVM powered by Tanssi: <code>0x0000000000000000000000000000000000000802</code> e clique em At Address</li> <li>O Call Permit Precompile aparecerá na lista de Deployed Contracts</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#generate-call-permit-signature", "title": "Gerar a Assinatura do Call Permit", "text": "<p>Para interagir com o Call Permit Precompile, você precisa ter ou gerar uma assinatura para despachar o call permit. Há várias formas de gerar a assinatura. Este guia mostra como fazê-lo usando o Ethers.js.</p> <p>Veja um resumo dos passos para obter a assinatura:</p> <ol> <li>Criar a <code>message</code>, incluindo parte dos dados necessários para o call permit: os argumentos da função <code>dispatch</code> e o nonce do signatário</li> <li>Montar a estrutura JSON dos dados a serem assinados, incluindo todos os tipos dos argumentos de <code>dispatch</code> e o nonce. Isso gera o tipo <code>CallPermit</code>, salvo como <code>primaryType</code></li> <li>Criar o domain separator usando exatamente <code>\"Call Permit Precompile\"</code> para o nome, a versão do seu dApp ou plataforma, o Chain ID da rede em que a assinatura será usada e o endereço do contrato que verificará a assinatura. Você deve especificar o Chain ID da sua rede no script para gerar a assinatura correta</li> <li>Assinar todos os dados montados usando Ethers.js</li> <li>A assinatura será retornada; use o <code>Signature.from</code> do Ethers.js para obter os valores <code>v</code>, <code>r</code> e <code>s</code></li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#call-permit-arguments", "title": "Argumentos do Call Permit", "text": "<p>Como visto na seção Interface do Call Permit, a função <code>dispatch</code> recebe os parâmetros: <code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code>, <code>v</code>, <code>r</code> e <code>s</code>.</p> <p>Para obter os argumentos da assinatura (<code>v</code>, <code>r</code> e <code>s</code>), você deve assinar uma mensagem contendo os argumentos para os demais parâmetros acima, além do nonce do signatário.</p> <ul> <li><code>from</code> - endereço da conta com a qual você assinará o call permit</li> <li><code>to</code> - endereço do contrato <code>SetMessage.sol</code></li> <li><code>value</code> - pode ser <code>0</code> neste exemplo, já que apenas definiremos uma mensagem (sem transferir fundos)</li> <li><code>data</code> - você pode enviar qualquer mensagem; precisa da representação hex da mensagem a definir no contrato <code>SetMessage.sol</code>. Ela inclui o function selector da função <code>set</code> e a string da mensagem. Para este exemplo, use <code>hello world</code> com a seguinte representação hex:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li><code>gasLimit</code> - <code>100000</code> é suficiente para enviar a chamada despachada</li> <li><code>deadline</code> - obtenha o horário UNIX atual executando <code>console.log(Date.now())</code> em um script JavaScript ou no console do navegador. Depois, adicione segundos extras para definir quando o call permit expira</li> </ul> <p>O nonce do signatário também é necessário. Se for a primeira vez que assina um call permit, o nonce será <code>0</code>. Você também pode verificar o nonce no Remix:</p> <ol> <li>Expanda o contrato do call permit</li> <li>Ao lado da função nonces, insira o endereço do signatário e clique em nonces</li> <li>O resultado aparecerá logo abaixo da função</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#use-ethers-to-create-the-signature", "title": "Use Ethers para Criar a Assinatura", "text": "<p>Para gerar a assinatura do call permit usando JavaScript e Ethers, primeiro crie um projeto local:</p> <pre><code>mkdir call-permit-example &amp;&amp; cd call-permit-example &amp;&amp; touch getSignature.js\nnpm init -y\n</code></pre> <p>Agora você tem um arquivo para o script e um <code>package.json</code>. Abra o <code>package.json</code> e abaixo de <code>\"dependencies\"</code> adicione:</p> <pre><code>\"type\": \"module\"\n</code></pre> <p>Em seguida, instale o Ethers.js:</p> <pre><code>npm i ethers\n</code></pre> <p>Remember</p> <p>Nunca revele suas chaves privadas, pois elas dão acesso direto aos fundos. Os passos a seguir são apenas demonstrativos.</p> <p>No arquivo <code>getSignature.js</code>, copie e edite o trecho a seguir. Além dos campos discutidos na seção Argumentos do Call Permit, você deve inserir o Chain ID da sua rede no Domain Separator para gerar a assinatura corretamente. Se usar um Chain ID incorreto, a assinatura será inválida e nenhuma transação poderá ser despachada.</p> getSignature.js <pre><code>import { ethers } from 'ethers';\n\nconst from = 'INSERT_FROM_ADDRESS';\nconst to = 'INSERT_TO_ADDRESS';\nconst value = 0;\nconst data =\n  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\nconst gaslimit = 100000;\nconst nonce = 'INSERT_SIGNERS_NONCE';\nconst deadline = 'INSERT_DEADLINE';\n\nconst createPermitMessageData = () =&gt; {\n  const message = {\n    from: from,\n    to: to,\n    value: value,\n    data: data,\n    gaslimit: gaslimit,\n    nonce: nonce,\n    deadline: deadline,\n  };\n\n  const typedData = {\n    types: {\n      CallPermit: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'gaslimit', type: 'uint64' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n      ],\n    },\n    primaryType: 'CallPermit',\n    domain: {\n      name: 'Call Permit Precompile',\n      version: '1',\n      chainId: INSERT-CHAIN-ID,\n      verifyingContract: '0x0000000000000000000000000000000000000802',\n    },\n    message: message,\n  };\n\n  return {\n    typedData,\n    message,\n  };\n};\n\nconst messageData = createPermitMessageData();\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst wallet = new ethers.Wallet(privateKey);\n\nconst signature = await wallet.signTypedData(messageData.typedData.domain, messageData.typedData.types, messageData.message);\n\nconsole.log(`Transaction successful with hash: ${signature}`);\n\nconst ethersSignature = ethers.Signature.from(signature);\nconst formattedSignature = {\n  r: ethersSignature.r,\n  s: ethersSignature.s,\n  v: ethersSignature.v,\n};\n\nconsole.log(formattedSignature);\n</code></pre> <p>Para executar o script:</p> <pre><code>node getSignature.js\n</code></pre> <p>No console, você verá a assinatura concatenada e os valores <code>v</code>, <code>r</code> e <code>s</code>. Copie-os, pois serão usados ao interagir com o Call Permit Precompile nas próximas seções.</p> <p></p> <p>Note</p> <p>Tome cuidado ao copiar os valores <code>v</code>, <code>r</code> e <code>s</code> para o método <code>dispatch</code> do precompile. A ordem no precompile pode não coincidir com a ordem de saída do script.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#interact-with-the-solidity-interface", "title": "Interaja com a Interface Solidity", "text": "<p>Agora que você gerou a assinatura do call permit, poderá testar a chamada da função <code>dispatch</code> do Call Permit Precompile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/call-permit/#dispatch-a-call", "title": "Despachar uma Chamada", "text": "<p>Ao enviar a função <code>dispatch</code>, use os mesmos argumentos que serviram para assinar o call permit. Para começar, volte à aba Deploy and Run no Remix e, em Deployed Contracts, expanda o contrato do call permit. Certifique-se de estar conectado à conta que consumirá o call permit e pagará as taxas. Em seguida:</p> <ol> <li>No campo from, informe o endereço da conta usada para assinar o call permit</li> <li>Copie e cole o endereço do contrato <code>SetMessage.sol</code></li> <li>Informe <code>0</code> no campo value</li> <li>Insira a representação hex do function selector da função <code>set</code> e a string que deseja definir como mensagem no contrato <code>SetMessage.sol</code>. Para este exemplo, use <code>hello world</code>:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li>Informe <code>100000</code> no campo gasLimit</li> <li>Informe o <code>deadline</code> usado ao assinar o call permit</li> <li>Copie o valor <code>v</code> obtido ao gerar a assinatura do call permit e cole em v</li> <li>Copie o valor <code>r</code> obtido ao gerar a assinatura do call permit e cole em r</li> <li>Copie o valor <code>s</code> obtido ao gerar a assinatura do call permit e cole em s</li> <li>Clique em transact para enviar a transação</li> <li>A MetaMask aparecerá para confirmar; clique em Confirm</li> </ol> <p></p> <p>Quando a transação for concluída, você poderá verificar se a mensagem foi atualizada para <code>hello world</code>. Para isso:</p> <ol> <li>Expanda o contrato <code>SetMessage.sol</code></li> <li>Clique em get</li> <li>O resultado aparecerá abaixo da função e deve exibir <code>hello world</code></li> </ol> <p></p> <p>Parabéns! Você gerou uma assinatura de call permit e a usou para despachar uma chamada em nome do signatário.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/", "title": "Transferências Nativas de Tokens Entre Cadeias", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#introduction", "title": "Introdução", "text": "<p>Como apresentado no artigo sobre Comunicação Nativa Entre Cadeias na seção Learn, redes powered by Tanssi contam com a capacidade nativa de se comunicar e interoperar com qualquer outra rede do ecossistema. Essa comunicação entre cadeias permite transferências de tokens seguras e rápidas usando o formato Cross-Consensus Message (XCM), que facilita a comunicação entre diferentes sistemas de consenso.</p> <p>O protocolo de comunicação que possibilita as transferências é construído sobre o Substrate e opera em um nível mais baixo que o EVM, o que dificulta o acesso direto para desenvolvedores EVM.</p> <p>Ainda assim, redes EVM contam com um precompile XCM que preenche a lacuna entre as camadas de execução, expondo uma interface de smart contract que abstrai as complexidades subjacentes e torna a execução de transferências cross-chain tão simples quanto qualquer chamada de contrato.</p> <p>Este guia mostra como interagir com o precompile XCM Interface para executar transferências de tokens entre cadeias via Ethereum API.</p> <p>O precompile XCM está localizado no seguinte endereço:</p> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#the-xcm-solidity-interface", "title": "A Interface Solidity XCM", "text": "<p>A interface <code>XCMInterface.sol</code> nas redes EVM da Tanssi é uma interface Solidity que permite aos desenvolvedores interagir com as funções do precompile.</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 59df8416\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight) \n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector b489262e\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 4461e6f5\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector d7c89659\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n}\n</code></pre> <p>A interface inclui as estruturas de dados necessárias e as funções a seguir:</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem, weight) — envia assets para outra rede compatível com EVM usando a transação <code>transfer_assets()</code> do pallet XCM ParâmetrosExemplo <ul> <li><code>paraId</code> uint32 - ID da rede de destino</li> <li><code>beneficiary</code> address - conta do tipo ECDSA na cadeia de destino que receberá os tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - array de assets a enviar</li> <li><code>feeAssetItem</code> uint32 - índice do asset que pagará as taxas</li> <li><code>weight</code> Weight memory - gás máximo de toda a operação. Definir <code>uint64::MAX</code> em <code>refTime</code> equivale na prática a weight ilimitado</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsToPara32(paraId, beneficiary, assets,feeAssetItem, weight) — envia assets para uma rede Substrate usando a transação <code>transfer_assets()</code> do pallet XCM ParâmetrosExemplo <ul> <li><code>paraId</code> uint32 - ID da rede de destino</li> <li><code>beneficiary</code> bytes32 - conta do tipo SR25519 na cadeia de destino que receberá os tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - array de assets a enviar</li> <li><code>feeAssetItem</code> uint32 - índice do asset que pagará as taxas</li> <li><code>weight</code> Weight memory - gás máximo de toda a operação. Definir <code>uint64::MAX</code> em <code>refTime</code> equivale na prática a weight ilimitado</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem, weight) — envia assets para a relay chain usando a transação <code>transfer_assets()</code> do pallet XCM ParâmetrosExemplo <ul> <li><code>beneficiary</code> bytes32 - conta do tipo sr25519 na relay chain que receberá os tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - array de assets a enviar</li> <li><code>feeAssetItem</code> uint32 - índice do asset que pagará as taxas</li> <li><code>weight</code> Weight memory - gás máximo de toda a operação. Definir <code>uint64::MAX</code> em <code>refTime</code> equivale na prática a weight ilimitado</li> </ul> <ul> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsLocation(dest, beneficiary, assets, feeAssetItem, weight) — envia assets usando a transação <code>transfer_assets()</code> do pallet XCM ParâmetrosExemplo <ul> <li><code>dest</code> Location memory - cadeia de destino</li> <li><code>beneficiary</code> Location memory - conta na cadeia de destino que receberá os tokens</li> <li><code>assets</code> AssetLocationInfo[] memory - array de assets a enviar</li> <li><code>feeAssetItem</code> uint32 - índice do asset que pagará as taxas</li> <li><code>weight</code> Weight memory - gás máximo de toda a operação. Definir <code>uint64::MAX</code> em <code>refTime</code> equivale na prática a weight ilimitado</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>beneficiary</code> - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#interact-with-the-solidity-interface", "title": "Interaja com a Interface Solidity", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, configure sua carteira para sua rede EVM e tenha uma conta com tokens nativos. Você pode adicionar sua rede EVM à MetaMask com um clique no Tanssi dApp. Ou configurar a MetaMask para a Tanssi com a rede EVM de demonstração.</p> <p>Note</p> <p>É necessário ter canais de comunicação estabelecidos com a cadeia de destino antes de usar a funcionalidade deste precompile. Para isso, consulte o guia Gerenciar Canais de Comunicação Entre Cadeias. Além disso, se o token transferido for nativo da sua rede, a cadeia de destino deve ter registrado o asset estrangeiro.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode interagir com o precompile XCM Interface usando o Remix. Para adicioná-lo ao Remix, siga:</p> <ol> <li>Obtenha uma cópia de <code>XCMInterface.sol</code></li> <li>Cole o conteúdo em um arquivo do Remix chamado <code>XcmInterface.sol</code></li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#compile-the-contract", "title": "Compile o Contrato", "text": "<p>Em seguida, compile a interface no Remix:</p> <ol> <li>Clique na aba Compile (segunda de cima)</li> <li>Clique em Compile XCMInterface.sol para compilar</li> </ol> <p></p> <p>Quando a compilação concluir, um check verde aparecerá ao lado da aba Compile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#access-the-contract", "title": "Acesse o Contrato", "text": "<p>Em vez de implantar o precompile, acesse a interface informando o endereço do contrato pré-compilado:</p> <ol> <li>Clique na aba Deploy and Run logo abaixo de Compile no Remix. Os contratos pré-compilados já estão acessíveis em seus endereços, portanto não há etapa de deployment</li> <li>Certifique-se de que Injected Provider - Metamask está selecionado em ENVIRONMENT. Ao selecionar, a MetaMask pode solicitar conexão com o Remix</li> <li>Garanta que a conta correta apareça em ACCOUNT</li> <li>Selecione XCM - XCMInterface.sol em CONTRACT. Como é um contrato pré-compilado, não há deployment; apenas informe o endereço do precompile no campo At Address</li> <li>Informe o endereço do precompile: <code>0x0000000000000000000000000000000000000804</code> e clique em At Address</li> </ol> <p></p> <p>O precompile XCM Interface aparecerá em Deployed Contracts.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-evm-chains", "title": "Envie tokens para outra rede compatível com EVM", "text": "<p>Para enviar tokens a uma conta em outra rede compatível com EVM, siga:</p> <ol> <li>Expanda a função transferAssetsToPara20</li> <li>Informe o ID da rede (<code>paraId</code>)</li> <li>Informe a conta de destino (20 bytes, estilo Ethereum)</li> <li> <p>Especifique os tokens a transferir. Este parâmetro é um array com pelo menos um asset; cada asset é definido por seu endereço e montante</p> <p>Note</p> <p>Os tokens são especificados pelo endereço ERC-20. Se o token que você deseja transferir for o nativo da rede, a precompilada ERC-20 do token nativo ajuda a referenciá-lo por meio de uma interface ERC-20.</p> </li> <li> <p>Informe o índice do asset que pagará as taxas (baseado em zero)</p> </li> <li>Informe o gás máximo da transação, derivado de <code>refTime</code> e <code>proofSize</code>. Na prática, definir <code>refTime</code> como <code>uint64::MAX</code> equivale a weight ilimitado</li> <li>Clique em transact</li> <li>A MetaMask aparecerá para revisão; clique em Confirm para enviar</li> </ol> <p></p> <p>Após a confirmação, aguarde alguns blocos para o saldo aparecer na cadeia de destino.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-substrate-chains", "title": "Envie Tokens para uma Rede Substrate", "text": "<p>Para enviar tokens a uma conta em uma rede Substrate, siga:</p> <ol> <li>Expanda a função transferAssetsToPara32</li> <li>Informe o ID da rede (<code>paraId</code>)</li> <li>Informe a conta de destino do tipo sr25519</li> <li> <p>Especifique os tokens a transferir. Este parâmetro é um array com pelo menos um asset; cada asset é definido por seu endereço e montante</p> <p>Note</p> <p>Os tokens são especificados pelo endereço ERC-20. Se o token que você deseja transferir for o nativo da rede, a precompilada ERC-20 do token nativo ajuda a referenciá-lo por meio de uma interface ERC-20.</p> </li> <li> <p>Informe o índice do asset que pagará as taxas (baseado em zero)</p> </li> <li>Informe o gás máximo da transação, derivado de <code>refTime</code> e <code>proofSize</code>. Na prática, definir <code>refTime</code> como <code>uint64::MAX</code> equivale a weight ilimitado</li> <li>Clique em transact</li> <li>A MetaMask aparecerá para revisão; clique em Confirm para enviar</li> </ol> <p></p> <p>Após a confirmação, aguarde alguns blocos para o saldo aparecer na cadeia de destino.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-relay-chain", "title": "Envie Tokens para a Relay Chain", "text": "<p>Para enviar tokens a uma conta na relay chain, siga:</p> <ol> <li>Expanda a função transferAssetsToRelay</li> <li>Informe a conta de destino do tipo sr25519</li> <li> <p>Especifique os tokens a transferir. Este parâmetro é um array com pelo menos um asset; cada asset é definido por seu endereço e montante</p> <p>Note</p> <p>Os tokens são especificados pelo endereço ERC-20. Se o token que você deseja transferir for o nativo da rede, a precompilada ERC-20 do token nativo ajuda a referenciá-lo por meio de uma interface ERC-20.</p> </li> <li> <p>Informe o índice do asset que pagará as taxas (baseado em zero)</p> </li> <li>Informe o gás máximo da transação, derivado de <code>refTime</code> e <code>proofSize</code>. Na prática, definir <code>refTime</code> como <code>uint64::MAX</code> equivale a weight ilimitado</li> <li>Clique em transact</li> <li>A MetaMask aparecerá para revisão; clique em Confirm para enviar</li> </ol> <p></p> <p>Após a confirmação, aguarde alguns blocos para o saldo aparecer na cadeia de destino.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-locations", "title": "Envie Tokens para Locais Específicos", "text": "<p>Esta função é mais genérica e permite especificar cadeia de destino, conta e assets usando XCM Multilocations. Para enviar tokens para locais específicos:</p> <ol> <li>Expanda a função transferAssetsLocation</li> <li>Informe a multilocation que especifica a cadeia de destino. Qualquer cadeia pode ser informada, independentemente de tipo ou configuração</li> <li>Informe a multilocation que especifica a conta de destino. Qualquer conta pode ser informada, independentemente do tipo (ECDSA, sr25519 ou outro)</li> <li> <p>Especifique os tokens a transferir. Este parâmetro é um array com pelo menos um asset; cada asset é definido por sua multilocation e montante</p> <p>Note</p> <p>Os tokens são especificados pelo endereço ERC-20. Se o token que você deseja transferir for o nativo da rede, a precompilada ERC-20 do token nativo ajuda a referenciá-lo por meio de uma interface ERC-20.</p> </li> <li> <p>Informe o índice do asset que pagará as taxas (baseado em zero)</p> </li> <li>Informe o gás máximo da transação, derivado de <code>refTime</code> e <code>proofSize</code>. Na prática, definir <code>refTime</code> como <code>uint64::MAX</code> equivale a weight ilimitado</li> <li>Clique em transact</li> <li>A MetaMask aparecerá para revisão; clique em Confirm para enviar</li> </ol> <p></p> <p>Após a confirmação, aguarde alguns blocos para o saldo aparecer na cadeia de destino.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/", "title": "Pré-compilado ERC-20 do Token Nativo", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#introduction", "title": "Introdução", "text": "<p>O contrato pré-compilado ERC-20 do token nativo em redes EVM powered by Tanssi permite que desenvolvedores interajam com o token nativo do protocolo por meio de uma interface ERC-20. Embora o token nativo da sua rede não seja um ERC-20, agora você pode interagir com ele como se fosse um ERC-20 padrão.</p> <p>Um dos principais benefícios desse precompile é eliminar a necessidade de ter uma representação embrulhada do token do protocolo como um smart contract ERC-20, como o WETH no Ethereum. Além disso, minimiza a necessidade de múltiplas representações embrulhadas do mesmo token do protocolo. Consequentemente, dApps que precisam interagir com o token do protocolo via uma interface ERC-20 podem fazê-lo sem precisar de um contrato separado.</p> <p>Por baixo dos panos, a precompilada ERC-20 executa ações específicas do Substrate relacionadas ao módulo de saldos, escrito em Rust. O módulo de saldos fornece funcionalidades para lidar com diversos tipos de saldos.</p> <p>Este guia mostrará como interagir com tokens UNIT, o token nativo do protocolo para redes de teste rápido no Dancelight, por meio da precompilada ERC-20. Você pode seguir e adaptar este guia para interagir com sua própria rede.</p> <p>A precompilada está localizada no seguinte endereço:</p> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#the-erc20-interface", "title": "Interface Solidity do ERC-20", "text": "<p>A interface <code>ERC20.sol</code> nas redes EVM da Tanssi segue o Padrão de Token EIP-20, que é a interface padrão de API para tokens em smart contracts. O padrão define as funções e eventos exigidos para que um contrato de token seja interoperável com diferentes aplicações.</p> ERC20.sol <pre><code>/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n</code></pre> <p>Note</p> <p>A precompilada ERC-20 não inclui as funções <code>deposit</code> e <code>withdraw</code> nem os eventos associados esperados de um token embrulhado, como o WETH.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#interact-with-the-solidity-interface", "title": "Interagir com a Interface Solidity", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisará ter sua carteira configurada para funcionar com sua rede EVM com Tanssi e uma conta com tokens nativos. Você pode adicionar sua rede EVM ao MetaMask com um clique no Tanssi dApp. Ou, se preferir, configure o MetaMask para Tanssi com a rede EVM de demonstração.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#add-token-to-evm-wallet", "title": "Adicionar token a uma carteira EVM", "text": "<p>Se quiser interagir com o token nativo da rede como faria com um ERC-20, adicione um token personalizado à sua carteira compatível com EVM usando o endereço da precompilada. Esta seção mostra como adicionar um ativo externo ao MetaMask.</p> <p>Para começar, abra o MetaMask, conecte-se à sua rede e:</p> <ol> <li>Acesse a aba Assets</li> <li>Clique em Import tokens</li> </ol> <p></p> <p>Agora, crie o token personalizado:</p> <ol> <li>Informe o endereço da precompilada para o endereço do contrato do token: <code>0x0000000000000000000000000000000000000800</code>. Ao inserir o endereço, os campos Token Symbol e Token Decimal devem preencher automaticamente. Caso não aconteça, use <code>UNIT</code> como símbolo e <code>18</code> como casas decimais. Lembre que o padrão de casas decimais das redes EVM da Tanssi é <code>18</code>, o mesmo do Ethereum</li> <li>Clique em Next</li> </ol> <p></p> <p>O MetaMask solicitará a confirmação da importação. Revise os detalhes e clique em Import Tokens para importar os tokens UNIT na carteira.</p> <p></p> <p>Pronto! Você adicionou o token UNIT como um ERC-20 personalizado na sua rede EVM da Tanssi.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode interagir com a precompilada ERC-20 usando o Remix. Para adicioná-la ao Remix, você precisará:</p> <ol> <li>Obter uma cópia de <code>ERC20.sol</code></li> <li>Colar o conteúdo em um arquivo do Remix chamado <code>IERC20.sol</code></li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#compile-the-contract", "title": "Compilar o Contrato", "text": "<p>Em seguida, compile a interface no Remix:</p> <ol> <li>Clique na aba Compile (segunda de cima)</li> <li>Compile a interface clicando em Compile IERC20.sol</li> </ol> <p></p> <p>Quando a compilação for concluída, um check verde aparecerá ao lado da aba Compile.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#access-the-contract", "title": "Acessar o Contrato", "text": "<p>Em vez de implantar a precompilada ERC-20, você acessará a interface informando o endereço do contrato pré-compilado:</p> <ol> <li>Clique na aba Deploy and Run logo abaixo da aba Compile no Remix. Observe que contratos pré-compilados já estão acessíveis em seus respectivos endereços, portanto não há etapa de implantação</li> <li>Certifique-se de que Injected Web3 está selecionado em ENVIRONMENT. Ao selecionar Injected Web3, o MetaMask pode solicitar conexão ao Remix caso ainda não esteja</li> <li>Verifique se a conta correta aparece em ACCOUNT</li> <li>Garanta que IERC20 - IERC20.sol esteja selecionado em CONTRACT. Por ser um contrato pré-compilado, não há implantação; em vez disso, informe o endereço da precompilada no campo At Address</li> <li>Informe o endereço da precompilada ERC-20: <code>0x0000000000000000000000000000000000000800</code> e clique em At Address</li> </ol> <p></p> <p>A precompilada IERC20 aparecerá na lista de Deployed Contracts.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#get-basic-token-information", "title": "Obter Informações Básicas do Token", "text": "<p>A interface ERC-20 permite obter rapidamente informações como oferta total, nome, símbolo e casas decimais. Para recuperar essas informações:</p> <ol> <li>Expanda o contrato IERC20 em Deployed Contracts</li> <li>Clique em decimals para obter as casas decimais do token nativo</li> <li>Clique em name para obter o nome do token</li> <li>Clique em symbol para obter o símbolo do token</li> <li>Clique em totalSupply para obter a oferta total de tokens nativos na rede</li> </ol> <p></p> <p>Os resultados de cada chamada são exibidos abaixo das respectivas funções.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#get-account-balance", "title": "Consultar Saldo de uma Conta", "text": "<p>Você pode verificar o saldo de qualquer endereço na rede chamando <code>balanceOf</code> e fornecendo um endereço:</p> <ol> <li>Expanda a função balanceOf</li> <li>Informe o endereço que deseja consultar no campo owner</li> <li>Clique em call</li> </ol> <p></p> <p>O saldo será exibido abaixo da função <code>balanceOf</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#approve-a-spend", "title": "Aprovar um Gasto", "text": "<p>Para aprovar uma permissão de gasto, forneça um endereço para o spender e o número de tokens que ele pode gastar. O spender pode ser uma conta externa (EOA) ou um smart contract. Neste exemplo, você aprovará uma allowance de 1 token UNIT. Siga:</p> <ol> <li>Expanda a função approve</li> <li>Informe o endereço do spender. Você deve ter criado duas contas antes de começar; use a segunda conta como spender</li> <li>Informe o valor de tokens que o spender pode gastar em value. Para este exemplo, permita 1 token UNIT em Wei (<code>1000000000000000000</code>)</li> <li>Clique em transact</li> <li>A MetaMask aparecerá; revise os detalhes e clique em Confirm para enviar</li> </ol> <p></p> <p>Após a confirmação, o saldo da sua conta permanece o mesmo: você apenas aprovou a permissão e o spender ainda não gastou os fundos. Na próxima seção, você usará <code>allowance</code> para verificar que o spender pode gastar 1 token UNIT em seu nome.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#get-allowance-of-spender", "title": "Obter Allowance do Spender", "text": "<p>Para conferir se o spender recebeu a allowance aprovada em Aprovar um Gasto:</p> <ol> <li>Expanda a função allowance</li> <li>Informe seu endereço em owner</li> <li>Informe o endereço do spender usado na seção anterior</li> <li>Clique em call</li> </ol> <p></p> <p>Quando a chamada finalizar, a allowance do spender será exibida e deve ser equivalente a 1 token UNIT (<code>1000000000000000000</code>).</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#send-transfer", "title": "Enviar Transferência", "text": "<p>Para enviar tokens diretamente da sua conta para outra, chame <code>transfer</code>:</p> <ol> <li>Expanda a função transfer</li> <li>Informe o endereço para o qual deseja enviar tokens UNIT</li> <li>Informe a quantidade de tokens UNIT a enviar. Neste exemplo, envie 1 UNIT (<code>1000000000000000000</code>)</li> <li>Clique em transact</li> <li>A MetaMask aparecerá; revise os detalhes e clique em Confirm para enviar</li> </ol> <p></p> <p>Após a transação, você pode checar seu saldo usando <code>balanceOf</code> ou pelo MetaMask. Verá que seu saldo diminuiu em 1 UNIT. Use <code>balanceOf</code> também para confirmar que o saldo do destinatário aumentou em 1 UNIT conforme esperado.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/erc20/#send-transferfrom", "title": "Enviar Transferência de uma Conta Específica", "text": "<p>Até agora, você aprovou uma allowance de 1 UNIT para o spender e enviou 1 UNIT via <code>transfer</code>. A função <code>transferFrom</code> difere da <code>transfer</code> padrão porque permite definir de qual endereço os tokens serão enviados. Você pode informar um endereço com allowance ou seu próprio endereço (se houver saldo). Neste exemplo, use a conta do spender para iniciar a transferência dos fundos permitidos do owner para o próprio spender. O spender poderia enviar para qualquer conta, mas aqui enviaremos do owner para o spender.</p> <p>Primeiro, mude para a conta do spender no MetaMask. Ao trocar, o endereço selecionado no Remix em Accounts passará a ser o do spender.</p> <p></p> <p>Agora, inicie e envie a transferência:</p> <ol> <li>Expanda a função transferFrom</li> <li>Informe seu endereço (do owner) no campo from</li> <li>Informe o endereço do destinatário, que deve ser o endereço do spender, no campo to</li> <li>Informe a quantidade de tokens UNIT a enviar. O spender só pode enviar 1 UNIT, então insira <code>1000000000000000000</code></li> <li>Clique em transact</li> </ol> <p></p> <p>Após a transação, verifique o saldo do owner e do spender usando <code>balanceOf</code>. O saldo do spender deve ter aumentado em 1 UNIT, e a allowance deve ter sido consumida. Para confirmar que o spender não tem mais allowance, chame <code>allowance</code> informando os endereços de owner e spender; o resultado deve ser 0.</p> <p></p> <p>E é isso! Você interagiu com a precompilada ERC-20 usando MetaMask e Remix!</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/", "title": "Ativos Externos como ERC-20", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#introduction", "title": "Introdução", "text": "<p>Como apresentado no artigo Comunicação Cross-Chain Nativa, as redes implantadas através da Tanssi podem se comunicar e interagir com qualquer outra rede no ecossistema. Este ambiente multi-chain leva a um mundo multi-ativo, onde a transferência perfeita de ativos, dados e valor entre diferentes redes amplia as possibilidades de construir casos de uso em diversos setores, como finanças (DeFi), ativos do mundo real (RWAs) e outros.</p> <p>Ativos externos são tokens nativos de outra blockchain, ou, em outras palavras, ativos cuja cadeia de reserva não é a cadeia com a qual você está interagindo. As redes Tanssi podem registrar ativos externos para permitir sua entrada. Para fazer isso, é necessário estabelecer um canal XCM com a outra cadeia e, em seguida, registrar um de seus ativos nativos como um ativo externo. Os ativos externos registrados se comportam, em certa medida, da mesma forma que os locais.</p> <p>A pré-compilação de ativos ERC-20 permite que as redes baseadas no Template Tanssi EVM acessem qualquer ativo externo registrado através da interface ERC-20 padrão. Consequentemente, contratos inteligentes implantados na rede podem interagir com esses ativos da mesma forma que fariam com qualquer outro ERC-20 regular.</p> <p>O endereço que representa o contrato ERC-20 é formado com as primeiras trinta e seis posições (dezoito bytes) definidas para o valor máximo e as últimas quatro posições (dois bytes) substituídas pela representação hexadecimal do identificador de ativo registrado:</p> <p>Por exemplo, para o ativo cujo ID é <code>1</code>, as últimas quatro posições devem ser substituídas por <code>0001</code>, e para um ativo com um ID de <code>10</code>, essas quatro posições devem ser substituídas por <code>000A</code>.</p> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#prerequisites", "title": "Pré-requisitos", "text": "<p>Para acompanhar o conteúdo deste guia, você precisará:</p> <ul> <li>Acesso a uma rede Tanssi EVM executando runtime 500 ou superior</li> <li>Um canal XCM bidirecional estabelecido para outra cadeia. Para gerenciar os canais da sua rede, consulte o artigo Gerenciar Canais de Comunicação Cross-Chain</li> <li>Um ativo externo registrado. Uma vez que os canais XCM estejam abertos, o registro de ativos pode ser facilmente feito usando o dApp, conforme explicado no guia Registrar Ativos Externos</li> <li>Finalmente, você precisará de uma carteira compatível com EVM configurada para funcionar com sua rede. Você também pode conectar sua carteira à rede demo EVM.</li> </ul> <p>Os exemplos neste guia são baseados na rede demo Tanssi EVM, que já possui canais abertos para outras redes e ativos externos registrados, como mostra a imagem a seguir:</p> <ol> <li>O ativo externo registrado (UNIT) que será usado nas seções a seguir</li> <li>Outros ativos externos disponíveis ainda não registrados</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#the-erc20-interface", "title": "A Interface Solidity ERC-20", "text": "<p>A interface <code>ERC20.sol</code> nas redes Tanssi EVM segue o EIP-20 Token Standard, que é a interface API padrão para tokens dentro de contratos inteligentes. O padrão define as funções e eventos necessários que um contrato de token deve implementar para ser interoperável com diferentes aplicações.</p> ERC20.sol <pre><code>/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n</code></pre> <p>Note</p> <p>A pré-compilação de ativos externos ERC-20 não inclui funções <code>deposit</code> e <code>withdraw</code> e eventos subsequentes esperados de um contrato de token embrulhado, como WETH.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#add-token-to-evm-wallet", "title": "Adicionar Token à uma Carteira EVM", "text": "<p>Se você quiser interagir com os ativos externos registrados da sua rede como faria com um ERC-20, pode adicioná-los à sua carteira usando o prefixo de endereço de pré-compilação e o ID do ativo. Esta seção irá guiá-lo através da adição de um ativo externo ao MetaMask.</p> <p>Para começar, abra o MetaMask e certifique-se de que você está conectado à sua rede e:</p> <ol> <li> <p>Vá para a aba Tokens</p> </li> <li> <p>Clique em Importar tokens</p> </li> </ol> <p></p> <pre><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001\n</code></pre> <ol> <li>Insira o endereço de pré-compilação para o endereço do contrato do token. Ao inserir o endereço, os campos Símbolo do token e Decimais do token devem ser preenchidos automaticamente. Se não preencherem, você pode inserir <code>UNIT</code> para o símbolo e <code>12</code> para as casas decimais</li> <li>Clique em Próximo</li> </ol> <p></p> <p>MetaMask solicitará que você confirme a importação. Você pode verificar os detalhes do token e clicar em Importar tokens para importar tokens UNIT para sua carteira.</p> <p></p> <p>E é isso! Você adicionou com sucesso o ativo externo do token UNIT como um token ERC-20 personalizado na rede demo Tanssi EVM.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#interact-with-the-solidity-interface-via-remix", "title": "Interagir com a Interface Solidity via Remix", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode interagir com a pré-compilação de ativos externos ERC-20 usando Remix. Para adicionar a pré-compilação ao Remix, você precisará:</p> <ol> <li>Obter uma cópia de <code>ERC20.sol</code></li> <li>Cole o conteúdo do arquivo em um arquivo Remix chamado <code>IERC20.sol</code></li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#compile-the-contract", "title": "Compilar o Contrato", "text": "<p>Em seguida, você precisará compilar a interface no Remix:</p> <ol> <li>Clique na aba Compilar, a segunda de cima</li> <li>Compile a interface clicando em Compilar IERC20.sol</li> </ol> <p></p> <p>Quando a compilação for concluída, você verá uma marca de seleção verde ao lado da aba Compilar.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#access-the-contract", "title": "Acessar o Contrato", "text": "<p>Em vez de implantar o contrato inteligente, você acessará a interface através do endereço da pré-compilação de ativos externos:</p> <ol> <li>Clique na aba Deploy and Run diretamente abaixo da aba Compilar no Remix. Observe que os contratos pré-compilados já estão acessíveis em seus respectivos endereços. Portanto, não há nenhuma etapa de implantação</li> <li>Certifique-se de que Injected Web3 esteja selecionado no menu suspenso ENVIRONMENT. Depois de selecionar Injected Web3, você pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ela ainda não esteja conectada</li> <li>Certifique-se de que a conta correta seja exibida em ACCOUNT</li> <li>Certifique-se de que IERC20 - IERC20.sol esteja selecionado no menu suspenso CONTRACT. Dado que é um contrato pré-compilado, não há nenhuma etapa de implantação. Em vez disso, você fornecerá o endereço da pré-compilação no campo At Address</li> <li>Forneça o endereço da pré-compilação ERC-20 (que é <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001</code> neste exemplo) e clique em At Address</li> <li>A pré-compilação IERC20 aparecerá na lista de Deployed Contracts </li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-basic-token-information", "title": "Obter Informações Básicas do Token", "text": "<p>A interface ERC-20 permite obter rapidamente informações sobre o token, incluindo a oferta total do token, nome, símbolo e casas decimais. Você pode recuperar essas informações seguindo estas etapas:</p> <ol> <li>Expanda o contrato IERC20 em Deployed Contracts</li> <li>Clique em decimals para obter as casas decimais do token do protocolo nativo da sua rede</li> <li>Clique em name para obter o nome do token</li> <li>Clique em symbol para obter o símbolo do token</li> <li>Clique em totalSupply para obter a oferta total de tokens nativos em sua rede</li> </ol> <p></p> <p>Os resultados de cada chamada de função são exibidos sob as respectivas funções.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-account-balance", "title": "Obter Saldo da Conta", "text": "<p>Você pode verificar o saldo de qualquer endereço em sua rede chamando a função <code>balanceOf</code> e passando um endereço:</p> <ol> <li>Expanda a função balanceOf</li> <li>Insira um endereço para o qual você gostaria de verificar o saldo para o owner</li> <li>Clique em call</li> </ol> <p></p> <p>Seu saldo será exibido na função <code>balanceOf</code>.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#send-transfer", "title": "Enviar Transferência", "text": "<p>Para enviar tokens da sua conta diretamente para outra conta, você pode chamar a função <code>transfer</code> seguindo estas etapas:</p> <ol> <li>Expanda a função transfer</li> <li>Insira o endereço para enviar tokens UNIT</li> <li>Insira a quantidade de tokens UNIT para enviar. Para este exemplo, você pode enviar 1 token UNIT (<code>1000000000000</code>)</li> <li>Clique em transact</li> <li>O MetaMask aparecerá e você será solicitado a revisar os detalhes da transação. Clique em Confirmar para enviar a transação</li> </ol> <p></p> <p>Assim que a transação for concluída, você poderá verificar seu saldo usando a função <code>balanceOf</code> ou olhando para o MetaMask. Você notará que seu saldo diminuiu em 1 token UNIT. Você também pode usar a função <code>balanceOf</code> para garantir que o saldo dos destinatários tenha aumentado em 1 token UNIT, conforme o esperado.</p> <p>E é isso! Você interagiu com sucesso com a pré-compilação de ativos externos ERC-20 usando MetaMask e Remix!</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/", "title": "Interagindo com o Proxy Precompile", "text": ""}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#introduction", "title": "Introdução", "text": "<p>A Proxy Precompile permite que as contas definam contas proxy por meio da API Ethereum. As contas proxy podem realizar ações limitadas em nome da conta com proxy, como governança, transferências de saldo, gerenciamento ou transações privilegiadas, entre outras.</p> <p>Se um usuário quisesse fornecer a outro usuário acesso a um número limitado de ações em seu nome, tradicionalmente, o único método para fazê-lo seria compartilhar a chave privada dessa conta. No entanto, as redes EVM powered by Tanssi incluem o módulo proxy, fornecendo uma camada adicional de segurança. Com proxies, muitas contas podem realizar ações para uma conta primária, e tais permissões podem ser revogadas a qualquer momento. Isto é melhor se, por exemplo, um usuário quiser manter sua carteira segura em armazenamento a frio, mas ainda quiser acessar partes da funcionalidade da carteira, como governança ou staking.</p> <p>Note</p> <p>O Proxy Precompile só pode ser chamado de uma Externally Owned Account (EOA) ou pela Batch Precompile.</p> <p>Para saber mais sobre contas proxy e como configurá-las para seus próprios propósitos sem o uso do Proxy Precompile, visite a página Proxy Accounts.</p> <p>A Proxy Precompile está localizada no seguinte endereço:</p> <pre><code>0x0000000000000000000000000000000000000805\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequências inesperadas. As precompiladas do Tanssi são derivadas das do Moonbeam; portanto, familiarize-se com as considerações de segurança das precompiladas do Moonbeam.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#prerequisites", "title": "Pré-requisitos", "text": "<p>Para acompanhar o conteúdo deste guia, você precisará:</p> <ul> <li>Acesso a uma rede EVM powered by Tanssi executando runtime 700 ou superior</li> <li>Uma carteira compatível com EVM configurada para funcionar com sua rede. Você também pode conectar sua carteira à rede EVM de demonstração</li> <li>Uma conta com fundos suficientes para pagar as taxas e depósitos necessários</li> <li>Uma segunda conta que você controla para usar como proxy</li> </ul>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#the-proxy-solidity-interface", "title": "A Interface Solidity do Proxy", "text": "<p><code>Proxy.sol</code> é uma interface que permite que desenvolvedores interajam com as funções da precompilação.</p> Proxy.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @author The Moonsong Labs Team\n/// @title Pallet Proxy Interface\n/// @title The interface through which solidity contracts will interact with the Proxy pallet\ninterface Proxy {\n    /// @dev Defines the proxy permission types.\n    /// The values start at `0` (most permissive) and are represented as `uint8`\n    enum ProxyType {\n        Any,\n        NonTransfer,\n        Governance,\n        Staking,\n        CancelProxy,\n        Balances,\n        AuthorMapping,\n        IdentityJudgement\n    }\n\n    /// @dev Register a proxy account for the sender that is able to make calls on its behalf\n    /// @custom:selector 74a34dd3\n    /// @param delegate The account that the caller would like to make a proxy\n    /// @param proxyType The permissions allowed for this proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function addProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Removes a proxy account from the sender\n    /// @custom:selector fef3f708\n    /// @param delegate The account that the caller would like to remove as a proxy\n    /// @param proxyType The permissions currently enabled for the removed proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function removeProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Unregister all proxy accounts for the sender\n    /// @custom:selector 14a5b5fa\n    function removeProxies() external;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 0d3cff86\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxy(\n        address real,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 685b9d2f\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param forceProxyType Specify the exact proxy type to be used and checked for this call\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxyForceType(\n        address real,\n        ProxyType forceProxyType,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Checks if the caller has an account proxied with a given proxy type\n    /// @custom:selector e26d38ed\n    /// @param real The real account that maybe has a proxy\n    /// @param delegate The account that the caller has maybe proxied\n    /// @param proxyType The permissions allowed for the proxy\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    /// @return exists True if a proxy exists, False otherwise\n    function isProxy(\n        address real,\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external view returns (bool exists);\n}\n</code></pre> <p>A interface inclui as estruturas de dados necessárias, juntamente com as seguintes funções:</p> addProxy(delegate, proxyType, delay) — registra uma conta proxy para o remetente após um número especificado de blocos <code>delay</code> (geralmente zero). Falhará se um proxy para o chamador já existir ParâmetrosExemplo <ul> <li><code>delegate</code> address - o endereço do proxy</li> <li><code>proxyType</code> ProxyType - o tipo de delegação que define as funções específicas que o proxy terá permissão para executar</li> <li><code>delay</code> uint32 - número de blocos a esperar até que o proxy seja habilitado</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxy(delegate, proxyType, delay) — remove um proxy registrado para o remetente ParâmetrosExemplo <ul> <li><code>delegate</code> address - o endereço do proxy a ser removido</li> <li><code>proxyType</code> ProxyType - o tipo de delegação a ser removido</li> <li><code>delay</code> uint32 - número de blocos a esperar até que a remoção entre em vigor</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxies() — remove todas as contas proxy delegadas ao remetente isProxy(real, delegate, proxyType, delay) — retorna <code>true</code> se o endereço delegado for um proxy do tipo <code>proxyType</code>, para o endereço <code>real</code>, com o <code>delay</code> especificado ParâmetrosExemplo <ul> <li><code>real</code> address - a conta que concede permissões ao proxy</li> <li><code>delegate</code> address - o endereço do proxy</li> <li><code>proxyType</code> ProxyType - o tipo de delegação</li> <li><code>delay</code> uint32 - número de blocos a aguardar</li> </ul> <ul> <li><code>delegate</code> - 0xbB8919d5DDfc85F4D15820a9e58018f1cfB39a2F</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> <p>O parâmetro <code>proxyType</code> é definido pela seguinte enumeração <code>ProxyType</code>, onde os valores começam em <code>0</code> com o tipo de proxy mais permissivo e são representados como valores <code>uint8</code>:</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#proxy-types", "title": "Tipos de Proxy", "text": "<p>Há vários tipos de funções de proxy que podem ser delegadas a contas, representadas em <code>Proxy.sol</code> através da enumeração <code>ProxyType</code>. A lista a seguir inclui todos os proxies possíveis e o tipo de transações que eles podem fazer em nome da conta principal:</p> <ul> <li>Any — o proxy any permitirá que a conta proxy faça qualquer tipo de transação. Observe que as transferências de saldo só são permitidas para EOAs, não para contratos ou Precompiles</li> <li>NonTransfer — o proxy de não transferência permite que a conta proxy faça qualquer tipo de transação em que o <code>msg.value</code> seja verificado como zero</li> <li>Governance - o proxy de governança permitirá que a conta proxy faça qualquer tipo de transação relacionada à governança</li> <li>CancelProxy - o proxy de cancelamento permitirá que a conta proxy rejeite e remova anúncios de proxy atrasados ​​(da conta principal). Atualmente, esta não é uma ação suportada pelo Proxy Precompile</li> <li>Balances - o proxy de saldos permitirá que a conta proxy faça apenas transferências de saldo para EOAs</li> </ul> <p>Note</p> <p>A interface Solidity contém mais tipos de proxy do que os listados acima. A lista anterior inclui apenas os tipos de proxy implementados no baseline EVM Template.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#interact-with-the-solidity-interface-via-remix", "title": "Interaja com a interface Solidity via Remix", "text": "<p>Esta seção irá guiá-lo pelas etapas para criar um proxy, verificar sua criação e revogar os privilégios do proxy. Estes exemplos são baseados na Tanssi demo EVM Network e usam Metamask. Este guia pode ser adaptado para sua própria rede EVM powered by Tanssi adicionando a URL RPC da sua rede para a carteira EVM de sua escolha.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#remix-set-up", "title": "Configuração do Remix", "text": "<p>Você pode interagir com a precompilação do Proxy usando Remix. Para adicionar a precompilação ao Remix, você precisará:</p> <ol> <li>Obter uma cópia de <code>Proxy.sol</code></li> <li>Cole o conteúdo do arquivo em um arquivo Remix chamado <code>Proxy.sol</code></li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#compile-the-contract", "title": "Compile o Contrato", "text": "<p>Em seguida, você precisará compilar a interface no Remix:</p> <ol> <li>Clique na guia Compilar, a segunda de cima</li> <li>Em seguida, para compilar a interface, clique em Compilar Proxy.sol</li> </ol> <p></p> <p>Quando a compilação estiver concluída, você verá uma marca de seleção verde ao lado da guia Compilar.</p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#access-the-contract", "title": "Acessar o Contrato", "text": "<p>Em vez de implantar o contrato inteligente, você acessará a interface através de seu endereço:</p> <ol> <li>Clique na guia Deploy and Run diretamente abaixo da guia Compile no Remix</li> <li>Certifique-se de que Injected Provider - Metamask esteja selecionado no menu suspenso ENVIRONMENT. Você pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ainda não esteja conectado</li> <li>Certifique-se de que a conta primária seja exibida em ACCOUNT</li> <li>Certifique-se de que Proxy - Proxy.sol esteja selecionado no menu suspenso CONTRACT. Dado que é um contrato pré-compilado, não há etapa de implantação. Em vez disso, você fornecerá o endereço da precompilação no campo At Address</li> <li>Forneça o endereço da precompilação do Proxy (que é <code>0x0000000000000000000000000000000000000805</code> neste exemplo) e clique em At Address</li> <li>A precompilação do Proxy aparecerá na lista de Deployed Contracts </li> </ol>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#add-proxy", "title": "Adicionar um Proxy", "text": "<p>Você pode adicionar proxies para sua conta chamando as funções de precompilação. No exemplo a seguir, você adicionará um proxy autorizado a executar qualquer transação em seu nome:</p> <ol> <li>Expanda o contrato Proxy Precompile para ver as funções disponíveis</li> <li>Encontre a função addProxy e pressione o botão para expandir a seção</li> <li>Insira o endereço de sua segunda conta como delegate, <code>0</code> como proxyType, o que significa <code>any</code>, e <code>0</code> como delay</li> <li>Clique em transact</li> <li>O MetaMask aparecerá e você será solicitado a revisar os detalhes da transação. Clique em Confirmar para executar a transação</li> </ol> <p>Note</p> <p>Ao construir a transação no Remix, o proxyType é representado como um <code>uint8</code>, em vez do enum <code>ProxyType</code> esperado. Em Solidity, os enums são compilados como <code>uint8</code>, então, quando você passa <code>0</code> para proxyType, você indica o primeiro elemento no enum <code>ProxyType</code>, que é o proxy <code>any</code>.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#check-proxy", "title": "Verifique uma existência de Proxy", "text": "<p>A função <code>isProxy</code> verifica se uma conta proxy existe. Após criar um proxy na etapa anterior, use os mesmos parâmetros para verificar se o proxy foi adicionado com sucesso:</p> <ol> <li>Expanda a função isProxy</li> <li>Insira sua conta principal como real, sua segunda conta (proxy) como delegate, <code>0</code> como proxyType e <code>0</code> como delay</li> <li>Clique em call</li> <li>As funções retornam se existe um proxy ou não. Neste exemplo, o proxy existe, portanto, a função retorna <code>true</code></li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/precompiles/proxy/#remove-proxy", "title": "Remover um Proxy", "text": "<p>Você pode revogar uma permissão de proxy quando não for mais necessária. Após criar um proxy na Adicionar Proxy, etapa, ele pode ser removido seguindo estas etapas:</p> <ol> <li>Expanda a função removeProxy</li> <li>Insira a conta proxy como delegate, <code>0</code> como proxyType e <code>0</code> como delay</li> <li>Clique em transact</li> <li>O MetaMask aparecerá e você será solicitado a revisar os detalhes da transação. Clique em Confirmar para executar a transação</li> </ol> <p>Depois que a transação for confirmada, se você repetir as etapas para verificar a existência de um proxy, o resultado deverá ser <code>false</code>.</p> <p></p> <p>E é isso! Você interagiu com sucesso com a precompilação do Proxy usando MetaMask e Remix!</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/wallets/", "title": "Carteiras", "text": "<p>Carteiras são ferramentas digitais que permitem aos usuários armazenar, gerenciar e transacionar com segurança seus ativos digitais. Elas armazenam as chaves criptográficas necessárias para acessar ativos digitais e permitem executar transações em redes blockchain.</p> <p>Para redes compatíveis com EVM, você pode usar qualquer carteira que suporte EVM, com a flexibilidade de adicionar configurações de rede personalizadas, permitindo conexão e interação contínuas com sua rede.</p> <p>As páginas desta seção fornecem uma visão geral de como começar com vários provedores de carteira. Ela aborda como criar e importar contas, conectar-se à sua rede e começar a interagir com ela.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/ledger/", "title": "Interagindo com EVM appchains powered by Tanssi Usando Ledger", "text": ""}, {"location": "builders/toolkit/ethereum-api/wallets/ledger/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de EVM appchains powered by Tanssi, como a demonstração Tanssi, têm uma variedade de opções quando se trata de carteiras. Em relação às carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, Ledger é uma das opções mais populares. A Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.</p> <p>Os dispositivos Ledger são carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles são usados para verificar e assinar as transações, mas ainda precisam de uma camada de software para fornecer a interface do usuário que interage com as redes, constrói as transações e envia as transações assinadas de volta para a rede assim que o usuário as tiver verificado.</p> <p>Este guia leva você por todas as etapas necessárias para usar seu dispositivo Ledger com EVM appchains powered by Tanssi.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/ledger/#setting-up-ledger-device", "title": "Configurando Seu Dispositivo Ledger", "text": "<p>Se você tem um dispositivo Ledger novo, consulte o site oficial para obter um guia sobre como iniciá-lo com a configuração inicial.</p> <p>Agora, com seu Ledger já iniciado, instale o aplicativo Ethereum seguindo as seguintes etapas:</p> <ol> <li>Abra o aplicativo Ledger Live em seu computador.</li> <li>Vá para My Ledger.</li> <li>Conecte e desbloqueie o dispositivo.</li> </ol> <p>Por fim, procure o aplicativo Ethereum (ETH) no Ledger Live e instale-o em seu dispositivo.</p> <p></p> <p>E é isso. Seu dispositivo agora tem uma conta Ethereum e é capaz de assinar transações em qualquer EVM appchain powered by Tanssi.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/ledger/#adding-Ledger-hot-wallet", "title": "Adicionando o Ledger a uma Carteira Quente", "text": "<p>Conforme apresentado na introdução, uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usuários verifiquem e assinem transações. No entanto, por design, ela não pode interagir com blockchains ou dApps sozinha, nem oferece uma interface do usuário para gerenciar ativos. Para complementar o dispositivo, uma carteira quente é necessária. O usuário pode escolher qualquer carteira compatível com Ethereum.</p> <p>Para fins de demonstração, mostraremos como configurar Metamask para funcionar com sua carteira de hardware, mas essas etapas são geralmente aplicáveis a qualquer outra carteira que suporte Ledger. Para seguir as etapas, certifique-se de ter o Metamask instalado em seu navegador, abra a extensão e clique no ícone suspenso ao lado do nome da conta.</p> <p></p> <p>Agora clique no botão + Adicionar conta ou carteira de hardware.</p> <p></p> <p>Selecione Carteira de hardware nas opções disponíveis.</p> <p></p> <p>Na tela seguinte:</p> <ol> <li>Selecione a caixa LEDGER. Você será solicitado a conectar seu Ledger, desbloqueá-lo e abrir o aplicativo Ethereum.</li> <li>Clique em Continuar.</li> </ol> <p></p> <p>Finalmente, você será apresentado com uma lista de contas derivadas. Selecione aquela que você deseja importar, clique em Desbloquear e pronto! Sua carteira Metamask agora pode assinar transações usando seu dispositivo Ledger.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/", "title": "Interagindo com Sua Rede EVM Tanssi Usando MetaMask", "text": ""}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores que constroem dApps em cima de redes EVM Powered by Tanssi podem aproveitar seus recursos de compatibilidade Ethereum integrando carteiras Ethereum conhecidas, como MetaMask. Ao fazer isso, eles podem usar a biblioteca injetada que MetaMask fornece para interagir com a rede EVM Tanssi.</p> <p>Este guia leva você por todas as etapas necessárias: desde a instalação da Metamask, configuração de uma carteira e, finalmente, conectando-a à sua rede EVM Tanssi.</p> <p>Note</p> <p>Você nunca deve compartilhar sua frase semente (mnemônico) ou chave privada com ninguém. Isso lhes dá acesso direto aos seus fundos. Este guia é apenas para fins educacionais.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension", "title": "Instale a Extensão MetaMask", "text": "<p>Primeiro, você começará com uma instalação MetaMask nova e padrão da Chrome store. Após baixar, instalar e inicializar a extensão, siga as etapas de Começar para configurar a carteira. Lá, você precisa criar uma carteira, definir uma senha e armazenar sua frase secreta de backup (isso dá acesso direto aos seus fundos, portanto, certifique-se de armazená-los em um local seguro).</p> <p>Note</p> <p>A extensão do navegador Metamask é compatível com Chrome, navegadores baseados em Chromium (como Microsoft Edge e Opera) e Firefox. Metamask também está disponível como um aplicativo móvel para dispositivos iOS e Android.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#setup-a-wallet", "title": "Configurar uma Carteira", "text": "<p>Após instalar MetaMask, a configuração abrirá automaticamente uma nova tarefa com uma tela de boas-vindas. Aqui, você tem duas opções:</p> <ul> <li>Criar uma nova carteira - você passará por algumas etapas para obter uma nova frase semente. Certifique-se de armazenar esta frase com segurança e não compartilhá-la publicamente</li> <li>Importar uma carteira existente - você já tem uma frase semente armazenada e deseja restaurar uma conta a partir dessa frase de recuperação</li> </ul> <p></p> <p>Depois de clicar na opção que se adapta às suas necessidades, siga as etapas e você deverá estar totalmente configurado.</p> <p>Note</p> <p>Várias contas podem ser derivadas de uma frase semente alterando o que é conhecido como o índice de endereço. Por padrão, ao criar ou importar uma conta a partir da frase semente, você obtém a conta com o índice de endereço 0. Você pode obter os outros índices apenas adicionando novas contas na tela principal da Metamask.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#import-accounts", "title": "Importar Contas", "text": "<p>Depois de criar uma carteira ou importar uma existente, você também pode importar qualquer conta para a MetaMask se tiver as chaves privadas.</p> <p>Para este exemplo, você usará chaves privadas da conta de desenvolvimento. Clique no botão de troca de conta para importar uma conta usando suas chaves privadas. É onde diz Account 1.</p> <p></p> <p>Em seguida, clique em Import Account.</p> <p></p> <p>Finalmente, insira as chaves privadas da conta que você está tentando importar. Depois de inserir a chave privada, clique em Import.</p> <p></p> <p>Você deve terminar com uma Conta 2 importada que se parece com isto:</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#connect-metamask-to-evm-network", "title": "Conecte a MetaMask à Sua Rede EVM Tanssi", "text": "<p>Depois de ter MetaMask instalado e ter criado ou importado uma conta, você pode conectá-la à sua rede EVM Tanssi. Para fazer isso, siga os seguintes passos:</p> <ol> <li>Clique no menu do seletor de rede no canto superior esquerdo</li> <li>Selecione Adicionar Rede</li> </ol> <p></p> <p>Em seguida, vá para a parte inferior da página e clique em Adicionar rede manualmente:</p> <p></p> <p>Aqui, você pode configurar a MetaMask para as seguintes redes:</p> Variável Valor Nome da Rede <code>Tanssi demo EVM appchain</code> RPC URL <code>https://services.tanssi-testnet.network/dancelight-2001/</code> Chain ID <code>5678</code> Símbolo (Opcional) <code>TANGO</code> Explorador de Blocos (Opcional) <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code> <p>Para fazer isso, preencha as seguintes informações:</p> <ol> <li>Nome da rede - nome que representa a rede à qual você está se conectando</li> <li>RPC URL - Endpoint RPC da rede</li> <li>Chain ID - ID da cadeia da rede compatível com Ethereum</li> <li>Símbolo - (opcional) símbolo do token nativo da rede</li> <li>Explorador de Blocos - (opcional) URL do explorador de blocos</li> <li>Depois de verificar todas as informações, clique em Salvar </li> </ol> <p>Depois de adicionar a rede, você será redirecionado para uma tela informando que você adicionou uma rede com sucesso. Além disso, você será solicitado a Mudar para Tanssi demo EVM appchain, a rede adicionada neste exemplo.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/wallets/metamask/#interact-with-network", "title": "Interaja com a Rede", "text": "<p>Depois de conectar a Metamask à sua rede EVM Tanssi, você pode começar a usar sua carteira por:</p> <ul> <li>Solicitando tokens TANGO do demo EVM network faucet</li> <li>Enviando uma transferência de token para outro endereço</li> <li>Adicionando ERC-20s à Metamask e interagindo com eles</li> <li>Adicionando ERC-721s à Metamask e interagindo com eles</li> </ul>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/", "title": "Interagindo com Sua Rede EVM Tanssi Usando o SubWallet", "text": ""}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de redes EVM Powered by Tanssi têm uma variedade de opções quando se trata de carteiras. Graças à sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, incluindo SubWallet.</p> <p>SubWallet é uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API do Ethereum, mas você pode consultar um tutorial semelhante para interagir com o SubWallet usando a API do Substrate. A extensão da carteira do navegador SubWallet pode ser baixada para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. O SubWallet também possui um aplicativo móvel para iOS e Android, mas isso está além do escopo deste guia. Um painel de ativos online completo é acessível em web.subwallet.app.</p> <p>Este guia leva você por todas as etapas necessárias, desde a instalação do SubWallet até a configuração de uma carteira, conectando-a à sua rede EVM Tanssi e enviando fundos.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/#creating-your-first-ethereum-account", "title": "Criando Sua Primeira Conta Ethereum", "text": "<p>Primeiro, baixe e instale a extensão SubWallet. A criação de uma nova conta gerará uma frase semente que pode derivar várias contas Ethereum e Substrate. Por padrão, o SubWallet gerará uma única conta Ethereum e uma única conta Substrate, mas você pode facilmente derivar mais da mesma frase semente. Clique em Criar uma nova conta para começar.</p> <p></p> <p>Na tela seguinte, você será solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p> <p>Você será solicitado a fazer backup de sua frase semente. Esta é uma etapa importante, especialmente porque você tem a opção de, posteriormente, derivar contas adicionais desta frase semente.</p> <p></p> <p>Note</p> <p>Você nunca deve compartilhar sua frase semente (mnemônico) ou chave privada com ninguém. Isso lhes dá acesso direto aos seus fundos. Este guia é apenas para fins educacionais.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/#importing-an-existing-evm-account", "title": "Importando uma Conta EVM Existente", "text": "<p>É claro que você pode importar uma conta EVM existente para o SubWallet. Para começar, siga estas etapas:</p> <ol> <li>Pressione o botão Todas as contas na parte superior</li> <li>Pressione o ícone Importar conta</li> </ol> <p></p> <p>Na tela seguinte, selecione o método pelo qual você gostaria de importar a conta existente.</p> <p></p> <p>Na tela seguinte, você poderá fornecer a frase semente relevante, a chave privada, o arquivo JSON ou o código QR, e poderá começar a usar sua nova conta imediatamente.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/#configuring-subwallet-for-your-evm-network", "title": "Configurando o SubWallet para Sua Rede EVM", "text": "<p>Para configurar o SubWallet para sua rede EVM Powered by Tanssi, pressione o ícone Mais opções no canto superior esquerdo. Em seguida, clique em Gerenciar redes. Pressione o ícone +. Na página seguinte, você será solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstração, a rede EVM de demonstração é usada aqui, mas você pode substituir esses detalhes pelos detalhes da sua própria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:</p> <ol> <li>Cole a URL HTTPS RPC de sua rede Tanssi. A URL RPC da rede EVM de demonstração é <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Outros parâmetros serão preenchidos automaticamente</li> <li>Cole a URL do explorador de blocos de sua rede Tanssi. A URL do explorador de blocos da rede EVM de demonstração é <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Pressione Salvar</li> </ol> <p></p> <p>Por padrão, todos os saldos são ocultos no SubWallet, mas se você pressionar o ícone de olho, poderá alternar a visibilidade do saldo.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/subwallet/#sending-assets-on-your-evm-network", "title": "Enviando Ativos em Sua Rede EVM", "text": "<p>Para transferir o token nativo da sua rede Tanssi, siga estas etapas:</p> <ol> <li>Especifique o ativo a ser enviado</li> <li>Especifique a cadeia de destino (neste caso, a mesma cadeia da qual você está enviando)</li> <li>Insira o endereço de destino</li> <li>Insira o número de tokens a serem enviados</li> <li>Veja os detalhes da transação e pressione Transferir e, em seguida, Aprovar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configuração do SubWallet para trabalhar com sua rede EVM Tanssi, mas o SubWallet também é uma carteira completa para contas Substrate (Polkadot). Na seção da API do Substrate, você encontrará um guia semelhante para configurar o SubWallet para uso com sua rede Substrate.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/", "title": "Interagindo com Sua Rede EVM Tanssi Usando Talisman", "text": ""}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de redes EVM Powered by Tanssi têm uma variedade de opções quando se trata de carteiras. Graças à sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, como a Talisman.</p> <p>A Talisman é uma carteira Web3 que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Ethereum, mas você pode conferir um tutorial semelhante para interagir com a Talisman usando a API Substrate. A extensão de navegador da carteira Talisman está disponível no Google Chrome e Brave, e um painel de ativos correspondente está acessível em app.talisman.xyz</p> <p>Este guia leva você por todas as etapas necessárias, desde a instalação do Talisman até a configuração de uma carteira, conectando-a à sua rede EVM Tanssi e enviando fundos.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#setting-up-talisman", "title": "Configurando o Talisman", "text": "<p>Primeiro, baixe e instale a extensão Talisman. Este guia cobrirá primeiro a criação de uma nova carteira e, posteriormente, abordará a importação de uma existente. Revise os termos e condições e, em seguida, pressione Começar.</p> <p></p> <p>Na tela seguinte, você será solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p>"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#creating-an-ethereum-account", "title": "Criando uma Conta Ethereum", "text": "<p>Para criar sua primeira conta Ethereum, siga as seguintes etapas:</p> <ol> <li>Selecione a opção Ethereum</li> <li>Dê um nome à sua conta</li> <li>Pressione Criar</li> </ol> <p></p> <p>Após criar sua primeira conta, você será solicitado a fazer backup de sua frase de semente. Esta é uma etapa importante, especialmente porque você tem a opção de derivar posteriormente contas adicionais dessa frase de semente.</p> <p></p> <p>Note</p> <p>Você nunca deve compartilhar sua frase de semente (mnemônico) ou chave privada com ninguém. Isso lhes dá acesso direto aos seus fundos. Este guia é apenas para fins educacionais.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#importing-an-existing-evm-account", "title": "Importando uma Conta EVM Existente", "text": "<p>É claro que você pode importar uma conta EVM existente para o Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Pressione Adicionar conta</li> <li>Pressione Importar</li> <li>Selecione Importar via frase de recuperação (observe que isso funciona para sementes e chaves privadas)</li> </ol> <p></p> <p>Na tela seguinte, siga as seguintes etapas:</p> <ol> <li>Selecione o tipo de conta Ethereum</li> <li>Forneça um nome para sua conta</li> <li>Cole sua semente ou chave privada</li> <li>Se você importou uma frase de semente mnemônica na etapa anterior, selecione quais contas você gostaria de importar</li> <li>Pressione Importar</li> </ol> <p></p>"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#configuring-talisman-for-your-evm-network", "title": "Configurando o Talisman para Sua Rede EVM", "text": "<p>Para configurar o Talisman para sua rede EVM Tanssi, abra a extensão Talisman e clique na guia Mais Opções. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione Configurações</li> <li>Marque a caixa Habilitar testnets</li> <li>Pressione Adicionar Rede</li> </ol> <p></p> <p>Na página seguinte, você será solicitado a inserir os detalhes da rede para sua rede Powered by Tanssi. Para fins de demonstração, a rede EVM de demonstração é usada aqui, mas você pode substituir esses detalhes por sua própria rede. Para adicionar sua rede ao Talisman, siga as seguintes etapas:</p> <ol> <li>Cole a URL RPC da sua rede Powered by Tanssi. A URL RPC da rede EVM de demonstração é <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Outros parâmetros serão preenchidos automaticamente</li> <li>Cole a URL do explorador de blocos da sua rede Powered by Tanssi. A URL do explorador de blocos da rede EVM de demonstração é <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Marque a caixa Esta é uma testnet, se aplicável</li> <li>Pressione Adicionar Rede</li> </ol> <p></p> <p>Se você tiver um saldo de tokens em sua conta recém-criada para sua rede, verá o saldo no painel Talisman.</p>"}, {"location": "builders/toolkit/ethereum-api/wallets/talisman/#sending-assets-on-your-evm-network", "title": "Enviando Ativos em Sua Rede EVM", "text": "<p>Para transferir o token nativo da sua rede Tanssi, siga as seguintes etapas:</p> <ol> <li>Clique no ícone Enviar</li> <li>Clique na conta Enviar de desejada</li> <li>Digite o endereço de destino</li> <li>Digite a quantidade de tokens a serem enviados</li> <li>Revise os detalhes da transação e, em seguida, pressione Revisar e, posteriormente, Confirmar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configuração do Talisman para trabalhar com sua rede EVM Powered by Tanssi, mas o Talisman também é uma carteira completa para contas Substrate (Polkadot). Na seção da API Substrate, você encontrará um tutorial semelhante para configurar o Talisman para trabalhar com cadeias baseadas em Substrate.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/", "title": "Integrações", "text": "<p>Descubra integrações que permitem estender a funcionalidade de seus dApps desenvolvidos com Tanssi. Essas integrações permitem a interação perfeita com fontes de dados externas, aprimoram a experiência do usuário e habilitam recursos avançados como feeds de dados on-chain, análise e suporte a carteiras.</p> <p>Pronto para começar a construir? Confira as seguintes integrações:</p> <ul> <li>Oracles - Acurast, Band e Phala</li> <li>Indexadores - SQD</li> <li>Carteiras - RainbowKit</li> </ul>"}, {"location": "builders/toolkit/integrations/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/integrations/indexers/", "title": "Indexadores", "text": "<p>Os indexadores permitem a ingestão, o processamento e a consulta eficientes de dados de blockchain, fornecendo aos desenvolvedores ferramentas poderosas para criar aplicações responsivas e ricas em dados em redes Powered by Tanssi.</p> <p>As principais características dos indexadores incluem:</p> <ul> <li>Velocidade de acesso a dados aprimorada - consulta mais rápida de dados na cadeia, organizando e indexando-os, permitindo tempos de recuperação mais rápidos</li> <li>Agregação de dados - ingerir e transformar dados que são mais fáceis de consultar e trabalhar com grandes quantidades de dados</li> <li>Capacidades de consulta aprimoradas - usar métodos de consulta sofisticados, como filtragem, classificação e paginação</li> <li>Atualizações de dados em tempo real - a sincronização com o blockchain permite que as aplicações acessem as informações mais recentes assim que estiverem disponíveis</li> </ul>"}, {"location": "builders/toolkit/integrations/indexers/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/", "title": "SQD", "text": "<p>SQD é um serviço de indexação e consulta de blockchain projetado para facilitar aos desenvolvedores a criação de aplicações ricas em dados em cadeias baseadas em Substrate, como as redes powered by Tanssi. Ele fornece uma solução eficiente e escalável para processamento, indexação e consulta de dados on-chain, permitindo que os desenvolvedores interajam facilmente com os dados de blockchain de que precisam, sem lidar diretamente com as complexidades dos dados brutos de blockchain.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/", "title": "Indexando Transferências ERC-20 em uma Rede EVM da Tanssi", "text": ""}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#introduction", "title": "Introdução", "text": "<p>SQD é uma rede de dados que permite recuperar informações de blockchain de mais de 100 cadeias de forma rápida e econômica usando o data lake descentralizado da SQD e seu SDK open source. Em termos simples, o SQD funciona como uma ferramenta ETL (extract, transform, load) com um servidor GraphQL incluído, permitindo filtragem, paginação e até busca full-text.</p> <p>O SQD tem suporte nativo e completo para dados EVM e Substrate, oferecendo um Archive e um Processor para cada. O Substrate Archive e o Processor podem indexar dados Substrate e EVM, permitindo extrair dados on-chain de qualquer rede powered by Tanssi e processar logs EVM e entidades Substrate (eventos, extrínsecos e itens de armazenamento) em um único projeto, servindo tudo em um único endpoint GraphQL. Se quiser indexar apenas dados EVM, use o EVM Archive e o Processor.</p> <p>Este tutorial passo a passo mostra como construir um Squid para indexar dados EVM do início ao fim. O ideal é seguir cada passo, mas você também pode conferir a versão completa do Squid deste tutorial no repositório tanssiSquid.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#check-prerequisites", "title": "Verificar Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisará de:</p> <ul> <li>Docker instalado</li> <li>Docker Compose instalado</li> <li>Um projeto Hardhat vazio. Para instruções passo a passo, veja a seção Criando um Projeto Hardhat na nossa documentação do Hardhat</li> </ul> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#deploy-an-erc20-with-hardhat", "title": "Implantar um ERC-20 com Hardhat", "text": "<p>Antes de indexar qualquer coisa com o SQD, precisamos ter algo para indexar! Esta seção mostra como implantar um token ERC-20 na sua rede com Tanssi para, em seguida, indexá-lo. Você pode pular para Criar um Projeto Squid se:</p> <ul> <li>Já implantou um token ERC-20 na sua rede (e fez várias transferências)</li> <li>Prefere usar um token ERC-20 já implantado na rede EVM de demonstração (há vários eventos de transferência lá)</li> </ul> <p>Se quiser usar um token existente na rede EVM de demonstração, use o contrato <code>MyTok.sol</code> abaixo. Os hashes de transferências também são fornecidos para ajudar na depuração.</p> <p>Nesta seção, vamos implantar um ERC-20 na sua rede EVM e criar um script rápido para disparar uma série de transferências que serão capturadas pelo indexador SQD. Certifique-se de ter inicializado um projeto Hardhat vazio conforme as instruções em Criando um Projeto Hardhat.</p> <p>Antes de criar o projeto, instale algumas dependências: o plugin Hardhat Ethers e os contratos OpenZeppelin. O plugin Hardhat Ethers facilita o uso da biblioteca Ethers para interagir com a rede. Usaremos a implementação base ERC-20 do OpenZeppelin para criar o token. Para instalar as dependências:</p> npmyarn <pre><code>npm install @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> <pre><code>yarn add @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> <p>Agora edite <code>hardhat.config.js</code> para incluir as configurações de rede e conta. Substitua os valores da rede EVM de demonstração pelos parâmetros da sua rede powered by Tanssi, que podem ser encontrados em apps.tanssi.network.</p> hardhat.config.js <pre><code>// 1. Import the Ethers plugin required to interact with the contract\nrequire('@nomicfoundation/hardhat-ethers');\n\n// 2. Add your private key that is funded with tokens of your Tanssi-powered network\n// This is for example purposes only - **never store your private keys in a JavaScript file**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  // 3. Specify the Solidity version\n  solidity: '0.8.20',\n  networks: {\n    // 4. Add the network specification for your Tanssi EVM network\n    demo: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Fill in the EVM ChainID for your Tanssi-powered network\n      accounts: [privateKey],\n    },\n  },\n};\n</code></pre> <p>Remember</p> <p>Nunca armazene suas chaves privadas em arquivos JavaScript ou Python. Fazemos isso aqui apenas para fins de demonstração. Use sempre um gerenciador de segredos ou serviço similar.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#create-an-erc-20-contract", "title": "Criar um contrato ERC-20", "text": "<p>Para este tutorial, criaremos um contrato ERC-20 simples, usando a implementação base do OpenZeppelin. Crie o arquivo do contrato <code>MyTok.sol</code>:</p> <pre><code>mkdir -p contracts &amp;&amp; touch contracts/MyTok.sol\n</code></pre> <p>Agora edite <code>MyTok.sol</code> para incluir o contrato abaixo, que cunha uma oferta inicial de MYTOKs e permite que apenas o owner do contrato cunhe mais tokens:</p> MyTok.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyTok is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") Ownable(msg.sender) {\n        _mint(msg.sender, 50000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n</code></pre>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#deploy-erc-20-contract", "title": "Implantar o Contrato ERC-20", "text": "<p>Com o contrato pronto, podemos compilá-lo e implantá-lo.</p> <p>Para compilar:</p> <pre><code>npx hardhat compile\n</code></pre> <p></p> <p>Esse comando compila o contrato e gera o diretório <code>artifacts</code> contendo o ABI.</p> <p>Para implantar, criaremos um script que faz o deploy do contrato ERC-20 e cunha uma oferta inicial de 1000 MYTOK usando a conta da Alith. A oferta inicial será enviada ao owner do contrato (Alith).</p> <p>Siga os passos:</p> <ol> <li> <p>Crie o diretório e o arquivo do script:</p> <pre><code>mkdir -p scripts &amp;&amp; touch scripts/deploy.js\n</code></pre> </li> <li> <p>No arquivo <code>deploy.js</code>, adicione:</p> deploy.js <pre><code>// scripts/deploy.js\nconst hre = require('hardhat');\nrequire('@nomicfoundation/hardhat-ethers');\n\nasync function main() {\n  // Get ERC-20 contract\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // This is a temporary stopgap solution to a bug\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Deploy the contract providing a gas price and gas limit\n  const myTok = await MyTok.deploy({\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // Wait for the deployment\n  await myTok.waitForDeployment();\n\n  console.log(`Contract deployed to ${myTok.target}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> </li> <li> <p>Execute o script usando a configuração da rede <code>demo</code> definida em <code>hardhat.config.js</code>:</p> <pre><code>npx hardhat run scripts/deploy.js --network demo\n</code></pre> </li> </ol> <p>O endereço do contrato implantado será exibido no terminal. Guarde-o; precisaremos dele para interagir com o contrato na próxima seção.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#transfer-erc-20s", "title": "Transferir ERC-20s", "text": "<p>Como vamos indexar eventos <code>Transfer</code>, enviaremos algumas transações transferindo tokens da conta de Alith para outras contas de teste. Criaremos um script simples que transfere 10 MYTOKs para Baltathar, Charleth, Dorothy e Ethan. Siga:</p> <p>Crie um novo script para enviar transações:</p> <pre><code>touch scripts/transactions.js\n</code></pre> <p>No arquivo <code>transactions.js</code>, adicione o script abaixo e insira o endereço do contrato MyTok implantado (exibido no passo anterior):</p> transactions.js <pre><code>// We require the Hardhat Runtime Environment explicitly here. This is optional\n// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.\n//\n// You can also run a script with `npx hardhat run &lt;script&gt;`. If you do that, Hardhat\n// will compile your contracts, add the Hardhat Runtime Environment's members to the\n// global scope, and execute the script.\nconst hre = require('hardhat');\n\nasync function main() {\n  // Get Contract ABI\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // Gas price is typically specified in 'wei' and gas limit is just a number\n  // You can use Ethers.js utility functions to convert from gwei or ether if needed\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Plug ABI to address\n  const myTok = await MyTok.attach('INSERT_CONTRACT_ADDRESS');\n\n  const value = 100000000000000000n;\n\n  let tx;\n  // Transfer to Baltathar\n  tx = await myTok.transfer(\n    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);\n\n  // Transfer to Charleth\n  tx = await myTok.transfer(\n    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);\n\n  // Transfer to Dorothy\n  tx = await myTok.transfer(\n    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);\n\n  // Transfer to Ethan\n  tx = await myTok.transfer(\n    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);\n}\n\n// We recommend this pattern to be able to use async/await everywhere\n// and properly handle errors.\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Execute o script para enviar as transações:</p> <pre><code>npx hardhat run scripts/transactions.js --network demo\n</code></pre> <p>Cada transação enviará um log para o terminal.</p> <p></p> <p>Agora podemos criar o Squid para indexar os dados no nó local de desenvolvimento.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#create-a-squid-project", "title": "Criar um Projeto Squid", "text": "<p>Vamos criar o projeto Subquid. Primeiro, instale o Squid CLI:</p> <pre><code>npm i -g @subsquid/cli@latest\n</code></pre> <p>Para verificar a instalação:</p> <pre><code>sqd --version\n</code></pre> <p>Agora podemos usar o comando <code>sqd</code> no projeto. Para criá-lo, usaremos o flag <code>--template</code> (<code>-t</code>) e o template EVM Squid, que é um projeto inicial para indexar cadeias EVM.</p> <p>Execute o comando para criar um EVM Squid chamado <code>tanssi-squid</code>:</p> <pre><code>sqd init tanssi-squid --template evm\n</code></pre> <p>Isso criará um Squid com todas as dependências. Instale-as:</p> <pre><code>cd tanssi-squid &amp;&amp; npm ci\n</code></pre> <p>Com o ponto de partida pronto, vamos configurar o projeto para indexar eventos <code>Transfer</code> do ERC-20 na nossa rede Tanssi.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#set-up-the-indexer-for-erc-20-transfers", "title": "Configurar o Indexador para Transferências ERC-20", "text": "<p>Para indexar transferências ERC-20, faremos:</p> <ol> <li>Definir o schema do banco e gerar as classes de entidades</li> <li>Usar o ABI do contrato <code>ERC20</code> para gerar classes de interface TypeScript</li> <li>Configurar o processor especificando exatamente quais dados ingerir</li> <li>Transformar os dados e inseri-los em um banco TypeORM em <code>main.ts</code></li> <li>Rodar o indexador e consultar o squid</li> </ol> <p>Primeiro, defina o schema para os dados de transferência. Edite o arquivo <code>schema.graphql</code> (na raiz) e crie as entidades <code>Transfer</code> e <code>Account</code>. Copie o schema abaixo, removendo qualquer schema existente.</p> schema.graphql <pre><code>type Account @entity {\n  \"Account address\"\n  id: ID!\n  transfersFrom: [Transfer!] @derivedFrom(field: \"from\")\n  transfersTo: [Transfer!] @derivedFrom(field: \"to\")\n}\n\ntype Transfer @entity {\n  id: ID!\n  blockNumber: Int!\n  timestamp: DateTime!\n  txHash: String!\n  from: Account!\n  to: Account!\n  amount: BigInt!\n}\n</code></pre> <p>Agora gere as classes de entidades a partir do schema (criadas em <code>src/model/generated</code>):</p> <pre><code>sqd codegen\n</code></pre> <p>No próximo passo, usaremos o ABI do ERC-20 para gerar classes de interface TypeScript. Abaixo há um ABI padrão do ERC-20. Copie-o para um arquivo <code>erc20.json</code> na pasta <code>abi</code> na raiz do projeto.</p> ERC-20 ABI <pre><code>[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_from\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"payable\": true,\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }\n]\n</code></pre> <p>Em seguida, use o ABI para gerar as interfaces TypeScript:</p> <pre><code>sqd typegen\n</code></pre> <p></p> <p>Isso gera as classes em <code>src/abi/erc20.ts</code>. Neste tutorial, usaremos os <code>events</code>.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#configure-the-processor", "title": "Configurar o Processor", "text": "<p>O arquivo <code>processor.ts</code> indica ao SQD quais dados ingerir. A transformação virá depois. Em <code>processor.ts</code>, precisamos indicar fonte de dados, endereço do contrato, evento(s) a indexar e intervalo de blocos.</p> <p>Abra <code>src/processor.ts</code>. Primeiro, informe ao processor qual contrato nos interessa. Crie a constante do endereço assim:</p> <pre><code>export const CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n</code></pre> <p>O <code>.toLowerCase()</code> é fundamental porque o processor diferencia maiúsculas/minúsculas e alguns explorers exibem endereços com capitalização. Em seguida, localize <code>export const processor = new EvmBatchProcessor()</code> seguido de <code>.setDataSource</code>. Faremos algumas alterações. O SQD tem archives disponíveis para várias cadeias que aceleram a obtenção de dados, mas é improvável que sua rede já tenha um archive hospedado. Sem problema: o SQD pode obter os dados via RPC da sua rede. Comente ou remova a linha do archive. O código deve ficar assim:</p> <pre><code>.setDataSource({\n  chain: {\n    url: assertNotNull(\n      'https://services.tanssi-testnet.network/dancelight-2001/'\n    ),\n    rateLimit: 300,\n  },\n})\n</code></pre> <p>O template vem com uma variável para a URL RPC no <code>.env</code>. Você pode substituir pela URL da sua rede. Para demonstração, a URL da rede EVM de teste está hardcoded acima. Se preferir definir no <code>.env</code>, a linha ficará:</p> <pre><code>RPC_ENDPOINT=https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Agora defina o evento a indexar:</p> <pre><code>.addLog({\n  address: [contractAddress],\n  topic0: [erc20.events.Transfer.topic],\n  transaction: true,\n})\n</code></pre> <p>O evento <code>Transfer</code> está em <code>erc20.ts</code>, gerado pelo <code>sqd typegen</code>. O import <code>import * as erc20 from './abi/erc20'</code> já vem no template.</p> <p>O intervalo de blocos é importante para restringir o escopo. Por exemplo, se você implantou o ERC-20 no bloco <code>650000</code>, não há motivo para consultar blocos anteriores. Definir um intervalo preciso melhora a performance do indexador. Configure o bloco inicial assim:</p> <pre><code>.setBlockRange({from: 632400,})\n</code></pre> <p>O bloco escolhido corresponde ao início relevante na rede EVM de demonstração; troque para o bloco adequado à sua rede.</p> <p>Altere <code>setFields</code> para especificar os dados a ingerir:</p> <pre><code>.setFields({\n  log: {\n    topics: true,\n    data: true,\n  },\n  transaction: {\n    hash: true,\n  },\n})\n</code></pre> <p>Também adicione estes imports em <code>processor.ts</code>:</p> <pre><code>import { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n</code></pre> <p>Após concluir, seu <code>processor.ts</code> deve estar parecido com:</p> processor.ts <pre><code>import { assertNotNull } from '@subsquid/util-internal';\nimport {\n  BlockHeader,\n  DataHandlerContext,\n  EvmBatchProcessor,\n  EvmBatchProcessorFields,\n  Log as _Log,\n  Transaction as _Transaction,\n} from '@subsquid/evm-processor';\nimport { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n\n// Here you'll need to import the contract\nexport const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n\nexport const processor = new EvmBatchProcessor()\n  .setDataSource({\n    chain: {\n      url: assertNotNull(\n        'https://services.tanssi-testnet.network/dancelight-2001'\n      ),\n      rateLimit: 300,\n    },\n  })\n  .setFinalityConfirmation(10)\n  .setFields({\n    log: {\n      topics: true,\n      data: true,\n    },\n    transaction: {\n      hash: true,\n    },\n  })\n  .addLog({\n    address: [contractAddress],\n    topic0: [erc20.events.Transfer.topic],\n    transaction: true,\n  })\n  .setBlockRange({\n    from: INSERT_START_BLOCK, // Note the lack of quotes here\n  });\n\nexport type Fields = EvmBatchProcessorFields&lt;typeof processor&gt;;\nexport type Block = BlockHeader&lt;Fields&gt;;\nexport type Log = _Log&lt;Fields&gt;;\nexport type Transaction = _Transaction&lt;Fields&gt;;\n</code></pre>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#transform-and-save-the-data", "title": "Transformar e Salvar os Dados", "text": "<p>Enquanto <code>processor.ts</code> define o que é consumido, <code>main.ts</code> define como processar e transformar os dados. Em resumo, processamos os dados ingeridos pelo processor e inserimos os trechos desejados em um banco TypeORM. Para detalhes, consulte a documentação SQD sobre desenvolvimento de Squid.</p> <p>O <code>main.ts</code> vai percorrer cada bloco processado em busca de eventos <code>Transfer</code> e decodificar detalhes como remetente, destinatário e valor. Ele também busca detalhes de contas e cria objetos de transferência com os dados extraídos, inserindo-os no TypeORM para consulta fácil. Em ordem:</p> <ol> <li><code>main.ts</code> roda o processor e refina os dados coletados. Em <code>processor.run</code>, o processor percorre os blocos selecionados e busca logs de <code>Transfer</code>, armazenando-os em um array de eventos de transferência para processamento posterior</li> <li>A interface <code>transferEvent</code> define a estrutura que guarda os dados extraídos dos logs</li> <li><code>getTransfer</code> é um helper que extrai e decodifica dados do evento <code>Transfer</code> de um log, retornando um objeto <code>TransferEvent</code> com ID da transação, número do bloco, remetente, destinatário e valor. É chamado ao armazenar os eventos relevantes no array</li> <li><code>processTransfers</code> enriquece os dados e insere os registros no banco TypeORM usando <code>ctx.store</code>. O Template <code>account</code>, embora não estritamente necessário, permite introduzir outra entidade no schema para demonstrar múltiplas entidades no Squid</li> <li><code>getAccount</code> é um helper que recupera/cria objetos de conta. Dado um ID e um mapa de contas existentes, retorna a conta correspondente; se não existir, cria, adiciona ao mapa e retorna</li> </ol> <p>Mostraremos uma query de exemplo adiante. Copie o código abaixo para <code>main.ts</code>:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\n// 1. Iterate through all selected blocks and look for transfer events,\n// storing the relevant events in an array of transfer events\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  let transfers: TransferEvent[] = [];\n\n  for (let block of ctx.blocks) {\n    for (let log of block.logs) {\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  await processTransfers(ctx, transfers);\n});\n\n// 2. Define an interface to hold the data from the transfer events\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\n// 3. Extract and decode ERC-20 transfer event data from a log entry\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\n// 4. Enrich and insert data into typeorm database\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  await ctx.store.upsert(Array.from(accounts.values()));\n  await ctx.store.insert(transfers);\n}\n\n// 5. Helper function to get account object\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>Pronto, já podemos rodar o indexador!</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#run-the-indexer", "title": "Rodar o Indexador", "text": "<p>Para rodar, execute a sequência de comandos <code>sqd</code>:</p> <p>Compile o projeto:</p> <pre><code>sqd build\n</code></pre> <p>Suba o banco:</p> <pre><code>sqd up\n</code></pre> <p>Remova o arquivo de migration que vem com o template EVM e gere um novo para nosso schema:</p> <pre><code>sqd migration:generate\n</code></pre> <pre><code>sqd migration:apply\n</code></pre> <p>Inicie o processor:</p> <pre><code>sqd process\n</code></pre> <p>No terminal, você verá o indexador começando a processar blocos!</p> <p></p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#query-your-squid", "title": "Consultar o Squid", "text": "<p>Para consultar o squid, abra um novo terminal no projeto e rode:</p> <pre><code>sqd serve\n</code></pre> <p>Pronto! Agora você pode fazer queries no playground GraphQL em <code>http://localhost:4350/graphql</code>. Crie sua própria query ou use a abaixo:</p> Exemplo de query <pre><code>query {\n  accounts {\n    id\n    transfersFrom {\n      id\n      blockNumber\n      timestamp\n      txHash\n      to {\n        id\n      }\n      amount\n    }\n    transfersTo {\n      id\n      blockNumber\n      timestamp\n      txHash\n      from {\n        id\n      }\n      amount\n    }\n  }\n}\n</code></pre> <p></p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#debug-your-squid", "title": "Depurar o Squid", "text": "<p>Pode parecer difícil depurar erros ao construir o Squid, mas há técnicas para facilitar. Primeiro, se encontrar erros, habilite o modo debug no <code>.env</code> descomentando a linha de debug. Isso gera logs bem mais verbosos e ajuda a localizar o problema.</p> <pre><code># Descomentar a linha abaixo habilita o modo debug\nSQD_DEBUG=*\n</code></pre> <p>Você também pode adicionar logs diretamente em <code>main.ts</code> para indicar parâmetros específicos, como altura de bloco. Por exemplo, veja esta versão de <code>main.ts</code> com logging detalhado:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  ctx.log.info('Processor started');\n  let transfers: TransferEvent[] = [];\n\n  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);\n  for (let block of ctx.blocks) {\n    ctx.log.debug(`Processing block number ${block.header.height}`);\n    for (let log of block.logs) {\n      ctx.log.debug(`Processing log with address ${log.address}`);\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        ctx.log.info(`Transfer event found in block ${block.header.height}`);\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  ctx.log.info(`Found ${transfers.length} transfers, processing...`);\n  await processTransfers(ctx, transfers);\n  ctx.log.info('Processor finished');\n});\n\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  ctx.log.debug(\n    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`\n  );\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  ctx.log.info('Starting to process transfer data');\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n  ctx.log.info(\n    `Accounts fetched, processing ${transfersData.length} transfers`\n  );\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  ctx.log.debug(`Upserting ${accounts.size} accounts`);\n  await ctx.store.upsert(Array.from(accounts.values()));\n  ctx.log.debug(`Inserting ${transfers.length} transfers`);\n  await ctx.store.insert(transfers);\n  ctx.log.info('Transfer data processing completed');\n}\n\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>Consulte o guia de logging do SQD para mais informações sobre o modo debug.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/erc20-transfers/#common-errors", "title": "Erros Comuns", "text": "<p>Alguns erros comuns ao construir o projeto e como resolvê-los:</p> <pre><code>Error response from daemon: driver failed programming external connectivity on endpoint my-awesome-squid-db-1\n(49df671a7b0531abbb5dc5d2a4a3f5dc7e7505af89bf0ad1e5480bd1cdc61052):\nBind for 0.0.0.0:23798 failed: port is already allocated\n</code></pre> <p>Esse erro indica que você tem outra instância do SQD rodando. Pare-a com <code>sqd down</code> ou clicando em Stop no container no Docker Desktop.</p> <pre><code>Error: connect ECONNREFUSED 127.0.0.1:23798\n     at createConnectionError (node:net:1634:14)\n     at afterConnectMultiple (node:net:1664:40) {\n     errno: -61,code: 'ECONNREFUSED',syscall: 'connect',\n     address: '127.0.0.1',port: 23798}\n</code></pre> <p>Para resolver, rode <code>sqd up</code> antes de <code>sqd migration:generate</code>.</p> <p>Seu Squid está sem erros, mas nenhuma transferência aparece? Verifique se os logs estão consistentes e iguais aos esperados pelo processor. O endereço do contrato também precisa estar em minúsculas; garanta isso definindo assim:</p> <pre><code>export const contractAddress = '0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85'.toLowerCase();\n</code></pre>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/indexers/sqd/quick-start/", "title": "Indexando uma Rede Tanssi com SQD", "text": ""}, {"location": "builders/toolkit/integrations/indexers/sqd/quick-start/#introduction", "title": "Introdução", "text": "<p>SQD é uma rede de dados que permite recuperar dados de blockchain de mais de 100 cadeias de forma rápida e econômica usando o data lake descentralizado da SQD e o SDK open-source. Em termos simples, o SQD funciona como uma ferramenta ETL (extrair, transformar e carregar) com um servidor GraphQL incluído. Ele oferece filtragem abrangente, paginação e até pesquisa de texto completo. O SQD tem suporte nativo e completo para dados EVM e Substrate, até no mesmo projeto.</p> <p>Este guia rápido mostra como criar um projeto Squid e configurá-lo para indexar dados em uma rede powered by Tanssi. Há uma seção para redes Substrate e outra para redes EVM. Se você estiver em uma rede EVM, pode usar a seção Substrate caso também precise indexar dados Substrate.</p> <p>Para um tutorial mais completo para redes EVM, confira Indexando Transferências ERC-20 em uma Rede EVM Tanssi.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/quick-start/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para os exemplos deste guia, você vai precisar de:</p> <ul> <li>Node.js versão 16 ou superior</li> <li>Docker</li> <li>Squid CLI</li> </ul>"}, {"location": "builders/toolkit/integrations/indexers/sqd/quick-start/#index-substrate-networks", "title": "Indexar uma Rede Substrate Tanssi", "text": "<p>Para começar a indexar dados Substrate na sua rede Tanssi, crie um projeto Squid e configure-o para sua rede com estes passos:</p> <ol> <li> <p>Crie um projeto Squid baseado no template Substrate executando:</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>Para mais detalhes sobre este template, veja o guia Primeiros passos: Cadeias Substrate na documentação da SQD.</p> </li> <li> <p>No diretório raiz do projeto, instale as dependências:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Ajuste <code>src/processor.ts</code> para apontar para o RPC da sua rede Tanssi. Remova a linha <code>archive: lookupArchive</code>, pois não será usado um arquivo Squid. Especifique o RPC da sua rede Substrate Tanssi, pois o endpoint é usado para ingerir os dados da cadeia:</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> </li> <li> <p>Suba o Postgres executando:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspecione e execute o processador:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Em outro terminal, no mesmo diretório, inicie o servidor GraphQL:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>Consulte o Squid Substrate de template com a query abaixo. Se você modificar o template para indexar dados diferentes, ajuste a query conforme necessário:</p> <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> </li> </ol> <p>Pronto! Agora você pode atualizar <code>schema.graphql</code>, <code>src/main.ts</code>, <code>typegen.json</code> e <code>src/processor.ts</code> para indexar os dados que precisa.</p>"}, {"location": "builders/toolkit/integrations/indexers/sqd/quick-start/#index-evm-networks", "title": "Indexar uma Rede EVM Tanssi", "text": "<p>Para indexar dados EVM em uma rede EVM Tanssi, crie um projeto Squid e configure-o assim:</p> <ol> <li> <p>Crie um projeto Squid para EVM usando o template EVM genérico ou o template ABI para dados de um contrato específico.</p> EVMABI <pre><code>sqd init INSERT_SQUID_NAME --template evm\n</code></pre> <pre><code>sqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>Para saber mais sobre esses templates, consulte:</p> <ul> <li>Primeiros passos: Cadeias EVM</li> <li>Início rápido: Ferramentas de geração Squid</li> </ul> </li> <li> <p>No diretório raiz do projeto, instale as dependências:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Ajuste <code>src/processor.ts</code> para apontar para o RPC da sua rede Tanssi. Remova a linha <code>archive: lookupArchive('eth-mainnet')</code>, pois não será usado um arquivo Squid. Abaixo, o RPC da rede EVM de demonstração é usado como exemplo; substitua pelo seu:</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> <p>Note</p> <p>Para testar na rede EVM de demonstração, você pode usar este RPC:</p> <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> </li> <li> <p>Suba o Postgres executando:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspecione e execute o processador:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Em outro terminal, inicie o servidor GraphQL:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>Execute consultas no playground GraphQL em <code>http://localhost:4350/graphql</code>, por exemplo:</p> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>Pronto! Agora você pode atualizar <code>schema.graphql</code>, <code>src/main.ts</code> e <code>src/processor.ts</code> para indexar os dados necessários.</p> <p>Para um guia passo a passo mais completo, veja o tutorial Indexando Transferências ERC-20 em uma Rede EVM Tanssi.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/oracles/", "title": "Oracles", "text": "<p>Oráculos de blockchain são serviços que permitem que blockchains interajam com fontes de dados externas, preenchendo a lacuna entre contratos inteligentes e informações do mundo real. Os oráculos são essenciais para aplicações dinâmicas que dependem de dados fora da cadeia precisos e oportunos.</p> <p>As principais características dos oráculos incluem:</p> <ul> <li>Conectividade externa - permitindo que contratos inteligentes busquem e utilizem dados do mundo real</li> <li>Automação - acionar a execução de contratos com base em condições externas</li> <li>Flexibilidade - suportar vários tipos de dados, como feeds de preços, atualizações meteorológicas e resultados esportivos</li> </ul>"}, {"location": "builders/toolkit/integrations/oracles/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/", "title": "Acessando Feeds de Preço com Acurast", "text": ""}, {"location": "builders/toolkit/integrations/oracles/acurast/#introduction", "title": "Introdução", "text": "<p>Acurast oferece computação permissionless, confiável e acessível para implantar aplicações. Um dos usos é permitir que desenvolvedores criem oráculos push/pull, consultando APIs off-chain para trazer preços on-chain. Os dados são processados de forma confidencial pelos Processors e enviados a contratos de redes EVM compatíveis com Tanssi via a interface padrão Chainlink Aggregator.</p> <p>Este tutorial mostra um demo de como interagir com feeds de preço fornecidos pela Acurast na rede EVM de demonstração da Tanssi. Você também pode implantar seus próprios feeds na sua rede EVM powered by Tanssi. Para produção, é altamente recomendável contatar a equipe Acurast para auxiliar no lançamento e garantir a integridade do processo.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#what-is-acurast", "title": "O que é Acurast?", "text": "<p>Acurast é uma nuvem descentralizada e sem servidor em que qualquer pessoa pode contribuir poder de computação (inclusive com celulares) e receber recompensas. Esses Processors formam uma rede distribuída mundialmente. Processors e desenvolvedores interagem pelo Acurast Console.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#fetch-price-data", "title": "Obter Dados de Preço", "text": "<p>Você pode desenhar o feed de preço Acurast como quiser. Os dados ficam em uma série de contratos (um por feed) e podem ser consultados via a interface do agregador. O feed demo usa a mesma interface de preço da Chainlink:</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>Na interface, cinco funções retornam dados: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code> e <code>latestRoundData</code>. Consulte a referência da Chainlink para detalhes.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#interacting-with-price-feeds-demo-evm-network", "title": "Interagir com Feeds na Rede EVM Demo da Tanssi", "text": "<p>Vamos usar o feed BTC/USDT já implantado (veja Ativos suportados). O contrato do agregador no Blockscout:</p> <pre><code>0x02093b190D9462d964C11587f7DedD92718D7B56\n</code></pre> <p>Como interagir pelo Remix:</p> <ol> <li>Conecte a MetaMask à rede EVM demo (guia Remix).  </li> <li>Cole o contrato Aggregator em um novo arquivo e compile.  </li> <li>Em Deploy and Run, defina ENVIRONMENT para Injected Provider -- MetaMask.  </li> <li>Selecione AggregatorV3Interface em CONTRACT.  </li> <li>No campo At Address, informe <code>0x02093b190D9462d964C11587f7DedD92718D7B56</code> e clique At Address.</li> </ol> <p></p> <p></p> <p>Para consultar:</p> <ol> <li>Expanda AggregatorV3Interface.  </li> <li>Clique em decimals para ver quantas casas decimais o preço usa.  </li> <li>Clique em description para verificar o par.  </li> <li>Clique em latestRoundData para ver o preço mais recente (retornado em int256 answer).</li> </ol> <p></p> <p>Lembre-se de ajustar pelo número de decimais informado por <code>decimals()</code>. Ex.: se o feed retorna <code>51933620000</code> e <code>decimals = 6</code>, o preço é <code>51,933.62</code>.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#supported-assets", "title": "Ativos Suportados", "text": "<p>Exemplo de chamada de API usada no demo:</p> <pre><code>curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"\n</code></pre> <p>Saída de exemplo:</p> curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"  {\"symbol\":\"BTCUSDT\",\"price\":\"51917.61000000\"} <p>Note</p> <p>Este exemplo usa apenas uma fonte (uma exchange). É possível construir scripts que agreguem múltiplas fontes.</p> <p>Por design, a Acurast pode suportar o feed de qualquer ativo acessível por API.</p> <p>Feeds implantados na rede EVM demo:</p> Ativo/Par Contrato agregador AAVE/USDT 0x6239Ff749De3a21DC219bcFeF9d27B0dfE171F42 BTC/USDT 0x02093b190D9462d964C11587f7DedD92718D7B56 CRV/USDT 0x01F143dfd745861902dA396ad7dfca962e5C83cA DAI/USDT 0x73aF6b14b73059686a9B93Cd28b2dEABF76AeC92 ETH/USDT 0x007c3F3cc99302c19792F73b7434E3eCbbC3db25 USDC/USDT 0xe4a46ef4cFbf87D026C3eB293b7672998d932F62 USDT/USD 0xf9c885E3A5846CEA887a0D69655BC08e52afe569 <p>Esses endereços estão disponíveis para testes, mas você pode implantar feeds adicionais para outros pares conforme necessário.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#designing-and-launching-your-own-price-feed", "title": "Criar e Lançar Seu Próprio Feed de Preço", "text": "<p>Você pode criar seu próprio feed Acurast na rede EVM da Tanssi. Este tutorial é apenas demonstrativo; para produção, contate a equipe Acurast.</p> <p>São necessários dois componentes: contrato e script. No exemplo anterior de interação com BTC/USD usamos a interface Chainlink porque é simples de demonstrar. O contrato subjacente segue a interface Chainlink Aggregator, mas o demo adiciona eventos e lógica exemplo. Código de contrato e script estão no repositório da Acurast.</p> <p>O contrato de demo <code>InsecureDummyPriceFeed.sol</code> emite eventos quando o preço é atualizado e quando um novo round inicia. O método <code>setPrice</code> é inseguro e serve apenas para mostrar onde adicionar consenso, controle de acesso etc.</p> InsecureDummyPriceFeed.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/**\nThis Dummy Oracle is compatible with Chainlink's AggregatorV2V3Interface, meaning projects currently using\nChainlink can seamlessly migrate. The updating of the price feed happens in the interval you specified on\nthe Acurast script.\n\nAt the moment no check on the signer/source is being performed, making this implementation INSECURE. However\nwith a minimal effort you can extend the \"setPrice\" entrypoint to reflext the kind of logic you are looking for\n(i.e. Aggregation Consensus, Check sources, thresholds, etc).\n**/\n\ncontract DummyChainlinkCompatibleOracle is AggregatorV2V3Interface {\n    int256 private latestPrice;\n    uint256 private latestPriceTimestamp;\n    uint256 private latestRoundId;\n\n    // Assuming price can be set without restriction for simplicity\n    // In a real-world scenario, there should be access control mechanisms\n    function setPrice(int256 _price) external {\n        latestPrice = _price;\n        latestPriceTimestamp = block.timestamp;\n        latestRoundId++;\n\n        emit AnswerUpdated(latestPrice, latestRoundId, latestPriceTimestamp);\n        emit NewRound(latestRoundId, msg.sender, latestPriceTimestamp);\n    }\n\n    // AggregatorInterface functions\n    function latestAnswer() external view override returns (int256) {\n        return latestPrice;\n    }\n\n    function latestTimestamp() external view override returns (uint256) {\n        return latestPriceTimestamp;\n    }\n\n    function latestRound() external view override returns (uint256) {\n        return latestRoundId;\n    }\n\n    function getAnswer(uint256 _roundId) external view override returns (int256) {\n        if(_roundId == latestRoundId) {\n            return latestPrice;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    function getTimestamp(uint256 _roundId) external view override returns (uint256) {\n        if(_roundId == latestRoundId) {\n            return latestPriceTimestamp;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    // AggregatorV3Interface functions\n    function decimals() external pure override returns (uint8) {\n        return 6; // Assume a common decimal value for simplicity\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"Sample Price Feed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId == latestRoundId, \"Only latest round data available\");\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n}\n</code></pre> <p>Warning</p> <p>O contrato de demonstração tem vulnerabilidades e não possui controles de acesso; não use em produção.</p> <p>Antes de prosseguir, implante o contrato do seu feed na rede EVM da Tanssi (ou na rede demo). Guarde o endereço, pois será usado no script Acurast.</p>"}, {"location": "builders/toolkit/integrations/oracles/acurast/#construindo-o-script-acurast", "title": "Construindo o Script Acurast", "text": "<p>O script Acurast atualiza o oracle on-chain com os preços, fazendo a ponte entre o feed de preço da rede Tanssi e a rede Acurast. No console você define parâmetros como frequência, agenda e recompensa dos Processors. Para publicar jobs você precisará de tokens cACU (pegue no faucet) — eles são a moeda nativa da rede Canary da Acurast.</p> <p>O script atualiza o oracle on-chain com preços. Exemplo de script:</p> AcurastScript.js <pre><code>/**\n * This Oracle Script observes the BTC USDT Pair and posts the price on-chain.\n * Deploying the script is easy using console.acurast.com and simply copy/pasting\n * this script. Make sure to update `DESTINATION_CONTRACT` and `EVM_RPC_NODE` to\n * reflect your deployment. For RPC's with API keys like i.e. infura make sure\n * to work with the Acurast confidential environment variables. After having set\n * them for your job, you can access them easily with a `_STD_.env[\"MY_KEY\"]`. They\n * also come in handy for paid API KEYs, that you don't want to share publicly.\n */\n\nconst DESTINATION_CONTRACT = 'INSERT_CONTRACT_ADDRESS';\nconst EVM_RPC_NODE = 'INSERT_NETWORK_RPC_URL';\n\nhttpGET(\n  'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',\n  {},\n  (response, certificate) =&gt; {\n    if (\n      certificate ===\n      '4795062d13e1ed971c6b6e5699764681e4d090bad39a7ef367cc9cb705652384'\n    ) {\n      //const price = BigInt(JSON.parse(response)[\"price\"] * 10 ** 18); // if you need more precision, just keep in mind that JS stored bigger numbers in float format, rounding up/down your stuff.\n      const price = BigInt(JSON.parse(response)['price'] * 10 ** 6);\n      const int256AsBytes = '0x' + price.toString(16).padStart(64, '0');\n      const payload = '0x' + _STD_.chains.ethereum.abi.encode(int256AsBytes);\n      _STD_.chains.ethereum.fulfill(\n        EVM_RPC_NODE,\n        DESTINATION_CONTRACT,\n        payload,\n        {\n          methodSignature: 'setPrice(int256)',\n          gasLimit: '9000000',\n          maxFeePerGas: '2550000000',\n          maxPriorityFeePerGas: '2550000000',\n        },\n        (opHash) =&gt; {\n          console.log('Succeeded: ' + opHash);\n        },\n        (err) =&gt; {\n          console.log('Failed: ' + err);\n        }\n      );\n    }\n  },\n  (err) =&gt; {\n    console.log('Failed: ' + err);\n  }\n);\n</code></pre> <p>Se você reutilizar o script de exemplo da Acurast, lembre-se de atualizar o endereço do contrato e o RPC da sua rede.</p> <p>No console Acurast, configure o job:</p> <ol> <li>Create Jobs → cadeia Moonbeam, ambiente Moonbase (Tanssi herda a compatibilidade EVM do Moonbeam).  </li> <li>Selecione Price Feeds.  </li> <li>Cole o script (altere o endereço do contrato implantado e o RPC da sua rede — disponível no Tanssi dApp).  </li> <li>Opcional: teste o código; erros aparecem no console do navegador.  </li> <li>Em seguida, defina Use Public Processors, Interval, horário de início/fim, intervalo em minutos, duração e max start delay.  </li> <li>Defina o Number of processors (mais processadores exigem mais cACU; obtenha no faucet).  </li> <li>Defina o Max Reward por execução (exemplo: <code>0.01</code> cACU).  </li> <li>Revise e clique Publish Job. Depois acompanhe o status na mesma página.</li> </ol> <p></p> <p></p> <p>Na tela seguinte você pode monitorar o status do job publicado.</p> <p>Para mais detalhes sobre como construir e acessar feeds de preço na sua rede EVM Tanssi, consulte a documentação da Acurast.</p> <p>Com isso você tem um fluxo completo: contrato on-chain, script de atualização e job publicado na Acurast para manter o feed de preços ativo.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/oracles/band/", "title": "Acessando Feeds de Preços com o Band Protocol", "text": ""}, {"location": "builders/toolkit/integrations/oracles/band/#introduction", "title": "Introdução", "text": "<p>Band Protocol é uma rede de oráculos descentralizada que fornece dados confiáveis, seguros e em tempo real para contratos inteligentes em várias redes blockchain.</p> <p>O protocolo é construído sobre o BandChain, uma rede projetada para ser compatível com a maioria das cadeias compatíveis com EVM, como as redes EVM powered by Tanssi, e com frameworks de desenvolvimento. O protocolo busca oferecer uma solução:</p> <ul> <li>Descentralizada, aproveitando o poder computacional de uma rede de validadores</li> <li>Flexível, suportando ampla variedade de fontes e formatos de dados, facilitando integrações</li> <li>Escalável, projetada para lidar com alto volume de requisições</li> <li>Acessível, permitindo solicitar dados apenas quando necessário e pagar apenas as taxas associadas</li> </ul> <p>Para implantar o oráculo na sua rede, entre em contato diretamente com a equipe do Band Protocol.</p> <p>Este tutorial percorre as etapas para interagir com feeds de preços usando o oráculo do Band Protocol na rede EVM de demonstração da Tanssi. </p>"}, {"location": "builders/toolkit/integrations/oracles/band/#setup-on-demo-evm-network", "title": "Configuração na Rede de Demonstração EVM da Tanssi", "text": "<p>O oráculo do Band Protocol já está implantado na rede EVM de demonstração da Tanssi e configurado para fornecer preços para os tokens <code>ETH</code> e <code>DOT</code>.</p> <p>Os feeds de preços são enviados regularmente para um contrato inteligente acessível no endereço:</p> <pre><code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68\n</code></pre> <p>O contrato pode ser utilizado via a interface:</p> IStdReference.sol <pre><code>// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.26;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    } \n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory);\n}\n</code></pre> <p>Como visto acima, há duas funções para buscar dados:</p> getReferenceData(_base, _quote) — busca o preço de um par base/cotação ParâmetrosExemplo <ul> <li><code>_base</code> string memory - token cujo preço você quer obter</li> <li><code>_quote</code> string memory - token (ou <code>USD</code>) em que o preço é expresso</li> </ul> <ul> <li><code>_base</code> - ETH</li> <li><code>_quote</code> - USD</li> </ul> getReferenceDataBulk(_bases, _quotes) — busca preços para os pares base/cotação fornecidos simultaneamente ParâmetrosExemplo <ul> <li><code>_bases</code> string[] memory - lista de tokens base para os quais deseja obter preços</li> <li><code>_quotes</code> string[] memory - lista de tokens (ou <code>USD</code>) em que os preços são expressos</li> </ul> <ul> <li><code>_bases</code> - [\"ETH\", \"DOT\"]</li> <li><code>_quotes</code> - [\"USD\", \"USD\"]</li> </ul> <p>A resposta de ambas as funções é composta pelos seguintes dados, agrupados em uma tupla no caso de <code>getReferenceData</code> e em uma lista de tuplas (uma por par) no caso de <code>getReferenceDataBulk</code>:</p> <ul> <li><code>rate</code> uint256 - preço do par base/cotação fornecido. Ajuste o resultado para considerar 18 casas decimais</li> <li><code>lastUpdatedBase</code> uint256 - timestamp de atualização do parâmetro <code>_base</code>, em epoch UNIX (segundos desde <code>01-01-1970 00:00:00 UT</code>)</li> <li><code>lastUpdatedQuote</code> uint256 - timestamp de atualização do parâmetro <code>_quote</code>, em epoch UNIX (segundos desde <code>01-01-1970 00:00:00 UT</code>)</li> </ul>"}, {"location": "builders/toolkit/integrations/oracles/band/#fetching-price-feeds-remix", "title": "Buscar Feeds de Preço usando Remix", "text": "<p>Nesta seção, usaremos o Remix para buscar o preço do par <code>ETH/USD</code>.</p> <p>Primeiro, certifique-se de ter uma carteira compatível com EVM conectada à rede EVM de demonstração. MetaMask é usada como exemplo. Em seguida, acesse o Remix, cole a interface <code>IStdReference</code> em um novo arquivo e compile.</p> <p></p> <p>Depois, siga:</p> <ol> <li>Vá para a aba Deploy &amp; Run Transactions</li> <li>Defina ENVIRONMENT como Injected Provider -- MetaMask</li> <li>Selecione o contrato <code>IStdReference.sol</code> no menu CONTRACT</li> <li>Informe o endereço do contrato de feed de dados <code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68</code> da rede EVM de demonstração no campo At Address e clique em At Address</li> </ol> <p></p> <p>O contrato estará acessível. Para interagir:</p> <ol> <li>Expanda o contrato IStdReference para ver as funções disponíveis</li> <li>Expanda getReferenceData e defina <code>_base</code> e <code>_quote</code> como <code>ETH</code> e <code>USD</code></li> <li>Clique em Call</li> <li>O resultado exibirá três valores: o preço, o horário de atualização do parâmetro <code>_base</code> e o horário de atualização do parâmetro <code>_quote</code></li> </ol> <p></p> <p>Para obter um preço legível, ajuste pelas casas decimais do feed (18). No exemplo, <code>2361167929271984201806</code> corresponde a um preço de <code>ETH</code> de <code>$2,361.167929271984201806</code> em <code>USD</code>. Observe também que os timestamps de atualização estão em epoch UNIX, ou seja, segundos desde <code>01-01-1970 00:00:00 UT</code>. </p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/oracles/phala/", "title": "Lançando Feeds de Preço com Phala", "text": ""}, {"location": "builders/toolkit/integrations/oracles/phala/#introduction", "title": "Introdução", "text": "<p>Phala Network é uma rede de computação off-chain apoiada por Secure Enclaves que permite a desenvolvedores criar contratos inteligentes potentes conectados a componentes off-chain, chamados Phat Contracts. Os Phat Contracts foram projetados para oferecer funcionalidades que superam as limitações de contratos tradicionais (armazenamento, custo, computação), mantendo-se trustless, verificáveis e sem permissão. Para saber mais sobre a arquitetura da Phala, consulte a documentação.</p> <p>A Phala não é, por si só, uma rede de oráculos; ela habilita várias capacidades de computação off-chain, incluindo uma rede descentralizada de oráculos. A Phala também oferece o Phala Bricks, um conjunto de ferramentas que facilita lançar rapidamente esse tipo de funcionalidade sem precisar construir tudo do zero.</p> <p>Este tutorial mostra um demo de como interagir com feeds de preço habilitados por Phat Contracts na rede EVM de demonstração da Tanssi. Em seguida, você verá como implantar feeds de preço na sua rede EVM powered by Tanssi. Para produção, é altamente recomendável contatar a equipe Phala para auxiliar no lançamento e garantir a integridade do processo.</p> <p>Se você já usa outro provedor de oráculos, a Phala serve como camada de execução confidencial para trazer esses dados para sua rede Tanssi. É possível adaptar o fluxo descrito aqui para outros feeds ou APIs, mantendo a mesma interface de consumo no contrato EVM.</p> <p>Além disso, por usar enclaves seguros, a Phala reduz a superfície de ataque ao processar dados sensíveis ou agregados de múltiplas fontes, reforçando a confiança no resultado final consumido pelos dApps.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#how-phala-enables-price-feeds", "title": "Como a Phala Habilita Feeds de Preço", "text": "<p>A Phala espelha os Chainlink Price Feeds do Ethereum Mainnet. Esses feeds são amplamente adotados e sua coleta/agragação é feita por vários node operators independentes, evitando dependência de uma única fonte de verdade e reduzindo risco de manipulação.</p> <p>O componente central do desenho do sistema é o Secure Enclave, que processa as mensagens recebidas da blockchain Phala (fila de mensagens criptografada) e garante execução fiel mesmo com trabalhadores maliciosos. A blockchain Phala solicita a atualização do feed; os workers off-chain buscam os preços no Ethereum Mainnet e devolvem para a blockchain Phala.</p> <p>Além de replicar oráculos existentes, é possível criar novos oráculos buscando dados off-chain via Phat Contracts. No exemplo de Phat-EVM Oracle, os preços vêm da API do CoinGecko e podem ser enviados continuamente (push) ou solicitados pelo contrato EVM (pull).</p> <p>Em resumo: a Phala funciona como uma ponte segura entre dados externos e sua rede EVM, permitindo reutilizar feeds consolidados da Chainlink ou construir integrações sob medida usando Phat Contracts.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#fetch-price-data", "title": "Buscar Dados de Preço", "text": "<p>Há vários feeds disponíveis na rede EVM demo. Os feeds habilitados por Phat Contracts usam a mesma interface dos feeds Chainlink. Cada feed fica em um contrato e pode ser consultado pela interface agregadora:</p> <p>Você também pode reutilizar a mesma interface para feeds personalizados que a sua equipe decidir publicar, mantendo uma API consistente para contratos e frontends.</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>A interface expõe cinco funções: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code> e <code>latestRoundData</code>. Para mais detalhes, veja a referência da Chainlink.</p> <p>Essas funções permitem consultar metadados do feed, verificar o par de ativos, e obter o preço mais recente ou de uma rodada específica.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#supported-assets", "title": "Ativos Suportados", "text": "<p>A Phala obtém os feeds espelhando os feeds Chainlink do Ethereum Mainnet. Há contratos para a rede EVM demo e para o Ethereum Mainnet:</p> Rede EVM demo TanssiEthereum Mainnet Par de Ativos Contrato agregador AAVE/USD 0x2E1640853bB2dD9f47831582665477865F9240DB BTC/USD 0x89BC5048d634859aef743fF2152363c0e83a6a49 CRV/USD 0xf38b25b79A72393Fca2Af88cf948D98c64726273 DAI/USD 0x1f56d8c7D72CE2210Ef340E00119CDac2b05449B ETH/USD 0x739d71fC66397a28B3A3b7d40eeB865CA05f0185 USDC/USD 0x4b8331Ce5Ae6cd33bE669c10Ded9AeBA774Bf252 USDT/USD 0x5018c16707500D2C89a0446C08f347A024f55AE3 Par de Ativos Contrato agregador AAVE/USD 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 BTC/USD 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c CRV/USD 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f DAI/USD 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 ETH/USD 0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419 USDC/USD 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6 USDT/USD 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D"}, {"location": "builders/toolkit/integrations/oracles/phala/#interacting-with-price-feeds-demo-evm-network", "title": "Interagir com Feeds na Rede EVM Demo", "text": "<ol> <li>Conecte a MetaMask à rede EVM demo (veja o guia Implantar contratos com Remix) e certifique-se de que a MetaMask está nessa rede.  </li> <li>Cole o contrato Aggregator em um novo arquivo no Remix e compile.  </li> <li>Vá para Deploy and Run Transactions → ENVIRONMENT = Injected Provider -- MetaMask.  </li> <li>Selecione AggregatorV3Interface em CONTRACT.  </li> <li>No campo At Address, insira o endereço do feed desejado (ex.: BTC/USD <code>0x89BC5048d634859aef743fF2152363c0e83a6a49</code>) e clique em At Address.</li> </ol> <p>Para consultar:</p> <ol> <li>Expanda AggregatorV3Interface.  </li> <li>Clique em decimals para ver quantas casas decimais o feed usa.  </li> <li>Clique em description para verificar o par.  </li> <li>Clique em latestRoundData para ver o preço mais recente (int256 answer).</li> </ol> <p></p> <p>Para obter um preço legível, ajuste pelo valor de <code>decimals()</code>. Ex.: se o retorno for <code>5230364122303</code> e <code>decimals=8</code>, o preço é <code>52.303,64</code>.</p> <p>Se preferir outro feed (DAI, ETH etc.), basta repetir os passos usando o endereço correspondente da tabela de ativos suportados.</p> <p>Caso esteja depurando valores inesperados, valide se o <code>decimals()</code> retornado confere com o esperado para aquele par. Divergências de escala são a causa mais comum de leituras “estranhas” no front-end.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#launching-price-feeds-on-an-evm-network", "title": "Lançando Feeds de Preço em uma Rede EVM", "text": "<p>É fácil lançar feeds em uma rede EVM da Tanssi! As etapas a seguir funcionam para redes Trial e dedicadas em Dancelight. Este guia é demonstrativo; para produção, contate a equipe Phala.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#setup", "title": "Setup", "text": "<p>Clone o repositório Phala Mirrored Price Feed e instale dependências:</p> <pre><code>cd mirrored-price-feed/ &amp;&amp; yarn install\n</code></pre> <p>Crie o <code>.env</code> a partir do exemplo:</p> <pre><code>cp env.example .env\n</code></pre> <p>Edite o <code>.env</code> e insira a chave privada de uma conta financiada na sua rede e o RPC da sua rede. Se estiver na sua própria rede, financie uma conta de teste via Sudo (dados no Tanssi dApp). Os demais campos podem ficar em branco.</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=INSERT_YOUR_NETWORK_RPC_URL\nVERIFIER_URL=\nVERIFY_ADDRESS=\n</code></pre> <p>Note</p> <p>Nunca compartilhe frase semente ou chave privada. Este guia é apenas educacional.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#configure-deployment-script", "title": "Configurar Script de Implantação", "text": "<p>Edite <code>scripts/OffchainAggregator.s.sol</code>. Ele recebe <code>decimals</code> (mantenha <code>8</code>) e a descrição do feed (ex.: <code>BTC / USD</code>). Use exatamente as descrições suportadas listadas em Ativos suportados, ou o feed não funcionará.</p> OffchainAggregator.s.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Script, console2} from \"forge-std/Script.sol\";\nimport {OffchainAggregator} from \"../src/OffchainAggregator.sol\";\n\ncontract OffchainAggregatorScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.startBroadcast();\n        OffchainAggregator aggregator = new OffchainAggregator(\n          8,\n          'BTC / USD'\n        );\n        console2.log(address(aggregator));\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>Defina sua cadeia com <code>defineChain</code>, informando o RPC e o chainId da sua rede:</p> <pre><code>const chain = defineChain({\n  id: INSERT_EVM_CHAIN_ID,\n  name: 'dancelight-evm-network',\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n});\n</code></pre> <p>Em <code>feeder.ts</code>, insira os detalhes da sua cadeia (RPC, chainId). O array <code>mainnetFeedContracts</code> (endereços do Mainnet) permanece. Limpe <code>aggregatorContracts</code> por enquanto — mais adiante você adicionará os endereços implantados na sua rede.</p> feeder.ts <pre><code>import {\n  createPublicClient,\n  http,\n  parseAbi,\n  createWalletClient,\n  defineChain,\n} from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst mainnetFeedContracts = {\n  'AAVE-USD': '0x547a514d5e3769680Ce22B2361c10Ea13619e8a9',\n  'CRV-USD': '0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f',\n  'ETH-USD': '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419',\n  'BTC-USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',\n  'DAI-USD': '0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9',\n  'USDT-USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D',\n  'USDC-USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',\n};\n\nconst aggregatorContracts = {};\n\nconst abi = parseAbi([\n  'function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n  'function transmit(uint80 _roundId, int192 _answer, uint64 _timestamp) external',\n  'function getRoundData(uint80 _roundId) public view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n]);\n\n// Insert your network details here\nconst chain = defineChain({\n  id: INSERT_EVM_CHAIN_ID,\n  name: 'dancelight-evm-network',\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n});\n\nconst publicClient = createPublicClient({\n  chain: mainnet,\n  transport: http(),\n});\n\nconst targetChainPublicClient = createPublicClient({\n  chain,\n  transport: http(),\n});\n\nasync function getLatestRoundData(pair: string) {\n  const address = mainnetFeedContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} mainnet feed contract did not exist.`);\n  }\n  const data = await publicClient.readContract({\n    address,\n    abi,\n    functionName: 'latestRoundData',\n  });\n  return data;\n}\n\nasync function getRoundDataFromAggregator(pair: string, roundId: number) {\n  const address = aggregatorContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const publicClient = createPublicClient({\n    chain,\n    transport: http(),\n  });\n  try {\n    const data = await publicClient.readContract({\n      address,\n      abi,\n      functionName: 'getRoundData',\n      args: [roundId],\n    });\n    return data;\n  } catch {}\n}\n\nasync function updateFeed(\n  walletClient: ReturnType&lt;createWalletClient&gt;,\n  pair: string\n) {\n  if (!aggregatorContracts[pair]) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const [roundId, answer, startedAt, updatedAt, answeredInRound] =\n    await getLatestRoundData(pair);\n  const aggregatorRoundId = Number(roundId &amp; BigInt('0xFFFFFFFFFFFFFFFF'));\n  const data = await getRoundDataFromAggregator(pair, aggregatorRoundId);\n  if (data[1] === answer) {\n    console.info(\n      `${pair} aggregatorRoundId ${aggregatorRoundId} data exists: ${data}`\n    );\n    return;\n  }\n\n  const hash = await walletClient.writeContract({\n    address: aggregatorContracts[pair],\n    abi,\n    functionName: 'transmit',\n    args: [roundId, answer, startedAt],\n  });\n  await targetChainPublicClient.waitForTransactionReceipt({ hash });\n  console.info(`${pair} updated, transmit tx hash: ${hash}`);\n}\n\nasync function main() {\n  if (!process.env.PRIVATE_KEY) {\n    throw new Error('missing process.env.PRIVATE_KEY');\n  }\n  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account,\n  });\n  for (const pair in aggregatorContracts) {\n    await updateFeed(walletClient, pair);\n  }\n}\n\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((err) =&gt; {\n    console.error(err);\n    process.exit(1);\n  });\n</code></pre>"}, {"location": "builders/toolkit/integrations/oracles/phala/#build-and-test", "title": "Build e Testes", "text": "<pre><code>yarn build\nyarn test\n</code></pre> <p>Saída esperada:</p> yarn build yarn run v1.22.10  forge build [.] compiling No files changed, compilation skipped ✨ Done in 0.765. yarn test yarn run v1.22.10  forge test [.] compiling No files changed, compilation skipped Running 1 test for test/OffchainAggregator.t.sol:OffchainAggregatorTest [PASS] test_transmit() (gas: 60497) Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.96ms Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests) ✨ Done in 0.765."}, {"location": "builders/toolkit/integrations/oracles/phala/#deploy", "title": "Deploy", "text": "<p>Para implantar o contrato agregador do par escolhido:</p> <pre><code>yarn deploy\n</code></pre> <p>Anote o endereço retornado.</p> Waiting for receipts. [O0:00:18]【######################################################】 1/1 receipts CO.0s) #####7796 ✅ [Success]Hash: Oxfb2f2dc6a35286c4595ce6e2bb64c93425b14c310a53f8224df0520666329fd ✅ Contract Address: OxBc788db88C3344a24706754c1203a267790D626 Block: 4049 Paid: 0.002392252 ETH (598063 gas * 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json ========================== ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.002392252 ETH (598063 gas * avg 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/kevin/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json ✨ Done in 30.765s."}, {"location": "builders/toolkit/integrations/oracles/phala/#access-aggregator-contract", "title": "Acessar o Contrato Agregador", "text": "<p>No Remix, com a MetaMask na sua rede EVM, cole o endereço implantado em At Address. Expanda AggregatorV3Interface e clique em latestRoundData — inicialmente deve retornar <code>0</code> (sem preço atualizado ainda).</p> <p> </p> <p>Se ainda não tiver sua rede configurada na MetaMask, use o botão Add to MetaMask no dashboard do Tanssi dApp para adicioná-la rapidamente.</p>"}, {"location": "builders/toolkit/integrations/oracles/phala/#Trigger", "title": "Disparar Atualização de Preço", "text": "<p>Inclua o endereço do agregador em <code>aggregatorContracts</code> no <code>feeder.ts</code>:</p> <pre><code>const aggregatorContracts = {\n  'BTC-USD': 'INSIRA_ENDERECO_DO_AGREGADOR',\n}\n</code></pre> <p>Depois execute:</p> <pre><code>npx tsx feeder.ts\n</code></pre> npx tsx feeder.ts BTC-USD updated, transmit tx hash: Oxf1797cfc5bd71e2d848b099cae197ff30dafb5f6947481a5ef6c69271e059a96 <p>No Remix, chame latestRoundData novamente para ver o preço atualizado.</p> <p></p> <p>Para mais informações sobre uso da Phala para dados off-chain, veja os docs da Phala.</p> <p>Essa abordagem completa (contrato + script + atualização via feeder) garante que os feeds fiquem sincronizados com as fontes da Chainlink no Mainnet e que sua rede Tanssi receba preços confiáveis.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/integrations/wallet-integrations/", "title": "Integrações de Carteiras", "text": "<p>As integrações de carteiras são essenciais para permitir as interações dos utilizadores com aplicações descentralizadas (dApps), permitindo que os utilizadores gerenciem de forma segura os seus ativos digitais, assinem transações e autentiquem a sua identidade. Estas integrações fornecem aos desenvolvedores as ferramentas para construir aplicações que podem interagir com as carteiras dos utilizadores, facilitando transações e interações blockchain de forma amigável.</p> <p>As principais características das integrações de carteira incluem:</p> <ul> <li>Suporte multi-carteira - suporte imediato para vários provedores de carteira, reduzindo a necessidade de integração personalizada</li> <li>Experiência do utilizador aprimorada - os utilizadores podem facilmente conectar-se usando sua carteira preferida através de uma interface de utilizador intuitiva</li> <li>Componentes de IU pré-construídos - componentes de IU prontos para usar para conexão de carteira, exibição de conta e gerenciamento de saldo, agilizando o desenvolvimento</li> <li>Personalização - personalize a aparência e o comportamento do modal da carteira para corresponder à sua marca e ao design da interface do utilizador</li> </ul>"}, {"location": "builders/toolkit/integrations/wallet-integrations/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/", "title": "Integrar RainbowKit a uma Rede Tanssi", "text": ""}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#introducao", "title": "Introdução", "text": "<p>RainbowKit é uma biblioteca React que adiciona conexão de carteiras a um dApp. Ela suporta várias carteiras e oferece recursos como alternar cadeias, resolver endereços ENS e exibir saldo. O RainbowKit traz opções de customização para cadeias compatíveis com EVM, facilitando conectar carteiras a redes personalizadas.</p> <p>O RainbowKit agrupa várias ferramentas para simplificar a conexão de carteiras em um dApp:</p> <ul> <li>Wagmi — hooks React para contas, carteiras, contratos, transações, assinatura, ENS e mais</li> <li>viem — interface TypeScript com primitivas de baixo nível para interagir com Ethereum</li> <li>WalletConnect — adiciona conexões criptografadas e UX aprimorada (ex.: conectar carteira móvel via QR)</li> <li>TanStack Query — ajuda a gerenciar e atualizar estado de servidor no app</li> </ul> <p>Usando essas peças juntas, você evita reimplementar fluxo de conexão, persistência de sessão, atualização de saldo e troca de redes, acelerando a entrega do dApp.</p> <p>Este guia explica como adicionar o RainbowKit a um dApp em uma rede powered by Tanssi usando a CLI, além de opções para personalizar a integração.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#quick-start", "title": "Início Rápido", "text": "<p>Para começar um projeto novo, o RainbowKit pode gerar um esqueleto via CLI com RainbowKit e Wagmi em uma aplicação Next.js. Use o gerenciador de pacotes de sua preferência:</p> npmpnpmyarn <pre><code>npm init @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>pnpm create @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>yarn create @rainbow-me/rainbowkit\n</code></pre> <p>O script pedirá o nome do projeto, criará o diretório com o boilerplate e instalará as dependências.</p> npm init @rainbow-me/rainbowkit@latest   🌈 Welcome to RainbowKit!  rainbow-demo  🚀 Creating a new RainbowKit app in /Users/papermoon/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo  📦 Installing dependencies with npm. This could take a while. 📚 Initializing git repository  🌈 Done! Thanks for using RainbowKit 🙏  👉 To get started, run cd rainbow-demo and then npm run dev <p>Em seguida, inicie o servidor de desenvolvimento e abra <code>http://localhost:3000</code>:</p> npmpnpmyarn <pre><code>cd INSERT_PROJECT_NAME\nnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\npnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\nyarn dev\n</code></pre> <p>Você verá a tela inicial:</p> <p></p> <p>Abra o projeto no editor e veja o arquivo <code>wagmi.ts</code>. É nele que você configura as cadeias disponíveis para conexão.</p> <p>Como a rede EVM demo é uma rede personalizada da Tanssi, ela não pode ser importada direto de <code>wagmi/chains</code>. Defina a cadeia manualmente em <code>wagmi.ts</code>.</p> <p>Configuração para a rede EVM demo da Tanssi:</p> Demo EVM Network src/wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'TODO: get project id from...',\n  chains: [demoEVMChain], \n  ssr: true,\n});\n</code></pre> <p>Atualize <code>wagmi.ts</code> conforme acima para suportar a rede demo. A próxima seção mostra como obter o <code>projectId</code> do WalletConnect.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#configuracao-manual", "title": "Configuração Manual", "text": "<p>As seções seguintes mostram como integrar o RainbowKit em um app React existente: instalar dependências, configurar cadeias, disponibilizar o RainbowKit no dApp, definir a cadeia padrão do Connect Wallet e personalizar o tema. O exemplo usa a rede EVM demo da Tanssi, mas pode ser adaptado mudando o RPC.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<ul> <li>Uma rede compatível com EVM na Tanssi</li> <li>Um dApp existente em React</li> <li>Exemplos do repositório RainbowKit (há templates para vários frameworks)</li> <li>Para seguir este guia, crie um projeto Next.js (Typescript + App Router) seguindo a instalação automática em Next.js</li> <li>A carteira deve suportar redes personalizadas (a rede demo será adicionada manualmente)</li> <li>Um <code>projectId</code> do WalletConnect (gratuito):<ol> <li>Vá em WalletConnect Cloud</li> <li>Em Projects, clique Create</li> <li>Preencha as informações (pode deixar Homepage URL em branco se não estiver deployado)</li> <li>Escolha o SDK AppKit</li> <li>Escolha o ambiente (React neste guia)</li> <li>Copie o <code>projectId</code> no menu lateral ou no snippet do Quickstart</li> </ol> </li> </ul>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#getting-started", "title": "Começando", "text": "<p>Instale RainbowKit e dependências:</p> npmpnpmyarn <pre><code>npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <p>Suba o servidor de desenvolvimento:</p> npmpnpmyarn <pre><code>npm run dev\n</code></pre> <pre><code>pnpm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <p>Abra <code>http://localhost:3000</code>.</p> <p>Para testar, conecte a carteira MetaMask na rede EVM demo da Tanssi. Adicione a rede no MetaMask:</p> <ol> <li>Configurações &gt; Redes &gt; Adicionar Rede</li> <li>Preencha:</li> <li>Nome: <code>Demo EVM Chain</code></li> <li>RPC URL: <code>https://services.tanssi-testnet.network/dancelight-2001/</code></li> <li>Chain ID: <code>5678</code></li> <li>Símbolo: <code>TANGO</code></li> <li>Block Explorer: <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> </ol> <p>Para instruções detalhadas, veja Conecte o MetaMask à sua Rede EVM Tanssi.</p> <p>Depois, adicione o <code>projectId</code> ao app:</p> <ol> <li> <p>Crie <code>.env.local</code> na raiz:</p> <pre><code>touch .env.local\n</code></pre> </li> <li> <p>Adicione o ID:</p> .env.local<pre><code>NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'\n</code></pre> </li> <li> <p>Confirme que <code>.env*.local</code> está no <code>.gitignore</code> para evitar commit.</p> </li> </ol> <p>Se você usa vários ambientes (dev/homologação/prod), crie um <code>projectId</code> separado para cada um e valide se o domínio cadastrado no WalletConnect Cloud corresponde ao ambiente correto.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#conectar-o-dapp-ao-metamask", "title": "Conectar o dApp ao MetaMask", "text": "<p>Passos principais:</p> <ol> <li>Importar RainbowKit, Wagmi e TanStack Query</li> <li>Configurar o Wagmi</li> <li>Envolver o app com providers</li> <li>Adicionar o botão de conexão</li> </ol> <p>Seguir essa ordem garante que o estado de conexão e os modais do RainbowKit funcionem em toda a aplicação.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#importar-rainbowkit-wagmi-e-tanstack-query", "title": "Importar RainbowKit, Wagmi e TanStack Query", "text": "<p>Crie <code>wagmi.ts</code> na raiz com imports e a cadeia demo EVM:</p> <pre><code>touch wagmi.ts\n</code></pre> wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',\n  chains: [demoEVMChain ], \n  ssr: true,\n});\n</code></pre>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#envolver-o-aplicativo-com-providers", "title": "Envolver o aplicativo com providers", "text": "<p>Crie <code>providers.tsx</code> para incluir <code>WagmiProvider</code> e <code>QueryClientProvider</code>:</p> <pre><code>cd app &amp;&amp; touch providers.tsx\n</code></pre> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { config } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider&gt;{children}&lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Depois, edite <code>app/layout.tsx</code> para usar <code>Providers</code>:</p> layout.tsx<pre><code>import type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport '@rainbow-me/rainbowkit/styles.css';\nimport { Providers } from './providers';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'My Tanssi dApp',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &lt;html lang='en'&gt;\n      &lt;body&gt;\n        &lt;Providers&gt;{children}&lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#adicionar-o-botao-connect", "title": "Adicionar o Botão Connect", "text": "<p>Use o componente <code>ConnectButton</code> (pode ficar em <code>page.tsx</code> ou em um header/nav):</p> page.tsx<pre><code>import { ConnectButton } from '@rainbow-me/rainbowkit';\n\nexport default function Home() {\n  return (\n    &lt;div className=\"flex h-screen items-center justify-center\"&gt;\n      &lt;ConnectButton /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Com o servidor rodando, aparecerá Connect Wallet; clicar abre o modal RainbowKit. Selecione MetaMask e conecte. A configuração padrão usa a Demo EVM Chain e mostra rede, saldo do token nativo e endereço.</p> <p>Se você tiver vários botões ou páginas, considere criar um componente compartilhado para evitar duplicar lógica de conexão e estilização.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#personalizar-o-rainbowkit", "title": "Personalizar o RainbowKit", "text": "<p>O RainbowKit facilita a conexão e permite customizar UI/UX. Veja todas as opções na docs do RainbowKit. Aqui vamos definir a cadeia inicial e aplicar tema customizado.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#definir-cadeia-inicial", "title": "Definir Cadeia Inicial", "text": "<p>O RainbowKit conecta na primeira cadeia da lista do Wagmi. Melhor é usar <code>initialChain</code> no <code>RainbowKitProvider</code>. Em <code>providers.tsx</code>, defina:</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider initialChain={demoEVMChain}&gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n\n}\n</code></pre> <p>Isso força conectar primeiro na Demo EVM Chain.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#definir-cores-de-tema", "title": "Definir Cores de Tema", "text": "<p>Use <code>lightTheme</code>, <code>darkTheme</code> ou <code>midnightTheme</code>. Exemplo com tema escuro customizado (adicione <code>darkTheme</code> ao import):</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider\n          initialChain={demoEVMChain}\n          theme={darkTheme({\n            accentColor: '#189B9B', // Tanssi accent color\n            accentColorForeground: 'white',\n            borderRadius: 'medium',\n            fontStack: 'system',\n            overlayBlur: 'small'\n          })}\n        &gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Campos: - <code>accentColor</code> — cor primária (ex.: #189B9B da Tanssi) - <code>accentColorForeground</code> — cor do texto sobre a primária - <code>borderRadius</code> — arredondamento - <code>fontStack</code> — fontes (ex.: <code>system</code>) - <code>overlayBlur</code> — desfoque de fundo em modais</p> <p>Você pode ainda ajustar ícones, textos do modal e posição do botão criando um tema customizado ou sobrescrevendo componentes via props do <code>ConnectButton</code>.</p> <p>Tip</p> <p>Teste temas e cores para combinar com o estilo do seu dApp.</p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#lidar-com-desconexoes", "title": "Lidar com Desconexões", "text": ""}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-dapp", "title": "Desconectar no dApp", "text": "<p>O modal RainbowKit inclui Disconnect; clique na seta ao lado da conta e depois Disconnect.</p> <p></p>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-metamask", "title": "Desconectar no MetaMask", "text": "<ol> <li>Abra a extensão MetaMask  </li> <li>Clique nos três pontos (canto superior direito)  </li> <li>Selecione Connected sites </li> <li>Revise e clique Disconnect nos sites desejados</li> </ol>"}, {"location": "builders/toolkit/integrations/wallet-integrations/rainbowkit/#final-result", "title": "Resultado final", "text": "<p>O botão Connect Wallet deve usar a cor definida em <code>accentColor</code>; o modal também. Escolha MetaMask, assine e veja a rede EVM demo conectada com o saldo de TANGO sem precisar trocar manualmente.</p> <p>Se desejar suportar redes adicionais, basta adicioná-las em <code>wagmi.ts</code> e fornecer RPCs confiáveis; o modal exibirá as opções no Switch Networks respeitando a ordem definida. Verifique também se os explorers configurados respondem corretamente para evitar erros de UX.</p> <p></p> <p>Mais opções estão na docs do RainbowKit. Código completo no repositório rainbowkit-manual-build-demo.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/", "title": "Ferramentas Substrate", "text": "<p>Ao desenvolver na Tanssi ou em qualquer rede powered by Tanssi, é importante entender a infraestrutura subjacente que impulsiona essas cadeias. Construídas sobre o framework Substrate, essas redes oferecem uma base robusta e flexível para a construção de aplicações e serviços descentralizados. Interagir com a API Substrate é fundamental para interagir com as funcionalidades principais do blockchain.</p> <p>Quer você esteja construindo aplicações descentralizadas (dApps), implantando contratos inteligentes ou consultando dados de blockchain, ter as ferramentas e fluxos de trabalho corretos para interagir com esta API ajudará você a otimizar o desenvolvimento e garantir uma integração perfeita com a rede.</p> <p>Pronto para mergulhar? Confira algumas das seguintes ferramentas:</p> <ul> <li>Ambientes de desenvolvimento - Chopsticks</li> <li>Bibliotecas - API Polkadot.js e API REST Sidecar</li> <li>Carteiras - SubWallet e Talisman</li> </ul>"}, {"location": "builders/toolkit/substrate-api/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/substrate-api/dev-env/", "title": "Configure Seu Espaço de Trabalho", "text": "<p>A construção no Substrate envolve trabalhar com uma estrutura de blockchain flexível e modular. Ao contrário das blockchains tradicionais, a arquitetura baseada em paletes do Substrate permite que os desenvolvedores criem blockchains personalizadas e integrem recursos especializados, o que requer um ambiente de desenvolvimento adaptado às suas complexidades.</p> <p>Nesta seção, você explorará ferramentas e técnicas que podem ajudá-lo a alcançar o seguinte com um ambiente de desenvolvimento Substrate:</p> <ul> <li>Configuração do ambiente local - inicie um ambiente de teste sem lidar com a complexidade de configurar um nó Substrate manualmente</li> <li>Interação com a rede - conecte-se e interaja com redes Tanssi e Powered by Tanssi</li> <li>Simulação de transação - teste e simule transações em redes bifurcadas para avaliar as alterações antes de implantar</li> <li>Depuração - use ferramentas de depuração para solucionar problemas e analisar o fluxo de transações, transições de estado e muito mais em um ambiente controlado</li> </ul>"}, {"location": "builders/toolkit/substrate-api/dev-env/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/", "title": "Como usar o Chopsticks para bifurcar sua rede", "text": ""}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#introduction", "title": "Introdução", "text": "<p>Chopsticks oferece uma forma amigável para desenvolvedores bifurcarem localmente cadeias baseadas em Substrate. Ele permite reproduzir blocos para examinar como transações afetam o estado, bifurcar múltiplas redes Tanssi para testes de XCM e muito mais. Isso facilita testar e experimentar configurações personalizadas de blockchain em um ambiente local sem precisar implantar uma rede real.</p> <p>Em resumo, o Chopsticks simplifica o processo de construir aplicações em Substrate e o torna acessível a mais desenvolvedores.</p> <p>Este artigo mostra como usar o Chopsticks para bifurcar e interagir com uma cópia local de uma rede Tanssi.</p> <p>Note</p> <p>O Chopsticks atualmente não suporta chamadas via Ethereum JSON-RPC. Portanto, você não pode bifurcar sua cadeia com o Chopsticks e conectar o Metamask a ela.</p>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#prerequisites", "title": "Pré-requisitos", "text": "<p>Para seguir este tutorial, clone o repositório com seus submódulos (Smoldot):</p> <pre><code>git clone --recurse-submodules https://github.com/AcalaNetwork/chopsticks.git\n</code></pre> <p>Depois, entre na pasta e instale as dependências usando o yarn:</p> <pre><code> cd chopsticks &amp;&amp; yarn\n</code></pre> <p>Por fim, faça o build do projeto:</p> <pre><code>yarn build-wasm\n</code></pre> <p>Agora o ambiente de desenvolvimento está pronto para começar a testar e depurar redes implantadas com Tanssi.</p>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#forking-demo-chain", "title": "Bifurcando uma rede EVM de Demonstração com o Chopsticks", "text": "<p>Para bifurcar uma rede Tanssi usando o Chopsticks, execute o comando passando apenas o endpoint RPC:</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Esse comando inicia um clone local da cadeia no último bloco.</p>      chopsticks % yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001         [01:59:42.628] INFO (xcm/59650): Frontier Container 2001 RPC listening on port 8000    <p>Normalmente, os parâmetros de configuração ficam em um arquivo de configuração, como os que estão na pasta <code>configs</code> do repositório para relay chains e parachains do ecossistema Dotsama. O arquivo a seguir funciona para a rede EVM de demonstração, sobrescrevendo a conta sudo da cadeia pela conta da Alith e financiando-a com tokens:</p> <pre><code>endpoint: wss://services.tanssi-testnet.network/dancelight-2001/\nmock-signature-host: true\nallow-unresolved-imports: true\ndb: ./tmp/db_ftrcon.sqlite\n\nimport-storage:\n  System:\n    Account:\n      - - - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\" # Alith\n        - providers: 1\n          sufficients: 1\n          consumers: 1\n          data:\n            free: \"100000000000000000000000\"\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n</code></pre> <p>O arquivo de configuração aceita todos os parâmetros a seguir:</p> Opção Descrição <code>genesis</code> Link para o raw genesis de uma parachain para construir o fork, em vez de usar um endpoint. <code>timestamp</code> Timestamp do bloco de origem do fork. <code>endpoint</code> Endpoint da parachain a ser bifurcada. <code>block</code> Especifica em qual hash ou número de bloco o fork deve ser reproduzido. <code>wasm-override</code> Caminho do Wasm a usar como runtime da parachain em vez do runtime do endpoint. <code>db</code> Caminho para o arquivo que armazena (ou armazenará) o banco de dados da parachain. <code>config</code> Caminho ou URL do arquivo de configuração. <code>port</code> Porta para expor um endpoint. <code>build-block-mode</code> Como os blocos devem ser construídos: batch, manual, instant. <code>import-storage</code> Caminho JSON/YAML de um storage predefinido para sobrescrever o storage da parachain. <code>allow-unresolved-imports</code> Se permite imports Wasm não resolvidos ao usar um Wasm para construir a parachain. <code>html</code> Inclua para gerar preview de diff de storage entre blocos. <code>mock-signature-host</code> Mock de assinatura: qualquer assinatura iniciada com <code>0xdeadbeef</code> e preenchida com <code>0xcd</code> é válida. <p>Você pode rodar <code>yarn start</code> para bifurcar cadeias informando um arquivo de configuração local. Como alternativa, use o nome ou a URL do GitHub se a cadeia estiver listada na pasta <code>configs</code> do repositório.</p> Caminho de arquivo localNome da cadeiaURL do GitHub <pre><code>yarn start --config=configs/polkadot.yml\n</code></pre> <pre><code>yarn start --config=polkadot\n</code></pre> <pre><code>yarn start \\\n--config=https://github.com/AcalaNetwork/chopsticks.git/master/configs/polkadot.yml\n</code></pre> <p>Todas as configurações (exceto <code>genesis</code> e <code>timestamp</code>) também podem ser passadas como flags para definir o ambiente apenas pela linha de comando. Por exemplo, o comando a seguir bifurca a rede EVM de demonstração no bloco 100.</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/ --block 100\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#interacting-with-a-fork", "title": "Interagir com um Fork", "text": "<p>Ao executar um fork, por padrão ele fica acessível em:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>Você pode interagir com a parachain via bibliotecas como Polkadot.js e sua interface Polkadot.js Apps.</p> <p></p> <p>Agora você deve conseguir interagir com a cadeia bifurcada como faria com a real.</p> <p>Note</p> <p>Se o navegador não conseguir conectar ao endpoint WebSocket do Chopsticks, talvez seja necessário permitir conexões inseguras na URL do Polkadot.js Apps. Outra opção é usar a versão em Docker do Polkadot.js Apps.</p>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#replaying-blocks", "title": "Reproduzindo Blocos", "text": "<p>Se quiser reproduzir um bloco e recuperar suas informações para dissecar os efeitos de um extrínseco, use o comando <code>yarn start run-block</code>. Os flags são:</p> Flag Descrição <code>endpoint</code> Endpoint da parachain a ser bifurcada. <code>block</code> Especifica em qual hash ou número de bloco reproduzir o fork. <code>wasm-override</code> Caminho do Wasm a usar como runtime da parachain em vez do runtime do endpoint. <code>db</code> Caminho para o arquivo que armazena (ou armazenará) o banco de dados da cadeia. <code>config</code> Caminho ou URL do arquivo de configuração. <code>output-path=/[file_path]</code> Imprime os resultados em um arquivo JSON em vez de exibi-los no console. <code>html</code> Inclua para gerar uma representação HTML do diff de storage entre blocos. <code>open</code> Define se abre a representação HTML. <p>Por exemplo, o comando abaixo executa novamente o bloco 1000 da rede EVM de demonstração e grava o diff de storage e outros dados em <code>chain-output.json</code>:  </p> <pre><code>yarn start run-block  \\\n--endpoint wss://services.tanssi-testnet.network/dancelight-2001/  \\\n--output-path=./chain-output.json  \\\n--block 1000\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/dev-env/chopsticks/#websocket-commands", "title": "Comandos WebSocket", "text": "<p>O servidor WebSocket interno do Chopsticks possui endpoints especiais para manipular a cadeia Substrate local.</p> <p>Estes são os métodos que podem ser invocados e seus parâmetros:</p> dev_newBlock (options) — Gera um ou mais blocos novos ParâmetrosExemplo <ul> <li>options - <code>{ \"to\": number, \"count\": number }</code> - objeto JSON em que <code>\"to\"</code> cria blocos até certo valor e <code>\"count\"</code> aumenta em determinado número de blocos. Use apenas uma entrada por vez no objeto</li> </ul> <pre><code>import { WsProvider } from '@polkadot/api'\nconst ws = new WsProvider(`ws://localhost:8000`)\n// Cria cinco blocos novos\nawait ws.send('dev_newBlock', [{ count: 5 }])\n</code></pre> dev_setStorage (values, blockHash) — Cria ou sobrescreve o valor de qualquer storage ParâmetrosExemplo <ul> <li>values - Objeto - JSON semelhante ao caminho para um valor de storage, como você obteria via Polkadot.js  </li> <li>blockHash - String - opcional, hash do bloco no qual o valor de storage é alterado  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Sobrescreve a chave sudo\nawait ws.send('dev_setStorage', \n    [{\"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" }}]\n);\n</code></pre> dev_timeTravel (date) — Define o timestamp do bloco para o valor informado ParâmetrosExemplo <ul> <li>date - Date - string compatível com a biblioteca Date do JavaScript que altera o timestamp dos próximos blocos. Todos os blocos futuros serão criados sequencialmente após esse ponto no tempo  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Define o timestamp para 15 de agosto de 2030\nawait ws.send('dev_timeTravel', [\"2030-08-15T00:00:00\"]);\n</code></pre> dev_setHead (hashOrNumber) — Define a head da blockchain para um hash ou número específico ParâmetrosExemplo <ul> <li>hashOrNumber - number | string - se encontrado, a head será definida para o bloco com esse número ou hash</li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Define a head para o bloco 500\nawait ws.send('dev_setHead', [500]);\n</code></pre>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/libraries/", "title": "Bibliotecas", "text": "<p>Como Tanssi e as redes baseadas em Tanssi são construídas no Substrate, os desenvolvedores podem utilizar bibliotecas personalizadas para a API Substrate para aproveitar os recursos distintos da rede.</p> <p>Essas bibliotecas simplificam a interação com a arquitetura modular do Substrate, ajudando você a navegar pelas complexidades dos módulos personalizados com facilidade e acelerar seu processo de desenvolvimento.</p> <p>Alguns recursos principais de trabalhar com bibliotecas incluem:</p> <ul> <li>Gerenciamento de transações - construir e assinar transações para enviar extrínsecas (mudanças de estado) para o blockchain</li> <li>Interação com módulos personalizados - invocar as funções expostas de um módulo, para consultar dados da cadeia ou acionar mudanças de estado</li> <li>Gerenciamento de contas - criar pares de chaves criptográficas para assinar transações e gerenciar informações de contas na cadeia, como saldos</li> </ul>"}, {"location": "builders/toolkit/substrate-api/libraries/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/", "title": "Biblioteca da API Polkadot.js", "text": ""}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#introduction", "title": "Introdução", "text": "<p>Polkadot.js é um conjunto de ferramentas que permite interagir com blockchains baseadas em Substrate, como a sua rede com Tanssi! A API Polkadot.js é um de seus componentes: uma biblioteca que permite aos desenvolvedores consultar a rede e interagir com as interfaces Substrate do nó usando JavaScript, possibilitando ler e escrever dados na rede.</p> <p>Você pode usar a API Polkadot.js para consultar dados on-chain e enviar transações pelo lado Substrate da sua rede Tanssi. É possível consultar constantes do runtime, estado da cadeia, eventos, dados de transações (extrínsecas) e muito mais.</p> <p>Aqui você encontra uma visão geral das funcionalidades disponíveis e exemplos de código em TypeScript para começar a interagir com sua rede Tanssi usando a biblioteca Polkadot.js API.</p> <p>Nota do editor (atualização 2025)</p> <p>Polkadot.js é o nome do conjunto de ferramentas para interação com blockchains Substrate. Embora o nome faça referência ao Polkadot, a biblioteca é agnóstica de cadeia e funciona com qualquer rede baseada em Substrate, incluindo o Tanssi.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#installing-polkadot.js-api-library", "title": "Instalar a API Polkadot.js", "text": "<p>Primeiro, instale a biblioteca Polkadot.js API e a biblioteca RLP usando um gerenciador de pacotes como <code>yarn</code>. Ambas são necessárias para executar os exemplos deste guia.</p> <p>Instale no diretório do projeto com:</p> npmyarn <pre><code>npm i @polkadot/api\nnpm i @polkadot/util-rlp\n</code></pre> <pre><code>yarn add @polkadot/api\nyarn add @polkadot/util-rlp\n</code></pre> <p>A biblioteca também inclui outros componentes centrais, como o Keyring para gerenciamento de contas e utilitários usados ao longo do guia.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-an-API-provider-instance", "title": "Criar uma Instância do Provedor da API", "text": "<p>Para interagir com sua rede Tanssi usando a Polkadot.js API, crie uma instância da API. Construa o <code>WsProvider</code> usando o endpoint WebSocket da sua rede Tanssi.</p> <pre><code>// Importar\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construir provedor da API\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Seu código aqui\n\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration", "title": "Metadata e Decoração Dinâmica da API", "text": "<p>Quando a API Polkadot.js se conecta a um nó, uma das primeiras ações é recuperar a metadata e decorar a API com base nela. A metadata fornece a estrutura:</p> <pre><code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;\n</code></pre> <p>Onde <code>&lt;type&gt;</code> pode ser:</p> <ul> <li><code>query</code> — endpoints de leitura de estado</li> <li><code>tx</code> — endpoints relacionados a transações</li> <li><code>rpc</code> — endpoints específicos para chamadas RPC</li> <li><code>consts</code> — endpoints para constantes do runtime</li> </ul> <p>Nada em <code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> é hardcoded. Isso torna a biblioteca modular e adaptável a qualquer cadeia Substrate com diferentes módulos, como sua rede Tanssi.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#querying-for-information", "title": "Consultar Dados On-Chain", "text": ""}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#state-queries", "title": "Consultas de Estado", "text": "<p>Recuperam informações sobre o estado atual da cadeia. Esses endpoints geralmente têm a forma <code>api.query.&lt;module&gt;.&lt;method&gt;</code>, decorados a partir da metadata. Liste endpoints inspecionando <code>api.query</code>, por exemplo:</p> <pre><code>console.log(api.query);\n</code></pre> <p>Após inicializar a API, você pode obter informações básicas de conta com:</p> <pre><code>// Definir endereço da carteira\nconst addr = 'INSERT_ADDRESS';\n\n// Obter o último timestamp\nconst now = await api.query.timestamp.now();\n\n// Obter saldo da conta e nonce atual via módulo system\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> Veja o script completo <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Retrieve the last timestamp via the timestamp module\n  const now = await api.query.timestamp.now();\n\n  // Retrieve the account balance &amp; current nonce via the system module\n  const { nonce, data: balance } = await api.query.system.account(addr);\n\n  console.log(\n    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#rpc-queries", "title": "Consultas RPC", "text": "<p>As chamadas RPC são a base para transmissão de dados com o nó. Endpoints como <code>api.query</code>, <code>api.tx</code> ou <code>api.derive</code> encapsulam chamadas RPC, fornecendo informações no formato esperado pelo nó. Liste endpoints via:</p> <pre><code>console.log(api.rpc);\n</code></pre> <p>O <code>api.rpc</code> segue formato semelhante ao <code>api.query</code>. Por exemplo, após inicializar a API, obtenha dados da cadeia e o cabeçalho mais recente:</p> <pre><code>// Obter nome da cadeia\nconst chain = await api.rpc.system.chain();\n\n// Obter o cabeçalho mais recente\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// Registrar as informações\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#query-subscriptions", "title": "Consultas por Assinatura", "text": "<p>O <code>rpc</code> também oferece endpoints de assinatura. Após inicializar a API, você pode ouvir novos blocos:</p> <pre><code>// Obter nome da cadeia\nconst chain = await api.rpc.system.chain();\n\n// Assinar novos cabeçalhos\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n</code></pre> <p>O padrão geral em <code>api.rpc.subscribe*</code> é passar um callback que é acionado a cada novo item importado.</p> <p>Chamadas em <code>api.query.*</code> também aceitam callbacks para modo assinado, inclusive chamadas com parâmetros. Exemplo para monitorar saldo de uma conta:</p> <pre><code>// Definir endereço da carteira\nconst addr = 'INSERT_ADDRESS';\n\n// Assinar mudanças de saldo para uma conta específica\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n</code></pre> Veja o script completo <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#keyrings", "title": "Criar um Keyring para uma Conta", "text": "<p>O objeto Keyring mantém pares de chaves e assina quaisquer dados, seja transferência, mensagem ou interação com contrato.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-a-keyring-instance", "title": "Criar uma Instância de Keyring", "text": "<p>Instancie a classe Keyring e defina o tipo padrão de endereço. O padrão é <code>sr25519</code>, mas para redes Tanssi compatíveis com EVM use <code>ethereum</code>.</p> <pre><code>// Importe o keyring conforme necessário\nimport Keyring from '@polkadot/keyring';\n\n// Crie uma instância de keyring (ECDSA)\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\n\n// Crie uma instância de keyring (SR25519)\nconst keyring = new Keyring({ type: 'sr25519' });\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#adding-accounts", "title": "Adicionar uma Conta ao Keyring", "text": "<p>Há várias formas de adicionar contas, incluindo frase mnemônica e chave privada curta. Exemplos:</p> Mnemonic (ECDSA)Chave privada (ECDSA)Mnemonic (SR25519) <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';\n\n// Import Ethereum account from mnemonic\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Define index of the derivation path and the derivation path\nconst index = 0;\nconst ethDerPath = \"m/44'/60'/0'/0/\" + index;\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst newPairEth = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${newPairEth.address}`);\n\n// Extract private key from mnemonic\nconst privateKey = u8aToHex(\n  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)\n    .secretKey\n);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from private key\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst otherPair = keyringECDSA.addFromUri(privateKeyInput);\nconsole.log(`Derived Address from provided Private Key: ${otherPair.address}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  await cryptoWaitReady();\n\n  // Import SR25519 account from mnemonic\n  const keyring = new Keyring({ type: 'sr25519' });\n  const mnemonic = 'INSERT_MNEMONIC';\n\n  // Extract SR25519 address from mnemonic\n  const newPair = keyring.addFromUri(`${mnemonic}`);\n  console.log(`Derived SR25519 Address from Mnemonic: ${newPair.address}`);\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#transactions", "title": "Enviando Transações", "text": "<p>Endpoints de transação têm a forma <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>, decorados via metadata. Eles permitem enviar transações para inclusão em blocos — transferências, interações com pallets, ou qualquer coisa suportada. Liste endpoints via:</p> <pre><code>console.log(api.tx);\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#sending-basic-transactions", "title": "Enviar uma Transação Básica", "text": "<p>A Polkadot.js API pode enviar transações. Supondo que você tenha inicializado a API e um keyring, use:</p> <pre><code>// Inicializar pares de chaves da carteira\nconst alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n// Montar a transação\nconst tx = await api.tx.balances.transferAllowDeath(\n  'INSERT_BOBS_ADDRESS',\n  BigInt(INSERT_VALUE)\n);\n\n// Obter o calldata codificado da transação\nconst encodedCallData = tx.method.toHex()\nconsole.log(`Encoded calldata: ${encodedCallData}`);\n\n// Assinar e enviar a transação\nconst txHash = await tx.signAndSend(alice);\n\n// Exibir o hash da transação\nconsole.log(`Submitted with hash ${txHash}`);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Form the transaction\n  const tx = await api.tx.balances.transferAllowDeath(\n    'INSERT_BOBS_ADDRESS',\n    BigInt(INSERT_VALUE)\n  );\n\n  // Retrieve the encoded calldata of the transaction\n  const encodedCalldata = tx.method.toHex();\n  console.log(`Encoded calldata: ${encodedCalldata}`);\n\n  // Sign and send the transaction\n  const txHash = await tx.signAndSend(alice);\n\n  // Show the transaction hash\n  console.log(`Submitted with hash ${txHash}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre> <p>Observe que <code>signAndSend</code> aceita parâmetros opcionais, como <code>nonce</code>, por exemplo <code>signAndSend(alice, { nonce: aliceNonce })</code>. Você pode usar o código da seção Consultas de estado para obter o nonce correto, incluindo transações no mempool.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#fees", "title": "Informações de Taxa", "text": "<p>Os endpoints de transação também oferecem um método para obter o peso de um <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>. Use <code>paymentInfo</code> após montar a transação com o módulo e método específicos.</p> <p><code>paymentInfo</code> retorna informações de peso em <code>refTime</code> e <code>proofSize</code>, que podem ser usadas para determinar a taxa da transação — útil ao criar execuções remotas via XCM.</p> <p>Exemplo, após inicializar a API, para obter peso de uma transferência simples:</p> <pre><code>// Transação para obter informações de peso\nconst tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n// Obter informações de peso\nconst { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\nconsole.log(`Transaction weight: ${weight}`);\nconsole.log(`Transaction fee: ${partialFee.toHuman()}`);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Transaction to get weight information\n  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n  // Get weight info\n  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\n  console.log(`Transaction weight: ${weight}`);\n  console.log(`Transaction fee: ${partialFee.toHuman()}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#transaction-events", "title": "Eventos de Transação", "text": "<p>Qualquer transação emite eventos; no mínimo, haverá <code>system.ExtrinsicSuccess</code> ou <code>system.ExtrinsicFailed</code>, indicando sucesso ou falha na execução. Dependendo da transação, outros eventos podem ser emitidos, por exemplo <code>balances.Transfer</code> em uma transferência.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#batching-transactions", "title": "Agrupar Transações", "text": "<p>A Polkadot.js API permite processar transações em lote via <code>api.tx.utility.batch</code>. As transações são processadas sequencialmente de um único remetente. A taxa pode ser estimada com <code>paymentInfo</code>.</p> <p>Assumindo que você tenha inicializado a API, um keyring e adicionado uma conta, o exemplo abaixo faz duas transferências em uma transação:</p> <pre><code>// Construir lista de transações para o batch\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n];\n\n// Estime as taxas como RuntimeDispatchInfo usando o assinante\n// (endereço ou par de chaves bloqueado/desbloqueado)\nconst info = await api.tx.utility\n  .batch(txs)\n  .paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construir o batch e enviar as transações\nawait api.tx.utility\n  .batch(txs)\n  .signAndSend(alice, ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`included in ${status.asInBlock}`);\n\n      // Desconecte a API aqui!\n    }\n  });\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  await api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#sample-code-for-monitoring-native-token-transfers", "title": "Código de Exemplo para Monitorar Transferências do Token Nativo", "text": "<p>Os códigos a seguir mostram como escutar transferências do token nativo, enviadas via Substrate ou Ethereum API, usando a biblioteca Polkadot.js ou o Substrate API Sidecar. Os snippets são para demonstração e precisam de ajustes e testes antes de produção.</p> <p>O snippet abaixo usa <code>subscribeFinalizedHeads</code> para assinar cabeçalhos de blocos finalizados, percorre as extrínsecas do bloco e recupera eventos de cada extrínseca. Se encontrar um evento <code>balances.Transfer</code>, extrai <code>from</code>, <code>to</code>, <code>amount</code> e o <code>tx hash</code> e mostra no console. O <code>amount</code> aparece na menor unidade (Wei). Veja a documentação oficial para detalhes da API Polkadot.js e do JSON RPC do Substrate.</p> <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all Native token transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for any Tanssi-powered network\n\nconst main = async () =&gt; {\n  // Define the provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  // Create the provider\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        (await polkadotApi.at(lastFinalizedHeader.hash)).query.system.events(),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>Há mais exemplos de transferências neste gist.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/polkadot-js-api/#utilities", "title": "Funções Utilitárias", "text": "<p>A API Polkadot.js inclui utilitários para primitivas criptográficas e funções de hash.</p> <p>O exemplo a seguir calcula o hash determinístico de uma transação Ethereum legacy crua: primeiro gera a codificação RLP (Recursive Length Prefix) e depois aplica keccak256.</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Defina o tipo da chave como string\ntype txType = {\n  [key: string]: any;\n};\n\n// Defina a transação assinada bruta\nconst txData: txType = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extraia os valores para um array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calcule a transação codificada em RLP\nvar encoded_tx = encode(txDataArray);\n\n// Faça o hash da transação codificada usando keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>Consulte o repositório NPM para a lista de métodos disponíveis em <code>@polkadot/util-crypto</code> e suas descrições.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/", "title": "Usando o Substrate API Sidecar", "text": ""}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#introduction", "title": "Introdução", "text": "<p>O Substrate API Sidecar permite que aplicações acessem blocos, saldo de contas e outras informações de blockchains baseadas em Substrate por meio de uma API REST. Isso é útil para exchanges, carteiras ou outras aplicações que precisam acompanhar saldo e mudanças de estado em uma rede powered by Tanssi. Esta página descreve como instalar e executar o Substrate API Sidecar para uma rede Tanssi e os endpoints mais usados.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#installing-and-running-substrate-api-sidecar", "title": "Instalando e Executando o Substrate API Sidecar", "text": "<p>Existem várias formas de instalar e executar o Substrate API Sidecar. Este guia descreve os passos para instalá-lo e executá-lo localmente via NPM. Para uso via Docker ou build e execução a partir do código-fonte, consulte o repositório oficial do Substrate API Sidecar.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessário.</p> <p>Verifique também se você tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documentação oficial.</p> <p>Além disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para módulos ES6. Você pode criar um <code>package.json</code> padrão com npm executando <code>npm init --yes</code>.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#installing-the-substrate-api-sidecar", "title": "Instalando o Substrate API Sidecar", "text": "<p>Para instalar o serviço localmente no diretório atual, execute:</p> <pre><code>npm install @substrate/api-sidecar@20.2.2\n</code></pre> <p>Note</p> <p>Se a pasta não tiver um projeto Node.js, crie manualmente <code>node_modules</code> com <code>mkdir node_modules</code>.</p> <p>O Substrate API Sidecar v20.2.2 é a versão estável atual testada com redes Tanssi. Verifique a instalação a partir da raiz do diretório:</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#setting-up-the-substrate-api-sidecar", "title": "Configurando o Substrate API Sidecar", "text": "<p>No terminal em que o Sidecar rodará, exporte a variável de ambiente com o endpoint WS da rede que deseja usar. Exemplos:</p> Tanssi MainNetDancelight TestNetRede EVM de DemonstraçãoSua rede <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=INSERIR_ENDPOINT_WSS_DA_REDE\n</code></pre> <p>Depois de definir, confirme com:</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>Ele deve exibir o endpoint configurado.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#running-substrate-api-sidecar", "title": "Executando o Substrate API Sidecar", "text": "<p>Com a variável de ambiente configurada e a partir da raiz da instalação, execute:</p> <pre><code>node_modules/.bin/substrate-api-sidecar\n</code></pre> <p>Se a instalação e configuração estiverem corretas, verá uma saída semelhante a:</p> <p></p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-sidecar-endpoints", "title": "Endpoints do Substrate API Sidecar", "text": "<p>Endpoints comuns:</p> <ul> <li>GET /blocks/head — bloco finalizado mais recente. O parâmetro opcional <code>finalized=false</code> retorna o bloco mais novo, possivelmente não finalizado</li> <li>GET /blocks/head/header — cabeçalho do último bloco. <code>finalized=false</code> opcional</li> <li>GET /blocks/{blockId} — bloco por altura ou hash</li> <li>GET /accounts/{accountId}/balance-info — saldo e informações da conta</li> <li>GET /node/version — implementação e versão do nó Substrate</li> <li>GET /runtime/metadata — metadata do runtime em JSON decodificado</li> </ul> <p>Para a lista completa, consulte a documentação oficial.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#fields-mapping-in-block-json-object", "title": "Mapeamento de Campos no Objeto JSON do Bloco", "text": "<p>O Sidecar retorna blocos em JSON. Parte do objeto é a estrutura aninhada das extrínsecas processadas em um bloco específico. Cada extrínseca chama um método de um módulo. Em linhas gerais, a estrutura é:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"MODULE_NAME\"\n                |--method: \"METHOD_NAME\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"MODULE_NAME\"\n                        |--method: \"METHOD_EVENT_NAME\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Saber o módulo e método chamados permite extrair informações específicas (por exemplo, transferências de saldo).</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#evm-fields-mapping-in-block-json-object", "title": "Mapeamento EVM em Blocos", "text": "<p>Para redes EVM da Tanssi, execuções EVM são identificadas por:</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre> <p>Estrutura aninhada:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Para transações Substrate, campos como “Nonce” e “Signature” ficam em:</p> <pre><code>extrinsics[extrinsic_number]\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-types-and-payload", "title": "Tipos de Transação EVM e Payload", "text": "<p>As redes EVM da Tanssi suportam <code>legacy</code>, <code>eip1559</code> e <code>eip2930</code>. Cada tipo contém o seguinte payload:</p> EIP1559LegacyEIP2930 <pre><code>    ...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <pre><code>    ...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n    ...\n</code></pre> <pre><code>    ...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <p>Para mais detalhes sobre EIP1559 e EIP2930, veja as especificações oficiais.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-field-mappings", "title": "Mapeamento de Campos da Transação", "text": "<p>Para obter remetente, destinatário e hash EVM de qualquer transação, verifique o evento em que:</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\"\n</code></pre> <p>Mapeamentos:</p> EIP1559LegacyEIP2930 Campo EVM Campo JSON do bloco Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> Max priority fee/gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Max fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> Assinatura <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> Endereço remetente <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Endereço destinatário <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status de execução <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> Campo EVM Campo JSON do bloco Nonce <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> Valor <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> Assinatura <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> Remetente EVM <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Destinatário EVM <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status execução <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> Campo EVM Campo JSON do bloco Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> Valor <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> Assinatura <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> Remetente EVM <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Destinatário EVM <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status execução <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>Para transações EVM, campos como “Nonce” e “Signature” ficam em:</p> <pre><code>extrinsics[extrinsic_number].args.transaction[transaction_type]\n</code></pre> <p>Assim, “Nonce” e “Signature” no nível Substrate (<code>extrinsics[extrinsic_number]</code>) ficam <code>null</code>.</p> <p>Uma transação EVM bem-sucedida retorna <code>succeed: \"Stopped\"</code> ou <code>succeed: \"Returned\"</code> no campo de status de execução EVM.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#monitor-transfers", "title": "Monitorar Transferências de Tokens", "text": "<p>Os trechos a seguir mostram como escutar transferências do token nativo enviadas via Substrate ou Ethereum API, e transferências de tokens ERC-20 via Ethereum API, usando o Substrate API Sidecar. Transferências pela Ethereum API se aplicam apenas a redes EVM da Tanssi.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#native-token-transfers", "title": "Transferências de Token Nativo", "text": "<p>Redes Tanssi EVM e não-EVM podem fazer transferências de saldo nativas baseadas em Substrate.</p> <p>O snippet abaixo usa Axios para consultar o endpoint <code>/blocks/head</code> para o último bloco finalizado, e decodifica <code>from</code>, <code>to</code>, <code>value</code>, <code>tx hash</code> e <code>transaction status</code> de transferências nativas tanto no nível EVM quanto Substrate.</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum)\n// in a given Sidecar block, and extract the tx hash. It can be adapted for\n// any Tanssi-powered network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transfer')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#erc-20-token-transfers", "title": "Transferências de Tokens ERC-20", "text": "<p>Eventos emitidos por smart contracts (como um contrato ERC-20 implantado em redes EVM da Tanssi) podem ser decodificados a partir do JSON do bloco. A estrutura é:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce:\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |-- address\n                            |-- topics\n                                |--0\n                                |--1\n                                |--2\n\\t\\t\\t\\t        |-- data\n            ...\n    ...\n</code></pre> <p>Transferências ERC-20 emitem o evento <code>Transfer</code>, que pode ser decodificado assim:</p> Informação da tx Campo JSON do bloco Endereço do contrato <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> Hash da assinatura <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> Endereço remetente <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> Endereço destinatário <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> Quantia <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>Outros eventos de contratos EVM podem ser decodificados de modo semelhante; o conteúdo de <code>topics</code> e <code>data</code> muda conforme a definição do evento.</p> <p>Note</p> <p>A quantia transferida leva em conta as casas decimais e vem em hexadecimal.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-transaction-fees", "title": "Taxas de Transação na Substrate API", "text": "<p>Para redes Tanssi EVM e não-EVM, todas as informações sobre taxas de transações enviadas via Substrate API podem ser extraídas do endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>Os endpoints de bloco retornam dados de um ou mais blocos. Saiba mais na documentação oficial do Sidecar.</p> <p>Lendo como JSON, para um <code>pallet</code> (módulo) e <code>method</code>, a taxa da transação vem de um evento com:</p> <pre><code>{event_number}.method.pallet: \"transactionPayment\"\n{event_number}.method.method: \"TransactionFeePaid\"\n</code></pre> <p>Estrutura relevante:</p> <pre><code>RESPONSE JSON Block Object:\n    ...\n    |--number\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n            |--signature\n            |--nonce\n            |--args\n            |--tip\n            |--hash\n            |--info\n            |--era\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"transactionPayment\"\n                        |--method: \"TransactionFeePaid\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n    ...\n</code></pre> <p>Mapeamento:</p> Informação da tx Campo JSON do bloco Conta que paga <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Taxas totais <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Gorjeta (tip) <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>A taxa total paga para a extrínseca está em:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[1]\n</code></pre>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#ethereum-api-transaction-fees", "title": "Taxas de Transação na Ethereum API", "text": "<p>Para redes EVM da Tanssi, usuários também podem enviar fundos via Ethereum API. Para calcular a taxa de uma transação Ethereum, use:</p> EIP-1559LegacyEIP-2930 <pre><code>GasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ?\n            BaseFee + MaxPriorityFeePerGas : \n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>As seções a seguir detalham cada componente.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#base-fee", "title": "Base Fee", "text": "<p>A <code>BaseFee</code> é o valor mínimo cobrado para enviar uma transação e é definida pela rede. Foi introduzida na EIP-1559. Redes EVM da Tanssi usam um mecanismo dinâmico semelhante ao da EIP-1559, ajustando a base fee conforme congestionamento.</p> <p>No template EVM da Tanssi, a gas price mínima é <code>1 GWei</code>.</p> <p>A <code>BaseFee</code> pode ser obtida em <code>baseFeePerGas</code> do módulo <code>baseFee</code>:</p> <pre><code>GET /pallets/baseFee/storage/baseFeePerGas?at={blockId}\n</code></pre> <p>Estrutura relevante:</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>O valor está em <code>value</code> (fixed point); divida pelas casas decimais para obter o valor real.</p>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#gasprice-maxfeepergas-maxpriorityfeepergas", "title": "GasPrice, MaxFeePerGas e MaxPriorityFeePerGas", "text": "<p><code>GasPrice</code> define o gas price em transações legacy (pré‑EIP-1559). <code>MaxFeePerGas</code> e <code>MaxPriorityFeePerGas</code> foram introduzidos com a EIP-1559 junto da <code>BaseFee</code>. <code>MaxFeePerGas</code> define a taxa máxima por unidade de gas (BaseFee + MaxPriorityFeePerGas). <code>MaxPriorityFeePerGas</code> é a gorjeta máxima configurada para priorizar a transação.</p> <p>Embora redes EVM da Tanssi sejam compatíveis com Ethereum, são cadeias Substrate, e prioridades funcionam de forma diferente: no Substrate transações não são priorizadas por gas price. O Tanssi usa um sistema de priorização ajustado que reordena transações Substrate com base na taxa por gas (derivada de tip e weight). Para transações Ethereum, a prioridade é definida pela priority fee.</p> <p>Nota: prioridade não é o único fator para ordenar transações; longevidade também influencia.</p> <p>Os valores de <code>GasPrice</code>, <code>MaxFeePerGas</code> e <code>MaxPriorityFeePerGas</code> podem ser lidos do JSON do bloco conforme descrito em Mapeamento EVM.</p> <p>Os dados de uma transação Ethereum em um bloco podem ser obtidos de:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>Trajetos relevantes:</p> EIP1559LegacyEIP2930 Campo EVM Campo JSON MaxFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> MaxPriorityFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Campo EVM Campo JSON GasPrice <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Campo EVM Campo JSON GasPrice <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code>"}, {"location": "builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-weight", "title": "Transaction Weight", "text": "<p><code>TransactionWeight</code> mede o Runtime de uma transação no bloco. Para todos os tipos, pode ser obtido no evento da extrínseca em que:</p> <pre><code>pallet: \"system\", method: \"ExtrinsicSuccess\"\n</code></pre> <p>E então <code>TransactionWeight</code> está em:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight\n</code></pre>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/wallets/", "title": "Carteiras", "text": "<p>Carteiras são ferramentas digitais que permitem aos usuários armazenar, gerenciar e transacionar com segurança seus ativos digitais. Elas armazenam as chaves criptográficas necessárias para acessar ativos digitais e permitem que se executem transações em redes blockchain.</p> <p>as páginas desta seção fornecem uma visão geral de como começar a usar vários provedores de carteira. Ela aborda como criar e importar contas, conectar-se à sua rede e começar a interagir com ela.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "builders/toolkit/substrate-api/wallets/ledger/", "title": "Interagindo com as Tanssi Chains do Substrate Usando Ledger", "text": ""}, {"location": "builders/toolkit/substrate-api/wallets/ledger/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de redes Substrate, como a rede Tanssi ou appchains Substrate não-EVM Powered by Tanssi, têm uma variedade de opções quando se trata de carteiras. Em relação às carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, Ledger é uma das opções mais populares. Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.</p> <p>Os dispositivos Ledger são carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles são usados para verificar e assinar as transações, mas ainda precisam de uma camada de software para fornecer a interface do usuário que interage com as redes, constrói as transações e envia as transações assinadas de volta para a rede assim que o usuário as verifica.</p> <p>Este guia leva você por todas as etapas necessárias para usar seu dispositivo Ledger com as Tanssi Chains do Substrate.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/ledger/#setting-up-ledger-device", "title": "Configurando Seu Dispositivo Ledger", "text": "<p>Se você tiver um dispositivo Ledger novo, consulte o site oficial para obter um guia sobre como iniciá-lo com a configuração inicial.</p> <p>Agora, com seu Ledger já iniciado, instale o aplicativo Polkadot seguindo estas etapas:</p> <ol> <li>Abra o aplicativo Ledger Live no seu computador.</li> <li>Vá para My Ledger.</li> <li>Conecte e desbloqueie o dispositivo.</li> </ol> <p>Por fim, procure o aplicativo Polkadot (DOT) no Ledger Live e instale-o em seu dispositivo.</p> <p>Note</p> <p>Por que Polkadot? Tanssi é construído usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptográfica. Isso significa que o aplicativo Ledger chamado Polkadot (DOT) é totalmente compatível com Tanssi.</p> <p></p> <p>E é isso. Seu dispositivo agora possui uma conta Substrate e é capaz de assinar transações na Tanssi e em qualquer appchain não-EVM Powered by Tanssi.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/ledger/#adding-Ledger-hot-wallet", "title": "Adicionando o Ledger a uma Carteira Quente", "text": "<p>Conforme apresentado na introdução, uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usuários verifiquem e assinem transações. No entanto, por design, ele não pode interagir com blockchains ou dApps por si só, nem oferece uma interface do usuário para gerenciar ativos. Para complementar o dispositivo, uma carteira quente é necessária. O usuário pode escolher qualquer carteira Substrate, como Talisman ou SubWallet.</p> <p>Para fins de demonstração, mostraremos como configurar o Talisman para funcionar com sua carteira de hardware, mas essas etapas são geralmente aplicáveis a qualquer outra carteira habilitada para Substrate que suporte Ledger. Para acompanhar as etapas, certifique-se de ter o Talisman instalado no seu navegador, em seguida, abra a extensão e:</p> <ol> <li>Pressione o ícone + (Adicionar conta).</li> <li>Clique na guia Conectar.</li> <li>Selecione Conectar Ledger.</li> </ol> <p></p> <p>Na tela seguinte, siga estas etapas:</p> <ol> <li>Selecione Polkadot. Outras opções serão apresentadas abaixo.</li> <li>Selecione Polkadot no menu suspenso.</li> <li>Selecione Aplicativo Polkadot na caixa. Você será solicitado a conectar seu ledger e abrir o aplicativo Polkadot.</li> <li>Certifique-se de que seu ledger está conectado com sucesso.</li> <li>Clique em Continuar.</li> </ol> <p></p> <p>Na próxima etapa, você será apresentado a uma lista de contas derivadas. Selecione aquela que você deseja importar, clique em Continuar, e pronto! Sua carteira Talisman agora pode assinar transações usando seu dispositivo Ledger.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/", "title": "Interagindo com Sua Rede Tanssi Substrate Usando SubWallet", "text": ""}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de redes Substrate powered by Tanssi têm uma variedade de opções quando se trata de carteiras. SubWallet é uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Substrate, mas você pode consultar um tutorial semelhante para interagir com SubWallet usando a API Ethereum.</p> <p>A extensão de navegador da carteira SubWallet pode ser baixada para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. SubWallet também possui um aplicativo móvel para iOS e Android, mas isso está além do escopo deste guia. Um painel de ativos online completo é acessível em web.subwallet.app.</p> <p>Este guia leva você por todas as etapas necessárias, desde a instalação do SubWallet até a configuração de uma carteira, conectando-a à sua rede Tanssi Substrate e enviando fundos.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#creating-your-first-substrate-account", "title": "Criando Sua Primeira Conta Substrate", "text": "<p>Primeiro, baixe e instale a extensão SubWallet. Criar uma nova conta gerará uma frase semente que pode derivar várias contas Ethereum e Substrate. Por padrão, SubWallet gerará uma única conta Ethereum e uma única conta Substrate, mas você pode facilmente derivar mais da mesma frase semente. Clique em Criar uma nova conta para começar.</p> <p></p> <p>Na tela seguinte, você será solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p> <p>Você será solicitado a fazer backup de sua frase semente. Esta é uma etapa importante, especialmente porque você tem a opção de derivar posteriormente contas adicionais desta frase semente.</p> <p></p> <p>Note</p> <p>Você nunca deve compartilhar sua frase semente (mnemônico) ou chave privada com ninguém. Isso lhes dá acesso direto aos seus fundos. Este guia é apenas para fins educacionais.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#importing-an-existing-substrate-account", "title": "Importando uma Conta Substrate Existente", "text": "<p>É claro que você pode importar uma conta Substrate existente para o SubWallet. Para começar, siga estas etapas:</p> <ol> <li>Pressione o botão Todas as contas na parte superior</li> <li>Pressione o ícone Importar conta</li> </ol> <p></p> <p>Na tela seguinte, selecione o método pelo qual você gostaria de importar a conta existente. Se você estiver importando uma conta Substrate, pode escolher entre as opções de frase semente, Polkadot.js (JSON) ou código QR.</p> <p></p> <p>Na tela seguinte, você poderá fornecer a frase semente relevante, o arquivo JSON ou o código QR, e poderá começar a usar sua nova conta imediatamente.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-dancelight", "title": "Conectando SubWallet ao Dancelight", "text": "<p>O SubWallet vem pré-configurado com suporte para Dancelight, a Tanssi TestNet, mas pode não estar habilitado por padrão. Você só precisa ir para a página Gerenciar redes para ativá-lo. Lembre-se de que Dancelight em si é a rede baseada em Substrate que orquestra e gerencia o lançamento de redes powered by Tanssi. Para configurar seu SubWallet para funcionar com Dancelight, pressione o ícone Mais opções no canto superior esquerdo. Em seguida, clique em Gerenciar redes e siga estas etapas:</p> <ol> <li>Procure por Dancelight</li> <li>Ative o controle deslizante para habilitar o suporte para Dancelight</li> </ol> <p></p> <p>Se você tiver um saldo de tokens Dancelight, verá o saldo da sua conta na página inicial da carteira SubWallet. Por padrão, todos os saldos são ocultos no SubWallet, mas se você pressionar o ícone de olho, poderá alternar a visibilidade do saldo.</p> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-your-substrate-network", "title": "Conectando SubWallet à Sua Rede Substrate", "text": "<p>Para configurar o SubWallet para sua rede Substrate, pressione o ícone Mais opções no canto superior esquerdo. Em seguida, clique em Gerenciar redes. Pressione o ícone +. Na página seguinte, você será solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstração, o Dancelight é usado aqui; no entanto, você pode substituir esses detalhes por sua própria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:</p> <ol> <li>Cole a URL WSS da sua rede Tanssi. Outros parâmetros, como a ID da parachain e as casas decimais dos tokens, podem ser preenchidos automaticamente</li> <li>Forneça um nome para sua rede Tanssi</li> <li>Pressione Salvar</li> </ol> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#connecting-to-polkadotjs", "title": "Conectando ao Polkadot.js", "text": "<p>Para conectar sua rede Tanssi Substrate ao Polkadot.js Apps, primeiro vá para Polkadot.js Apps. Neste exemplo, Polkadot.js Apps está conectado ao Dancelight, mas você pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo endpoint personalizado.</p> <p></p> <p>A extensão SubWallet solicitará que você selecione as contas que deseja usar com o Polkadot.js Apps. Se ele não aparecer automaticamente, você pode abrir a extensão SubWallet e clicar no ícone Conectado ao lado da sua conta na parte superior. Para configurar o SubWallet para interagir corretamente com sua rede Tanssi no Polkadot.js Apps, você deve seguir estas etapas:</p> <ol> <li>Selecione as contas Substrate que você gostaria de usar com o Polkadot.js Apps</li> <li>Pressione Conectar</li> </ol> <p></p> <p>Sua carteira SubWallet agora está conectada ao Polkadot.js Apps. Após atualizar o Polkadot.js Apps, você deverá ver sua conta SubWallet na [página Contas do Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=\\_blank} sob o cabeçalho extensão.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/subwallet/#sending-a-transaction", "title": "Enviando uma Transação", "text": "<p>Para enviar uma transação por meio da API Substrate, clique em Enviar ao lado da sua conta no Polkadot.js Apps. Em seguida, siga estas etapas:</p> <ol> <li>Insira o enviar para endereço</li> <li>Insira o valor</li> <li>Pressione Fazer Transferência e confirme a transação no pop-up do Polkadot.js resultante</li> <li>Pressione Ver Detalhes se você quiser inspecionar o conteúdo da transação</li> <li>Pressione Aprovar para enviar a transação</li> </ol> <p></p> <p>Você também pode enviar uma transação por meio da API Substrate diretamente da extensão SubWallet sem usar o Polkadot.js Apps. Para fazer isso, pressione o ícone Enviar e siga estas etapas:</p> <ol> <li>Especifique o ativo a ser enviado</li> <li>Especifique a cadeia de destino (neste caso, a mesma cadeia de onde você está enviando)</li> <li>Insira o endereço de destino</li> <li>Insira o número de tokens a serem enviados</li> <li>Analise os detalhes da transação e, em seguida, pressione Transferir e, em seguida, Aprovar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configuração do SubWallet para funcionar com sua rede Tanssi Substrate, mas o SubWallet também é uma carteira completa para contas EVM. Na seção da API Ethereum, você encontrará um guia semelhante para configurar o SubWallet para uso com sua rede Tanssi EVM.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/", "title": "Interagindo com Tanssi ou Sua Appchain Substrate Usando Talisman", "text": ""}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#introduction", "title": "Introdução", "text": "<p>Desenvolvedores e usuários de redes Substrate, como a rede Tanssi ou appchains Substrate powered by Tanssi, têm uma variedade de opções quando se trata de carteiras. Talisman é uma ótima opção, pois oferece suporte nativo total para contas Substrate e Ethereum. Este guia se concentra na API Substrate. Você também pode conferir um guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM.</p> <p>Talisman é uma carteira Web3 que suporta nativamente contas Substrate e Ethereum. A extensão do navegador da carteira Talisman está disponível no Google Chrome, Brave e outros navegadores baseados em Chromium, bem como no Firefox. Um painel de ativos é acessível em app.talisman.xyz</p> <p>Este guia leva você por todas as etapas necessárias, desde a instalação do Talisman até a configuração de uma carteira, conectando-a à sua rede Substrate Tanssi e enviando fundos.</p> <p>Nota do Editor (Atualização de 2025)</p> <p>Este guia faz referência a opções como Polkadot.js Apps ou tipo de conta Polkadot porque esses são os rótulos usados em ferramentas Substrate comuns. A própria Tanssi é independente — construída com Substrate e alinhada com a segurança apoiada pela Ethereum.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#setting-up-talisman", "title": "Configurando o Talisman", "text": "<p>Primeiro, baixe e instale a extensão Talisman. Este guia primeiro abordará a criação de uma nova carteira e, mais tarde, tratará da importação de uma existente. Revise os termos e condições e, em seguida, pressione Começar.</p> <p></p> <p>Na tela seguinte, você será solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#create-a-substrate-account", "title": "Criar uma Conta Substrate", "text": "<p>Para criar sua primeira conta Substrate no Talisman, siga as seguintes etapas:</p> <ol> <li>Selecione a opção Polkadot.</li> <li>Dê um nome para sua conta.</li> <li>Pressione Criar.</li> </ol> <p>Note</p> <p>Por que Polkadot? Tanssi e appchains powered by Tanssi são construídos usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptográfica.</p> <p></p> <p>Após criar sua primeira conta, você será solicitado a fazer backup de sua frase semente. Esta é uma etapa importante, especialmente porque você tem a opção de, mais tarde, derivar contas adicionais dessa frase semente.</p> <p></p> <p>Note</p> <p>Você nunca deve compartilhar sua frase semente (mnemônico) ou chave privada com ninguém. Isso lhes dá acesso direto aos seus fundos. Este guia é apenas para fins educacionais.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#importing-an-existing-substrate-account", "title": "Importando uma Conta Substrate Existente", "text": "<p>É claro que você pode importar uma conta Substrate existente para o Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Pressione Adicionar Conta.</li> <li>Pressione Importar.</li> <li>Selecione Importar via Frase de Recuperação.</li> </ol> <p></p> <p>Na tela seguinte, siga as seguintes etapas:</p> <ol> <li>Selecione o tipo de conta Polkadot.</li> <li>Forneça um nome para sua conta.</li> <li>Cole sua semente.</li> <li>Selecione quais contas você gostaria de importar.</li> <li>Pressione Importar.</li> </ol> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-the-tanssi-network", "title": "Conectando o Talisman à Rede Tanssi", "text": "<p>Talisman já vem pré-configurado com suporte para Tanssi MainNet e Dancelight. Para se conectar ao Dancelight, você primeiro precisa garantir que ativou o suporte para TestNets no Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Abra a extensão Talisman e clique no logotipo do Talisman.</li> <li>Selecione Configurações.</li> <li>Certifique-se de que Habilitar testnets esteja marcado.</li> </ol> <p></p> <p>Se você tiver um saldo de tokens Tanssi MainNet ou Dancelight, verá o saldo da sua conta na página inicial da carteira Talisman. Quando você não tem um saldo, a rede é omitida da sua lista de ativos.</p> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-your-substrate-network", "title": "Conectando o Talisman à Sua Rede Substrate", "text": "<p>Para configurar o Talisman para sua rede Substrate powered by Tanssi, abra a extensão Talisman e clique na guia Mais Opções. Clique em Configurações &gt; Redes e Tokens &gt; Gerenciar Redes.</p> <ol> <li>Deslize o controle deslizante da rede para Polkadot.</li> <li>Marque a caixa Habilitar testnets.</li> <li>Pressione Adicionar Rede.</li> </ol> <p></p> <p>Na página seguinte, você será solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstração, o Dancelight é usado aqui, mas você pode substituir esses detalhes pela sua própria rede Tanssi. Para adicionar sua rede Tanssi ao Talisman, siga as seguintes etapas:</p> <ol> <li>Cole a URL RPC da sua rede Tanssi. Outros parâmetros serão preenchidos automaticamente.</li> <li>Opcionalmente, insira a URL do explorador de blocos da sua rede Tanssi, se aplicável.</li> <li>Marque a caixa Esta é uma testnet, se aplicável.</li> <li>Pressione Adicionar Rede.</li> </ol> <p></p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs", "title": "Conectando ao Polkadot.js", "text": "<p>Para conectar sua rede Substrate Tanssi aos Polkadot.js Apps, primeiro acesse [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=_blank}. Neste exemplo, os Polkadot.js Apps estão conectados ao Dancelight, mas você pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo de endpoint personalizado.</p> <p></p> <p>A extensão Talisman solicitará que você selecione as contas que deseja usar com os Polkadot.js Apps. Se ela não aparecer automaticamente, você pode abrir a extensão Talisman e clicar no título polkadot.js.org na parte superior. Para configurar o Talisman para interagir corretamente com sua rede Tanssi nos Polkadot.js Apps, você deve seguir as seguintes etapas:</p> <ol> <li>Selecione a(s) conta(s) Substrate que você deseja usar com os Polkadot.js Apps</li> <li>Pressione Conectar 1. O valor mudará dependendo do número de contas que você está conectando</li> </ol> <p></p> <p>Sua carteira Talisman agora está conectada aos Polkadot.js Apps. Após atualizar os Polkadot.js Apps, você deve ver sua conta Talisman na [página Contas dos Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=_blank} abaixo do título extensão.</p>"}, {"location": "builders/toolkit/substrate-api/wallets/talisman/#sending-a-transaction", "title": "Enviando uma Transação", "text": "<p>Para enviar uma transação por meio da API Substrate, clique em Enviar próximo à sua conta nos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Insira o endereço para enviar.</li> <li>Insira o valor.</li> <li>Pressione Fazer Transferência e confirme a transação no pop-up Polkadot.js resultante.</li> <li>Pressione Ver Detalhes se você quiser inspecionar o conteúdo da transação.</li> <li>Pressione Aprovar para enviar a transação.</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configuração do Talisman para funcionar com sua rede Substrate Tanssi, mas o Talisman também é uma carteira completa para contas EVM. Na seção da API Ethereum, você encontrará um guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "learn/", "title": "Aprenda", "text": "<p>Lançar uma rede descentralizada tem sido tradicionalmente um processo desafiador e demorado, exigindo experiência em infraestrutura, segurança e configuração operacional. Tanssi simplifica essa jornada, removendo as complexidades e tornando a implantação de rede rápida e acessível.</p> <p>Esta seção explora os elementos centrais que definem Tanssi como uma solução líder para o desenvolvimento de redes. Se você está começando sua jornada em redes descentralizadas ou aprofundando sua compreensão das capacidades únicas da Tanssi, estes documentos fornecem tudo que você precisa para entender como o Tanssi estabelece um novo padrão para a infraestrutura de rede.</p>"}, {"location": "learn/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/#comece-a-construir-agora", "title": "Comece a Construir AgoraConstrua Sua Rede", "text": "<p>Comece sua jornada Tanssi aqui se você preferir aprender fazendo.</p> <p>Aprenda a projetar e personalizar sua rede com Templates e ferramentas prontos para uso, adaptados às suas necessidades técnicas.</p>"}, {"location": "learn/decentralized-networks/", "title": "Redes Tanssi-Powered", "text": "<p>Desenvolver uma blockchain que equilibre escalabilidade, eficiência e personalização é uma tarefa complexa. As Redes Tanssi-Powered abordam estes desafios através da sua integração na infraestrutura modular da Tanssi. Esta secção explica a estrutura, funcionalidade e características únicas das redes no ecossistema Tanssi.</p> <p>Principais funcionalidades das redes Tanssi-powered:</p> <ul> <li>Personalização de Runtime - adapte os tipos de transacções, a lógica de execução e as transições de estado para se adequar aos requisitos específicos da sua rede</li> <li>Eficiência de transacções - otimize as taxas de transacções para escalabilidade e sustentabilidade económica</li> <li>Escalabilidade no seu núcleo - construa redes preparadas para crescer juntamente com o seu ecossistema</li> </ul>"}, {"location": "learn/decentralized-networks/#explore-esta-seccao", "title": "Explore Esta Secção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/decentralized-networks/included-templates/", "title": "Templates de Rede Incluídos na Tanssi", "text": ""}, {"location": "learn/decentralized-networks/included-templates/#introduction", "title": "Introdução", "text": "<p>A construção de uma nova rede do zero pode ser uma tarefa assustadora. Felizmente, graças ao framework de desenvolvimento de rede usado pela Tanssi e sua arquitetura orientada a módulos, os desenvolvedores podem aproveitar alguns Templates de rede pré-empacotados que os ajudam a dar o pontapé inicial no processo e se beneficiar em alguns aspectos, como:</p> <ul> <li> <p>Head Start - Os Templates de rede Tanssi fornecem um ponto de partida para seu projeto, economizando tempo e esforço significativos, fornecendo uma estrutura básica e um conjunto de funcionalidades testadas e prontas para uso. Ele permite que os desenvolvedores acelerem a construção de protótipos ou produtos minimamente viáveis (MVPs) e reduzam o tempo de lançamento</p> </li> <li> <p>Consistência - os Templates de rede Tanssi incluídos seguem padrões de design estabelecidos, padrões de codificação e melhores práticas amplamente aceitos entre a comunidade de desenvolvedores. Eles também fornecem um conjunto padrão de definições de arquitetura para otimizar o desenvolvimento de blockchain</p> </li> <li> <p>UX - Os Templates de rede Tanssi cobrem os casos de uso mais exigidos, como o suporte EVM para uma rede compatível com Ethereum</p> </li> <li> <p>Customização - Os Templates de rede Tanssi são um ótimo ponto de partida e são totalmente personalizáveis. As funcionalidades e configurações padrão que eles incluem podem ser modificadas, substituídas ou estendidas para atender aos requisitos específicos do caso de uso</p> </li> <li> <p>Atualizações e Compatibilidade - Tanssi é construído sobre um framework em evolução, com novos recursos, aprimoramentos e correções de bugs sendo introduzidos regularmente. Os Templates de rede Tanssi fornecidos são mantidos atualizados com essas atualizações</p> </li> </ul>"}, {"location": "learn/decentralized-networks/included-templates/#start-building", "title": "Comece a Construir uma Rede", "text": "<p>Para começar a construir uma rede descentralizada para implantação em Tanssi, alguns Templates de rede Tanssi úteis para iniciar o processo de desenvolvimento são fornecidos no repositório oficial.</p> <p>O processo é tão simples quanto:</p> <ol> <li>Selecione um dos Templates</li> <li>Adicione a lógica específica para adaptar o Runtime aos requisitos do caso de uso</li> <li>Implante na Tanssi</li> </ol> <p></p> <p>Os dois Templates incluídos são o Template de rede de linha de base e o Template EVM de linha de base, que são apresentados nas seções a seguir.</p>"}, {"location": "learn/decentralized-networks/included-templates/#baseline-network-template", "title": "Template de Rede Baseline", "text": "<p>Conforme apresentado no artigo Visão geral, as redes implantadas por meio da Tanssi são blockchains totalmente soberanas e personalizáveis.</p> <p>Como parte do ecossistema Tanssi, as redes devem incluir os componentes essenciais para implementar o mecanismo de consenso e ser capazes de interagir e sincronizar com o provedor de segurança de sua escolha (por exemplo, Symbiotic no Ethereum). O Template de rede Tanssi de linha de base inclui toda a funcionalidade necessária para a lógica de Sequencers, p2p, banco de dados e camadas de sincronização entre a rede e o provedor de segurança, permitindo que os desenvolvedores se concentrem exclusivamente na personalização de seu produto.</p> <p>Este Template também inclui o módulo Author Noting da Tanssi, que implementa a lógica para recuperar e validar o conjunto de Sequencers atribuídos para fornecer serviços de produção de blocos à rede. Ele também inclui a lógica que permite que um Sequencer assine o bloco quando o mecanismo de consenso determina que é a vez do Sequencer produzir o bloco (e, portanto, ser recompensado de acordo).</p> <p>O código fonte para este Template é público e acessível no repositório Tanssi GitHub.</p>"}, {"location": "learn/decentralized-networks/included-templates/#baseline-evm-template", "title": "Template Baseline EVM (Ethereum Virtual Machine)", "text": "<p>Estendendo o Template de rede Tanssi de linha de base, este Template fornece não apenas suporte ao protocolo Tanssi, mas também um EVM e compatibilidade total com Ethereum.</p> <p>Aproveitando um conjunto de módulos específicos para EVM, este Template inclui uma camada de compatibilidade com Ethereum para que as redes possam executar dApps Ethereum não modificadas.</p> <p>Usando este Template, as redes suportam a implantação e execução de qualquer contrato inteligente existente escrito em Solidity ou Vyper, sem alterações. Ao emular a produção de blocos Ethereum e expor a interface RPC esperada, os desenvolvedores também podem continuar usando as mesmas ferramentas como Metamask, Hardhat, Remix, Foundry, e muitos mais prontos para uso, sem adaptadores extras.</p> <p>Com este Template EVM, os desenvolvedores podem implantar uma rede semelhante a Moonbeam em nenhum momento e adicionar sua lógica e recursos personalizados, específicos para seu caso de uso.</p> <p>O código fonte para este Template é público e acessível no repositório Tanssi GitHub.</p>"}, {"location": "learn/decentralized-networks/overview/", "title": "Visão Geral das Redes Tanssi", "text": ""}, {"location": "learn/decentralized-networks/overview/#introduction", "title": "Introdução", "text": "<p>As redes implantadas via Tanssi recebem vários benefícios, como produção de blocos como serviço, recuperabilidade de dados como serviço e segurança por meio de provedores externos de segurança, como Symbiotic na Ethereum.</p> <p>Além disso, como as redes powered by Tanssi se baseiam em uma pilha modular, elas ganham vantagens únicas quando são necessárias customizações em nível de runtime. Essa modularidade permite adicionar funcionalidades direto no runtime ou estender as capacidades da própria EVM via precompilados.</p> <p>Por exemplo, a Tanssi fornece um template pronto para uso que inclui os módulos Frontier, possibilitando implantar facilmente redes compatíveis com EVM, similar ao Moonbeam.</p> <p>Esta seção aborda os fundamentos de uma rede Tanssi, sua arquitetura, módulos e funcionalidades principais e o mecanismo de taxas de transação.</p>"}, {"location": "learn/decentralized-networks/overview/#general-architecture", "title": "Arquitetura Geral", "text": "<p>Como mencionado, as redes implantadas via Tanssi são blockchains customizáveis que, entre outras características, recebem produção de blocos como serviço e herdam segurança com finalização determinística em segundos de um provedor externo de segurança.</p> <p>As redes powered by Tanssi são totalmente descentralizadas. Essa natureza descentralizada aumenta consideravelmente a resiliência e a tolerância a falhas, já que não dependem de uma autoridade única para garantir disponibilidade, segurança e desempenho, mas sim de protocolos trustless e descentralizados. Por exemplo, recebem serviços de produção de blocos de um conjunto descentralizado e incentivado de Sequencers gerenciados pela Tanssi.</p> <p>O protocolo Tanssi funciona com um provedor externo de segurança, que possui um conjunto de operators (validadores) com ativos em stake, validando as transações da própria rede Tanssi e de todas as redes implantadas via Tanssi. Assim, todas as redes powered by Tanssi herdam a segurança econômica do protocolo Tanssi e, indiretamente, dos operators, que verificam cada transação de cada rede. As redes Tanssi não precisam manter seu próprio conjunto de operators nem fazer bootstrapping de liquidez para proteger o protocolo.</p> <p>As redes Tanssi também se beneficiam de um conjunto de Data-Preservers, com nós de arquivo completos, garantindo a disponibilidade da camada de dados. Esses data-preservers são incentivados pelos serviços de recuperação de dados da Tanssi e também fornecem a infraestrutura RPC para apps e usuários que interagem com redes Tanssi.</p> <pre><code>flowchart TB\n    networks[\"Tanssi Networks&lt;br/&gt;(Decentralized Networks)\"]\n\n    subgraph tanssi[\"Tanssi Protocol\"]\n        direction TB\n        sequencers[\"Decentralized Sequencers Set\"]\n        node[\"Full Archive Nodes with&lt;br/&gt;RPC Services\"]\n    end\n\n    security[\"External Security Provider&lt;br/&gt;Operators\"]\n\n    networks&lt;--Block Production--&gt;tanssi\n    networks&lt;--Shared Security Model--&gt;tanssi\n    networks&lt;--Data Availability&lt;br/&gt;RPC endpoints--&gt;tanssi\n    tanssi&lt;--Transactions&lt;br/&gt;Validation and Finality--&gt;security</code></pre>"}, {"location": "learn/decentralized-networks/overview/#network-transaction-flow", "title": "Fluxo de Transações da Rede", "text": "<p>Uma transação enviada a uma rede Tanssi segue um caminho complexo porém transparente, desde o envio até a inclusão no bloco e finalização. A infraestrutura da rede, a Tanssi e o provedor de segurança escolhido atuam em níveis diferentes para que o processo ocorra o mais rápido possível, geralmente em cerca de 30 segundos. Uma transação em uma rede Tanssi atinge finalização determinística; uma vez final, torna-se irreversível e imutável, e a transição de estado resultante é definitiva.</p> <p>Por exemplo, um usuário inicia uma transação ao interagir com um aplicativo implantado em uma rede Tanssi. O provedor RPC compartilha a transação, que permanece no pool de transações da cadeia, com todos os participantes. Um Sequencer designado pela Tanssi para essa rede capturará a transação e a incluirá no próximo bloco.</p> <p>Em seguida, o Sequencer compartilhará com os operators do provedor de segurança:</p> <ul> <li>O bloco em si com as transições de estado</li> <li>Os componentes de armazenamento no banco de dados da rede Tanssi que o bloco está modificando</li> <li>Os hashes necessários dos pontos não afetados na árvore de Merkle do armazenamento</li> </ul> <p>Esses componentes constituem a prova de validade (PoV).</p> <p>Depois, a PoV é verificada pelos operators do provedor de segurança. Observe que os operators não verificam se o storage da rede Tanssi é válido, mas se as transições de estado que o afetam são válidas. Um resumo dessa verificação é disseminado para outros operators, para que verifiquem e incluam no próximo bloco da Tanssi. Por fim, esse bloco da Tanssi com todas as verificações é finalizado.</p> <p>O fluxo da transação está resumido no diagrama a seguir:</p> <p></p>"}, {"location": "learn/decentralized-networks/runtime-features/", "title": "Recursos Essenciais de Runtime", "text": ""}, {"location": "learn/decentralized-networks/runtime-features/#introduction", "title": "Introdução", "text": "<p>As redes implantadas via Tanssi têm muitos benefícios devido à sua arquitetura exclusiva.</p> <p>Além disso, redes powered by Tanssi são únicas pelo framework (Substrate) em que são construídas, que oferece características que os desenvolvedores podem aproveitar para ajustar comportamentos específicos no runtime.</p> <p>Esta seção aborda alguns desses recursos essenciais de runtime em redes Tanssi, incluindo as diferentes origens que uma transação pode ter, os diferentes tipos de transação e como são executadas e incluídas em um bloco, a conta especial conhecida como SUDO e o recurso bastante singular das redes Tanssi: os upgrades de runtime sem fork.</p>"}, {"location": "learn/decentralized-networks/runtime-features/#origins", "title": "Origens", "text": "<p>De modo geral, todas as chamadas em uma rede Tanssi têm uma origem. Mas o que é uma origem? Desenvolvedores do mundo EVM conhecem o msg.sender em transações EVM. As origens são para redes Tanssi o que msg.sender é para uma transação EVM, mas com diversas funcionalidades extras.</p> <p>Uma origem define de onde a chamada vem. Diferentemente de cadeias compatíveis com Ethereum, pode haver muitas origens em redes Tanssi. Por exemplo, o msg.sender de uma transação EVM é uma signed origin, o que significa que a chamada é uma transação assinada pela chave privada de alguma conta on-chain. Isso permite ao runtime autenticar a origem da chamada e, por exemplo, cobrar taxas da conta associada.</p> <p>No entanto, origens podem fazer mais do que representar um par de chaves privada/pública. Elas também têm diferentes níveis de privilégio. Por exemplo, uma signed origin pode enviar uma transação despachada pelo par de chaves, mas não deveria poder autorizar um upgrade de runtime.</p> <p>Alguns dos tipos mais comuns de origem são:</p> <ul> <li>Root - origem em nível de sistema com o nível mais alto de privilégio; pode ser vista como o superusuário da cadeia, capaz de executar qualquer chamada</li> <li>Signed - como mencionado, a origem de uma transação assinada pela chave privada de uma conta on-chain, que inclui o identificador da conta (endereço) como assinante</li> <li>None - ausência de origem. Usada em ações específicas que devem ser acordadas no nível do runtime. Por exemplo, é possível programar o runtime para que uma transação com origem none efetive um upgrade de runtime pré-autorizado, sem taxa associada</li> <li>Custom - desenvolvedores podem criar origens personalizadas para casos específicos. Por exemplo, a governança on-chain da Moonbeam tem origens específicas para cada tipo de voto, chamadas tracks. Cada track pode ser configurada para executar chamadas com níveis de privilégio específicos. Uma track é Root, cuja origem é a Root mencionada, com configuração bem restritiva para aprovação. Outras tracks têm níveis de privilégio muito menores para operações menos críticas</li> </ul>"}, {"location": "learn/decentralized-networks/runtime-features/#transaction-types", "title": "Tipos de Transação", "text": "<p>Redes Tanssi possuem três tipos principais de transações:</p> <ul> <li>Signed Transactions - incluem um payload assinado solicitando executar alguma chamada de runtime. Em geral, a assinatura está associada a um par de chaves privada/pública. Dependendo da lógica do runtime, a conta associada à assinatura paga a taxa de transação</li> <li>Unsigned Transactions - incluem um payload não assinado solicitando executar alguma chamada de runtime. Como são não assinadas, não há conta associada. Portanto, os runtimes precisam definir condições específicas para evitar spam ou replay, pois não há mecanismo de taxa para impedir comportamentos maliciosos. Um exemplo de transação não assinada é executar ações pré-aprovadas, como um upgrade de runtime</li> <li>Inherent Transactions - transação não assinada que um Sequencer insere em um bloco ao iniciar sua construção. Elas fazem parte do bloco e não ficam no pool de transações nem são compartilhadas entre participantes. Além disso, os dados inseridos por transações inherents podem pular validação de runtime, ficando a cargo dos operators aceitá-los. Um exemplo é o timestamp do bloco, injetado por uma transação inherent; operators podem aceitar ou rejeitar o bloco com base em o timestamp estar dentro de um intervalo aceitável</li> </ul>"}, {"location": "learn/decentralized-networks/runtime-features/#transaction-execution", "title": "Execução de Transações", "text": "<p>Quando um usuário ou aplicativo envia uma transação assinada a uma rede Tanssi, a transação é validada em nível de nó completo usando regras definidas no runtime e, em seguida, é enfileirada no transaction pool. Isso garante que apenas transações que cumpram certas condições específicas da cadeia sejam consideradas para inclusão em um bloco.</p> <p>Note</p> <p>O tipo de transação mais comum é a assinada. Ainda assim, transações não assinadas também são validadas antes de entrarem no transaction pool.</p> <p>A fila de transações válidas tem dois pools: ready e future. O pool ready contém todas as transações que podem ser incluídas em um novo bloco pendente. O pool future é para transações que não atendem a todos os critérios agora, mas podem se tornar válidas (por exemplo, nonce futura). Transações inválidas são rejeitadas diretamente.</p> <p>Durante a construção do bloco, um Sequencer usa um sistema de prioridade via um módulo de orquestração de transações para ordenar as transações do próximo bloco até atingir a capacidade máxima. A ordem de construção e execução do bloco tem as seguintes operações:</p> <ul> <li>Initializing a Block - conhecido como <code>on_initialize</code>, permite definir lógica de runtime executada antes de qualquer outra transação. Por exemplo, transações inherents como o timestamp são comumente executadas ao inicializar o bloco. Após a lógica de inicialização, o módulo de orquestração verifica o parent hash no cabeçalho e a trie root para garantir que as informações estejam corretas</li> <li>Transaction Execution - com o bloco já inicializado, o módulo de orquestração executa cada transação válida conforme sua prioridade. O estado inicial não é armazenado em cache antes da execução; se uma transação falhar no meio, quaisquer alterações de estado já cometidas não podem ser revertidas, e o bloco subsequente será inválido. Portanto, a lógica de runtime deve realizar todas as verificações necessárias para garantir que as transações válidas serão bem-sucedidas</li> <li>Finalizing a Block - após executar todas as transações válidas em fila ou atingir o limite do bloco, o módulo de orquestração chama, em cada módulo do runtime, as funções <code>on_idle</code> e <code>on_finalize</code>. Essas funções permitem definir lógica extra executada automaticamente na finalização do bloco. Depois da última <code>on_finalize</code>, o módulo de orquestração garante que o block digest e o storage root correspondam ao que foi calculado ao inicializar o bloco</li> </ul>"}, {"location": "learn/decentralized-networks/runtime-features/#forkless-upgrades", "title": "Upgrades sem Fork", "text": "<p>Redes implantadas via Tanssi têm um recurso empolgante: forkless upgrades. Eles permitem alterar a função de transição de estado que governa a cadeia sem criar um fork, como já visto várias vezes na Ethereum. Além disso, se a rede Tanssi estiver configurada com governança on-chain, upgrades podem ocorrer de forma realmente descentralizada e trustless.</p> <p>Os forkless upgrades são possíveis porque a função de transição de estado fica armazenada como um blob Wasm tanto na rede Tanssi quanto na rede powered by Tanssi. Quando um novo runtime é agendado por uma chamada na rede powered by Tanssi, a rede Tanssi valida esse bloco e se prepara para validar blocos usando a função mais recente. Após um período de atraso configurado para o upgrade, um Sequencer na rede powered by Tanssi constrói um bloco que referencia um bloco da rede Tanssi, sinalizando que o novo runtime pode ser aplicado. Assim, essa nova função de transição de estado é usada para aquele bloco. Como todos os participantes usam o blob Wasm on-chain, cada node operator da rede Tanssi pode validar novos blocos com a função mais recente.</p> <p>Um resumo em alto nível do processo de upgrade de runtime está no diagrama a seguir:</p> <p></p>"}, {"location": "learn/decentralized-networks/runtime-features/#sudo-account", "title": "Conta SUDO", "text": "<p>Redes Tanssi podem usar um módulo específico chamado SUDO. Esse módulo introduz um novo tipo de conta, também chamada SUDO, que pode executar transações com a Root origin.</p> <p>Consequentemente, a conta SUDO pode realizar qualquer ação que o runtime permita à origem Root. Isso inclui:</p> <ul> <li>Cunhar novos tokens nativos da rede Tanssi</li> <li>Realizar upgrades de runtime sem fork</li> <li>Enviar transações se passando por outros tipos de origem. Assim, SUDO pode enviar transações em nome de outros usuários sem acessar suas chaves privadas</li> </ul> <p>SUDO é recomendada para TestNets, pois permite fazer mudanças rapidamente sem um processo longo de governança on-chain. É boa prática manter as chaves SUDO em segurança e conceder acesso a chamadas SUDO por meio de contas proxy. Contudo, manter SUDO habilitada em produção pode trazer consequências indesejadas.</p> <p>Entender os riscos de centralização de ter SUDO em produção é fundamental.</p>"}, {"location": "learn/decentralized-networks/tx-fees/", "title": "Taxas de Transação", "text": ""}, {"location": "learn/decentralized-networks/tx-fees/#introduction", "title": "Introdução", "text": "<p>Redes powered by Tanssi são construídas com um framework modular chamado Substrate. Com esse framework, você pode criar formas próprias de lidar com taxas de transação. Por exemplo, a maioria das transações usa um módulo específico chamado Transaction Payment. Contudo, em redes Tanssi compatíveis com EVM, as taxas podem ser cobradas no nível da execução EVM, contornando outros módulos relacionados a taxas.</p> <p>Sob o capô, para Runtime, em vez de um mecanismo baseado em gas, todas as redes Tanssi usam um mecanismo baseado em weight. Weight refere-se ao tempo (em picosegundos) para validar um bloco. De modo geral, para redes Tanssi EVM e não EVM, todas as chamadas têm um weight associado, que define limites de entrada/saída de storage e de computação. Para redes Tanssi EVM, há um mapeamento gas-to-weight totalmente compatível com os requisitos de gas esperados por ferramentas baseadas na Ethereum API.</p> <p>Um esquema de taxas é aplicado sobre o mecanismo de weight para alinhar incentivos econômicos, limitando Runtime, computação e número de chamadas (leituras/gravações). Taxas são fundamentais para evitar spam, pois representam o custo de usar o serviço da rede Tanssi. Assim, um usuário que interage com a rede por meio de uma chamada paga uma taxa determinada por um algoritmo de taxa base.</p> <p>Esta página aborda os fundamentos das taxas em redes Tanssi. Primeiro cobre a arquitetura subjacente de taxas e como ela é adaptada a um Template totalmente compatível com EIP-1559 para redes Tanssi EVM.</p>"}, {"location": "learn/decentralized-networks/tx-fees/#baseline-fees", "title": "Baseline Fees Calculation", "text": "<p>Cada ação que altera o estado de uma rede Tanssi gera uma taxa de transação. Essa taxa é essencial para a operação da rede, cobrindo os recursos computacionais necessários para processar transações, de forma similar aos parâmetros de gas e gas price em cadeias compatíveis com EVM como a Ethereum.</p> <p>O framework modular das redes Tanssi usa um mecanismo de cálculo baseado em weight para determinar taxas. Essa abordagem considera vários fatores, incluindo recursos computacionais e operações de storage (inputs/outputs), para refletir com precisão o custo real das transações. Ao contabilizar esses elementos, a rede garante alocação de recursos justa e eficiente.</p> <p>Além disso, a modularidade das redes Tanssi garante que redes compatíveis com EVM suportem mecanismos de precificação legados e compatíveis com EIP-1559, assegurando compatibilidade total com ambientes de desenvolvimento usados na Ethereum.</p> <p>Esta seção apresenta os diferentes conceitos associados às taxas em redes Tanssi.</p>"}, {"location": "learn/decentralized-networks/tx-fees/#baseline-weight", "title": "Weight", "text": "<p>De forma ampla, weight refere-se ao Runtime para validar um bloco, medido em picosegundos. O weight se divide em duas variáveis:</p> <ul> <li><code>refTime</code> - peso associado a tempo de computação e leituras/gravações em banco de dados</li> <li><code>proofSize</code> - peso associado ao tamanho da Prova de Validade (PoV). A PoV se relaciona ao estado relevante de uma transação, e é o que o Sequencer da rede Tanssi compartilha com os operators do provedor de segurança para validar e finalizar um bloco como parte do fluxo de transações da rede</li> </ul> <p>Para descobrir os weights de todas as chamadas, elas são benchmarked em hardware de referência, e valores aproximados de <code>refTime</code> e <code>proofSize</code> são definidos. Esse processo se repete para todas as chamadas que consomem espaço de bloco e afetam a PoV.</p> <p>Para transações em que as taxas são tratadas pelo módulo transaction payment, todos os parâmetros baseados em weight passam por um algoritmo weight to fee que converte tudo em um valor final, deduzido da conta do remetente ao executar a chamada. O algoritmo pode ser personalizado, mas redes Tanssi definem um valor constante.</p> <p>Para transações EVM, o gas é convertido em weight por meio de um algoritmo gas-to-weight, para que todas as chamadas EVM possam ser mapeadas para o Runtime do bloco. Ainda assim, as taxas são tratadas no nível da execução EVM.</p>"}, {"location": "learn/decentralized-networks/tx-fees/#baseline-transaction-fees", "title": "Baseline Transaction Fees", "text": "<p>Com todas as chamadas benchmarked, a taxa de transação para cada chamada específica pode ser obtida. As taxas geralmente são compostas pelos seguintes elementos:</p> <ul> <li><code>BaseFee</code> - custo básico para incluir a transação. Cobre a sobrecarga de inclusão, como verificação de assinatura. A taxa é definida por dois parâmetros:<ul> <li><code>ExtrinsicBaseWeight</code> - valor constante que representa o weight da sobrecarga de inclusão</li> <li><code>WeightToFee</code> - função polinomial que converte weight em taxa</li> </ul> </li> <li><code>WeightFee</code> - taxa definida por dois parâmetros:<ul> <li><code>BenchmarkedWeight</code> - weight que reflete a complexidade (Runtime) de uma chamada específica</li> <li><code>CongestionMultiplier</code> - função que converte weight em taxa e pode ser ajustada para considerar a congestão da rede (weight consumido no bloco anterior). A estratégia padrão nas redes Tanssi é <code>SlowAdjustingFeeUpdate</code>, que ajusta esse multiplicador lentamente conforme a carga da rede</li> </ul> </li> <li><code>LengthFee</code> - taxa correlacionada ao tamanho em bytes da chamada. Definida por dois parâmetros:<ul> <li><code>ByteLengthFunctionCall</code> - tamanho em bytes da chamada</li> <li><code>LengthToFee</code> - função que define o algoritmo de taxa por byte. Nas redes Tanssi, é um valor constante</li> </ul> </li> <li><code>Tip</code> - valor opcional que aumenta a taxa total, elevando a prioridade da transação ao incentivar Sequencers a incluí-la no próximo bloco</li> </ul> <p>Assim, em termos gerais, a taxa de transação pode ser calculada pela equação:</p> <pre><code>BaseFee = ExtrinsicBaseWeight * WeightToFee\nWeightFee = BenchmarkedWeight  * CongestionMultiplier\nLengthFee = ByteLengthFunctionCall * LengthToFee\n\nInclusionFee = BaseFee + WeightFee + LengthFee\nFinalFee = InclusionFee + Tip\n</code></pre> <p>Todas as chamadas não EVM disponíveis aos desenvolvedores usam esses cálculos básicos para taxas. Redes Tanssi EVM adicionam uma camada extra para traduzir esse esquema para algo semelhante ao Template Ethereum do ponto de vista da Ethereum JSON-RPC e da EVM.</p>"}, {"location": "learn/decentralized-networks/tx-fees/#evm-transaction-fees", "title": "EVM Transaction Fees", "text": "<p>A Tanssi oferece templates para redes EVM completas. Essas redes fornecem um ambiente similar ao Ethereum, onde os desenvolvedores podem usar bibliotecas como Ethers.js, Hardhat e Foundry.</p> <p>Além disso, todas as redes Tanssi compatíveis com EVM têm um mecanismo de precificação compatível com EIP-1559 para transações EVM. Elas suportam os dois tipos de transação EVM mais comuns:</p> <ul> <li>Tipo 0 (Legacy) - a taxa é calculada por um valor único de gas price incluído no blob da transação assinada. Como as redes Tanssi EVM têm precificação dinâmica, o gas price deve ser maior que o <code>baseFee</code> do bloco atual para a transação ser válida</li> <li>Tipo 2 (EIP-1559) - a taxa é calculada com a combinação de <code>maxFeePerGas</code> e <code>maxPriorityFeePerGas</code> no blob da transação, e o <code>baseFee</code> da rede muda dinamicamente com base na congestão do bloco</li> </ul> <p>Independentemente do tipo de transação, o resultado é um custo em tokens nativos que a rede deve cobrar.</p> <p>Por padrão, redes Tanssi compatíveis com EVM têm os seguintes parâmetros:</p> <ul> <li>Minimum BaseFee - gas price mínimo da rede caso não haja transações por longos períodos. O valor padrão é 1 GWei</li> <li>Block Fulness Target (Elasticity) - alvo de gas usado em um bloco para manter o <code>baseFee</code> estável. A EIP-1559 define esse valor como 2, significando que a meta de uso é 50% do limite de gas do bloco. Todas as redes Tanssi EVM usam a mesma meta</li> <li>Maximum BaseFee Increase - aumento máximo do <code>baseFee</code>, em pontos percentuais, com base no uso-alvo do bloco anterior. A EIP-1559 define esse valor como 12,5%. Assim, se o bloco estiver cheio/vazio, o <code>baseFee</code> aumenta/diminui 12,5%, ajustando-se linearmente para valores intermediários. Esse valor é configurável, mas o padrão nas redes Tanssi EVM é 12,5%</li> </ul> <p>Note</p> <p>Uma diferença importante na implementação EIP-1559 das redes Tanssi EVM é que as taxas são calculadas usando o <code>baseFee</code> do bloco anterior.</p> <p>O custo de taxa de transação para chamadas EVM nas redes Tanssi é capturado no nível de execução EVM. Ainda assim, transações EVM consomem Runtime de bloco. Portanto, é necessário um algoritmo gas-to-weight para contabilizar o weight consumido por uma chamada em relação ao gas usado.</p> <p>Por fim, a taxa e o weight associados a uma chamada EVM em uma rede Tanssi compatível com EVM podem ser calculados assim:</p> EIP-1559Legacy <pre><code>Gas Price = baseFee + maxPriorityFeePerGas &lt; maxFeePerGas ? \n           baseFee + maxPriorityFeePerGas : \n           maxFeePerGas;\nTransaction Fee = Gas Price * Gas Used\nTransaction Weight = Gas Used * GasToWeight\n</code></pre> <pre><code>Transaction Fee = GasPrice * GasUsed\nTransaction Weight = GasUsed * GasToWeight\n</code></pre> <p><code>GasToWeight</code> é um valor constante definido como <code>25000</code>.</p>"}, {"location": "learn/framework/", "title": "Estrutura de Desenvolvimento de Rede", "text": "<p>A construção de uma blockchain do zero é um processo intrincado que exige um profundo conhecimento de algoritmos de consenso, criptografia, estruturas de dados, governança e muito mais. Tanssi simplifica esse processo, aproveitando o Substrate, um poderoso framework de desenvolvimento de blockchain que fornece todos os componentes essenciais para a criação de blockchains personalizadas.</p> <p>Com a arquitetura modular do Substrate, você pode modificar as características do Runtime, integrar módulos pré-construídos ou desenvolver novos com base nas necessidades específicas da sua rede. Tanssi fornece a base que você precisa para dar vida à sua visão de blockchain.</p> <p>Principais recursos do framework:</p> <ul> <li>Arquitetura central do Substrate - dividida em core client, que gerencia as comunicações externas e as responsabilidades internas, como armazenamento, e o runtime, que executa transações e gerencia as transições de estado com lógica personalizável</li> <li>Simplicidade para o usuário final - o funcionamento interno do framework é abstraído para os usuários finais, garantindo uma interação perfeita por meio de dApps ou via endpoints RPC, como os usados ​​por carteiras</li> <li>Design de sistema modular - incorpore módulos pré-construídos ou crie módulos personalizados para atender às necessidades específicas</li> <li>Flexibilidade centrada no desenvolvedor - concentre-se nas características de Runtime e nas especificidades dos casos de uso, permitindo que você crie um blockchain adaptado à sua visão sem complexidade desnecessária</li> </ul>"}, {"location": "learn/framework/architecture/", "title": "Arquitetura do Framework", "text": ""}, {"location": "learn/framework/architecture/#introduction", "title": "Introdução", "text": "<p>Substrate é um kit de desenvolvimento de software (SDK) para a construção de blockchains. Este framework é a base e o motor que impulsionam muitos projetos em todo o ecossistema Web3, incluindo a própria rede Tanssi e as redes implantadas através da Tanssi.</p> <p>Escrito na linguagem Rust e projetado com uma arquitetura modular, o Substrate é extremamente performático, flexível e altamente personalizável, tornando-o a melhor opção para o desenvolvimento de blockchains.</p> <p>Neste artigo, a arquitetura de um nó Substrate é abordada.</p>"}, {"location": "learn/framework/architecture/#architecture", "title": "Arquitetura", "text": "<p>O framework Substrate é projetado para máxima personalização, fornecendo uma implementação totalmente funcional para todos os aspectos internos importantes de uma blockchain. Ele permite que os desenvolvedores se concentrem nos detalhes do caso de uso e nas características do runtime, e oferece a capacidade de alterar qualquer um dos recursos padrão (se necessário).</p> <p>A arquitetura de um nó Substrate contém dois componentes principais:</p> <ul> <li>Cliente Core - lida com a comunicação com o mundo exterior (outros nós, dApps, usuários finais, entre outros), e muitas outras responsabilidades internas, como armazenamento e comunicação</li> <li>Runtime - implementa a lógica personalizada da rede Tanssi, executa transações e gerencia as transições de estado</li> </ul> <p>Da perspectiva do usuário final, toda a interação com a rede Tanssi é geralmente feita através de dApps ou diretamente através dos endpoints RPC do nó, por exemplo, usando uma carteira. Quando um usuário aciona uma solicitação para buscar dados ou envia transações para um nó, o cliente core é responsável por responder ou enfileirar as transações até a execução no runtime. Ainda assim, todos esses aspectos internos do design do nó são mantidos transparentes para o usuário.</p> <p></p>"}, {"location": "learn/framework/architecture/#core-client", "title": "O Cliente Core", "text": "<p>O cliente core compreende componentes responsáveis por tudo na operação de um nó na rede, exceto pelo que acontece no runtime.</p> <p>Alguns dos principais componentes são:</p> <ul> <li>Networking - este componente lida com a comunicação com os pares na rede (sincronização de blocos, propagação de transações e assim por diante) e expõe os endpoints que permitem que os dApps se integrem e interajam com a rede Tanssi</li> <li>Storage - este componente gerencia o armazenamento de estado da rede Tanssi em um banco de dados chave-valor altamente eficiente</li> <li>Consenso - este componente garante que todos os participantes da rede concordem com o estado da blockchain, validando transações, transições de estado e os blocos resultantes</li> </ul> <p>A configuração padrão de um nó Substrate e as implementações embutidas dos componentes são geralmente a melhor escolha para a maioria dos casos de uso. Ainda assim, as equipes são bem-vindas para inovar e alterar ou substituir qualquer parte do nó ou até mesmo escrever uma implementação completamente diferente do cliente core, como Kagome (implementação C++) e Gossamer (implementação Golang).</p>"}, {"location": "learn/framework/architecture/#runtime", "title": "O Runtime", "text": "<p>O runtime desempenha um papel crucial na operação da rede Tanssi. Ele contém a lógica e as regras principais para atender aos requisitos do caso de uso que os desenvolvedores estão construindo e, portanto, é responsável por validar as transações e executar as transições de estado.</p> <p>Sendo o elemento central em uma rede Tanssi, projetar a arquitetura Substrate uma decisão importante foi tomada em relação ao formato para o runtime: ele é compilado para código de bytes WebAssembly (Wasm).</p> <p>O formato Wasm oferece muitas vantagens para uma rede Tanssi implantada, incluindo:</p> <ul> <li>Portabilidade - o formato Wasm é independente de plataforma, o que significa que o mesmo binário pode ser distribuído e executado em diferentes nós usando diferentes arquiteturas de hardware e sistemas operacionais</li> <li>Execução Determinística - o formato Wasm garante a execução determinística do código, o que significa que a mesma entrada sempre produzirá a mesma saída. A determinância é um aspecto crítico em blockchains para obter as mesmas transições de estado em todos os nós da rede e alcançar um consenso</li> <li>Atualização sem fork - Substrate armazena o blob Wasm do runtime on-chain, o que significa que o próprio runtime se torna parte do estado. Este projeto permite a atualização da lógica do runtime de forma sem fork usando uma transação</li> </ul> <p>Além do formato, internamente, um runtime Substrate é construído compondo diferentes módulos, fornecidos e prontos para uso pelo Substrate ou feitos sob medida. Cada um desses módulos define, entre outras coisas, as transações que expõem, a lógica por trás delas, o que precisa ser armazenado no estado da cadeia, o melhor formato para fazê-lo e como eles cooperam com outros módulos para compor a funcionalidade. Mais detalhes sobre a construção de um runtime serão abordados na seção módulos.</p>"}, {"location": "learn/framework/architecture/#client-runtime-communication", "title": "Comunicação Cliente-Runtime", "text": "<p>Como descrito anteriormente, os dois principais componentes de um nó Substrate (o cliente core e o runtime) têm uma clara separação de preocupações. Além das responsabilidades funcionais, em um nível inferior, sua representação binária e ambientes de execução são diferentes. Embora o nó seja compilado para ser instalado e executado em uma plataforma específica (seja Linux x64 ou qualquer outra), o runtime da rede Tanssi é compilado para um formato Wasm que é agnóstico à plataforma e é executado em um ambiente de execução isolado.</p> <p>Tendo em mente os ambientes de execução separados, toda a comunicação entre o cliente do nó e o runtime ocorre por meio de uma interface limitada e bem definida, permitindo as operações necessárias, como:</p> <ul> <li>Executar Transações - quando um usuário envia uma transação para o nó cliente, o nó passa essa transação para o runtime através da API definida para sua execução</li> <li>Consultas de Estado - o nó cliente pode consultar o estado atual da blockchain para recuperar informações como saldos de contas e quaisquer outros dados específicos do domínio</li> <li>Consenso e Finalidade - o nó cliente coordena o consenso e a finalização dos blocos, mas é responsabilidade do runtime determinar a validade de novos blocos, validar transações e garantir que as regras de consenso sejam seguidas</li> <li>Notificações de Eventos - o runtime emite eventos ao executar transações que o nó cliente pode usar para manter os usuários externos atualizados sobre ações ou alterações específicas no estado</li> </ul>"}, {"location": "learn/framework/modules/", "title": "Módulos de Framework de Rede", "text": ""}, {"location": "learn/framework/modules/#introduction", "title": "Introdução", "text": "<p>O framework Substrate fornece implementações completas e prontas para uso das funções principais que uma rede Tanssi precisa para funcionar corretamente, incluindo criptografia, consenso, governança e assim por diante. Estas implementações são totalmente personalizáveis e podem ser substituídas por lógica personalizada, se necessário.</p> <p>Ao criar o Runtime, que define as regras de transição de estado entre dois blocos aplicados a um conjunto de transações, o comportamento e as funcionalidades pretendidas da blockchain precisam de ser definidos ao determinar as regras da transição de estado.</p> <p>Para construir o Runtime, o Substrate fornece muitos módulos integrados (também conhecidos como pallets) que podem ser livremente usados como blocos de construção para compor e interagir com quaisquer outros módulos feitos sob medida, permitindo que as equipas criem comportamentos únicos de acordo com os requisitos específicos da sua rede Tanssi.</p> <p></p>"}, {"location": "learn/framework/modules/#built-in-modules", "title": "Módulos Integrados", "text": "<p>Ao projetar e escrever as regras de uma rede Tanssi, o conjunto disponível de módulos funcionais traz uma solução para muitos dos requisitos de codificação que, caso contrário, precisariam ser construídos do zero.</p> <p>Aqui está uma lista de alguns dos módulos mais populares:</p> <ul> <li>Balances - fornece funções para lidar com contas e saldos para a moeda nativa da rede Tanssi</li> <li>Assets - fornece funções para lidar com qualquer tipo de token fungível</li> <li>NFTs - fornece funções para lidar com tokens não fungíveis</li> <li>Democracy - fornece funções para gerir e administrar a votação geral dos stakeholders</li> <li>Multisig - fornece funções para envio de multi-assinaturas</li> <li>Recovery - fornece funções para permitir que os utilizadores recuperem o acesso às suas contas quando a chave privada é perdida. Isto funciona ao conceder a outras contas o direito de assinar transações em nome da conta perdida (observe que é necessário ter escolhido previamente as contas autorizadas)</li> <li>Staking - fornece funções para administrar tokens apostados, apoiar recompensas, cortes, depósito, levantamento, e assim por diante</li> </ul> <p>Além daqueles já listados, outros módulos como identity, smart contracts, vesting, e muitos outros que estão livremente disponíveis podem acelerar o desenvolvimento da rede Tanssi e, consequentemente, o tempo de lançamento.</p> <p>Note</p> <p>O framework também inclui outros módulos que fornecem funcionalidades essenciais de protocolo, como consenso e codificação de dados de baixo nível.</p>"}, {"location": "learn/framework/modules/#custom-modules", "title": "Módulos Feitos sob Medida", "text": "<p>Os desenvolvedores que criam novos módulos desfrutam de total liberdade para expressar qualquer comportamento desejado na lógica principal da blockchain, como expor novas transações, armazenar informações sensíveis e validar e impor lógica de negócios.</p> <p>Como explicado no artigo Arquitetura, um módulo precisa ser capaz de se comunicar com o cliente principal, expondo e integrando com uma API muito específica que permite que o Runtime exponha transações, acesse o armazenamento e code e decodifique informações armazenadas na cadeia. Também precisa incluir muitos outros códigos de ligação necessários que fazem o módulo funcionar no nó.</p> <p>Para melhorar a experiência do desenvolvedor ao escrever módulos, o Substrate depende muito de macros Rust. As macros são instruções especiais que se expandem automaticamente para o código Rust pouco antes do tempo de compilação, permitindo que os módulos mantenham até sete vezes a quantidade de código fora da vista dos desenvolvedores. Isto permite que os desenvolvedores se concentrem nos requisitos funcionais específicos ao escrever módulos, em vez de lidar com tecnicidades e o código de suporte necessário.</p> <p>Todos os módulos no Substrate, incluindo os feitos sob medida, implementam estas macros de atributo, das quais as três primeiras são obrigatórias:</p> <ul> <li><code>#[frame_support::pallet]</code> - atributo de entrada que marca o módulo como utilizável no runtime</li> <li><code>#[pallet::pallet]</code> - aplicado a uma estrutura usada para recuperar informações do módulo com facilidade</li> <li><code>#[pallet::config]</code> - atributo obrigatório para definir a configuração dos tipos de dados do módulo</li> <li><code>#[pallet::call]</code> - macro usada para definir funções expostas como transações, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transações e lógica personalizadas</li> <li><code>#[pallet::error]</code> - como transações podem falhar (por exemplo, fundos insuficientes) e, por segurança, um módulo não deve gerar exceções, todos os possíveis erros devem ser identificados e listados em um enum para serem retornados em uma execução malsucedida</li> <li><code>#[pallet::event]</code> - eventos podem ser definidos e usados para fornecer mais informações ao usuário</li> <li><code>#[pallet::storage]</code> - macro usada para definir elementos que serão persistidos em storage; como recursos são escassos em uma blockchain, deve ser usada com parcimônia para armazenar apenas informações essenciais</li> </ul> <p>Todas estas macros atuam como atributos que devem ser aplicados ao código logo acima dos módulos, funções, estruturas, enums, tipos, etc., Rust, permitindo que o módulo seja construído e adicionado ao Runtime, que, com o tempo, irá expor a lógica personalizada ao mundo exterior, conforme exposto na seção seguinte.</p>"}, {"location": "learn/framework/modules/#custom-module-example", "title": "Exemplo de Módulo Personalizado", "text": "<p>Como exemplo de um módulo personalizado, o seguinte código (não destinado a uso em produção) demonstra o uso das macros mencionadas anteriormente, apresentando uma loteria simples com funcionalidade mínima, expondo duas transações:</p> <ul> <li> <p>buy_ticket - esta transação verifica se o utilizador que está a assinar o pedido ainda não comprou um bilhete e tem fundos suficientes para pagar. Se tudo estiver bem, o módulo transfere o preço do bilhete para uma conta especial e regista o utilizador como participante do prémio</p> </li> <li> <p>award_prize - esta transação gera um número aleatório para escolher o vencedor da lista de participantes. O vencedor recebe a quantia total dos fundos transferidos para a conta especial do módulo</p> </li> </ul> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre> <p>Para mais informações sobre o processo passo a passo de criação de um módulo feito sob medida para o Runtime, consulte Adicionar um módulo personalizado na secção de Builder.</p>"}, {"location": "learn/framework/overview/", "title": "Visão Geral da Estrutura de Desenvolvimento de Rede", "text": ""}, {"location": "learn/framework/overview/#introduction", "title": "Introdução", "text": "<p>A construção de uma rede do zero é uma tarefa muito complexa que exige profundo conhecimento em uma ampla gama de áreas, incluindo (mas não se limitando a):</p> <ul> <li> <p>Algoritmos de Consenso - o consenso garante que todos os participantes da rede blockchain concordem com a validade das transações. Alguns mecanismos de consenso populares incluem Prova de Trabalho (PoW) e Prova de Participação (PoS)</p> </li> <li> <p>Criptografia - a criptografia desempenha um papel crucial na segurança da blockchain. Você precisará de algoritmos criptográficos para tarefas como criar assinaturas digitais, verificar transações e criptografar dados</p> </li> <li> <p>Rede Distribuída - uma arquitetura de rede para permitir que os nós se comuniquem, validem transações e sincronizem os dados da blockchain é fundamental para manter um livro-razão compartilhado em uma rede descentralizada</p> </li> <li> <p>Estruturas de Dados - além da lista de blocos, onde cada bloco contém um conjunto de transações junto com uma referência ao bloco anterior, é necessária uma estratégia otimizada e de alto desempenho para armazenar o estado da rede</p> </li> <li> <p>Governança - se a rede for projetada para ser sem permissão, um mecanismo de votação é importante para mantê-la evoluindo e refletindo a vontade da comunidade</p> </li> <li> <p>Atualização - é necessário definir claramente como atualizar, como as modificações são implementadas e como os conflitos são resolvidos dentro da rede</p> </li> </ul> <p>Felizmente, não há necessidade de construir esses componentes de blockchain do zero, graças a uma excelente estrutura de código aberto chamada Substrate. A própria Tanssi é construída com essa estrutura, aproveitando suas implementações de base abrangentes, modularidade e flexibilidade para alcançar um alto nível de personalização.</p>"}, {"location": "learn/framework/overview/#substrate-framework", "title": "Estrutura Substrate", "text": "<p>Substrate é uma estrutura extremamente performática, flexível, modular e altamente personalizável para construir blockchains. Essa estrutura é a base e o motor que impulsionam muitos projetos no ecossistema Web3, incluindo a própria rede Tanssi e as redes implantadas por meio da Tanssi.</p> <p>Muitos de seus ótimos recursos, como desempenho, facilidade de uso e modularidade, resultam da linguagem de programação escolhida para seu desenvolvimento. É aqui que a Linguagem de Programação Rust se destaca: ela é rápida, portátil e fornece um Template maravilhoso para lidar com a memória, entre outros motivos detalhados na próxima seção.</p> <p>Ao desenvolver uma rede, Substrate representa uma grande vantagem ao fornecer um conjunto de implementações prontas para uso dos principais blocos de construção que um projeto precisa:</p> <ul> <li> <p>Algoritmos de Consenso - existem vários mecanismos de consenso integrados, como Aura (Prova de Autoridade), Babe (Prova de Participação) e Grandpa (finalidade de bloco), mas devido ao alto grau de personalização que Substrate oferece, as equipes podem sempre optar por desenvolver seu consenso específico para se adaptar às necessidades do caso de uso, como a equipe Moonbeam fez com a Estrutura de Consenso Nimbus Parachain</p> </li> <li> <p>Módulos de Runtime - muitos módulos integrados (explicados em detalhes na seção modules) podem ser selecionados e configurados em sua rede, como contas, saldos, staking, governança, identidade e muito mais</p> </li> <li> <p>Rede - protocolos e bibliotecas integradas para estabelecer conexões, propagar transações e blocos, sincronizar o estado da blockchain e gerenciar interações de rede</p> </li> <li> <p>Armazenamento - mecanismos de armazenamento integrados para armazenamento e recuperação de dados eficientes</p> </li> <li> <p>Fila de Transações - sistema de fila de transações integrado que gerencia a validação, priorização e inclusão de transações em blocos, garantindo a consistência e integridade do estado da rede</p> </li> <li> <p>APIs RPC - Substrate fornece APIs de Chamada de Procedimento Remoto (RPC) que permitem que aplicativos externos interajam com a rede, consultando dados da blockchain, enviando transações e acessando várias funcionalidades expostas pelo Runtime</p> </li> </ul> <p>Cada recurso que o Substrate oferece pode ser usado como está, estendido, personalizado ou substituído para atender aos requisitos específicos do caso de uso da rede.</p> <p>Substrate agiliza e acelera o processo de desenvolvimento de novas redes. Quando usado em conjunto com Tanssi, que ajuda a lidar com a infraestrutura e supervisionar a implantação, a tarefa de lançar uma nova rede se torna significativamente mais simples!</p>"}, {"location": "learn/framework/overview/#rust-programming-language", "title": "Linguagem de Programação Rust", "text": "<p>Rust é uma linguagem de programação com recursos que os desenvolvedores classificam consistentemente em pesquisas como a pesquisa anual de desenvolvedores do Stack Overflow.</p> <p>Além de fornecer uma ótima experiência para os desenvolvedores, o Rust se destaca em muitas áreas:</p> <ul> <li> <p>Segurança da memória - O compilador Rust impõe verificações estritas em tempo de compilação para evitar erros de programação comuns, como desreferências de ponteiros nulos, estouros de buffer e condições de corrida de dados. Além disso, a memória é gerenciada por meio de um novo sistema de propriedade (verificado pelo compilador), que elimina a necessidade de um coletor de lixo</p> </li> <li> <p>Desempenho - Rust atinge um desempenho comparável ao de C e C++, fornecendo controle de baixo nível sobre os recursos do sistema e minimizando a sobrecarga de Runtime. Ele tem um princípio de abstração de custo zero, semelhante a \"o que você não usa, você não paga\" de C++, o que significa que as abstrações não têm sobrecarga extra</p> </li> <li> <p>Concorrência - Rust possui recursos integrados que facilitam a escrita de código concorrente e paralelo sem introduzir condições de corrida de dados. Ele fornece threads leves (tarefas) e um Template de propriedade poderoso que garante o compartilhamento seguro de dados entre threads</p> </li> <li> <p>Abstrações expressivas e seguras - Rust oferece um rico conjunto de recursos de linguagem modernos, como correspondência de padrões, tipos de dados algébricos, closures e inferência de tipos, permitindo que os desenvolvedores escrevam e leiam código expressivo e conciso. O compilador Rust impõe o forte sistema de tipos, evitando muitos erros em Runtime em tempo de compilação</p> </li> <li> <p>Compatibilidade entre plataformas - Rust foi projetado para funcionar bem em uma variedade de plataformas e arquiteturas. Ele suporta os principais sistemas operacionais como Windows, macOS e Linux, bem como sistemas embarcados e WebAssembly. Essa versatilidade permite que os desenvolvedores escrevam código que pode ser implantado em diferentes ambientes</p> </li> <li> <p>Ecossistema em crescimento - Rust tem um ecossistema em rápido crescimento com uma comunidade vibrante e uma rica coleção de bibliotecas e ferramentas. O gerenciador de pacotes oficial, Cargo, simplifica o gerenciamento de dependências, construção e teste</p> </li> <li> <p>Interoperabilidade - Rust fornece interoperabilidade perfeita com bases de código existentes escritas em C e C++. Ele tem uma Interface de Função Estrangeira (FFI) que permite que o código Rust se interface com o código escrito em outras linguagens, permitindo que os desenvolvedores introduzam gradualmente Rust em projetos existentes, como o kernel Linux</p> </li> </ul>"}, {"location": "learn/framework/xcm/", "title": "Comunicação Nativa Cross-Chain", "text": ""}, {"location": "learn/framework/xcm/#introduction", "title": "Introdução", "text": "<p>Todas as redes Powered by Tanssi têm uma capacidade inerente de se comunicar e interagir com qualquer outra rede no ecossistema. Esse recurso de comunicação cross-chain nativo é possível graças à infraestrutura exclusiva sobre a qual as redes são construídas, alavancando o formato de Mensagem Cross-Consensus (XCM para abreviar), que facilita a comunicação entre diferentes sistemas de consenso.</p> <p>XCM é uma linguagem de mensagens projetada para ser genérica. Ela não faz nenhuma suposição sobre a cadeia de destino e pode comunicar diferentes intenções entre sistemas de consenso soberanos.</p> <p>A mensagem XCM é um programa que contém uma ou mais instruções que serão retransmitidas para execução na cadeia de destino. Por si só, cada instrução XCM é sem sentido, mas a combinação de um conjunto específico de instruções pode resultar em uma ação desejada quando a mensagem XCM é executada na cadeia de destino.</p> <p>Neste artigo, abordamos os conceitos básicos do mecanismo de comunicação cross-chain nativo que permite pontes rápidas e seguras dentro do ecossistema.</p>"}, {"location": "learn/framework/xcm/#design-principles", "title": "Princípios de Design", "text": "<p>Concebido com uma mentalidade abstrata, o XCM não foi projetado para estar em conformidade com um caso de uso específico ou configuração de rede de destino específica, minimizando assim o efeito de acoplamento. Seus princípios básicos de design são:</p> <ul> <li>Assíncrono - semelhante ao envio de um cartão postal - mas muito mais rápido - o remetente continuará a realizar suas tarefas como de costume, sem se bloquear ou aguardar uma resposta do destino</li> <li>Absoluto - as mensagens têm garantia de serem entregues ao destino pretendido, em ordem e em tempo hábil</li> <li>Assimétrico - as mensagens enviadas não têm contrapartida de resposta. Quaisquer valores de retorno, se necessários, devem ser enviados de volta do destino para o remetente com outra mensagem</li> <li>Agnóstico - não há qualquer suposição sobre a configuração ou propriedades de duas redes de comunicação. As redes podem diferir em todos os aspectos, exceto na capacidade de entender o XCM. Por exemplo, uma cadeia pode ser compatível com EVM e a outra não, uma cadeia pode ser uma rede DeFi e a outra uma rede de jogos, e assim por diante.</li> </ul>"}, {"location": "learn/framework/xcm/#fees", "title": "Taxas", "text": "<p>Um usuário que executa uma transação em uma rede deve pagar as taxas derivadas do esforço computacional associado à tarefa, e a execução cross-chain não é exceção a essa regra. Na comunicação cross-chain, uma mensagem requer execução em pelo menos duas cadeias diferentes, e o usuário precisa pagar as taxas associadas ao esforço computacional feito por cada cadeia envolvida. Além dos custos relacionados à execução, as redes Tanssi incluem uma taxa de entrega padrão para evitar spam XCM.</p> <p>Por exemplo, se um usuário na rede A deseja chamar um contrato inteligente na rede B, o usuário deve ter fundos suficientes para pagar a entrega da mensagem e incluir instruções na mensagem XCM para fornecer um ativo que a rede B aceite como pagamento por seus serviços para cobrir as taxas associadas. Uma vez que esse ativo é fornecido, a execução agora pode ser comprada na cadeia de destino.</p> <p>Note</p> <p>Como as redes são soberanas, elas decidem quais tokens são válidos para pagar suas taxas de execução XCM. Por exemplo, se a rede B aceitar tokens da rede A para pagamentos de taxas, qualquer usuário na rede A pode pagar por uma mensagem XCM destinada à rede B usando apenas tokens da rede A.</p>"}, {"location": "learn/framework/xcm/#common-use-cases", "title": "Casos de Uso Comuns", "text": "<p>Muitos casos de uso podem ser abordados, beneficiando-se do terreno comum e da versatilidade que o XCM oferece. Dois dos mais recorrentes são transferências de ativos e execução remota.</p>"}, {"location": "learn/framework/xcm/#asset-transfer", "title": "Transferências de Ativos", "text": "<p>Mover ativos digitais de uma rede para outra é essencial para criar um ecossistema blockchain mais dinâmico, eficiente e interconectado. O recurso cross-chain nativo permite duas estratégias principais para transferir ativos de uma cadeia para outra:</p> <ul> <li>Teleporte - teletransportar um ativo é um mecanismo simples e eficiente, mas tem uma grande ressalva: requer confiança entre as partes. Essencialmente, quando a rede A deseja enviar X quantidade de ativos para a rede B, ela queima X quantidade de ativos e envia uma mensagem para a rede B instruindo-a a cunhar exatamente X quantidade de ativos, preservando o saldo geral de ativos e concluindo a ação de teletransporte. Nesse processo, a rede A confia na rede B para não cunhar mais tokens do que o transferido, e a rede B confia na rede A para queimar os tokens que foram transferidos</li> <li>Transferência de reserva - Uma transferência de reserva envolve a cadeia de reserva de um ativo, que é a cadeia onde o ativo é nativo (por exemplo, Moonbeam é a cadeia de reserva para o token GLMR). Além disso, as redes não reservadas mantêm uma conta soberana na cadeia de reserva, uma conta sem chave gerenciada pelo respectivo governador da rede. Assim, quando a rede de reserva A deseja enviar X quantidade de um ativo para a rede não reservada B, ela transfere localmente os ativos para a conta soberana da rede B e, na mesma ação atômica, envia uma mensagem XCM para a rede B com instruções para cunhar X quantidade de uma forma derivada do ativo transferido. Por outro lado, se a rede não reservada B deseja enviar X quantidade de um ativo para a rede de reserva A, as etapas são: a rede B queima a forma derivada do ativo localmente e envia uma mensagem XCM para a rede A, com instruções para transferir os ativos da conta soberana da rede B para a conta de destino da rede A. Mesmo que a rede não reservada cunhe tokens derivados em excesso (ou não queime tokens ao transferir), esses tokens não terão valor real porque não são apoiados um a um na cadeia de reserva</li> </ul> <p>As taxas associadas à execução de transferências são tipicamente deduzidas do valor transferido, para que o destinatário receba a quantia pretendida menos as taxas.</p>"}, {"location": "learn/framework/xcm/#remote-execution", "title": "Execução Remota", "text": "<p>A interoperabilidade nativa que o XCM fornece permite que uma rede envie uma mensagem a outra, acionando alguma ação. Por exemplo, se a cadeia de destino for compatível com EVM, a rede A poderá chamar um contrato inteligente implantado na rede B.</p> <p>Conforme mencionado na seção de taxas, para que qualquer solicitação na cadeia seja executada, é necessário cobrir suas taxas associadas. No XCM, a execução remota pode ser comprada com duas etapas:</p> <ol> <li>Reservar alguns ativos usando a instrução <code>WithdrawAsset</code> XCM, que retira fundos da origem da chamada e os coloca em um registro de retenção</li> <li>Pagar pela execução na cadeia, usando a instrução <code>BuyExecution</code> XCM, que usa os ativos previamente retirados</li> </ol> <p>Note</p> <p>Quando uma rede envia uma mensagem XCM, sua fonte padrão no lado receptor é a conta soberana da rede de origem. A rede remetente pode adicionar uma instrução XCM chamada <code>DescendOrigin</code> à mensagem, alterando a conta de origem para corresponder à conta do usuário que assina, garantindo que a execução ocorra em nome da mesma entidade que inicia a mensagem XCM na cadeia de origem e evitando um cenário potencialmente inseguro.</p> <p>Finalmente, a execução ocorre na cadeia de destino, chamando um contrato inteligente ou qualquer outra transação usando a instrução XCM chamada <code>Transact</code>.</p> <p>O fluxo geral para execução remota é representado no seguinte diagrama:</p> <p></p>"}, {"location": "learn/framework/xcm/#channel-registration", "title": "Estabelecendo Comunicação Cross-Chain", "text": "<p>Antes que duas cadeias possam se comunicar, um canal de mensagens deve ser estabelecido. Os canais são unidirecionais, o que significa que canais separados são necessários para enviar mensagens da cadeia A para a cadeia B e da B para a A.</p> <p>Para que a cadeia A se comunique com a cadeia B, a cadeia A deve enviar uma transação de canal aberto para a cadeia de retransmissão solicitando que um canal seja aberto com a cadeia B. A cadeia B deve então aceitar a solicitação enviando uma mensagem XCM correspondente para a cadeia de retransmissão. Somente quando ambas as cadeias concordam é que o canal é aberto na próxima época. O mesmo processo é necessário para estabelecer um canal da cadeia B para a cadeia A.</p> <p>É importante notar que um canal entre uma rede e a cadeia de retransmissão é aberto automaticamente mediante registro e integração da rede.</p> <p></p> <p>Depois que o canal é estabelecido, as mensagens cross-chain podem ser enviadas entre as redes. Para transferências de ativos, os ativos também precisarão ser registrados antes de serem transferidos.</p> <p>Note</p> <p>XCM é uma linguagem versionada e em constante evolução. Quando duas redes de comunicação usam versões diferentes do XCM, elas devem usar a versão mais recente com suporte do lado menos atualizado. Para descobrir a versão XCM mais recente com a qual uma rede pode trabalhar, outras redes podem consultá-la e assinar atualizações sempre que isso mudar.</p>"}, {"location": "learn/framework/xcm/#message-destinations", "title": "Destinos de Mensagens", "text": "<p>Para compor mensagens significativas em um ambiente multichain, é necessário ter uma maneira precisa e abstrata de referenciar recursos localizados em diferentes sistemas de consenso. Um conceito chamado multilocalização é usado para servir a esse propósito e direcionar uma cadeia específica ou qualquer um de seus elementos internos, como uma conta, um ativo ou um contrato inteligente.</p> <p>Os elementos de destino do XCM são organizados em uma arquitetura hierárquica, onde os elementos estão contidos em outros componentes. Por exemplo, um contrato inteligente é um elemento contido em uma rede, e o mesmo pode ser dito para uma conta ou um ativo ERC20. As redes estão contidas pela cadeia de retransmissão, que desempenha um papel crucial no processo de mensagens cross-chain, retransmitindo mensagens de uma rede para outra.</p> <p>Multilocalizações não são um localizador de recursos universal. Eles se referem a elementos da perspectiva do remetente e são compostos por dois componentes: <code>pais</code> e <code>interior</code>. Pais é uma propriedade que indica se a rota deve \"subir\" na hierarquia, ou seja, de uma rede para a cadeia de retransmissão. Interior é uma lista de junções que definem como localizar o destino. Aqui estão alguns exemplos de multilocalizações:</p> <ul> <li>Rede A referencia um contrato inteligente na rede B - do ponto de vista da rede A, para alcançar um contrato inteligente na rede B, é necessário subir na hierarquia (para a cadeia de retransmissão) e, em seguida, descer para a rede B para, uma vez lá, referenciar o endereço do contrato inteligente. A multilocação é, portanto, definida com um valor de <code>pais</code> definido como <code>1</code>, que sobe, e duas junções, uma que define qual rede deve receber a mensagem e a outra que define o endereço H160 do contrato inteligente que será chamado</li> </ul> <p></p> <ul> <li>Rede A referencia uma conta na cadeia de retransmissão - do ponto de vista da rede A, para referenciar uma conta na cadeia de retransmissão, é necessário subir e, em seguida, referenciar a conta. A multilocação é definida com um valor de <code>pais</code> definido como <code>1</code>, que sobe para a cadeia de retransmissão, e uma junção que referencia o endereço de destino do tipo substrato</li> </ul> <p></p>"}, {"location": "learn/tanssi/", "title": "Saiba mais Sobre Tanssi", "text": "<p>Com Tanssi, os desenvolvedores podem contar com a produção contínua de blocos, integração com ferramentas essenciais e a flexibilidade de escolher provedores de segurança que melhor se adequem ao seu ambiente de blockchain, capacitando-os a se concentrar na inovação, e não nos obstáculos técnicos.</p> <p>A estrutura modular, a personalização de Runtime, o gerenciamento de transações e a interoperabilidade da Tanssi transformam o desenvolvimento de rede em um processo acessível e eficiente, reduzindo drasticamente o tempo de lançamento no mercado, garantindo, ao mesmo tempo, alto desempenho e escalabilidade.</p> <p>Esta seção inclui uma visão geral dos principais recursos da Tanssi que suportam o desenvolvimento da rede, cobrindo tudo, desde infraestrutura e segurança até integrações essenciais.</p>"}, {"location": "learn/tanssi/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/tanssi/account-types/", "title": "Contas no Protocolo Tanssi", "text": ""}, {"location": "learn/tanssi/account-types/#introduction", "title": "Introdução", "text": "<p>A tecnologia blockchain baseia-se na criptografia de chaves público-privadas para propriedade segura de ativos e verificação de transações. Chaves privadas autorizam transações, enquanto chaves públicas servem como endereços para verificação. Devido à natureza híbrida Substrate e Ethereum do protocolo Tanssi, entender os diferentes tipos de conta é crucial para usuários e operators.</p>"}, {"location": "learn/tanssi/account-types/#key-types-in-tanssi-protocol", "title": "Tipos de Conta no Protocolo Tanssi", "text": "Tipo de Conta Algoritmo Subjacente Uso Principal na Tanssi Sr25519 Assinaturas Schnorr no grupo Ristretto Esquema padrão de assinatura para transações baseadas em Substrate e identidade de operator. Ed25519 EdDSA usando Curve25519 Usado para funções específicas de consenso (ex.: produção de blocos, finalidade) no Substrate. ECDSA Algoritmo de Assinatura Digital de Curva Elíptica Recebimento de recompensas via protocolo Symbiotic baseado em Ethereum para operators."}, {"location": "learn/tanssi/account-types/#identity-and-operations", "title": "Identidade e Operações", "text": "<p>A Tanssi, construída com o framework Substrate, utiliza esquemas criptográficos distintos para funções diferentes, principalmente Sr25519 e Ed25519. Esses tipos de conta são essenciais para interagir com os componentes Substrate do protocolo, assinando transações.</p> <p>Sr25519 (Schnorrkel/Ristretto x25519) – é o tipo de conta principal usado na maioria das operações voltadas ao usuário dentro da Tanssi. Seus pontos fortes são segurança e eficiência. Contas Sr25519 servem como sua identidade on-chain, usadas para manter tokens, participar de governança, pagar taxas de transação e outras interações gerais com a rede.</p> <p>Ed25519 (Algoritmo de Assinatura Digital de Curva Edwards) – enquanto Sr25519 cuida da identidade e transações gerais, Ed25519 é usado por seu alto desempenho em assinatura criptográfica, ideal para operações de consenso. Na Tanssi, contas Ed25519 são usadas por node operators para mecanismos críticos, como produção de blocos e finalidade. Usuários comuns normalmente não criam ou usam diretamente contas Ed25519, mas elas são fundamentais para a segurança e operação da rede.</p> <p>Operators de nó na Tanssi precisam de uma conta Substrate para registrar suas atividades, incluindo validadores que protegem a rede e Sequencers que produzem blocos. Esta conta também rastreia recompensas, com chaves de sessão mapeadas para ela para maior segurança.</p>"}, {"location": "learn/tanssi/account-types/#security-and-rewards-on-ethereum", "title": "Segurança e Recompensas no Ethereum", "text": "<p>O Algoritmo de Assinatura Digital de Curva Elíptica (ECDSA) é fundamental para o Ethereum e é usado pela Tanssi para integrar-se à rede Ethereum via Symbiotic. Essa parceria alavanca a segurança do Ethereum para redes powered by Tanssi.</p> <p>Operators Tanssi precisam de uma conta ECDSA para receber recompensas distribuídas no Ethereum, geralmente via protocolo Symbiotic. A necessidade de contas Substrate e ECDSA destaca o design híbrido da Tanssi, em que as operações são baseadas em Substrate, e a segurança e as recompensas estão vinculadas ao Ethereum.</p>"}, {"location": "learn/tanssi/account-types/#account-mappings-in-tanssi", "title": "Mapeamentos de Conta na Tanssi", "text": ""}, {"location": "learn/tanssi/account-types/#vinculacao-interna-de-chaves-sr25519-e-ed25519", "title": "Vinculação Interna de Chaves (Sr25519 e Ed25519)", "text": "<p>Dentro do protocolo Substrate da Tanssi, a identidade Sr25519 primária de um operator se vincula a chaves Ed25519 específicas usadas para tarefas de consenso (como produção de blocos). Os operators criam essa vinculação com uma transação on-chain, mapeando suas chaves públicas internas (“chaves de sessão”) para a conta de stash. Esse registro on-chain garante que a rede atribua corretamente todas as ações das chaves de sessão à identidade primária do operator.</p>"}, {"location": "learn/tanssi/account-types/#mapeamento-de-recompensas-entre-ecossistemas-sr25519-e-ecdsa", "title": "Mapeamento de Recompensas entre Ecossistemas (Sr25519 e ECDSA)", "text": "<p>Para recompensas no Ethereum (por exemplo, via Symbiotic), a identidade Sr25519 do operator é mapeada para um endereço ECDSA no Ethereum. As duas contas são vinculadas pelo middleware da Tanssi, garantindo que as recompensas do trabalho do operator na rede Tanssi sejam roteadas para a conta Ethereum designada.</p>"}, {"location": "learn/tanssi/glossary/", "title": "Glossário", "text": ""}, {"location": "learn/tanssi/glossary/#introduction", "title": "Introdução", "text": "<p>O protocolo Tanssi oferece uma ampla gama de recursos e arquitetura em camadas, tornando-o rico e complexo. Há uma grande quantidade de terminologia específica para Tanssi, Appchains, Symbiotic e o espaço web3 em geral. Compilamos uma lista de termos que você vai querer conhecer ao revisar a documentação da Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#appchain", "title": "Appchain", "text": "<p>Um blockchain personalizável específico para aplicações implantado através da Tanssi que entra em operação em minutos, beneficiando-se da segurança compartilhada, serviços de produção de blocos, bridging integrado e outros serviços.</p>"}, {"location": "learn/tanssi/glossary/#beefy", "title": "BEEFY", "text": "<p>BEEFY significa Bridge Efficiency Enabling Finality Yielder. É um protocolo de consenso que o Tanssi utiliza para bridging eficiente e sem confiança para o Ethereum.</p>"}, {"location": "learn/tanssi/glossary/#bridge", "title": "Bridge", "text": "<p>Uma bridge no contexto web3 conecta dois blockchains soberanos diferentes. Tanssi oferece uma bridge integrada baseada no Snowbridge, conectando a rede Tanssi ao Ethereum de forma descentralizada e sem confiança.</p>"}, {"location": "learn/tanssi/glossary/#dancelight", "title": "Dancelight", "text": "<p>A TestNet oficial da Tanssi para implantação e experimentação rápida de redes.</p>"}, {"location": "learn/tanssi/glossary/#data-preservers", "title": "Data Preservers", "text": "<p>Nós de arquivamento completo que garantem a disponibilidade de dados e fornecem infraestrutura RPC para as redes Tanssi e powered by Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#ecdsa", "title": "ECDSA", "text": "<p>ECDSA significa Elliptic Curve Digital Signature Algorithm, que é o esquema criptográfico usado para contas Ethereum.</p>"}, {"location": "learn/tanssi/glossary/#ed25519", "title": "Ed25519", "text": "<p>É o esquema criptográfico para produzir assinaturas digitais usado por node operators para mecanismos de consenso como produção de blocos.</p>"}, {"location": "learn/tanssi/glossary/#gateway", "title": "Gateway Contract", "text": "<p>Um dos componentes da bridge Tanssi-Ethereum. Ele serve como o ponto central de mensagens do Ethereum que recebe e valida mensagens da Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#light-client", "title": "Light Client", "text": "<p>Um dos componentes da bridge Tanssi-Ethereum. Serve como um verificador on-chain para a legitimidade dos dados em uma rede.</p> <p>Um cliente leve é um software que permite interagir com um blockchain sem ter que baixar todos os dados. Ele utiliza um subconjunto de informações (como cabeçalhos de blocos) e usa ferramentas como provas de Merkle para verificar a autenticidade de transações e dados. Isso torna os clientes leves mais eficientes em termos de recursos do que os nós completos.</p>"}, {"location": "learn/tanssi/glossary/#merkle-root", "title": "Merkle Root", "text": "<p>Um único hash criptográfico que permite a verificação de um conjunto inteiro de dados, como todas as transações em um bloco.</p>"}, {"location": "learn/tanssi/glossary/#operator", "title": "Operator", "text": "<p>Um nó que valida transações, fornecendo segurança através de um protocolo de restaking para Tanssi e todas as appchains movidas a Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#relayer", "title": "Relayer", "text": "<p>Um componente sem estado que transporta mensagens e provas entre diferentes redes blockchain, como Tanssi e Ethereum.</p>"}, {"location": "learn/tanssi/glossary/#restaking", "title": "Restaking", "text": "<p>A prática de usar tokens já apostados para proteger protocolos ou serviços adicionais.</p>"}, {"location": "learn/tanssi/glossary/#sequencer", "title": "Sequencer", "text": "<p>Um nó responsável por executar transações e produzir blocos para appchains movidas a Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#session", "title": "Session", "text": "<p>Um período de tempo durante o qual o mesmo conjunto de autoridades (sequencers ou validadores) está ativo.</p>"}, {"location": "learn/tanssi/glossary/#sr25519", "title": "Sr25519", "text": "<p>O principal esquema de assinatura que é usado para a maioria das operações voltadas para o usuário dentro da rede Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#substrate", "title": "Substrate", "text": "<p>Uma estrutura de desenvolvimento de blockchain modular e de alto desempenho usada para construir Tanssi e appchains Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#symbiotic", "title": "Symbiotic", "text": "<p>Um protocolo de restaking baseado em Ethereum, fornecendo serviços de restaking e segurança econômica para Tanssi e appchains powered by Tanssi.</p>"}, {"location": "learn/tanssi/glossary/#tanssi-substrate", "title": "$TANSSI(Substrate)", "text": "<p>O token de utilidade nativo do protocolo Tanssi. É usado para staking, governança, operações de rede e muito mais.</p>"}, {"location": "learn/tanssi/glossary/#tanssi-erc20", "title": "$TANSSI(ERC20)", "text": "<p>A representação ERC20 Ethereum do token Tanssi. É usado para pagar recompensas aos operators e muito mais.</p>"}, {"location": "learn/tanssi/glossary/#trustless", "title": "Trustless", "text": "<p>Assim como uma bridge sem confiança, ela permite a operação sem exigir confiança em intermediários centralizados, contando, em vez disso, com provas criptográficas.</p>"}, {"location": "learn/tanssi/glossary/#vault", "title": "Vault", "text": "<p>Um componente Symbiotic que recebe e gerencia colaterais em restaking, delegando aos operators e fornecendo segurança econômica às redes.</p>"}, {"location": "learn/tanssi/glossary/#verifier", "title": "Verifier", "text": "<p>O componente que valida provas criptográficas.</p>"}, {"location": "learn/tanssi/overview/", "title": "O Que é Tanssi?", "text": "<p>Tanssi é um protocolo de infraestrutura de appchain descentralizado que permite que os desenvolvedores lancem sua appchain em minutos. Em outras palavras, Tanssi reduz o processo de configuração de seis a doze meses normalmente necessário para qualquer equipe entrar em funcionamento com uma nova cadeia para minutos.</p> <p>Pode-se pensar em Tanssi como AWS para appchains. Em vez de lidar com toda a infraestrutura de rede você mesmo, Tanssi lida com todos os obstáculos, permitindo que você se concentre na criação da lógica do seu aplicativo, no crescimento de sua comunidade e em outras tarefas essenciais para o sucesso do seu produto.</p> <p>A segurança é outro obstáculo significativo que os desenvolvedores devem enfrentar, assumindo a responsabilidade de atrair ativos em stake para garantir a segurança do consenso e inicializar um conjunto de validadores, o que pode ser particularmente desafiador para projetos em seus estágios iniciais. Todas as appchains powered by Tanssi se beneficiam da segurança de nível Ethereum desde o início e, ao aproveitar o design descentralizado da Tanssi, as appchains não estão expostas a pontos únicos de falha.</p> <p>As appchains powered by Tanssi também se beneficiam de uma pilha de tecnologia modular, fornecendo controle máximo sobre a lógica que alimenta o Runtime do blockchain, oferecendo uma excelente maneira de os projetos escalarem e construírem soluções otimizadas para seus produtos. Esse controle completo sobre a lógica da appchain e o mecanismo de governança se adequa perfeitamente a uma ampla gama de casos de uso, incluindo protocolos DeFi, Ativos do Mundo Real (RWA), plataformas de jogos e outros.</p>"}, {"location": "learn/tanssi/overview/#the-problem-with-appchains", "title": "O Problema com Appchains", "text": "<p>Os desenvolvedores que buscam construir appchains descentralizadas geralmente têm que lidar com os seguintes problemas:</p> <ul> <li> <p>Gerenciamento de Infraestrutura Complexo: As implantações de appchain normalmente exigem o manuseio de numerosos componentes de infraestrutura, incluindo bootstrapping de Sequencers, operators (também conhecidos como validadores), carteiras, exploradores de blocos, oráculos, indexadores, endpoints RPC e muito mais. O gerenciamento adequado desses componentes consome tempo e recursos.</p> </li> <li> <p>Segurança Fraca e Ineficiente: As appchains geralmente sofrem por ter um pequeno conjunto de operators ou segurança econômica fraca. Projetos em estágio inicial geralmente carecem de apoio econômico suficiente para oferecer suporte a um mecanismo de consenso robusto. Além disso, os desenvolvedores geralmente têm que pagar pela validação total da capacidade do blockchain, mesmo quando podem não ter alcançado o ajuste produto-mercado, e os blocos podem estar quase vazios. Isso essencialmente significa que os operators estão sendo super pagos, e há um custo de oportunidade significativo, pois esses recursos poderiam ser usados em outros lugares para desenvolver o protocolo.</p> </li> <li> <p>Cross-Chain e Interoperabilidade: As appchains inerentemente carecem de recursos cross-chain, o que as impede de se conectar a outros ecossistemas de blockchain. Além disso, o desenvolvimento de soluções de interoperabilidade requer expertise especializada e implementação meticulosa.</p> </li> <li> <p>Tempo para o mercado lento: As complexidades da infraestrutura da appchain desviam o foco dos desenvolvedores da lógica do aplicativo, que é o principal impulsionador de interfaces intuitivas e uma experiência do usuário perfeita, crítica para a adoção.</p> </li> </ul>"}, {"location": "learn/tanssi/overview/#what-tanssi-provides", "title": "O que Tanssi Fornece", "text": "<p>Tanssi aborda os pontos problemáticos mais comuns da appchain:</p> <ul> <li> <p>Sequenciamento como Serviço: As appchains construídas com Tanssi têm seus blocos produzidos pelos trabalhadores incentivados da Tanssi. Tanssi garante a atividade contínua da appchain, orquestrando um conjunto descentralizado de Sequencers.</p> </li> <li> <p>Segurança Econômica por Meio de Provedores Externos: As appchains implantadas por meio da Tanssi aproveitam a segurança de um provedor de escolha (por exemplo, Symbiotic para Ethereum). O protocolo foi projetado para finalizar as transações de forma determinística em segundos por meio de um conjunto descentralizado de operators.</p> </li> <li> <p>Tanssi/Ethereum Bridge: Mova a liquidez de e para o Ethereum usando a ponte integrada com base no Snowbridge.</p> </li> <li> <p>Integrações Chave: As appchains construídas com Tanssi podem acessar componentes de infraestrutura importantes, juntamente com a produção de blocos, de forma totalmente automatizada e padronizada. As appchains powered by Tanssi vêm com suporte integrado para ferramentas essenciais, incluindo carteiras, exploradores de blocos, indexadores, provedores RPC e muito mais, economizando o esforço dos desenvolvedores de integrar esses componentes.</p> </li> <li> <p>Estrutura Modular de Blockchain: As appchains construídas com Tanssi podem usar uma estrutura de blockchain modular chamada Substrate, que permite que os desenvolvedores criem de forma rápida e fácil blockchains otimizadas e personalizáveis para qualquer caso de uso. Tanssi lida com a maioria das complexidades de infraestrutura, permitindo que os desenvolvedores se concentrem na lógica personalizada de sua appchain.</p> </li> </ul> <p>Em resumo, as appchains implantadas por meio da Tanssi são soluções soberanas de Camada 1 projetadas para serem altamente modulares e interconectadas, com foco na simplificação do processo de implantação e no desenvolvimento da personalização da própria appchain. Isso capacita os desenvolvedores a levar seus aplicativos blockchain ao mercado mais rápido, com segurança e com maior potencial de integração e interação nos ecossistemas blockchain mais amplos.</p>"}, {"location": "learn/tanssi/overview/#tanssi-key-aspects", "title": "Principais Aspectos da Tanssi", "text": "<p>A tabela a seguir resume os principais benefícios que Tanssi traz para seu projeto:</p> Aspecto A solução Tanssi Tempo de implantação - Minutos para implantar - Tempo mais rápido de lançamento no mercado Produção de bloco - Sequenciamento como serviço- Conjunto descentralizado de Sequencers por projeto Segurança - Segurança de nível Ethereum desde o início Finalidade/Liquidação - Determinístico- Finalidade em segundos Custo - Título de registro + Template de pagamento conforme o uso Personalização - Escolha o mecanismo de governança que melhor se adapta ao seu projeto - Estrutura modular- Personalização completa do Runtime Integrações e ferramentas - Ferramentas essenciais disponíveis desde o início"}, {"location": "learn/tanssi/overview/#tanssi-architecture", "title": "Arquitetura Geral da Tanssi e Appchains powered by Tanssi", "text": "<p>Como discutido anteriormente, as appchains implantadas por meio da Tanssi são blockchains soberanas e personalizáveis que, entre outros recursos, aproveitam o sequenciamento como serviço e herdam a finalidade do bloco de um provedor de segurança externo.</p> <p>Uma visão geral de alto nível da arquitetura é apresentada abaixo, apresentando Symbiotic como o provedor de segurança.</p> <p></p> <p>O protocolo Tanssi gerencia e orquestra um conjunto descentralizado de Sequencers atribuídos a fornecer serviços de produção de blocos para appchains powered by Tanssi. Os Sequencers executam transações e as incluem em blocos, que os operators do provedor de segurança prosseguem para validar. O protocolo de restaking da Symbiotic permite que seus operators ofereçam segurança econômica de nível Ethereum. O mecanismo de como isso funciona é explicado em dois artigos separados: Serviços de Produção de Blocos e Ethereum com Symbiotic.</p> <p>Embora os Sequencers que fornecem serviços de produção de blocos sejam rotacionados e realocados para uma appchain diferente a cada mudança de sessão, cada appchain terá seu próprio conjunto de Preservadores de Dados executando nós de arquivo completos, garantindo a disponibilidade de dados. Esses Preservadores de Dados fornecerão a infraestrutura RPC para aplicativos e usuários que interagem com appchains powered by Tanssi.</p> <p></p>"}, {"location": "learn/tanssi/overview/#whats-next", "title": "O Que Vem a Seguir?", "text": "<ul> <li>Vá para o Tanssi dApp e lance sua appchain.</li> <li>Interaja com uma appchain powered by Tanssi ao vivo: a Tanssi Demo EVM appchain.</li> </ul>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/", "title": "Ponte Tanssi-Ethereum", "text": ""}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#introduction", "title": "Introdução", "text": "<p>Blockchains tradicionais frequentemente criam silos, limitando a interoperabilidade de ativos e funcionalidades. A ponte Tanssi-Ethereum supera essas limitações ao permitir operações multichain contínuas que beneficiam ambos os ecossistemas.</p> <p>A ponte é mais do que uma troca de ativos. É um protocolo seguro e padronizado para interação direta entre cadeias, sem intermediários centralizados. Seu design sem confiança evita os riscos de pontos centrais de falha que muitas outras pontes enfrentam.</p> <p>Este artigo apresenta a ponte Tanssi-Ethereum como uma camada fundamental de interoperabilidade entre as duas redes. Você aprenderá como ela funciona, incluindo sua arquitetura, gestão de operators, Template econômico, mecanismos de slashing e transferências de ativos.</p> <p>Você também conhecerá as camadas de consenso que protegem a comunicação (BEEFY em Tanssi e a Beacon Chain do Ethereum), além dos papéis de provers, verifiers e relayers, oferecendo uma visão clara de como ativos e mensagens se movem com segurança entre Tanssi e Ethereum.</p>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#core-functions", "title": "Funções Principais", "text": "<p>A ponte facilita várias operações críticas entre Tanssi e Ethereum:</p> <ul> <li>Gestão de Operators - mantém informações de stake de operators no Ethereum via o protocolo Symbiotic, fornecendo esses dados à Tanssi para selecionar operators ativos, descentralizados e economicamente alinhados a cada era</li> <li>Operações Econômicas - distribui recompensas da Tanssi para stakers e operators no Ethereum</li> <li>Slashing - processa solicitações de slashing da Tanssi para o Ethereum quando operators violam as regras do protocolo</li> <li>Transferência de Ativos - permite transferências bilaterais e sem confiança de ativos entre Tanssi e Ethereum, aumentando a liquidez.</li> </ul> <p>Essa interoperabilidade amplia o potencial de aplicações descentralizadas e melhora significativamente a liquidez e a usabilidade de ativos em blockchain.</p>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#bridge-architecture", "title": "Arquitetura da Ponte", "text": "<p>Entender a funcionalidade de consenso da ponte requer examinar seus componentes principais: provers, verifiers e relayers. Provers geram provas criptográficas, verifiers as validam e relayers transportam dados entre as cadeias.</p> <p>Os provers incluem o módulo BEEFY da Tanssi e o consenso da Beacon Chain do Ethereum. Eles produzem dados de consenso transmitidos por relayers especializados.</p> <p>Cada cadeia executa um light client da outra, atuando como verificador on-chain da legitimidade dos dados. Por exemplo, quando o Tanssi envia uma mensagem ao Ethereum, ele gera provas compactas de eventos ou mudanças de estado baseadas em seu consenso. O light client do Ethereum verifica essas provas antes de agir. Esse método eficiente evita processar todo o estado da cadeia de origem, confiando em vez disso na verificação de provas criptográficas concisas.</p>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-consensus", "title": "Consenso de Tanssi para Ethereum", "text": "<p>BEEFY (Bridge Efficiency Enabling Finality Yielder) é o protocolo de consenso da Tanssi, atuando como prover. Ele foi projetado para ponte sem confiança e eficiente para cadeias como o Ethereum, que não são nativamente construídas para interoperabilidade.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_Pallet as Tanssi &lt;br/&gt; Pallet BEEFY (prover)\n    participant Beefy_Relayer as Relayer &lt;br/&gt; (Beefy)\n    participant Eth_BeefyClient as Ethereum &lt;br/&gt; Cliente BEEFY (verifier)\n\n    Tanssi_Pallet-&gt;&gt;Beefy_Relayer: Gerar compromisso BEEFY\n    activate Beefy_Relayer\n    Beefy_Relayer-&gt;&gt;Eth_BeefyClient: Enviar compromisso/prova\n    deactivate Beefy_Relayer\n\n    activate Eth_BeefyClient\n    Eth_BeefyClient-&gt;&gt;Eth_BeefyClient: Verificar compromisso\n    deactivate Eth_BeefyClient\n</code></pre>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-consensus", "title": "Consenso de Ethereum para Tanssi", "text": "<p>Para a ponte de Ethereum para Tanssi, o consenso da Beacon Chain do Ethereum é o prover. Ele fornece ao light client on-chain da Tanssi a prova do estado finalizado do Ethereum, incluindo eventos ou mensagens destinadas à Tanssi.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_BeaconCons as Ethereum &lt;br/&gt; Consenso da Beacon Chain (Prover)\n    participant Beacon_Relayer as Relayer &lt;br/&gt; (Beacon)\n    participant Tanssi_EthClient as Tanssi &lt;br/&gt; Cliente Light de Ethereum (verifier)\n\n    Eth_BeaconCons-&gt;&gt;Beacon_Relayer: Atualização da Beacon chain (Header/Proof)\n    activate Beacon_Relayer\n    Beacon_Relayer-&gt;&gt;Tanssi_EthClient: Enviar atualização/prova\n    deactivate Beacon_Relayer\n\n    activate Tanssi_EthClient\n    Tanssi_EthClient-&gt;&gt;Tanssi_EthClient: Verificar atualização/prova\n    deactivate Tanssi_EthClient</code></pre> <p>Do ponto de vista das mensagens, a ponte usa sua camada de verificação de consenso para comunicação multichain segura. Relayers dedicados transportam mensagens: o Execution Relay para Ethereum → Tanssi e o Tanssi Relay para Tanssi → Ethereum.</p> <p>Relayers são stateless e apenas submetem provas. Eles não podem forjar mensagens ou roubar fundos, pois o mecanismo de consenso revalida cada prova on-chain. Vários relayers em paralelo melhoram a responsividade sem centralizar poder.</p> <p>O contrato <code>Gateway</code> do Ethereum é o ponto central de mensagens. Ele recebe mensagens da Tanssi via relayers, valida-as usando provas de consenso e executa operações como cunhagem/desbloqueio de tokens ou chamadas de contratos inteligentes.</p>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-messages", "title": "Mensagens de Entrada de Ethereum para Tanssi", "text": "<p>Esta seção descreve mensagens de Ethereum para Tanssi, usando o consenso da Beacon Chain do Ethereum para provas e um Execution Relay (ou Beacon Relay).</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Contrato Gateway\n    participant Exec_Relay as Relayer &lt;br/&gt; (Execution Relay)\n    participant Tanssi_InQueue as Tanssi &lt;br/&gt; Fila de Entrada\n\n    Note over Eth_Gateway: Mensagem pronta / Evento ocorre\n    Eth_Gateway-&gt;&gt;Exec_Relay: Mensagem + Prova\n    activate Exec_Relay\n    Exec_Relay-&gt;&gt;Tanssi_InQueue: Submeter mensagem/prova\n    deactivate Exec_Relay\n\n    activate Tanssi_InQueue\n    Tanssi_InQueue-&gt;&gt;Tanssi_InQueue: Processar mensagem de entrada\n    deactivate Tanssi_InQueue</code></pre>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-messages", "title": "Mensagens de Saída de Tanssi para Ethereum", "text": "<p>Esta seção descreve mensagens de Tanssi para Ethereum, usando o consenso BEEFY para provar o estado da Tanssi e um Tanssi Relay para a transmissão.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_OutQueue as Tanssi &lt;br/&gt; Fila de Saída\n    participant Para_Relay as Relayer &lt;br/&gt; (Tanssi Relay)\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Contrato Gateway\n\n    Note over Tanssi_OutQueue: Mensagem pronta / Prova confirmada\n    Tanssi_OutQueue-&gt;&gt;Para_Relay: Mensagem + Prova\n    activate Para_Relay\n    Para_Relay-&gt;&gt;Eth_Gateway: Submeter mensagem/prova\n    deactivate Para_Relay\n\n    activate Eth_Gateway\n    Eth_Gateway-&gt;&gt;Eth_Gateway: Processar mensagem de saída\n    deactivate Eth_Gateway</code></pre> <p>O <code>Gateway</code> gerencia as comunicações de saída do Ethereum. Para transferências entre cadeias, ele registra um evento, bloqueia tokens se necessário e empacota os dados para envio à Tanssi. O Tanssi usa duas filas para processar mensagens com eficiência.</p> <p>A <code>Fila de Saída</code> lida com mensagens para o Ethereum. Ela as agrupa e adiciona uma raiz de Merkle (compromisso criptográfico) a cada cabeçalho de bloco. Isso permite que o light client do Ethereum verifique a inclusão de mensagens usando provas de consenso de forma eficiente.</p> <p>A <code>Fila de Entrada</code> processa mensagens vindas do Ethereum. Ela recebe e verifica provas de eventos do Ethereum por meio do light client de Ethereum on-chain da Tanssi. Eventos verificados tornam-se instruções internas na Tanssi. Essa arquitetura em camadas, protegida por consenso, garante interações sem confiança entre cadeias.</p>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#token-transfers-flow", "title": "Fluxo de Transferência de Tokens", "text": "<p>Esta seção explica como a ponte move ativos e mensagens. Ela envolve o bloqueio/cunhagem de ativos em uma cadeia e uma ação complementar na outra, protegida por provas verificadas. A seguir, são descritas as sequências típicas de transferência.</p> <ol> <li>Início (Cadeia de Origem) - o usuário inicia a transferência de ativos</li> <li>Prova via Relay - relayers off-chain coletam o evento e enviam provas criptográficas para a cadeia de destino</li> <li>Verificação (Cadeia de Destino) - light clients on-chain verificam de forma independente as provas enviadas</li> <li>Execução - após verificação bem-sucedida, tokens são cunhados/desbloqueados na cadeia de destino</li> </ol>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#transferencia-de-ethereum-para-tanssi", "title": "Transferência de Ethereum para Tanssi", "text": "<p>Esta seção detalha a movimentação de ativos do Ethereum para a Tanssi (como ativos derivativos).</p> <ol> <li>Bloquear no Ethereum - um usuário deposita ativos no contrato da Ponte do Ethereum. O contrato bloqueia os tokens e emite um evento de depósito</li> <li>Enviar Prova à Tanssi - um relayer off-chain detecta o evento finalizado, cria um pacote de prova (incluindo o cabeçalho do bloco do Ethereum e a prova de Merkle do depósito) e o envia para a <code>Fila de Entrada</code> da Ponte da Tanssi</li> <li>Verificar na Tanssi - o módulo <code>EthereumClient</code> da Ponte da Tanssi (um light client on-chain) recebe a prova da <code>Fila de Entrada</code>. Ele verifica a finalização/validade do cabeçalho do bloco do Ethereum e a autenticidade da prova de Merkle</li> <li>Cunhar na Tanssi - após a verificação bem-sucedida pelo <code>EthereumClient</code>, a <code>Fila de Entrada</code> é notificada e cunha o ativo correspondente na Tanssi</li> </ol> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant User\n    participant EBridge as Contrato da Ponte &lt;br/&gt; no Ethereum\n    participant Relayer\n    participant TBP as Ponte da Tanssi&lt;br/&gt; (Fila de Entrada + Cliente ETH)\n    participant TAH as Tanssi\n\n    User-&gt;&gt;EBridge: 1. Depositar ativo\n    activate EBridge\n    Note over EBridge: Bloquear tokens e emitir evento\n    deactivate EBridge\n\n    Relayer-&gt;&gt;Relayer: Observar evento no Ethereum\n    Relayer-&gt;&gt;TBP: 2. Enviar cabeçalho + prova de Merkle\n    activate TBP\n    Note over TBP: Receber prova (Fila de Entrada)\n    TBP-&gt;&gt;TBP: 3. Verificar prova (Pallet EthereumClient)\n    TBP-&gt;&gt;TAH: Enviar solicitação de cunhagem\n    deactivate TBP\n\n    activate TAH\n    TAH-&gt;&gt;TAH: 4. Cunhar ativo\n    TAH--&gt;&gt;User: (Ativo aparece na conta do destinatário)\n    deactivate TAH</code></pre>"}, {"location": "learn/tanssi/tanssi-ethereum-bridge/#transferencia-de-tanssi-para-ethereum", "title": "Transferência de Tanssi para Ethereum", "text": "<p>Este fluxo descreve o processo inverso, movendo ativos da Tanssi para o Ethereum.</p> <ol> <li>Iniciar e Confirmar na Tanssi - o usuário inicia uma transferência na Tanssi. Uma mensagem com os detalhes da transferência vai para a <code>Fila de Saída</code> da Ponte. A fila processa, agrupa o payload e confirma sua raiz de Merkle no cabeçalho do bloco da Tanssi, representando todas as mensagens de saída nesse bloco</li> <li>Enviar Prova ao Ethereum - um relayer off-chain monitora o Tanssi em busca de blocos finalizados com raízes de Merkle da <code>Fila de Saída</code>. Ele obtém as provas: um compromisso BEEFY (declaração assinada de cabeçalhos de bloco finalizados da Tanssi) e uma prova de Merkle do payload da transferência do usuário sob a raiz confirmada</li> <li>Submeter Compromisso no Ethereum - o relayer envia o compromisso BEEFY e a prova de Merkle para o contrato <code>Gateway</code> do Ethereum</li> <li>Verificar no Ethereum - o contrato Beefy Client do Ethereum (light client on-chain da Tanssi) recebe o compromisso BEEFY do <code>Gateway</code> e verifica sua validade (incluindo assinaturas)</li> <li>Validar Payload - após a verificação do compromisso, o <code>Gateway</code> valida a prova de Merkle do payload do usuário</li> <li>Executar no Ethereum - com ambas as provas verificadas, o contrato <code>Gateway</code> executa a ação, normalmente liberando ativos bloqueados pelo contrato principal da Ponte para o destinatário ou executando uma chamada para o contrato-alvo no Ethereum</li> </ol> <p>O diagrama a seguir ilustra a fase de início e confirmação do processo de transferência de ativos na Tanssi.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant User\n    participant TAH as Tanssi\n    participant TBP as Ponte da Tanssi&lt;br/&gt; (Fila de Saída)\n    participant Relayer\n\n    User-&gt;&gt;TAH: 1. Iniciar transferência e depositar ativo\n    activate TAH\n    TAH-&gt;&gt;TBP: Enviar mensagem para a Fila de Saída\n    deactivate TAH\n\n    activate TBP\n    Note over TBP: Processar mensagem, agrupar e&lt;br/&gt;confirmar raiz de Merkle no cabeçalho da Tanssi\n    deactivate TBP\n\n    Relayer-&gt;&gt;Relayer: 2. Observar cabeçalho da Tanssi /&lt;br/&gt;compromisso BEEFY e obter prova\n    Note over Relayer: O relayer agora está pronto para interagir&lt;br/&gt;com o Ethereum com base nos dados observados.</code></pre> <p>O diagrama seguinte detalha as etapas de relay, verificação e execução no lado do Ethereum para a transferência de ativos.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Relayer\n    participant EGateway as Contrato Gateway &lt;br/&gt; do Ethereum\n    participant EBeefy as Contrato Beefy Client &lt;br/&gt; do Ethereum\n    participant EBridge as Contrato da Ponte &lt;br/&gt; do Ethereum\n    participant User\n\n    Relayer-&gt;&gt;EGateway: 3. Submeter compromisso BEEFY + prova de Merkle\n    activate EGateway\n    EGateway-&gt;&gt;EBeefy: 4. Verificar compromisso BEEFY\n    activate EBeefy\n    EBeefy--&gt;&gt;EGateway: Verificação OK\n    deactivate EBeefy\n\n    EGateway-&gt;&gt;EGateway: 5. Verificar prova de Merkle do payload\n    Note over EGateway: Prova validada\n\n    EGateway-&gt;&gt;EBridge: 6. Executar: desbloquear tokens / chamar contrato-alvo\n    activate EBridge\n    Note over EBridge: Ativos transferidos ou&lt;br/&gt;chamada ao contrato-alvo executada\n    EBridge--&gt;&gt;User: (Tokens recebidos / chamada executada)\n    deactivate EBridge\n    deactivate EGateway</code></pre>"}, {"location": "learn/tanssi/external-security-providers/", "title": "Provedores de Segurança Externos", "text": "<p>A Tanssi integra provedores de segurança externos para fortalecer a flexibilidade e resiliência de seu ecossistema. Ao adotar Templates de segurança descentralizados, esses provedores oferecem soluções personalizadas que atendem às diversas necessidades operacionais, garantindo maiores níveis de segurança e confiança em todas as redes.</p> <p>Essa abordagem aborda desafios comuns que os desenvolvedores enfrentam, como garantir recursos econômicos significativos ou negociar com operators para manter os nós. Por meio da estrutura de segurança colaborativa da Tanssi, os desenvolvedores podem contornar esses obstáculos e se concentrar na inovação, aproveitando uma infraestrutura segura e escalável para otimizar a implantação de redes.</p>"}, {"location": "learn/tanssi/external-security-providers/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/", "title": "Ethereum com Symbiotic", "text": ""}, {"location": "learn/tanssi/external-security-providers/symbiotic/#introduction", "title": "Introdução", "text": "<p>O protocolo Tanssi cuida de componentes críticos de infraestrutura, facilitando que desenvolvedores lancem suas redes em poucos minutos. Além da produção de blocos, recuperabilidade de dados e integrações com ferramentas essenciais como carteiras, endpoints RPC, exploradores de blocos e outras, outro grande desafio é fornecer segurança para a rede.</p> <p>O Tanssi foi criado para oferecer aos desenvolvedores um Template de segurança compartilhada, evitando que eles tenham de buscar segurança econômica suficiente ou negociar com operators para rodar nós que façam opt-in para suas redes. Ao implantar redes por meio da Tanssi e escolher o Symbiotic como provedor de segurança, os desenvolvedores se beneficiam de segurança em nível de Ethereum, aproveitando bilhões de dólares em segurança compartilhada de ETH em stake.</p> <p>As seções a seguir descrevem como funciona o protocolo Symbiotic e como as redes Tanssi podem aproveitá-lo como mecanismo de consenso.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#symbiotic", "title": "Segurança em Nível de Ethereum com Symbiotic", "text": "<p>O Symbiotic é um protocolo de segurança compartilhada projetado para ser permissionless, multi-ativo e agnóstico à rede. Ele promove eficiência de capital ao permitir que usuários estendam a funcionalidade de seus ativos em stake para proteger outras redes, oferecendo utilidade adicional.</p> <p>O protocolo fornece uma camada de coordenação para seus principais componentes e participantes, alinhando incentivos entre as partes enquanto minimiza riscos na camada de execução ao implantar contratos centrais não atualizáveis no Ethereum. O diagrama a seguir resume todos os componentes e atores que participam do protocolo:</p> <pre><code>flowchart TD\n    %% Vaults subgraph\n    subgraph Ethereum[\"Ethereum/Symbiotic\"]\n        slash[/Eventos de Slashing/]\n        Restakers -- Depositar Ativos --&gt; Vaults\n        manager[\"Gerentes de Vaults\"] -- Administram --&gt; Vaults\n        Resolvers -- Decidem Sobre --&gt; slash\n        slash -- Executa Em --&gt; Vaults\n    end\n\n    %% Operators subgraph\n    subgraph Operators\n        direction BT\n        operators[\"Operators (Validadores)\"]\n        node_operators[\"Operators de Nós\"]\n        node_operators -- Operam --&gt; operators\n    end\n\n    %% Networks subgraph\n    subgraph Networks\n        direction BT\n        developers[\"Desenvolvedores\"]\n        networks[\"Redes Descentralizadas\"]\n        developers -- Lançam --&gt; networks\n    end\n\n    Vaults &lt;--&gt; Tanssi\n    Tanssi &lt;--&gt; Operators\n    Tanssi &lt;--&gt; Networks</code></pre> <p>O design flexível do Symbiotic permite que cada parte decida configurações que melhor atendam seus casos de uso. Por exemplo, os vaults podem escolher quais tipos de colateral aceitam, os operators podem determinar para quais redes querem prestar serviços e as redes descentralizadas podem personalizar seu caso de uso e definir o nível de segurança (quais colaterais são aceitos, por exemplo) de que precisam.</p> <p>As seções a seguir descrevem os principais componentes do protocolo.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#vaults", "title": "Vaults", "text": "<p>Os Vaults são o alicerce econômico do protocolo Symbiotic. Eles gerenciam liquidez e depósitos de restakers, conectam operators e redes e definem estratégias de delegação.</p> <p>Cada vault está vinculado a um token específico que atende à interface ERC20 e é aceito como colateral. Internamente, os fundos dentro do vault são representados como shares, o que fornece um mecanismo para rastrear propriedade e distribuir recompensas. No entanto, o token de recompensa pode ser diferente do token de colateral.</p> <p>Um vault é composto por três módulos principais, cada um com uma função distinta: o slasher, o delegator e o módulo de contabilidade. A implementação desses módulos pode variar dependendo das decisões do gerente do vault.</p> <ul> <li>Módulo Slasher - implementa a lógica de slashing, que penaliza maus atores</li> <li>Módulo Delegator - define como os fundos são delegados entre operators e redes. Diversas estratégias estão disponíveis, permitindo ao gerente do vault selecionar quais operators e redes deseja atender</li> <li>Módulo de Contabilidade - lida com as operações financeiras do vault, incluindo processar depósitos de usuários, gerenciar pedidos de saque, rastrear saldos ativos e oferta total, e implementar contabilidade baseada em épocas para saques e eventos de slashing. A implementação padrão do módulo de contabilidade é o ERC-4626, que oferece um sistema de shares embutido</li> </ul> <p>Como os operators recebem stake delegado do vault e podem ser alvo de slashing, eles devem ser aprovados previamente pelos gerentes de vault. Da mesma forma, os gerentes de vault analisam e autorizam cada rede que o vault protegerá, considerando, por exemplo, as recompensas que a rede oferece.</p> <p>Os gerentes de vault também designam resolvers, responsáveis por aprovar ou vetar eventos de slashing causados por operators em redes com suporte a veto-slashing, como a Tanssi Network.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#operators", "title": "Operators", "text": "<p>Os node operators são entidades ou indivíduos responsáveis por executar os nós (também conhecidos como operators ou validadores), que são os componentes computacionais que validam as transações das redes. Eles são responsáveis pela configuração dos nós, setup de hardware, disponibilidade e desempenho.</p> <p>Os node operators fazem opt-in para prestar serviços a redes, que precisam aceitar sua solicitação. Eles também fazem opt-in para prestar serviços em vaults, que igualmente precisam aceitar seu pedido.</p> <p>Depois que um operator é aceito por um vault e por uma rede conectada a esse vault, o nó pode começar a fornecer serviços de validação para essa rede, recebendo recompensas em troca.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#networks", "title": "Redes", "text": "<p>As Redes são os serviços ou redes ativamente validados. Essas blockchains específicas de aplicação podem ser de uma ampla gama de setores, como Gaming, DeFi, RWAs e outros, e são as plataformas com as quais, por meio de dApps, os usuários finais interagem.</p> <p>Como os operators fazem opt-in para prestar serviços às redes e os gerentes de vault precisam aceitar as redes, os desenvolvedores são responsáveis por definir, controlar e adaptar sua metodologia para onboarding, recompensa e slashing de operators.</p> <p>Note</p> <p>As redes implantadas por meio da Tanssi não precisam trabalhar o relacionamento com vaults e operators, pois o protocolo Tanssi lida com essas complexidades.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#tanssi-symbiotic", "title": "Tanssi com Symbiotic", "text": "<p>Desenvolvedores que lançam redes por meio da Tanssi se beneficiam dos serviços de produção de blocos, recuperabilidade de dados como serviço e do Template de segurança compartilhada derivado de todos os vaults que fazem opt-in para suportar o protocolo Tanssi. Isso elimina o obstáculo de lidar com componentes de infraestrutura e segurança que, de outra forma, os desenvolvedores precisariam assumir.</p> <p>Gerentes de vaults podem se candidatar a oferecer os colaterais em restaking como segurança econômica para a Tanssi Network. Como as redes Tanssi rodam em um ambiente semelhante a um sandbox, e o protocolo Tanssi gerencia todas as responsabilidades relacionadas às redes, os gerentes de vaults só precisam analisar e fazer opt-in para o protocolo Tanssi, independentemente da qualidade e quantidade de redes que estejam rodando pelo protocolo Tanssi em qualquer momento.</p> <p>Operators que fazem opt-in para prestar serviços ao protocolo Tanssi (desde que participem de um vault que suporta o protocolo Tanssi) têm a vantagem de rodar o mesmo setup para fornecer serviços de produção de blocos e validação para a Tanssi Network e, consequentemente, para todas as redes implantadas via Tanssi. Essa arquitetura única facilita todas as tarefas relacionadas a executar e manter os operators, já que não há mudanças no setup quando uma nova rede Tanssi é lançada ou desativada.</p> <p>Note</p> <p>O protocolo Tanssi efetivamente abstrai os detalhes do conjunto ativo de redes para longe dos gerentes de vaults e operators. Particularidades das redes não exigem qualquer configuração adicional dos operators nem representam riscos aos ativos do vault.</p> <p>Tudo isso forma um ecossistema funcional e elegante no qual os desenvolvedores podem se concentrar em criar e inovar. O Tanssi cuida dos componentes de infraestrutura, garantindo disponibilidade e desempenho, e o Symbiotic fornece os mecanismos econômicos que asseguram a validade das operações.</p> <pre><code>flowchart LR\n    subgraph Symbiotic\n        direction LR\n        Operators\n        Vaults\n    end\n    Symbiotic  -- Valida/Protege --&gt; tanssi[\"Tanssi Network\"]\n    tanssi -- Serviços de Produção de Blocos--&gt; Networks\n    tanssi -- Segurança--&gt; Networks\n    tanssi -- Recuperação de Dados--&gt; Networks\n\n    class Symbiotic custom-container</code></pre>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#tanssi-ethereum-communication", "title": "Comunicação Tanssi-Ethereum", "text": "<p>É importante entender como Tanssi e Ethereum trocam dados para compreender a mecânica do protocolo. Eles se conectam por meio de uma ponte bidirecional que permite que se comuniquem entre si. Cada protocolo tem um papel específico para viabilizar operações cross-chain.</p> <p>Existem três componentes-chave entre Symbiotic e Tanssi:</p> <pre><code>flowchart LR\n\nTanssi[\"Tanssi\"] &lt;--&gt; Relayer \nRelayer &lt;--&gt; Gateway \nGateway[\"Gateway\"] &lt;--&gt; Middleware\nMiddleware &lt;--&gt; Symbiotic[\"Symbiotic\"]\n\nclass Tanssi tanssiNode;\n\nclass Middleware middlewareNode;\n\nclass Gateway gatewayNode;\n\nclass Symbiotic symbioticNode;\n\nclass Relayer relayerNode;</code></pre> <ul> <li> <p><code>Relayer</code> - é o software que monitora continuamente ambas as blockchains e transmite mensagens. Ele habilita comunicação bidirecional confiável entre Tanssi e Ethereum, servindo como a camada de conexão que garante que mensagens sejam entregues corretamente entre as redes</p> </li> <li> <p><code>Gateway</code> - opera no lado Ethereum da ponte e cumpre três funções essenciais. Ele recebe, verifica e encaminha mensagens recebidas da Tanssi para garantir que sejam processadas corretamente. O contrato aceita mensagens de saída destinadas à rede Tanssi, preparando-as para o relay. Por fim, lida com funcionalidades de aplicação de nível superior, principalmente transferências de tokens entre as duas redes, fornecendo uma interface segura para movimentação de ativos entre cadeias</p> </li> <li> <p><code>Middleware</code> - é a implementação da Tanssi para lidar com eventos e operações da rede. Ele é o elo crítico entre o <code>Gateway</code> e o protocolo central da Tanssi</p> </li> </ul> <p>O <code>Middleware</code> desempenha um papel central na coordenação da rede entre Tanssi e Symbiotic. Ele distribui recompensas a operators e vaults com base em suas contribuições para segurança e desempenho da rede. O contrato ordena os operators por stake para criar um sistema de ranking meritocrático para sua seleção e transmite a lista de chaves de operators ordenadas à Tanssi para atribuição. Além disso, facilita os processos de registro de operators e gerencia os protocolos de recompensa e slashing que mantêm o alinhamento de incentivos da rede.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#from-ethereum-tanssi", "title": "De Ethereum para Tanssi", "text": "<p>O <code>Middleware</code> transmite informações sobre o conjunto de operators para a Tanssi para atribuição de sessões por meio da ponte. Ele envia detalhes sobre operators ativos para cada época, ordenando-os por seu stake total agregado em todos os vaults. O Tanssi então usa essas informações para atribuir operators para as próximas sessões, garantindo que os mais alinhados economicamente protejam a rede. Esse mecanismo cria um processo de seleção de operators ponderado por stake, em que a segurança econômica no Ethereum se traduz em segurança operacional na Tanssi.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#from-tanssi-ethereum", "title": "De Tanssi para Ethereum", "text": "<p>O Tanssi envia dados operacionais de volta ao Ethereum através do mesmo canal de comunicação. Essa mensagem inclui informações de recompensa que permitem a distribuição adequada aos stakeholders com base no desempenho da rede. A rede também transmite dados de eventos de slashing quando os operators falham em desempenhar corretamente ou violam regras do protocolo, permitindo que o protocolo aplique penalidades. O Tanssi também pode solicitar a criação de novos tokens no Ethereum e registrar tokens, facilitando o gerenciamento de ativos entre as duas redes.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#rewards", "title": "Recompensas", "text": "<p>Operators e restakers bem-comportados são recompensados por sua participação com tokens TANSSI. O processo de recompensa consiste em duas fases principais: Fase de Distribuição de Recompensas e Fase de Reivindicação de Recompensas.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#reward-distribution-phase", "title": "Fase de Distribuição de Recompensas", "text": "<p>A fase de distribuição de recompensas calcula e aloca recompensas por meio de cinco etapas principais que envolvem operators, restakers e contratos inteligentes. As etapas são:</p> <ol> <li>Cálculo de Recompensas - o Tanssi calcula recompensas com base na atividade de operators e stakers e então cria uma raiz de Merkle. Essa raiz de Merkle é uma impressão digital criptográfica que resume as alocações de recompensas, indicando quem recebe o quê. Stakers são recompensados de acordo com seu stake em cada vault</li> <li>Dados de Recompensa Enviados via XCM - os dados de alocação de recompensas são enviados usando XCM (Cross-Consensus Messaging), um protocolo padronizado para comunicação entre blockchains. A Snowbridge atua como uma ponte sem confiança entre Tanssi e Ethereum</li> <li>Recepção da Mensagem no Ethereum - uma vez que a mensagem é encaminhada para o contrato <code>Gateway</code>, esse contrato serve como ponto de entrada autorizado da Tanssi no Ethereum para a ponte Snowbridge</li> <li>Processamento e Validação da Mensagem - o <code>Gateway</code> encaminha os dados para o <code>Middleware</code>, que é responsável por várias tarefas, incluindo passar as informações para o contrato <code>OperatorReward</code></li> <li>Armazenamento e Distribuição de Recompensas - este é o destino final dos dados. O contrato <code>OperatorRewards</code> armazena a árvore de Merkle das alocações de recompensa e lida com a transferência de tokens de recompensa quando um claim é feito</li> </ol> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n    participant Rede Tanssi\n    participant Snowbridge (XCM)\n    participant Gateway\n    participant Middleware\n    participant OperatorRewards\n\n    Rede Tanssi-&gt;&gt;Rede Tanssi: 1. Calcular recompensas e gerar raiz de Merkle\n    Rede Tanssi-&gt;&gt;Snowbridge (XCM): 2. Dados de recompensa enviados via XCM (raiz de Merkle + dados)\n    Snowbridge (XCM)-&gt;&gt;Gateway: 3. Repassar a mensagem e enviar ao Ethereum \n    Gateway -&gt;&gt;Middleware: 4. Processamento e validação da mensagem\n    Middleware-&gt;&gt;OperatorRewards: 5. Armazenamento e distribuição de recompensas</code></pre>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#reward-claiming-phase", "title": "Fase de Reivindicação de Recompensas", "text": "<p>Na fase de reivindicação de recompensas, operators e stakers podem reivindicar recompensas com base em sua participação na rede. O Tanssi determina a divisão para operators e stakers, atualmente fixada em 20% para operators e 80% para stakers.</p> <ol> <li>Reivindicação de Recompensa pelo Operator - operators podem reivindicar sua parcela chamando o contrato <code>OperatorRewards</code> usando um recibo criptográfico que comprova seu direito</li> <li>Liberação de Tokens - a chamada do operator aciona a liberação de tokens, e o <code>OperatorRewards</code> envia o valor estabelecido ao operator</li> <li>Distribuição de Tokens aos Stakers - as recompensas restantes são encaminhadas ao contrato <code>StakerRewards</code> para posterior reivindicação dos stakers</li> <li>Alocação dos Stakers - os 80% restantes das recompensas são direcionados automaticamente ao contrato <code>StakerRewards</code>, onde os stakers podem reivindicar recompensas proporcionais ao seu stake nos vaults</li> </ol> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n participant Operator\n participant OperatorRewards\n participant StakerRewards\n participant Stakers\n\n Operator-&gt;&gt;OperatorRewards: 1. Reivindicação de recompensa pelo operator\n OperatorRewards-&gt;&gt;Operator: 2. Liberar recompensas para o operator\n OperatorRewards-&gt;&gt;StakerRewards: 3. Encaminhar o restante para o StakerRewards\n Stakers-&gt;&gt;StakerRewards: 4. Stakers reivindicam recompensas individuais</code></pre>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#slashing", "title": "Slashing", "text": "<p>O protocolo Tanssi implementa slashing para penalizar operators por mau comportamento. Quando um evento de slashing é acionado, as autoridades designadas como resolvers pelos gerentes de vault podem aceitar ou reverter essa ação.</p> <p>As seguintes ações podem acionar eventos de slashing:</p> <ul> <li>Produção de blocos inválidos (por exemplo, blocos que incluem transações inválidas)</li> <li>Validação inválida (por exemplo, dupla assinatura ou quebra das regras do protocolo)</li> <li>Tempo de inatividade ou indisponibilidade</li> <li>Violações de consenso</li> </ul> <p>Note</p> <p>Eventos de slashing só podem ser acionados por mau comportamento dos operators dentro da Tanssi Network. Mesmo que redes Tanssi sejam defeituosas ou maliciosas, elas operam em um ambiente isolado e não podem causar slashing.</p>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#slashing-process", "title": "Processo de Slashing", "text": "<p>O processo de slashing segue um caminho semelhante ao das recompensas. Quando um operator se comporta mal, a Tanssi Network envia uma mensagem de solicitação de slashing para a ponte sem confiança (Snowbridge). A mensagem passa pelo <code>Gateway</code> e chega ao <code>Middleware</code>, onde o método de slashing é chamado.</p> <p>O método de slashing recebe um identificador exclusivo para a identidade do operator, a severidade do slash como uma porcentagem do stake do operator atribuído em cada vault e o contexto temporal em que a infração ocorreu.</p> <p>O processo de slashing consiste nas seguintes etapas:</p> <ol> <li>Slash Reportado - o Tanssi envia a solicitação de slashing ao <code>Middleware</code> com os parâmetros <code>operatorKey</code>, <code>percentage</code> e <code>epoch</code></li> <li>Validação do Operator - o <code>Middleware</code> valida a identidade do operator e verifica se ele está sujeito ao slashing</li> <li>Recuperar Vaults Ativos - o <code>Middleware</code> percorre todos os vaults ativos durante a época da infração, ignorando qualquer vault inativo</li> <li>Recuperar Stake do Operator - para cada vault ativo, o <code>Middleware</code> recupera o stake do operator infrator</li> <li>Calcular Valor do Slash - o <code>Middleware</code> calcula o valor do slashing aplicando a porcentagem de corte ao stake do operator em cada vault</li> <li> <p>Slashing - dependendo da implementação de slashing do vault, existem duas rotas possíveis</p> <ul> <li> <p>Slashing Instantâneo - se o vault usa slashing instantâneo, o stake é reduzido imediatamente</p> </li> <li> <p>Veto Slashing - se o vault usa veto slashing, o <code>Middleware</code> solicita o slashing a um resolver. Uma janela de veto com tempo limitado é criada (por exemplo, 7 dias)</p> </li> </ul> <p>O slashing é cancelado se o resolver vetar a solicitação dentro da janela de tempo. Caso contrário, a penalidade de slashing é executada se nenhum veto ocorrer dentro da janela.</p> </li> </ol> <p>Esse processo garante que o slashing de cada vault seja tratado de forma independente, evitando contaminação cruzada, e oferece slashing instantâneo e com atraso, com mecanismos de resolução de disputas.</p> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n    participant Network\n    participant Middleware\n    participant Vault\n    participant Slasher\n\n    Network-&gt;&gt;Middleware: 1. Slash reportado\n    Middleware-&gt;&gt;Middleware: 2. Validação do operator\n    loop Cada Vault Ativo\n        Middleware-&gt;&gt;Vault: 3. Recuperar stake do operator\n        Vault--&gt;&gt;Middleware: 4. Recuperar stake do vault\n        Middleware-&gt;&gt;Middleware: 5. Calcular valor do slash\n        alt Slasher Instantâneo\n            Middleware-&gt;&gt;Slasher: 6.1 Slash\n        else Veto Slasher\n            Middleware-&gt;&gt;Slasher: 6.2 Solicitar slash\n            opt Se Não Vetado\n                Slasher-&gt;&gt;Slasher: 6.2 Executar slash\n            end\n        end\n    end</code></pre>"}, {"location": "learn/tanssi/external-security-providers/symbiotic/#burner", "title": "Burner", "text": "<p>O contrato <code>Burner</code> é uma extensão responsável por lidar com ações que seguem um evento de slashing, especialmente a queima do colateral slashed. Uma vez que um slash é executado, o contrato <code>Slasher</code> chama o <code>Burner</code> para realizar essas tarefas pós-slashing.</p> <p>Dentro do protocolo, o contrato <code>Burner</code> desempenha um papel crucial ao decidir o que acontece após o slashing. Embora existam diferentes maneiras de implementar o processo de queima, a abordagem recomendada é queimar os ativos slashed. Quando um slash é executado, a função <code>onSlash</code> do contrato <code>Burner</code> é ativada. Essa função dá início ao processo de queimar os ativos slashed.</p> <p>O gerente do vault escolhe a implementação específica do processo de queima durante a fase de inicialização do vault e, uma vez definida, o gerente do vault não pode modificá-la. O design exato do contrato <code>Burner</code> pode variar dependendo do tipo de ativo colateral envolvido. Abaixo estão algumas opções de implementação em potencial:</p> <ul> <li>Queima de Tokens - se o colateral slashed for um token ERC-20 comum, o <code>Burner</code> destrói esses tokens, removendo-os permanentemente de circulação</li> <li>Desembrulhar e Queimar - se os tokens slashed representarem algo como ativos em stake (por exemplo, tokens de staking líquido) ou tokens de provedor de liquidez (LP) de uma DEX, o <code>Burner</code> pode convertê-los de volta à sua forma original antes de queimá-los</li> <li>Operações entre Cadeias - se os tokens estiverem vinculados a ativos em outra blockchain, o <code>Burner</code> pode desembrulhá-los no Ethereum e acionar o processo de queima na rede original</li> <li>Tratamento Alternativo - às vezes, queimar não é a melhor opção. Em vez disso, o <code>Burner</code> pode redistribuir os ativos slashed para outros operators, compensar usuários afetados ou bloqueá-los em pools de liquidez — conforme o sistema for projetado para fazer</li> </ul> <p>Queimar o colateral slashed é importante porque penaliza operators que se comportam mal e reduz a oferta total de tokens, o que pode ter efeitos deflacionários.</p>"}, {"location": "learn/tanssi/network-features/", "title": "Recursos da Rede", "text": "<p>Os recursos da rede em Tanssi são projetados para fornecer os mecanismos fundamentais que apoiam a descentralização, a segurança e a escalabilidade. De proteger redes por meio de staking a capacidades futuras, esta seção descreve os elementos principais que capacitam a infraestrutura de rede da Tanssi.</p>"}, {"location": "learn/tanssi/network-features/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/tanssi/network-features/staking/", "title": "Staking da Tanssi para Produção de Blocos", "text": ""}, {"location": "learn/tanssi/network-features/staking/#introduction", "title": "Introdução", "text": "<p>Uma das propostas centrais da Tanssi é simplificar a complexidade de infraestrutura das redes. Um componente crucial é iniciar um conjunto descentralizado de Sequencers, que a Tanssi oferece por meio de sua arquitetura e mecânica de staking.</p> <p>A mecânica de staking da Tanssi garante que os Sequencers das redes powered by Tanssi sejam escolhidos de forma descentralizada e trustless, além de incentivar a comunidade a delegar para Sequencers de melhor desempenho ou mais engajados.</p> <p>Este conteúdo apresenta os conceitos fundamentais do staking da Tanssi e como ele mantém um conjunto descentralizado de produção de blocos que garante a disponibilidade das redes.</p> Learn How to Stake -&gt;"}, {"location": "learn/tanssi/network-features/staking/#core-concepts", "title": "Conceitos Básicos", "text": "<p>A mecânica do módulo de staking da Tanssi foi inspirada no conceito de tokens de pool de liquidez (LP tokens) em AMMs tradicionais como Uniswap V2.</p> <p>Cada Sequencer possui quatro pools de liquidez pelos quais os delegadores passam ao realizar diferentes operações de staking. Cada pool representa um estado do processo: ingresso, recompensas manuais, recompensas com auto-compound e saída. Diferente dos LP tokens tradicionais, os tokens de participação nesses pools não são transferíveis.</p> <p>O delegador tem quatro transações simples para percorrer os estados (pools): delegar (para recompensas manuais ou auto-compound), undelegar, trocar e executar operações pendentes. Por exemplo, para entrar em um dos pools de recompensas, o usuário delega e entra no Joining Pool imediatamente. Após um atraso, o próprio usuário (ou qualquer pessoa) pode executar a operação pendente e entrar no pool de recompensas escolhido. Depois, pode trocar entre pools de recompensa quando quiser. Por fim, quem está em um pool de recompensas pode usar undelegate para ir ao Leaving Pool e remover o stake; após o atraso, qualquer pessoa pode executar a operação pendente e concluir a saída.</p> <p>Pools de liquidez possuem shares, análogas a LP tokens em AMMs. Ao entrar em um novo pool, o usuário recebe shares conforme o tipo de pool, a quantidade delegada, o total de shares e o total delegado nesse pool.</p> <p>Recompensas são atribuídas aos pools Manual ou Auto-Compound de um Sequencer quando a Tanssi atesta que o slot de produção de blocos designado foi cumprido com sucesso.</p> <p>Todas as recompensas (de todos os pools) ficam em uma conta do protocolo, mas o protocolo rastreia internamente os tokens nativos de cada pool. A diferença entre pools Manual e Auto-Compound é como as recompensas são distribuídas: no Manual Rewards Pool, o usuário precisa reivindicar; no Auto-Compound Rewards Pool, as recompensas são automaticamente reinvestidas a cada bloco da Tanssi.</p> <p>As operações de delegar e undelegar precisam ser enviadas pelo próprio delegador, sinalizando a intenção e pedindo ao protocolo para realizar as verificações necessárias. Essas ações só podem ser executadas depois de um número de sessões, mas qualquer participante pode realizar a segunda etapa por meio da transação execute pending operation.</p> <p>O diagrama a seguir resume o fluxo de delegar e undelegar para um Sequencer; ações do usuário em ciano e pools em coral.</p> <p></p>"}, {"location": "learn/tanssi/network-features/staking/#staking-parameters", "title": "Parâmetros de Staking", "text": "Tanssi MainNetDancelight TestNet Variável Valor Joining Delay 7200 blocos (12 horas) Leaving Delay 7200 blocos (12 horas) Variável Valor Joining Delay 7200 blocos (12 horas) Leaving Delay 7200 blocos (12 horas)"}, {"location": "learn/tanssi/network-features/staking/#staking-pools", "title": "Pools de Staking", "text": "<p>Esta seção detalha cada pool que representa uma etapa do processo de staking.</p>"}, {"location": "learn/tanssi/network-features/staking/#joining-pool", "title": "Joining Pool", "text": "<p>Ao delegar para iniciar o staking, o usuário escolhe o mecanismo de recompensas: manual ou auto-compound (cada um é um pool). Após a transação, o usuário entra no Joining Pool e recebe shares proporcionais ao valor delegado. Esse pool oferece estabilidade aos Sequencers, impondo um atraso entre delegar e receber recompensas (pelo menos uma sessão).</p> <p>Exemplo prático: Alice inicia o staking mirando o Manual Rewards Pool e entra no Joining Pool no meio de uma sessão; ela deve esperar até o fim da sessão seguinte para executar a operação pendente e começar a receber recompensas.</p> <p>Joining Pools têm proporção 1:1 entre shares e tokens delegados. Se Alice delega 100 tokens, recebe 100 shares do Joining Pool. Quando a operação pendente de delegate é executada, o protocolo consome as shares do Joining Pool em troca dos tokens nativos, que são imediatamente convertidos em shares do Manual ou Auto-Compound Rewards Pool.</p> <p>O diagrama abaixo supõe que o usuário está direcionando stake para o Manual Rewards Pool.</p> <p></p>"}, {"location": "learn/tanssi/network-features/staking/#manual-rewards-pool", "title": "Manual Rewards Pool", "text": "<p>Ao entrar no Manual Rewards Pool, o protocolo destrói as shares do Joining Pool em favor do token nativo. No mesmo bloco, calcula quantas shares do Manual Pool podem ser cunhadas com esse valor, com base no preço da share:</p> <pre><code>SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool \n</code></pre> <p>Shares não têm decimais; qualquer resto de tokens ao adquirir shares é devolvido ao usuário. O preço da share não muda com novas entradas, pois a razão é mantida. Com shares do Manual Rewards Pool, o usuário passa a acumular recompensas (na mesma sessão) que precisam ser reivindicadas manualmente.</p> <p>Ao contrário do Auto-Compound, a distribuição no Manual ocorre por um mecanismo de checkpoint de recompensas. Ele rastreia o histórico de tokens nativos por share atribuído pelo protocolo naquele Manual Rewards Pool em um momento específico. Quando a Tanssi atesta um bloco produzido por um Sequencer, novas recompensas são atribuídas ao Manual Rewards Pool para os usuários reivindicarem, e o contador de recompensas aumenta. Assim, as recompensas são refletidas na razão de tokens por share, diferença entre o contador atual do pool e o checkpoint do usuário.</p> <p>O contador de recompensas por share é essencial para calcular o valor devido ao reivindicar. Após calcular, o protocolo envia os tokens para o usuário e redefine o checkpoint dele para o contador atual do pool, garantindo alinhamento e zero recompensas pendentes.</p> <p>De forma semelhante, ao adicionar ou remover stake, as recompensas são reivindicadas automaticamente e o checkpoint é redefinido, pois a condição de recompensas para aquele montante muda e precisa ser sincronizada com o pool.</p> <p></p>"}, {"location": "learn/tanssi/network-features/staking/#autocompounded-rewards-pool", "title": "Auto-Compound Rewards Pool", "text": "<p>Ao entrar no Auto-Compound Rewards Pool, o protocolo destrói as shares do Joining Pool em favor do token nativo. No mesmo bloco, calcula quantas shares de Auto-Compound podem ser cunhadas com esse valor, com base no preço da share:</p> <pre><code>SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool \n</code></pre> <p>Shares não têm decimais; qualquer resto é devolvido ao usuário. O preço da share não muda na entrada. Com shares do Auto-Compound Rewards Pool, o usuário acumula recompensas na mesma sessão.</p> <p>Ao contrário do Manual, as recompensas em tokens nativos no Auto-Compound são atribuídas automaticamente a cada bloco da Tanssi em que o protocolo atesta o Sequencer designado. Como o número de tokens no pool cresce e o de shares permanece, o preço da share sobe; ao resgatar, o usuário recebe mais tokens por share do que na entrada.</p> <p></p> <p>As recompensas são reinvestidas como novo stake no Auto-Compound Rewards Pool, caracterizando o auto-compound.</p> <p>Contudo, quando recompensas auto-compound são atribuídas, elas não ficam no saldo reservado do usuário; ainda estão na conta do protocolo, e o aumento do stake é representado pelo aumento do preço da share. Em alguns cenários, o usuário pode querer que esse saldo conste no estado como saldo reservado (por exemplo, governança).</p> <p>Por isso, o protocolo oferece uma chamada específica para atualizar o saldo reservado de qualquer delegado, movendo as recompensas auto-compound da conta do protocolo para o saldo reservado do usuário. Isso também é executado automaticamente ao remover liquidez do Auto-Compound Rewards Pool.</p>"}, {"location": "learn/tanssi/network-features/staking/#leaving-pool", "title": "Leaving Pool", "text": "<p>Ao sair de posições no Manual ou Auto-Compound, o usuário pode iniciar uma undelegation. Como na entrada, é um processo em duas etapas: assina a intenção de remover a delegação e aguarda pelo menos uma sessão antes de a operação ser executada por qualquer pessoa.</p> <p>Ao executar a intenção de saída, o protocolo troca shares do pool específico por tokens nativos ao preço atual. Para o Manual Rewards Pool, recompensas não reivindicadas são atribuídas ao usuário. Em seguida, o protocolo compra shares do Leaving Pool em proporção 1:1 aos tokens nativos recebidos, garantindo que o usuário entre no Leaving Pool com shares equivalentes ao valor a ser retirado.</p> <p>Após uma sessão, qualquer usuário pode executar a operação pendente; o protocolo então troca shares do Leaving Pool por tokens nativos em proporção 1:1.</p> <p>O objetivo principal do Leaving Pool é fornecer um buffer para saídas, permitindo implementar mecanismos de slashing para coibir mau comportamento. O slashing não está implementado atualmente, mas pode ser adicionado no futuro.</p> <p>O diagrama a seguir supõe que o usuário está saindo do Manual Rewards Pool.</p> <p></p>"}, {"location": "learn/tanssi/network-features/staking/#swap-rewards-pool", "title": "Trocar entre Pools de Recompensa", "text": "<p>O módulo de staking da Tanssi permite trocar o stake de um pool de recompensas para outro, total ou parcialmente, sem passar novamente pelos pools de entrada e saída.</p> <p>Primeiro, todas as recompensas pendentes do Manual Rewards Pool são reivindicadas em nível de protocolo, pois a liquidez está sendo alterada e o checkpoint precisa ser sincronizado. Em seguida, shares do pool original são consumidas e trocadas por tokens nativos ao preço atual; então, shares do novo pool são adquiridas ao preço do novo pool. Qualquer “poeira” restante é convertida em shares do Leaving Pool. Tudo ocorre no mesmo bloco; não há atraso para começar a receber recompensas no novo pool. A poeira no Leaving Pool pode ser reivindicada após os atrasos necessários.</p> <p></p>"}, {"location": "learn/tanssi/network-services/", "title": "Serviços de Rede", "text": "<p>Os serviços de rede da Tanssi fornecem a infraestrutura essencial para operações de blockchain seguras e eficientes. No cerne desses serviços, o protocolo Tanssi oferece produção de blocos como serviço, garantindo o desempenho contínuo e a escalabilidade de redes descentralizadas.</p>"}, {"location": "learn/tanssi/network-services/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "learn/tanssi/network-services/block-production/", "title": "Serviços de Produção de Blocos", "text": ""}, {"location": "learn/tanssi/network-services/block-production/#introduction", "title": "Introdução", "text": "<p>Como apresentado no artigo Visão Geral, Tanssi é um protocolo de infraestrutura que agiliza a implantação de redes descentralizadas com lógica personalizada que se adequa a uma ampla gama de casos de uso, incluindo DeFi, NFTs, Jogos e qualquer outro caso de uso que as equipes de desenvolvimento possam querer abordar.</p> <p>A infraestrutura representa um enorme desafio para os desenvolvedores, exigindo que eles inicializem Sequencers, preservadores de dados e endpoints RPC, além de gerenciar integrações, interoperabilidade e segurança. Isso exige tempo e recursos valiosos, desviando o foco do que realmente importa: entregar valor aos seus usuários.</p> <p>Tanssi orquestra recursos, permitindo que os desenvolvedores implantem redes descentralizadas (também conhecidas como serviços validados ativamente ou AVSs) que são totalmente adaptáveis a qualquer aplicativo ou caso de uso específico. Nesta analogia, a rede Tanssi se assemelha ao Kubernetes em seu papel como orquestrador, gerenciando recursos para garantir a atividade e o desempenho das redes.</p> <p>O protocolo também aborda a frente de segurança, permitindo que as redes selecionem e se conectem a provedores de segurança externos (como Symbiotic), garantindo segurança de nível Ethereum desde o início.</p> <p>Este artigo aborda os aspectos necessários a serem considerados ao construir e implantar seu próprio blockchain modular, juntamente com os aspectos técnicos mais relevantes do protocolo Tanssi.</p>"}, {"location": "learn/tanssi/network-services/block-production/#block-production-as-a-service", "title": "Produção de Blocos como Serviço", "text": "<p>O protocolo Tanssi fornece produção de blocos como serviço, orquestrando um conjunto descentralizado e confiável de Sequencers, garantindo a atividade das redes. Para fazer isso, o protocolo conecta ambas as extremidades:</p> <ul> <li>Operators de nós: Que executam Sequencers, oferecendo seus serviços de produção de blocos para obter recompensas.</li> <li>Desenvolvedores: Que lançam redes, que exigem Sequencers.</li> </ul> <p>O protocolo atribui um subconjunto de Sequencers para fornecer serviços a cada rede, rotacionando-os após um período de tempo. Os Sequencers podem servir qualquer rede baseada em Tanssi, independentemente da lógica personalizada que implementam. Por outro lado, as redes implantadas por meio da Tanssi podem personalizar seu Runtime tanto quanto precisarem para se adequar ao seu caso de uso e atualizar a lógica a qualquer momento de forma sem bifurcação, sem se preocupar com a configuração do Sequencer.</p> <p>O diagrama a seguir ilustra como o Tanssi atribui dois Sequencers a cada rede ativa, selecionando-os de um conjunto descentralizado de Sequencers.</p> <pre><code>flowchart TB\n    subgraph network1 [Rede 1]\n        s1bis[Sequencer 1]\n        s2bis[Sequencer 2]\n    end\n\n    subgraph network2 [Rede 2]\n        s3bis[Sequencer 3]\n        s4bis[Sequencer 4]\n    end\n\n    Tanssi[Rede Tanssi&lt;br/&gt;Orquestrador]\n\n    subgraph sequencers [Pool de Sequencers]\n        direction LR\n        s1[Sequencer 1]\n        s2[Sequencer 2]\n        s3[Sequencer 3]\n        s4[Sequencer 4]\n        sn[Sequencer N]\n\n        s1 --- s2 --- s3 --- s4 --- sn\n    end\n\n    sequencers -- Gerenciado por --&gt; Tanssi\n    Tanssi -- Atribui Sequencers --&gt; network1\n    Tanssi -- Atribui Sequencers --&gt; network2</code></pre>"}, {"location": "learn/tanssi/network-services/block-production/#sequencer-selection-process", "title": "Processo de Seleção do Sequencer", "text": "<p>A qualquer momento, todas as redes Tanssi exigem um certo número de Sequencers, dependendo do número de redes ativas e da configuração atual de produção de blocos definida na Tanssi. A configuração define o número máximo de Sequencers totais no conjunto e o número de Sequencers que cada rede deve ter atribuído.</p> Tanssi MainNet Variável Valor Máx. nº de Sequencers 100 nº de Sequencers (Redes) 5 Dancelight TestNet Variável Valor Máx. nº de Sequencers 100 nº de Sequencers (Redes) 2 <p>Assim que o número necessário de Sequencers para uma determinada sessão for conhecido, o Tanssi usa dois mecanismos para decidir o conjunto de Sequencers distribuídos entre todas as redes.</p> <p>O primeiro mecanismo é através do módulo Invulneráveis, que define uma lista de Sequencers fixos priorizados pelo protocolo e garante a estabilidade da produção de blocos em certos cenários, como TestNets.</p> <p>O segundo mecanismo é através do módulo de staking da Tanssi. O módulo ajuda a criar um conjunto descentralizado de Sequencers para todas as redes Tanssi, fornecendo ao protocolo uma lista de Sequencers classificados por valor apostado. O Tanssi anexa a lista classificada por aposta de Sequencers aos invulneráveis (se houver), em seguida, pega da lista apenas a quantidade exata de Sequencers necessária, começando do topo, deixando de fora da próxima sessão aqueles Sequencers que têm menos valor apostado, para finalmente iniciar o processo de atribuição do Sequencer.</p>"}, {"location": "learn/tanssi/network-services/block-production/#block_producers-assignment", "title": "Atribuição de Sequencers", "text": "<p>Assim que o conjunto de Sequencers que participará da próxima sessão for conhecido, o Tanssi embaralha a lista e os atribui para fornecer serviços de produção de blocos às redes Tanssi ativas.</p> <p>O algoritmo de atribuição começará a distribuir os Sequencers que atendem às redes pela data de registro em ordem de chegada. Depois que a atribuição for feita, ela será mantida por pelo menos uma sessão, representando um período medido em blocos com um conjunto constante de Sequencers. No Tanssi MainNet, a duração da sessão padrão é definida como 3600 blocos, o que, com um tempo médio de bloco de seis segundos, se traduz em (aproximadamente) six horas.</p> <p>Cada nova atribuição funciona intencionalmente com um atraso de uma sessão, para que os Sequencers saibam com antecedência a qual das redes eles estão atribuídos. Os Sequencers começarão a sincronizar a nova rede que terão que servir na próxima sessão com um mecanismo de sincronização especial chamado warp sync. O warp sync permite que os Sequencers sincronizem rapidamente a nova rede sem atuar como um nó de arquivo.</p> <p>Quando uma nova sessão começa, o protocolo Tanssi colocará a atribuição na fila em vigor. Os Sequencers mudarão automaticamente e começarão a produzir blocos na nova rede Tanssi a que foram atribuídos, descartando o estado da cadeia da atribuição anterior. O Tanssi também calculará a nova atribuição, considerando as alterações nas redes Tanssi que podem ter sido ativadas ou desativadas e os Sequencers que podem ter sido adicionados ou removidos do pool ou alterado o valor total apostado. Esta nova atribuição será enfileirada para a próxima sessão.</p> <p></p>"}, {"location": "learn/tanssi/network-services/block-production/#tanssi-newtwork", "title": "O Papel da Rede Tanssi", "text": "<p>Como discutido anteriormente, o protocolo Tanssi atribui Sequencers às redes Tanssi, e o resultado desta atribuição é armazenado no estado da cadeia. Além de executar o nó da rede, os Sequencers também executam o Tanssi. Portanto, ao acessar os dados armazenados nos blocos finalizados da Rede Tanssi, eles podem aprender sua atribuição para a sessão, e as redes Tanssi podem confirmar que um determinado grupo de Sequencers foi atribuído a elas.</p> <p>À medida que as redes Tanssi produzem blocos, esses blocos precisam ser validados e finalizados por um provedor de segurança externo. Depois que um operator verifica um bloco, uma pequena prova de validade é produzida e armazenada na Tanssi, mantendo o controle das provas para cada bloco de cada cadeia. Esta pequena representação da prova de validade é chamada de recibo de candidato e é composta por um conjunto de valores, incluindo a raiz do estado, que pode ser usada para verificar provas de estado.</p> <p>Finalmente, o Tanssi pode verificar se o autor de um bloco de rede foi o esperado e recompensá-lo de acordo.</p> <p>O diagrama a seguir mostra um Template simplificado dos dados que o Tanssi armazena em seu estado interno. Para cada rede ativa (neste exemplo, duas), o Tanssi armazena os Sequencers atribuídos, que são os únicos autorizados a produzir blocos em nome da rede, prova de validade (recibos de candidatos) estendidos pelos operators do provedor de segurança, a raiz do estado mais recente e o Sequencer mais recente.</p> <p></p>"}, {"location": "learn/tanssi/network-services/block-production/#network", "title": "O Papel da Rede powered by Tanssi", "text": "<p>Como um Sequencer atribuído a uma rede powered by Tanssi inclui funcionalidade de nó Tanssi integrada, é tecnicamente viável ler o estado da Rede Tanssi.</p> <p>Aproveitando essa capacidade de acessar os estados, o Sequencer atual com a autoridade para produzir um bloco lerá o estado do último bloco produzido na cadeia Tanssi. Ele prosseguirá para incluir este estado no bloco da rede, o conjunto atual de Sequencers atribuídos à rede e sua assinatura pública, permitindo que o Tanssi saiba quem produziu o bloco e recompense o operator do nó.</p> <p>Depois que o bloco for preenchido com as transações da rede, ele será proposto como candidato e entregue à cadeia Tanssi, onde os operators do provedor de segurança garantirão que as provas de estado incluídas correspondam às provas de estado do último estado da Tanssi (impedindo a produção não autorizada de blocos) e que as transações produziram transições de estado válidas. Tendo verificado o trabalho do Sequencer, os operators finalizarão o bloco proposto, incluindo seu recibo de candidato em um bloco de rede Tanssi.</p> <p></p>"}, {"location": "learn/tanssi/network-services/block-production/#block-production-fees", "title": "Taxas de Produção de Blocos", "text": "<p>Como apresentado na Introdução, Tanssi é um protocolo de infraestrutura que aborda as complexidades e os altos custos associados à configuração e manutenção da infraestrutura blockchain, agilizando a implantação de redes. Este protocolo traz benefícios para ambos os participantes:</p> <ul> <li>Redes: As equipes podem se concentrar na lógica principal de seu produto, na UX e na UI, sem lidar com os desafios da inicialização da infraestrutura e seu gerenciamento.</li> <li>Sequencers: Assumindo a responsabilidade de manter sua configuração de hardware e software em ótimas condições, eles são incentivados a executar transações e produzir blocos em nome das redes Tanssi.</li> </ul> <p>A produção de blocos como serviço acarreta custos associados que devem ser cobertos pelas redes que desejam alavancar o Tanssi para tal fim. As seções a seguir cobrem os aspectos gerais desses custos e pagamentos de serviços associados.</p>"}, {"location": "learn/tanssi/network-services/block-production/#service-payments", "title": "Pagamentos de Serviços", "text": "<p>Existem três custos principais associados à produção de blocos como serviço que qualquer rede deve cobrir usando tokens Tanssi para implantar com sucesso e obter os serviços de produção de blocos:</p> <ul> <li>Depósito de registro: O depósito inicial que é bloqueado da conta que assina a transação de registro da rede.</li> <li>Depósito de armazenamento de registro: O depósito inicial que é bloqueado da conta que assina a transação de registro da rede. É um valor variável dependendo do tamanho do Runtime da appchain.</li> <li>Atribuição de Sequencers: Toda vez que o protocolo Tanssi atribui Sequencers, o que acontece uma vez por sessão, uma taxa fixa é cobrada. Esta taxa dá às redes o direito de serem atribuídas Sequencers e desencoraja redes cuja lógica de Runtime não consegue produzir transações ou blocos válidos.</li> <li>Produção de blocos: As redes devem pagar por cada bloco produzido em seu nome. Como o protocolo seleciona e atribui os Sequencers por sessão, as redes devem ter fundos suficientes para cobrir todos os blocos a serem produzidos em uma sessão inteira para serem atendidos.</li> </ul> <p>A configuração atual é definida da seguinte forma:</p> Tanssi MainNet Variável Valor Depósito de registro 1000 TANSSI Depósito de armazenamento de registro 6.6666666 x 10<sup>-5</sup> TANSSI por byte de Runtime da appchain Atribuição de Sequencers 50 TANSSI por sessão Produção de blocos 0.03 TANSSI por bloco Dancelight TestNet Variável Valor Depósito de registro 40 STAR Depósito de armazenamento de registro 6.6666666 x 10<sup>-5</sup> STAR por byte de Runtime da appchain Atribuição de Sequencers 100 x 10<sup>-6</sup> STAR por sessão Produção de blocos 1 x 10<sup>-6</sup> STAR por bloco <p>Para garantir a produção de blocos na próxima sessão, o saldo total deve ser pelo menos suficiente para cobrir o custo de atribuição de Sequencers mais o custo de produção dos 3600 blocos que compõem uma sessão inteira.</p> <p>Note</p> <p>Embora os custos de atribuição de Sequencers e produção de blocos sejam atualmente fixos, à medida que o desenvolvimento do protocolo progride, eles podem se tornar dinâmicos, variando em resposta à carga de trabalho da rede.</p>"}, {"location": "learn/tanssi/network-services/block-production/#tipping", "title": "Gorjetas", "text": "<p>Em algumas ocasiões, o Tanssi pode experimentar uma alta demanda por seus serviços de produção de blocos que não pode ser atendida com os recursos disponíveis. Por exemplo, se houver dez redes ativas para a próxima sessão e o Tanssi só puder servir oito, duas redes serão paralisadas durante toda a duração da sessão.</p> <p>Para lidar com esses períodos de alta carga de trabalho, o protocolo Tanssi implementa um mecanismo de gorjeta que permite que as redes compitam por uma prioridade maior em relação ao restante. Semelhante às redes compatíveis com Ethereum, onde uma taxa de prioridade pode ser definida para superar as transações concorrentes e obter tratamento de execução preferencial, as redes Tanssi serão atendidas de acordo com a prioridade dada pelas gorjetas que oferecem. Seguindo o exemplo anterior, se houver dez redes ativas para a próxima sessão e o Tanssi só puder servir oito, apenas as oito redes com maior lance receberão Sequencers atribuídos.</p>"}, {"location": "node-operators/", "title": "Operators de Nós", "text": "<p>A operação de nós é uma parte crucial para manter um ecossistema de blockchain, e o Tanssi garante que esse processo seja o mais perfeito possível. Da execução de nós de rede e gerenciamento de Sequencers à integração de operators, esta seção fornece tudo o que você precisa para começar e operar com eficiência.</p> <p>Se você está configurando pela primeira vez, lidando com tarefas operacionais ou aposentando seu nó, esses guias oferecem instruções claras e concisas para ajudá-lo a manter operações seguras e confiáveis.</p>"}, {"location": "node-operators/#tipos-de-nos-no-ecossistema-tanssi", "title": "Tipos de Nós no Ecossistema Tanssi", "text": "<p>A compreensão dos papéis de diferentes nós na rede Powered by Tanssi ajuda você a escolher o certo com base no seu nível desejado de participação no ecossistema Tanssi:</p> <ul> <li>Nós de Rede - fornecem endpoints RPC e serviços de disponibilidade de dados para fluxo de dados e interação suaves entre cadeias e usuários</li> <li>Sequencers - responsáveis pela produção de blocos dentro do ecossistema Tanssi, os Sequencers coletam transações, as executam e as compilam em blocos, mantendo a vivacidade e a continuidade operacional para todas as redes Powered by Tanssi</li> <li>Operators - também conhecidos como validadores de rede, os operators são responsáveis por proteger o ecossistema. Eles verificam cada bloco produzido por Sequencers dentro das redes Powered by Tanssi, verificando se as transações incluídas são válidas. Os operators devem se registrar e apostar no provedor de segurança (por exemplo, Symbiotic). Eles também produzem blocos para a própria rede Tanssi, mantendo sua vivacidade</li> </ul>"}, {"location": "node-operators/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/network-node/", "title": "Executar um Nó", "text": "<p>A configuração de um nó de rede é essencial para interagir com a Tanssi ou sua rede Powered by Tanssi, fornecendo um endpoint RPC seguro e dedicado. Esta seção oferece guias passo a passo para ajudá-lo a configurar e gerenciar diferentes tipos de nós de forma eficaz.</p> <ul> <li>Nó Tanssi - um nó Tanssi se conecta diretamente à rede Tanssi, permitindo que você interaja via endpoint RPC</li> <li>Nó de Rede Powered by Tanssi - execute um nó para sua rede Powered by Tanssi, permitindo que você mantenha seu próprio endpoint RPC</li> </ul>"}, {"location": "node-operators/network-node/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/network-node/tanssi/", "title": "Executar um Nó Tanssi", "text": "<p>A configuração de um Nó Tanssi é um passo importante para interagir e consultar a rede Tanssi. Você tem duas opções de configuração: usar Docker ou Systemd. Seja qual for o caminho escolhido, oferecemos tutoriais passo a passo para orientá-lo durante o processo.</p>"}, {"location": "node-operators/network-node/tanssi/#requisitos-de-hardware", "title": "Requisitos de Hardware", "text": "<p>O hardware adequado é essencial para executar um nó Tanssi com sucesso. Uma configuração de alto desempenho garante um serviço confiável e resposta rápida às consultas.</p> <p>Hardware recomendado:</p> <ul> <li>Configuração Recomendada - hardware bare metal executando Linux Debian ou Ubuntu</li> <li>CPUs Recomendados - Intel Ice Lake ou mais recente (Xeon ou série Core), AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito núcleos físicos @ 3,4 GHz com hyperthreading desabilitado (SMT para processadores AMD)</li> <li>NVMe Recomendado - SSD NVMe de 500 GB</li> <li>RAM Recomendada - 32 GB de RAM ECC</li> <li>Rede Recomendada - conexão de 1 Gbps</li> </ul> <p>Warning</p> <p>Manter o desempenho do seu Nó Tanssi, mantê-lo atualizado e garantir sua segurança são cruciais para uma operação confiável.</p>"}, {"location": "node-operators/network-node/tanssi/#portas-de-rede-necessarias", "title": "Portas de Rede Necessárias", "text": "<p>Para garantir a comunicação adequada com a rede Tanssi, certifique-se de que a seguinte porta esteja aberta para conexões de entrada:</p> Rede Porta Tanssi Chain 30333 (TCP)"}, {"location": "node-operators/network-node/tanssi/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/", "title": "Executar um Nó Tanssi Usando Docker", "text": ""}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#introduction", "title": "Introdução", "text": "<p>Neste guia, você aprenderá como iniciar um nó Tanssi usando a imagem oficial com Docker em sistemas Linux. Os nós são cruciais para o ecossistema Tanssi, pois fornecem endpoints de API estáveis aos quais aplicativos e usuários podem se conectar para obter dados da cadeia e enviar transações.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": ""}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#installing-docker", "title": "Instalando o Docker", "text": "<p>Para começar, você precisará de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instalação:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execução bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#pull-docker-image", "title": "Puxar a Imagem Docker", "text": "<p>Para cada versão, uma imagem Docker é construída e publicada. Ela contém todas as dependências que um nó Tanssi exige e o próprio binário.</p> <p>A imagem combina o binário da versão estável mais recente do nó cliente com o arquivo de especificações do orquestrador Tanssi.</p> <p>Execute o comando abaixo para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>O comando fará download/extrair a imagem e exibirá o status após a execução:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#set-up-data-directory", "title": "Configure o diretório de dados", "text": "<p>Executar um nó requer sincronizar com a cadeia Tanssi e armazenar seu estado.</p> <p>Crie o diretório onde o nó armazenará os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando a seguir se quiser rodar o nó com o usuário atualmente logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diretório é um parâmetro no comando de inicialização do Docker. Se decidir criá-lo em outro lugar, ajuste o comando.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#generate-node-key", "title": "Gerar a Chave do Nó", "text": "<p>Para gerar e armazenar em disco as chaves de sessão referenciadas no comando de inicialização, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#start-your-node", "title": "Inicie Seu Nó", "text": "<p>Para iniciar seu nó, execute a imagem Docker com <code>docker run</code>.</p> <p>Substitua <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome legível e defina <code>INSERT_YOUR_IP_ADDRESS</code> com seu IP público.</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#run-flags", "title": "Executar Flags", "text": "<p>As flags do <code>docker run</code> podem ser ajustadas conforme suas preferências e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mantém todos os dados de estado (necessário para consultas históricas)</li> <li>--blocks-pruning=archive - mantém todos os blocos (necessário para dados históricos de blocos)</li> <li>--database=paritydb - usa ParityDB como backend otimizado para desempenho de nó RPC</li> <li>--unsafe-rpc-external - permite conexões externas ao RPC; exige medidas adicionais de segurança em produção (proxy reverso, autenticação, firewall)</li> </ul> <p>Warning</p> <p>A flag <code>--unsafe-rpc-external</code> expõe seu nó RPC externamente. Em produção, proteja com firewall, proxy reverso, autenticação e limitação de taxa.</p> <p>Você pode visualizar todas as flags disponíveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#syncing-your-node", "title": "Sincronizando Seu Nó", "text": "<p>Na primeira execução, o processo de sincronização exibirá muitos logs do nó e da cadeia. Alguns erros iniciais são esperados e desaparecem quando a cadeia alcança o último bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] 💤 Idle (0 peers), best: #0 (0x4a2b…7de3), finalized #0 (0x4a2b…7de3), ⬇ 0 ⬆ 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] ✨ Imported #14139635 (0x8c41…8df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] 💤 Idle (8 peers), best: #14139635 (0x8c41…8df6), finalized #14139632 (0xa9a8…cab9), ⬇ 32.7kiB/s ⬆    <p>Quando o processo de sincronização terminar, seu nó estará pronto para atender solicitações de API.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-docker/#testing-your-rpc-node", "title": "Testando Seu Nó", "text": "<p>Depois de sincronizado, teste o endpoint RPC com uma solicitação simples, por exemplo:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>Se estiver funcionando, você receberá uma resposta JSON com o cabeçalho do bloco mais recente.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/", "title": "Executar um Nó Tanssi Usando Systemd", "text": ""}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#introduction", "title": "Introdução", "text": "<p>Neste guia, você aprenderá a iniciar um Nó Tanssi usando o binário estável mais recente e gerenciar o serviço com Systemd em sistemas Linux. Os nós fornecem endpoints de API essenciais para que aplicações e usuários interajam com a rede Tanssi.</p> <p>O artigo segue a boa prática de executar o serviço com uma conta não-root e conceder a essa conta acesso de gravação a um diretório específico. Você pode adaptar as etapas à sua configuração, preferências e políticas de segurança.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para começar, você precisará de acesso a um computador executando Ubuntu Linux com Landlock habilitado e privilégios de root. Você também precisará de:</p> <ul> <li>Arquivos binários do Nó - um nó requer três binários: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code> ``</li> </ul> <p>As instruções executam a versão estável mais recente. Você pode compilar seu próprio arquivo a partir do código-fonte.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#check-landlock", "title": "Verificar Suporte Landlock", "text": "<p>Os nós Tanssi usam o recurso Landlock do kernel Linux como medida de segurança para restringir acesso a recursos do sistema, limitando danos caso o aplicativo seja comprometido.</p> <p>Verifique o suporte Landlock executando:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>Saída esperada:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>Se o Landlock estiver desabilitado, atualize o kernel para a versão 5.13 ou superior.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#download-latest-release", "title": "Baixar a Versão Mais Recente", "text": "<p>Baixe o binário mais recente e torne-o executável:</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#set-up-systemd-service", "title": "Configure o serviço Systemd", "text": "<p>O Systemd é um sistema de gerenciamento para Linux que controla serviços (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.</p> <p>Os comandos a seguir criam uma nova conta, o diretório e movem os arquivos previamente baixados para o local correto.</p> <ol> <li> <p>Crie uma nova conta para executar o serviço:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Crie um diretório para armazenar os arquivos e dados necessários:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Defina a propriedade da pasta para a conta que executará o serviço, garantindo permissão de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Mova os binários para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dancelight-data\n</code></pre> </li> </ol>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#generate-node-key", "title": "Gerar a chave do nó", "text": "<p>Para gerar e armazenar em disco as chaves de sessão que serão referenciadas no comando de inicialização, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#create-systemd-configuration", "title": "Criar o arquivo de configuração do Systemd", "text": "<p>O próximo passo é criar o arquivo de configuração do Systemd.</p> <p>Crie o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configuração do serviço, substituindo a tag <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome legível e <code>INSERT_YOUR_IP_ADDRESS</code> pelo seu endereço IP público. Esse nome ajuda a relacionar entradas de log e métricas ao nó que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Serviço systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Serviço systemd Dancelight\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=dancelight_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/dancelight-data/tanssi-relay --chain=dancelight \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#run-flags", "title": "Flags de Execução", "text": "<p>As flags usadas no <code>ExecStart</code> podem ser ajustadas conforme suas preferências e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mantém todos os dados de estado (necessário para consultas históricas)</li> <li>--blocks-pruning=archive - mantém todos os blocos (necessário para dados históricos de blocos)</li> <li>--database=paritydb - usa ParityDB como back-end otimizado para desempenho de nó RPC</li> <li>--unsafe-rpc-external - permite conexões externas ao RPC; requer medidas adicionais de segurança em produção (proxy reverso, autenticação, firewall)</li> </ul> <p>Warning</p> <p>A flag <code>--unsafe-rpc-external</code> expõe o RPC externamente. Em produção, proteja com firewall, proxy reverso, autenticação e limitação de taxa.</p> <p>Você pode visualizar todas as flags disponíveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#run-the-service", "title": "Execute o serviço", "text": "<p>Por fim, habilite o serviço e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Você pode verificar se o serviço está ativo e rodando corretamente executando:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  ● network.service - \"Network systemd service\"        Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)        Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago       Main PID: 4045278 (container-chain)         Tasks: 44 (limit: 9462)        Memory: 6.5G        CGroup: /system.slice/network.service                └─4045278 4045278 /var/lib/network-data/container-chain- ...    <p>Verifique os logs, se necessário, com o comando a seguir:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"}, {"location": "node-operators/network-node/tanssi/tanssi-node-systemd/#testing-your-rpc-node", "title": "Testando Seu Nó", "text": "<p>Depois que seu nó estiver totalmente sincronizado, você pode verificar se o endpoint RPC está funcionando corretamente fazendo uma solicitação simples. Use curl para testar:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>Se o endpoint RPC estiver funcionando, você receberá uma resposta JSON contendo as informações do cabeçalho do bloco mais recente.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/", "title": "Executar um Nó em uma Rede Tanssi-Powered", "text": "<p>A configuração de um nó de rede é essencial para interagir com sua rede Tanssi-powered e fornecer um endpoint RPC seguro e dedicado. Esta seção oferece guias passo a passo para ajudá-lo a configurar e gerenciar seu nó de forma eficaz. Explore duas abordagens diferentes para executar seu nó:</p> <ul> <li>Usando Docker - instruções para configurar seu nó em um ambiente conteinerizado para fácil implantação e isolamento</li> <li>Usando Systemd - orientação para configurar seu nó como um serviço, permitindo o gerenciamento automatizado e a integração do sistema</li> </ul>"}, {"location": "node-operators/network-node/tanssi-powered-network/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/", "title": "Executar um Nó Appchain usando Docker", "text": ""}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#introduction", "title": "Introdução", "text": "<p>Executar um nó de appchain com Tanssi permite conectar e interagir com a appchain usando sua própria infraestrutura via HTTP ou WebSocket.</p> <p>Os nós armazenam dados de blocos e estado da rede. Há diferentes tipos que os desenvolvedores podem operar:</p> <ul> <li>Nó Arquivo Completo - armazena todos os dados de blocos e estados da rede em todas as alturas. Útil para consultar dados históricos, mas consome muito espaço</li> <li>Nó Podado Completo - armazena dados de blocos e estado até um certo número de blocos antes da altura atual. Útil para consultar dados recentes ou enviar transações pela sua infraestrutura. Requer bem menos espaço que um nó arquival, mas não mantém todo o estado da rede</li> </ul> <p>Neste guia, você aprenderá como iniciar rapidamente um nó appchain Tanssi usando Docker em um computador Linux. Ele pode ser adaptado para outros sistemas operacionais.</p> <p>Note</p> <p>Não é possível executar um nó RPC para appchains de teste rápidas, pois elas rodam em uma rede privada e, portanto, não estão acessíveis para sincronização.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#checking-prerequisites", "title": "Verificação de Pré-requisitos", "text": ""}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#installing-docker", "title": "Instalando o Docker", "text": "<p>Para começar, você precisará de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instalação:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execução bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#getting-specifications-files", "title": "Obtendo os arquivos de especificação", "text": "<p>Um nó de appchain precisa de informações sobre duas blockchains para funcionar corretamente: a própria appchain e a cadeia de orquestração do Tanssi.</p> <p>Essas informações ficam em um arquivo de especificações de cadeia, que inclui, entre outras coisas, o estado gênesis, permitindo que o nó verifique e sincronize corretamente os blocos e estados recebidos de outros nós.</p> <p>Para obter o arquivo de especificação do Tanssi, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>Para obter o arquivo de especificação da appchain, baixe-o no dashboard do dApp clicando no link Network Data.</p> <p></p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#setup-data-directory", "title": "Configurar o diretório de dados", "text": "<p>Executar um sequenciador ou um nó de appchain exige sincronizar duas cadeias: a cadeia de orquestração do Tanssi e a appchain para a qual ele trabalha.</p> <p>Crie o diretório onde o nó armazenará os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando abaixo se quiser rodar o sequenciador com o usuário logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diretório é um parâmetro no comando de inicialização do Docker. Se optar por criar o diretório em outro lugar, ajuste o comando.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-docker-image", "title": "Extraindo a Imagem Docker", "text": "<p>Duas imagens Docker são criadas e publicadas para cada versão: uma para appchains compatíveis com EVM e outra para appchains Substrate.</p> <p>Essas imagens incluem todos os binários necessários para executar a versão estável mais recente do nó cliente.</p> <p>Puxe a imagem correspondente ao tipo de appchain que você deseja executar.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-evm-docker-image", "title": "Appchains Compatíveis com EVM", "text": "<p>Se a appchain foi registrada escolhendo o Template EVM ou enviando uma especificação personalizada compatível com EVM, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <p>O comando fará download e extração da imagem e exibirá o status após a execução:</p> docker pull moondancelabs/container-chain-evm-template  Using default tag: latest      latest: Pulling from moondancelabs/container-chain-evm-template      31ad3619f756: Already exists       8f3d9759dcde: Pull complete       de5eaba9b289: Pull complete       Digest: sha256:4930d631a8ac7f7852754d4cf77bb3317229d768f44092a00295ba50641b2a33      Status: Downloaded newer image for moondancelabs/container-chain-evm-template      docker.io/moondancelabs/container-chain-evm-template:latest"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-substrate-docker-image", "title": "Appchains Substrate Simples", "text": "<p>Se a appchain foi registrada escolhendo o Template Substrate básico ou enviando uma especificação personalizada Substrate, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <p>O comando fará download e extração da imagem e exibirá o status após a execução, semelhante ao exemplo anterior.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#start-up-command", "title": "Comando de Inicialização", "text": "<p>Para iniciar seu nó, execute a imagem Docker com <code>docker run</code>. Altere conforme necessário:</p> <ul> <li><code>Arquivo de especificações da appchain</code> - substitua <code>INSERT_YOUR_APPCHAIN_SPECS_FILE</code> pelo nome do arquivo de specs baixado na etapa de obtenção das especificações.</li> <li><code>Bootnode</code> - é um nó arquivo completo usado para sincronizar a rede do zero. Você precisará recuperar o bootnode da sua rede Tanssi e substituir <code>INSERT_YOUR_NETWORK_BOOTNODES</code> pela informação real de bootnode.</li> </ul> Tanssi MainNetDancelight TestNet Appchain compatível com EVMAppchain Substrate Simples <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> Appchain compatível com EVMAppchain Substrate Simples <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <p>Note</p> <p>Por padrão, apenas o estado histórico dos últimos 256 blocos finalizados é mantido. Para executar um nó de arquivo completo, defina a flag <code>--state-pruning archive</code>. Mais informações na seção de sinalizadores.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#fetching-bootnode-information", "title": "Obtendo informações de bootnode", "text": "<p>As informações de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, você pode usar o portal do desenvolvedor para obter os bootnodes de uma rede específica no Dancelight.</p> <p>Para isso, siga estas etapas:</p> <ol> <li>Selecione dataPreservers como o módulo a consultar</li> <li>Defina a consulta de armazenamento como bootNodes</li> <li>Informe o ID da sua rede Tanssi</li> <li>Clique no sinal de +</li> </ol> <p></p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#example-demo-evm-appchain", "title": "Exemplo de Nó Completo para Demo EVM Appchain", "text": "<p>O exemplo abaixo inicia um nó RPC de arquivo completo para a rede demo EVM implantada no Dancelight (ID <code>2001</code>). Assume que os arquivos de specs estão na pasta de dados.</p> Demo EVM Appchain (Dancelight) <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=/data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=demoAppchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#run-flags", "title": "Executar Sinalizadores", "text": "<p>As flags usadas no <code>docker run</code> podem ser ajustadas conforme suas preferências e hardware. Algumas das principais:</p> <ul> <li><code>--name INSERT_NAME</code> - nome legível para este nó</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o nó ouve</li> <li><code>--unsafe-rpc-external</code> - expõe o serviço RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (nó atua como completo mantendo todo o estado), <code>archive-canonical</code> (mantém apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados serão mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (nó completo mantendo todos os blocos), <code>archive-canonical</code> (mantém apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita saída detalhada de logs</li> </ul> <p>Warning</p> <p>O parâmetro <code>--unsafe-rpc-external</code> permite acesso externo à interface RPC do seu nó, tornando-a acessível de qualquer endereço IP. Certifique-se de que controles de segurança adequados estejam configurados.</p> <p>Para ver a lista completa de flags disponíveis, descrição e valores possíveis, execute:</p> Appchain compatível com EVMAppchain Substrate Simples <pre><code>docker run -ti moondancelabs/container-chain-evm-template --help\n</code></pre> <pre><code>docker run -ti moondancelabs/container-chain-simple-template --help\n</code></pre>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-docker/#syncing-your-node", "title": "Sincronizando Seu Nó", "text": "<p>Após iniciar, o processo de sincronização exibirá muitos logs do nó e da appchain Tanssi. Alguns erros iniciais são esperados e desaparecem quando a cadeia alcança o último bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] 💤 Idle (0 peers), best: #0 (0x4a2b…7de3), finalized #0 (0x4a2b…7de3), ⬇ 0 ⬆ 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] ✨ Imported #14139635 (0x8c41…8df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] 💤 Idle (8 peers), best: #14139635 (0x8c41…8df6), finalized #14139632 (0xa9a8…cab9), ⬇ 32.7kiB/s ⬆    <p>Note</p> <p>A duração da sincronização é proporcional ao tamanho da cadeia que está sendo sincronizada.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/", "title": "Execute um Nó Appchain Usando Systemd", "text": ""}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#introduction", "title": "Introdução", "text": "<p>Executar um nó de appchain com Tanssi permite conectar e interagir com a appchain usando sua própria infraestrutura via HTTP ou WebSocket.</p> <p>Os nós armazenam dados de blocos e estado da rede. Há diferentes tipos que os desenvolvedores podem operar:</p> <ul> <li>Nó Arquivo Completo - armazena todos os dados de blocos e estados da rede em todas as alturas. Útil para consultar dados históricos, mas consome muito espaço</li> <li>Nó Podado Completo - armazena dados de blocos e estado até um certo número de blocos antes da altura atual. Útil para consultar dados recentes ou enviar transações pela sua infraestrutura. Requer bem menos espaço que um nó arquival, mas não mantém todo o estado da rede</li> </ul> <p>Neste guia, você aprenderá a iniciar um nó appchain da Tanssi usando um binário executável e gerenciar o serviço com Systemd em sistemas Linux.</p> <p>O artigo segue a boa prática de executar o serviço com uma conta não-root e conceder a essa conta acesso de gravação a um diretório específico. Você pode adaptar as etapas à sua configuração, preferências e políticas de segurança.</p> <p>Note</p> <p>Não é possível executar um nó RPC para appchains de teste rápido, pois eles rodam em uma rede privada e, portanto, não estão acessíveis para sincronização.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para começar, você precisará de acesso a um computador executando Ubuntu Linux com privilégios de root. Você também precisará de:</p> <ul> <li>Arquivo binário do nó - as instruções executam a versão estável mais recente. Se quiser compilar e rodar o seu próprio arquivo, siga as instruções para construir seu nó appchain.</li> <li>Arquivos de especificações de cadeia - o nó precisa de informações sobre duas blockchains diferentes para sincronizar e executar corretamente. A seção a seguir mostra como obtê-los.</li> </ul>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#getting-specifications-files", "title": "Obtendo os arquivos de especificação", "text": "<p>Um nó de appchain precisa de informações sobre duas blockchains para funcionar corretamente: a própria appchain e a cadeia de orquestração do Tanssi.</p> <p>Essas informações ficam em um arquivo de especificações de cadeia, que inclui, entre outras coisas, o estado gênesis, permitindo que o nó verifique e sincronize corretamente os blocos e estados recebidos de outros nós.</p> <p>Para obter o arquivo de especificação do Tanssi, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>Para obter o arquivo de especificação da appchain, baixe-o no dashboard do dApp clicando no link Network Data.</p> <p></p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#download-latest-release", "title": "Baixe a Versão mais Recente", "text": "<p>Cada nova versão inclui dois binários, um para redes compatíveis com EVM e outro para redes Substrate. Para começar, execute o comando que corresponde ao seu tipo de rede e torne-o executável:</p> Rede Compatível com EVMRede Substrate <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-frontier-node &amp;&amp; \\\nchmod +x ./container-chain-frontier-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-simple-node &amp;&amp; \\\nchmod +x ./container-chain-simple-node\n</code></pre> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#setup-systemd-service", "title": "Configurar o serviço Systemd", "text": "<p>O Systemd é um sistema de gerenciamento para Linux que controla serviços (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.</p> <p>Os comandos a seguir configuram uma nova conta, o diretório e movem os arquivos baixados para o local correto.</p> <p>Crie uma nova conta para executar o serviço:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Crie um diretório para armazenar os arquivos e dados necessários:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Defina a propriedade da pasta para a conta que executará o serviço, garantindo permissão de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Mova o arquivo de especificação da cadeia para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Mova também o binário do nó:</p> Tanssi MainNetDancelight TestNet Appchain compatível com EVMRede Substrate <pre><code>mv ./container-chain-frontier-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/tanssi-data\n</code></pre> Appchain compatível com EVMRede Substrate <pre><code>mv ./container-chain-frontier-node /var/lib/dancelight-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/dancelight-data\n</code></pre> <p>Por fim, mova o arquivo de especificações do seu appchain para a mesma pasta.</p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#create-systemd-configuration", "title": "Crie o Arquivo de Configuração do Serviço Systemd", "text": "<p>A próxima etapa é criar o arquivo de configuração do Systemd.</p> <p>Você pode criar o arquivo executando:</p> <pre><code>sudo touch /etc/systemd/system/appchain.service\n</code></pre> <p>Em seguida, abra o arquivo no seu editor favorito e adicione a configuração do serviço.</p> <p>Note que o comando <code>ExecStart</code> tem parâmetros que precisam ser ajustados para sua rede:</p> <ul> <li> <p><code>Arquivo de especificação</code> - substitua <code>INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME</code> pelo nome do arquivo do seu appchain. Para um appchain MainNet, o caminho será parecido com <code>/var/lib/tanssi-data/SEU_ARQUIVO.json</code>.</p> </li> <li> <p><code>Bootnode</code> - é um nó arquivo completo usado para sincronizar a rede do zero. Você precisará recuperar o bootnode da sua rede Tanssi e substituir <code>INSERT_YOUR_NETWORK_BOOTNODES</code> pela informação real de bootnode.</p> </li> </ul> Tanssi MainNetDancelight TestNet Appchain compatível com EVMRede Substrate <pre><code>[Unit]\nDescription=\"Serviço systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-frontier-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Serviço systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-simple-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> Rede Compatível com EVMRede Substrate <pre><code>[Unit]\nDescription=\"Serviço systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Serviço systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-simple-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#fetching-bootnode-information", "title": "Obtendo informações de bootnode", "text": "<p>As informações de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, você pode usar o portal do desenvolvedor para obter os bootnodes de uma rede específica no Dancelight.</p> <p>Para isso, siga estas etapas:</p> <ol> <li>Selecione dataPreservers como o módulo a consultar</li> <li>Defina a consulta de armazenamento como bootNodes</li> <li>Informe o ID da sua rede Tanssi</li> <li>Clique no sinal de +</li> </ol> <p></p>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#example-demo-evm-network", "title": "Exemplo de Configuração Completa para a Rede EVM de Demonstração", "text": "<p>O exemplo a seguir implanta um nó de arquivo completo e funcional para a rede EVM de demonstração implantada no Dancelight com ID <code>2001</code>.</p> <p>O arquivo de especificação de cadeia bruta é necessário para executar o nó e pode ser baixado deste repositório público no GitHub. Baixe o arquivo e coloque-o em <code>/var/lib/dancelight-data/</code>.</p> Demo EVM Appchain (Dancelight) <pre><code>[Unit]\nDescription=\"Serviço systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=para \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--base-path=/var/lib/dancelight-data \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-flags", "title": "Flags de Execução", "text": "<p>As flags usadas no comando <code>ExecStart</code> podem ser ajustadas conforme suas preferências e configuração de hardware. Algumas das mais importantes:</p> <ul> <li><code>--name INSERT_NAME</code> - nome legível para este nó</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o nó ouve</li> <li><code>--unsafe-rpc-external</code> - expõe o serviço RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (nó atua como completo mantendo todo o estado), <code>archive-canonical</code> (mantém apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados serão mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (nó completo mantendo todos os blocos), <code>archive-canonical</code> (mantém apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita saída detalhada de logs</li> </ul> <p>Warning</p> <p>O parâmetro <code>--unsafe-rpc-external</code> permite acesso externo à interface RPC do seu nó, tornando-a acessível de qualquer endereço IP. Certifique-se de que controles de segurança adequados estejam configurados.</p> <p>Para ver a lista completa de flags disponíveis, descrição e valores possíveis, execute:</p> Rede compatível com EVMRede Substrate Simples <pre><code>/var/lib/dancelight-data/container-chain-frontier-node --help\n</code></pre> <pre><code>/var/lib/dancelight-data/container-chain-simple-node --help\n</code></pre>"}, {"location": "node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-the-service", "title": "Execute o Serviço", "text": "<p>Finalmente, habilite o serviço e inicie-o pela primeira vez:</p> <pre><code>systemctl enable appchain.service &amp;&amp; \\\nsystemctl start appchain.service\n</code></pre> <p>Verifique se o serviço está funcionando corretamente executando:</p> <pre><code>systemctl status appchain.service\n</code></pre> systemctl status network.service  ● network.service - \"Network systemd service\"        Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)        Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago       Main PID: 4045278 (container-chain)         Tasks: 44 (limit: 9462)        Memory: 6.5G        CGroup: /system.slice/network.service                └─4045278 4045278 /var/lib/network-data/container-chain- ...    <p>E verifique os logs, se necessário:</p> <pre><code>journalctl -f -u appchain.service\n</code></pre> journalctl -f -u network.service  Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 Parachain Collator Template      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ✌️  version 0.1.0-3b1fbbfdfe7      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ❤️  by Moondance Labs,      2020-2024      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 📋 Chain specification: Frontier Container 2001      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 🏷  Node name: para      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 👤 Role: FULL      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 💾 Database: RocksDb at /var/lib/network-data/chains/frontier_container_2001/db/full      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain id: Id(2001)      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain Account: 5Ec4AhPQLGvfWywVhJZwufTDvknLT3BVPQcbV977JmBDUsHP      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V0: 0x000000000000000000000000000000000000000000000000000000000000000000e1324cc53e66      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V1: 0x000000000000000000000000000000000000000000000000000000000000000000327cfde8482b"}, {"location": "node-operators/operators/", "title": "Operators Tanssi", "text": "<p>Os operators (também conhecidos como validadores) são responsáveis por manter a segurança em todas as redes powered by Tanssi, verificando a integridade e a validade de suas transações. Eles participam de um mecanismo de consenso DPoS (Delegated Proof-of-Stake), que melhora a descentralização e promove um bom comportamento por meio de incentivos econômicos.</p> <p>Esta seção fornece tudo o que você precisa para começar, desde a configuração inicial até as melhores práticas operacionais e o gerenciamento de contas.</p>"}, {"location": "node-operators/operators/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/offboarding/", "title": "Desativando um Operator da Tanssi", "text": "<p>Deixar de ser um operator requer seguir os procedimentos adequados para garantir uma transição tranquila. Esta seção fornece instruções claras sobre como desativar seu operator da rede Tanssi.</p> <p>Pré-requisitos</p> <p>Antes de iniciar o offboarding do seu nó Tanssi, verifique os pré-requisitos.</p> <p>Opt-out da Tanssi (Obrigatório)</p> <p>Faça opt-out da rede Tanssi na Ethereum.</p> <p>Opt-out do Vault (Opcional)</p> <p>Esta etapa é opcional e só é necessária se você quiser remover totalmente sua associação com o cofre. Ignorá-la não afeta sua capacidade de voltar à rede no futuro.</p> <p>Retornando como Operator</p> <p>Se você decidir retornar como um validador Tanssi no futuro, poderá facilmente se cadastrar novamente seguindo as etapas descritas no guia Onboarding.</p>"}, {"location": "node-operators/operators/offboarding/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/", "title": "Cancelar a Participação na Tanssi", "text": ""}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#introduction", "title": "Introdução", "text": "<p>A capacidade de gerenciar a participação dos node operators no ecossistema Tanssi é crucial. Este guia aborda a etapa inicial do processo de desligamento: cancelar a participação na rede Tanssi. Essa ação sinaliza sua intenção de retirada e permite que o protocolo Tanssi verifique sua identidade como o operator legítimo.</p> <p>Durante o processo de onboarding, uma etapa foi fazer opt-in na rede Tanssi para se tornar um operator. Este guia o conduz pelo processo de opt-out. Há várias maneiras de interagir com os contratos inteligentes envolvidos. Consulte o artigo de pré-requisitos para avaliar qual alternativa se adapta melhor a você.</p> <p>Validação de identidade</p> <p>Ao cancelar a participação, você assina a transação usando a chave privada ou o dispositivo Ledger associado à sua conta de operator. Essa assinatura serve como prova criptográfica de que você é o proprietário legítimo da conta do operator, garantindo que apenas operators autorizados possam iniciar o processo de desligamento.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#methods-for-opting-out", "title": "Métodos para Cancelar a Participação de uma Rede Tanssi", "text": "<p>Para cancelar a participação na rede Tanssi, você deve interagir com um contrato inteligente. A seguir estão os diferentes métodos disponíveis para realizar essa ação. Escolha o que melhor se adapta à sua configuração e preferências de segurança.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-cli", "title": "Usando a CLI Symbiotic", "text": "<p>A CLI Symbiotic oferece uma maneira simples de cancelar a participação na rede. Escolha o comando apropriado com base na sua rede e no método de assinatura.</p> <p>Usando um dispositivo Ledger:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Para assinar com uma chave privada:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Observe que este método exige expor sua chave privada; portanto, não é recomendado.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-etherscan", "title": "Usando Etherscan", "text": "<p>Você pode interagir diretamente com o contrato inteligente pelo Etherscan usando uma carteira de navegador como a MetaMask.</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Endereço do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Certifique-se de selecionar Contract e Write Contract, depois clique em Connect to Web3 e selecione sua carteira preferida (por exemplo, MetaMask): </p> <ol> <li>Expanda a função optOut</li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Se você estiver cancelando a participação na Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para a TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Write e assine a transação</li> </ol> <p></p> <p>Warning</p> <p>Após enviar sua transação de cancelamento, salve o hash da transação. Você precisará desse hash posteriormente para verificação no formulário de desligamento de operator.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-safe", "title": "Usando Safe para Configurações Multisig", "text": "<p>Para contas Safe, use o Transaction Builder com estes endereços:</p> MainNetTestNet (Sepolia) <p>0x7133415b33B438843D581013f98A08704316633c</p> <p>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Em seguida, escolha a função optOut, insira o <code>TANSSI_NETWORK_ADDRESS</code> no qual seu nó está registrado (<code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code> para Tanssi MainNet e <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> para TestNet) e assine a transação.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-status", "title": "Verificando Seu Status de Cancelamento", "text": "<p>Depois de enviar a transação de cancelamento, é importante confirmar se a ação foi bem-sucedida e se seu operator não está mais participando da rede. Você pode verificar esse status usando os métodos a seguir.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-etherscan", "title": "Usando Etherscan para Verificar", "text": "<p>Você pode verificar seu status de cancelamento no Etherscan consultando o contrato inteligente:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Endereço do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Na página do contrato:</p> <ol> <li>Selecione a guia Read Contract</li> <li>Localize e expanda a função isOptedIn</li> <li>Cole o endereço da conta do seu operator no campo who</li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Para Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Query</li> </ol> <p></p> <p>Você obterá um resultado <code>false</code> se o operator tiver cancelado a participação com sucesso e <code>true</code> se ainda estiver participando.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-cli", "title": "Usando a CLI Symbiotic para Verificar", "text": "<p>Você também pode verificar seu status de cancelamento usando a CLI Symbiotic:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4\n</code></pre> <p>A saída mostrará <code>false</code> se você tiver cancelado a participação com sucesso e <code>true</code> se ainda estiver participando.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#contact-tanssi-team", "title": "Entre em Contato com a Equipe Tanssi", "text": "<p>Após o opt-out da rede, a próxima etapa do desligamento do operator Tanssi envolve notificar formalmente a equipe Tanssi. Esta página orienta você sobre como enviar o formulário de desligamento necessário e o que esperar durante o processo final de remoção.</p> <p>Após cancelar a participação na rede, informe à equipe Tanssi sua intenção de parar de operar. Para isso, preencha o formulário de desligamento do operator e aguarde a confirmação da conclusão do pedido pela equipe Tanssi.</p> <p>Ao receber sua solicitação, a remoção do seu operator será agendada. Essa etapa é semiautomática e pode levar algum tempo para ser concluída. Você será notificado por e-mail quando for seguro desativar o nó. Não desative seu nó até receber essa notificação.</p> <p>Fornecer feedback</p> <p>Considere fornecer feedback no formulário de desligamento sobre sua experiência para ajudar a melhorar a rede Tanssi.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#pause-operations", "title": "Pausar Operações (Opcional)", "text": "<p>Depois de receber a confirmação da remoção do seu operator pela equipe Tanssi, você pode parar com segurança quaisquer serviços em execução relacionados ao operator. Se necessário, faça backup de arquivos de configuração importantes, logs ou quaisquer dados relevantes antes de excluí-los. Em seguida, você pode reaproveitar, encerrar ou desligar toda a sua infraestrutura.</p>"}, {"location": "node-operators/operators/offboarding/opt-out-from-tanssi/#next-steps-vault-opt-out", "title": "Próximas Etapas (Opcional)", "text": "<p>Após cancelar a participação na rede e informar a equipe Tanssi enviando o formulário de desligamento, você pode dar um passo opcional adicional e cancelar a participação em quaisquer cofres específicos com os quais seu operator possa estar associado.</p>"}, {"location": "node-operators/operators/offboarding/prerequisites/", "title": "Pré-requisitos para Offboarding", "text": ""}, {"location": "node-operators/operators/offboarding/prerequisites/#introduction", "title": "Introdução", "text": "<p>O offboarding de operator é o processo formal pelo qual os node operators saem do protocolo Tanssi de forma segura e transparente. Ele garante a integridade, segurança e estabilidade da rede, fornecendo etapas claras para os operators que desejam deixar de participar.</p> <p>Os operators desempenham um papel crítico no consenso e nas operações da rede. Desligar abruptamente um nó sem seguir os procedimentos adequados pode impactar negativamente os operators, potencialmente resultando em slashing.</p> <p>Este guia descreve os pré-requisitos para o offboarding, e guias subsequentes o guiarão pelo processo.</p> <p>Se você tiver dúvidas durante qualquer parte do processo de offboarding, a equipe da Tanssi pode te ajudar no Discord.</p>"}, {"location": "node-operators/operators/offboarding/prerequisites/#prerequisites", "title": "Pré-requisitos", "text": "<p>Antes de iniciar o processo de offboarding, certifique-se de ter o seguinte:</p> <ul> <li>Acesso à carteira Ethereum (EVM) que controla sua conta de operator</li> <li>ETH suficiente em sua carteira para cobrir as taxas de gás para as transações</li> </ul>"}, {"location": "node-operators/operators/offboarding/prerequisites/#why-smart-contracts", "title": "Por que a Interação com Contratos Inteligentes é Necessária", "text": "<p>Como muitos sistemas descentralizados, o protocolo Tanssi utiliza contratos inteligentes na blockchain Ethereum para gerenciar operações críticas, incluindo registro e staking de operator. Quando um operator decide sair, ele muda seu status e relacionamento com esses contratos principais do protocolo. As principais etapas de offboarding, como sinalizar sua intenção de sair ou cancelar formalmente o registro, envolvem transações que atualizam o estado registrado nesses contratos inteligentes.</p>"}, {"location": "node-operators/operators/offboarding/prerequisites/#metodos-de-interacao", "title": "Métodos de Interação", "text": "<p>Existem várias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configurações multisig</li> </ul> <p>Em todos os casos, você precisará assinar a transação com a conta que pretende usar para o nó. Você pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (não recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A seção a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opção.</p>"}, {"location": "node-operators/operators/offboarding/prerequisites/#set-up-the-cli", "title": "Configurar o Symbiotic CLI", "text": "<p>O Symbiotic CLI é uma ferramenta para interagir com os contratos principais do Symbiotic. Ele é escrito em Python, portanto você precisará instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependências:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instalação foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos disponíveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options:  --chain CHAIN    Chain ID to use.  [default: mainnet]  --provider TEXT  Ethereum provider URL [http(s)].  --help           Show this message and exit. Commands:  active-balance-of       Get an active balance of a given account...  check-opt-in-network    Check if operator is opted in to a network.  check-opt-in-vault      Check if operator is opted in to a vault.  claim                   Claim a withdrawal for some epoch at the...  deposit                 Deposit to the vault.  .......                 .........."}, {"location": "node-operators/operators/offboarding/vault-opt-out/", "title": "Exclusão Voluntária de Vault (Opcional)", "text": ""}, {"location": "node-operators/operators/offboarding/vault-opt-out/#introduction", "title": "Introdução", "text": "<p>Esta página detalha a etapa final opcional no processo de desligamento Tanssi: a exclusão voluntária de um vault específico. Embora não seja obrigatória, esta ação permite que os operators desassocie suas contas de vaults individuais. Antes de prosseguir com esta etapa, certifique-se de ter cumprido todas as condições descritas no guia de pré-requisitos.</p> <p>Este guia fornece instruções sobre como cancelar a participação usando um dos métodos disponíveis e como verificar a conclusão bem-sucedida dessa ação.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#opting-out-of-a-vault", "title": "Cancelamento de Participação em um Vault", "text": "<p>Para prosseguir com a exclusão de um vault, use um dos métodos detalhados nas seções a seguir.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-cli", "title": "Usando a CLI Symbiotic", "text": "<p>Usando um dispositivo Ledger:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Para assinar com uma chave privada:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Observe que este método exige expor sua chave privada; portanto, não é recomendado.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-etherscan", "title": "Usando o Etherscan", "text": "<p>Acesse o contrato via Etherscan:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Endereço do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Certifique-se de selecionar Contract e Write Contract, depois clique em Connect to Web3 e selecione sua carteira preferida (por exemplo, MetaMask): </p> <ol> <li>Expanda a função optOut</li> <li>Insira o <code>VAULT_ADDRESS</code> no campo where (por exemplo, <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet)</li> <li>Clique em Write e assine a transação</li> </ol> <p></p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-safe", "title": "Usando o Safe", "text": "<p>Para contas Safe, use estes endereços de contrato no Transaction Builder:</p> MainNetTestNet (Sepolia) <p>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Em seguida, escolha a função optOut, insira o <code>VAULT_ADDRESS</code> ao qual seu nó está registrado (por exemplo, <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet) e assine a transação.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#verify-vault-opt-out-status", "title": "Verificar o Status de Exclusão de Vault", "text": "<p>Depois de enviar a transação de exclusão de vault, você pode verificar seu status de exclusão usando um dos métodos abaixo.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#usando-o-etherscan", "title": "Usando o Etherscan", "text": "<p>Você pode verificar o status de exclusão do seu vault no Etherscan:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Endereço do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Na página do contrato:</p> <p>Certifique-se de selecionar Contract e Write Contract, depois clique em Connect to Web3 e selecione sua carteira preferida (por exemplo, MetaMask): 1. Selecione a guia Read Contract 2. Localize e expanda a função isOptedIn 3. Cole a conta do seu operator no campo who 4. Insira o endereço do vault no campo where 5. Clique em Query</p> <p>Você obterá um resultado <code>false</code> se o operator tiver cancelado a participação no vault com sucesso e <code>true</code> se ainda estiver inscrito.</p> <p></p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#usando-a-cli-symbiotic", "title": "Usando a CLI Symbiotic", "text": "<p>Você também pode verificar o status de exclusão do seu vault usando a CLI Symbiotic:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482\n</code></pre> <p>A saída mostrará <code>false</code> se você tiver cancelado o vault com sucesso e <code>true</code> se ainda estiver inscrito.</p>"}, {"location": "node-operators/operators/offboarding/vault-opt-out/#proximos-passos", "title": "Próximos Passos", "text": "<p>Após concluir o processo de desligamento, se planeja retornar no futuro, siga novamente o processo de onboarding.</p>"}, {"location": "node-operators/operators/onboarding/", "title": "Onboarding", "text": "<p>Um dos principais pilares da Tanssi para builders é que ela fornece segurança econômica de nível Ethereum para cada rede powered by Tanssi, independentemente de seu TVL, base de usuários ou detalhes do caso de uso. O design da Tanssi oferece aos desenvolvedores um Template de segurança compartilhado, livrando-os de ter que obter segurança econômica suficiente ou negociar com operators para executar nós optando por suas redes.</p> <p>O protocolo Tanssi consegue isso integrando-se a provedores de segurança externos, como o Symbiotic. Nesse Template, diferentes cofres associados à Tanssi fornecem segurança econômica, e operators confiáveis fornecem serviços de validação à rede Tanssi.</p> <p>Siga estas etapas para configurar seu nó e preparar sua conta para participação ativa no protocolo Tanssi.</p> <p>Execute um nó operador</p> <p>Configure o nó usando Systemd ou Docker.</p> <p>Registrar no Symbiotic</p> <p>Adicione sua conta ao registro de operadores do Symbiotic. Esse registro é o ponto central para identificar operadores dentro do ecossistema Symbiotic.</p> <p>Fazer opt-in na Tanssi Network</p> <p>Adicione sua conta ao registro de operadores da rede Tanssi. Esse registro é o ponto central para identificar operadores que participam do protocolo Tanssi.</p> <p>Fazer opt-in em um cofre habilitado para Tanssi</p> <p>Adicione sua conta a um cofre habilitado para Tanssi. Operadores devem fazer opt-in (e serem admitidos) em um cofre que gerencia e delega os ativos em stake aos operadores.</p> <p>Preencha o formulário de inscrição</p> <p>Preencha o formulário para se candidatar como operador. Como esta etapa não é totalmente automatizada, o processamento pode levar até uma semana.</p> <p>Configure sua conta</p> <p>Associe sua conta ao seu nó para começar a validar no protocolo Tanssi.</p> <p>Configure uma identidade on-chain</p> <p>Defina uma identidade para melhorar a visibilidade e o reconhecimento da conta Substrate do seu operador.</p> <p>Depois de totalmente integrado, confira as tarefas operacionais relacionadas à manutenção do seu nó.</p>"}, {"location": "node-operators/operators/onboarding/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/onboarding/account-setup/", "title": "Configure Sua Conta para Proteger o Ecossistema Tanssi", "text": ""}, {"location": "node-operators/operators/onboarding/account-setup/#introduction", "title": "Introdução", "text": "<p>Como apresentado na seção de integração, assim que você optar com sucesso para um cofre habilitado para Tanssi, optar para a rede Tanssi, e preencher o formulário de inscrição, esta é a sexta etapa do processo. Após esta etapa, seu nó estará apto a participar do protocolo Tanssi.</p> <p>Nesta etapa, você mapeará sua conta de stash do Substrate (a que acompanha suas recompensas) para as chaves de sessão do seu nó (aquelas utilizadas para comunicação e consenso), permitindo que o protocolo inclua seu nó no conjunto ativo.</p> <p>Este guia te orienta na geração de chaves de sessão para o seu nó, mapeando-as para sua conta através do portal do desenvolvedor Tanssi e verificando se a associação foi estabelecida corretamente.</p>"}, {"location": "node-operators/operators/onboarding/account-setup/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Antes de configurar sua conta, certifique-se de que:</p> <ul> <li>Você tem um nó corretamente configurado e em execução</li> <li>Você se registrou como operator no registro Symbiotic</li> <li>Você optou pela Rede Tanssi e um cofre habilitado para Tanssi</li> </ul>"}, {"location": "node-operators/operators/onboarding/account-setup/#map-account", "title": "Mapear uma Conta para Seu Nó", "text": "<p>A primeira etapa é um processo de duas etapas que gera e mapeia as chaves de sessão para sua conta. Chaves de sessão podem ser comparadas ao ID do nó, e são usadas para executar operações na rede, como assinar provas de validade, enquanto sua conta acompanha seu trabalho e recompensas relacionadas, e pode ter uma identidade na cadeia.</p> <p>Você precisará criar chaves de sessão para seus servidores principal e de backup. Cada servidor deve ter suas próprias chaves exclusivas. Como as chaves nunca saem de seus servidores, você pode considerá-las um ID exclusivo para aquele servidor.</p>"}, {"location": "node-operators/operators/onboarding/account-setup/#generate-session-keys", "title": "Gerar Chaves de Sessão", "text": "<p>Para gerar chaves de sessão, envie uma chamada RPC usando o método <code>author_rotateKeys</code> para o endpoint HTTP do seu nó. Para referência, se o endpoint HTTP do seu nó estiver na porta <code>9944</code>, a chamada JSON-RPC pode ser assim:</p> <pre><code>\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{  \n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Suas chaves de sessão codificadas em hexadecimal serão impressas no terminal no campo <code>\"result\"</code>.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":    \"0xca17757962a065eeebec2c6e0d2dc7fb24b56967fd9003e4d22bf4981da86fd4ac7cd701462730a76ab539d5a48f4fd2821acf07743335e56eef84d1544686480ada0ff0f38dfccee43515e619e03b0de95a08c74fcbb2da26af55ad144d5f54829a57d7d77bb9333cf9301eaa5d20c384f67388f36b402e33a03b949148325e80b812699fb22d9e4b4976e1d0e9964034489cb0b5b6b70c37d227fb54ffe50b444434b488361038b8b6949c36f0073c6bd52f2907c0991e32257d96bb946c590320539c343fc1f2e1dd1951a0ff38c6c9ea2f93a263e81ee95da1de0697e47e32\"} <p>Note</p> <p>Certifique-se de anotar suas chaves de sessão. Na próxima seção, você precisará mapeá-las para sua conta.</p>"}, {"location": "node-operators/operators/onboarding/account-setup/#map-session-keys", "title": "Mapear Chaves de Sessão", "text": "<p>Para executar a etapa seguinte e mapear suas chaves de sessão para sua conta, abra o portal do desenvolvedor e vá para a aba Desenvolvedor, seção Extrinsics. O seguinte link o levará diretamente para lá:</p> Tanssi MainNetDancelight TestNet <p>Portal do desenvolvedor da Mainnet</p> <p>Portal do desenvolvedor da TestNet</p> <p>Agora, siga estas etapas:</p> <ol> <li>Selecione sua conta, que deve ser a mesma conta que você registrou com a Tanssi anteriormente</li> <li>Selecione o módulo session e a extrínseca setKeys</li> <li>Para keys, insira suas chaves de sessão</li> <li>Para proof, insira <code>0x</code></li> <li>Clique em Enviar Transação e assine e envie a transação de sua carteira</li> </ol> <p></p>"}, {"location": "node-operators/operators/onboarding/account-setup/#verify-keys-mapping", "title": "Verifique o Mapeamento das Chaves", "text": "<p>Usar o método <code>session.keyOwner</code> permite verificar se suas chaves de sessão foram mapeadas para sua conta conforme o esperado. Este método é acessível através do portal do desenvolvedor, na aba Desenvolvedor, seção Chain state. O link a seguir o levará direto para lá:</p> Tanssi MainNetDancelight TestNet <p>Portal do desenvolvedor da Mainnet</p> <p>Portal do desenvolvedor da TestNet</p> <p>Agora, siga estas etapas:</p> <ol> <li>Selecione o módulo session e o query keyOwner</li> <li>Insira <code>gran</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira os primeiros sessenta e seis caracteres codificados em hexadecimal de suas chaves de sessão (por exemplo, <code>0x00a12170e0925a9bf98f31bbdd7988550c1bf587766a2d2735e969aa5b4291dc</code>)</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A conta associada às chaves de sessão, que deve ser sua conta, será exibida na parte inferior da página</li> </ol> <p></p> <p>E é isso! Você mapeou sua conta com sucesso, e seu nó agora está qualificado para participar do protocolo.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/", "title": "Optar pela Tanssi", "text": ""}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#introduction", "title": "Introdução", "text": "<p>Após registrar seu nó no protocolo Symbiotic, as próximas etapas são fazer opt-in tanto nos cofres habilitados para Tanssi quanto na própria rede Tanssi. Como apresentado na seção de onboarding, estas são a terceira e a quarta etapas.</p> <p>Este guia percorre as etapas para fazer opt-in com sucesso em um cofre habilitado para Tanssi e na rede Tanssi, permitindo escolher entre vários métodos, incluindo usar a Symbiotic CLI, interagir diretamente com contratos inteligentes via Etherscan ou utilizar o Safe para configurações multisig.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Antes de fazer opt-in em um cofre habilitado para Tanssi e na rede Tanssi, certifique-se de que:</p> <ul> <li>Você tem um nó corretamente configurado e em execução</li> <li>Você se registrou como operator no registro Symbiotic</li> </ul> <p>Para seguir este guia, você deve interagir com contratos inteligentes: um do protocolo principal da Symbiotic e outro da integração da Tanssi com a Symbiotic.</p> <p>Existem várias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configurações multisig</li> </ul> <p>Em todos os casos, você precisará assinar a transação com a conta que pretende usar para o nó. Você pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (não recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A seção a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opção.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#set-up-the-cli", "title": "Configurar o Symbiotic CLI", "text": "<p>O Symbiotic CLI é uma ferramenta para interagir com os contratos principais do Symbiotic. Ele é escrito em Python, portanto você precisará instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependências:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instalação foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos disponíveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options:  --chain CHAIN    Chain ID to use.  [default: mainnet]  --provider TEXT  Ethereum provider URL [http(s)].  --help           Show this message and exit. Commands:  active-balance-of       Get an active balance of a given account...  check-opt-in-network    Check if operator is opted in to a network.  check-opt-in-vault      Check if operator is opted in to a vault.  claim                   Claim a withdrawal for some epoch at the...  deposit                 Deposit to the vault.  .......                 .........."}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults", "title": "Optar por Cofres Habilitados para Tanssi", "text": "<p>Antes de habilitar seu operator para estar ativo na rede Tanssi, você deve fazer opt-in em pelo menos um dos cofres habilitados para Tanssi. As seções a seguir descrevem várias formas de optar pelos cofres.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-cli", "title": "Optar Usando a Symbiotic CLI", "text": "<p>Se você instalou corretamente a Symbiotic CLI e deseja assinar a transação usando um dispositivo Ledger, execute o comando a seguir, substituindo <code>INSERT_VAULT_ADDRESS</code> pelo endereço específico que você quer ingressar e <code>INSERT_OPERATOR_ADDRESS</code> pela sua conta:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Se quiser assinar a transação diretamente usando a chave privada da conta do operator, execute o comando abaixo, substituindo o parâmetro <code>INSERT_PRIVATE_KEY</code>:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Observe que este método exige expor sua chave privada; portanto, não é recomendado.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-etherscan", "title": "Optar Usando o Etherscan", "text": "<p>Você pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transação com uma carteira de navegador (MetaMask, por exemplo).</p> <p>Para abrir a página do contrato, acesse:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Endereço do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Clique em Connect to Web3 e selecione sua carteira preferida (por exemplo, MetaMask):</p> <p></p> <p>Note</p> <p>Você pode configurar o MetaMask para usar uma carteira fria.</p> <p>Após a conexão:</p> <ol> <li>Expanda a função <code>optin</code></li> <li>Insira o <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no TestNet Sepolia)</li> <li>Clique em Write e assine a transação</li> </ol> <p></p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-safe", "title": "Optar Usando o Safe para Configurações Multisig", "text": "<p>Se você tiver uma conta Safe, abra o Transaction builder e insira o seguinte endereço de contrato:</p> MainNetTestNet (Sepolia) <p>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Finalmente, escolha a função <code>optin</code>, insira o <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no TestNet Sepolia) e assine a transação.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#check-vault-registration", "title": "Verificar o Status do Registro", "text": "<p>Você pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Endereço do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Na página do contrato:</p> <ol> <li>Selecione a função <code>isOptedIn</code></li> <li>Cole a conta do seu operator no campo who</li> <li>Insira o <code>VAULT_ADDRESS</code> no campo where</li> <li>Clique em Query</li> </ol> <p>Você obterá um resultado <code>true</code> se seu operator foi registrado corretamente e <code>false</code> caso contrário.</p> <p></p> <p>Você também pode verificar o status do seu registro usando a Symbiotic CLI executando o comando abaixo, que imprime <code>true</code> ou <code>false</code> para qualquer endereço de operator em um cofre habilitado para Tanssi:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482\n</code></pre> <p>E a saída se parece com:</p> python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS Connected to chain ID 1 True"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi", "title": "Optar pela Rede Tanssi", "text": "<p>Antes de habilitar seu operator para estar ativo na rede Tanssi, você deve fazer opt-in na rede e ser aprovado pela equipe Tanssi. As seções a seguir descrevem várias formas de optar pela rede.</p> <p>Note</p> <p>O endereço da Tanssi Network na MainNet será divulgado no lançamento.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-cli", "title": "Optar Usando a Symbiotic CLI", "text": "<p>Se você instalou corretamente a Symbiotic CLI e deseja assinar a transação usando um dispositivo Ledger, execute o seguinte comando, substituindo <code>INSERT_OPERATOR_ADDRESS</code>:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Se você quiser assinar a transação diretamente usando a chave privada da conta do operator, execute o comando abaixo, substituindo o parâmetro <code>INSERT_PRIVATE_KEY</code>:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Observe que este método exige expor sua chave privada; portanto, não é recomendado.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-etherscan", "title": "Optar Usando o Etherscan", "text": "<p>Você pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transação com uma carteira de navegador (MetaMask, por exemplo).</p> <p>Vá para a página do contrato abrindo o link:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Endereço do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Clique em Connect to Web3 e selecione sua carteira preferida (por exemplo, MetaMask):</p> <p></p> <p>Note</p> <p>Você pode configurar o MetaMask para usar uma carteira fria.</p> <p>Após a conexão:</p> <ol> <li>Expanda a função <code>optin</code></li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code>. Se estiver fazendo opt-in para a Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Write e assine a transação</li> </ol> <p></p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-safe", "title": "Optar Usando o Safe para Configurações Multisig", "text": "<p>Se você tiver uma conta Safe, abra o Transaction builder e insira o seguinte endereço de contrato:</p> MainNetTestNet (Sepolia) <p>0x7133415b33B438843D581013f98A08704316633c</p> <p>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Finalmente, escolha a função <code>optin</code>, insira o endereço da Rede Tanssi (<code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code> para Tanssi MainNet e <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> para TestNet) e assine a transação.</p>"}, {"location": "node-operators/operators/onboarding/opt-in-to-tanssi/#check-tanssi-registration", "title": "Verificar o Status do Registro", "text": "<p>Você pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Endereço do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Na página do contrato:</p> <ol> <li>Selecione a função <code>isOptedIn</code></li> <li>Cole a conta do seu operator no campo who</li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Se estiver optando pela Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Query</li> </ol> <p>Você obterá um resultado <code>true</code> se seu operator foi registrado corretamente e <code>false</code> caso contrário.</p> <p></p> <p>Você também pode verificar o status do seu registro usando a Symbiotic CLI executando o comando a seguir, que imprime <code>true</code> ou <code>false</code> para qualquer endereço de operator na Rede Tanssi:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 \n</code></pre> <p>E a saída se parece com:</p> python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 Connected to chain ID 1 True <p>Note</p> <p>Fazer opt-in nas Redes Tanssi requer aprovação da equipe Tanssi. As solicitações para participar podem levar até uma semana.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/", "title": "Registrar no Symbiotic", "text": ""}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#introduction", "title": "Introdução", "text": "<p>Como apresentado na seção de integração, registrar no Symbiotic é o segundo passo do processo. Você já deve ter o nó sincronizado e em execução, seja usando Docker ou Systemd.</p> <p>O protocolo Tanssi fornece às suas appchains segurança de nível Ethereum desde o início, confiando em provedores externos como o Symbiotic. Para participar como operator no ecossistema Tanssi, você deve primeiro registrar seu nó no protocolo Symbiotic. O processo de registro estabelece seu nó como operator reconhecido.</p> <p>Este guia mostra as etapas para registrar seu nó como operator Symbiotic, permitindo escolher entre vários métodos: CLI Symbiotic, interação direta via Etherscan ou uso do Safe para configurações multisig.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Antes de se registrar, certifique-se de já ter configurado o nó e que ele esteja em execução.</p> <p>Para seguir este guia, você deverá interagir com contratos inteligentes. Existem várias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configurações multisig</li> </ul> <p>Em todos os casos, você precisará assinar a transação com a conta que pretende usar para o nó. Você pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (não recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A seção a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opção.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#set-up-the-cli", "title": "Configurar o Symbiotic CLI", "text": "<p>O Symbiotic CLI é uma ferramenta para interagir com os contratos principais do Symbiotic. Ele é escrito em Python, portanto você precisará instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependências:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instalação foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos disponíveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options:  --chain CHAIN    Chain ID to use.  [default: mainnet]  --provider TEXT  Ethereum provider URL [http(s)].  --help           Show this message and exit. Commands:  active-balance-of       Get an active balance of a given account...  check-opt-in-network    Check if operator is opted in to a network.  check-opt-in-vault      Check if operator is opted in to a vault.  claim                   Claim a withdrawal for some epoch at the...  deposit                 Deposit to the vault.  .......                 .........."}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#registering-operator", "title": "Registrar como Operator", "text": "<p>O protocolo Symbiotic mantém um registro de todos os operators. Antes de proteger redes Tanssi, registre-se usando um dos métodos abaixo.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#register-with-cli", "title": "Registrar usando a CLI Symbiotic", "text": "<p>Se você instalou a CLI Symbiotic e quer assinar com um dispositivo Ledger, execute o comando abaixo, substituindo <code>INSERT_OPERATOR_ADDRESS</code> pela sua conta:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Se preferir assinar diretamente com a chave privada da conta, execute (substitua <code>INSERT_PRIVATE_KEY</code>):</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Este método exige expor sua chave privada; não é recomendado.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#register-with-etherscan", "title": "Registrar usando o Etherscan", "text": "<p>Você pode interagir com os contratos do Symbiotic pelo Etherscan e assinar com uma carteira de navegador (MetaMask, por exemplo).</p> <p>Abra a página do contrato:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Endereço do contrato: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Clique em Conectar ao Web3 e selecione sua carteira preferida (por exemplo, MetaMask):</p> <p></p> <p>Note</p> <p>Você pode configurar o MetaMask para usar uma carteira fria.</p> <p>Depois de conectado:</p> <ol> <li>Expanda a função <code>registerOperator</code></li> <li>Clique em Write e assine a transação</li> </ol> <p></p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#register-with-safe", "title": "Registrar Usando o Safe para Multisig", "text": "<p>Se você tiver uma conta Safe, abra o Transaction builder e insira o seguinte endereço do contrato:</p> MainNetTestNet (Sepolia) <p>0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Por fim, escolha a função <code>registerOperator</code> e assine a transação.</p>"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#check-registration", "title": "Verificar o Status do Registro", "text": "<p>Você pode verificar rapidamente seu status de registro no Etherscan. Abra:</p> MainNetTestNet (Sepolia) <p>Endereço do contrato: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Endereço do contrato: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Na página do contrato:</p> <ol> <li>Selecione a função <code>isEntity</code></li> <li>Cole a conta do seu operator</li> <li>Clique em Query</li> </ol> <p>Se o operator foi registrado corretamente, o resultado será <code>true</code>; caso contrário, <code>false</code>.</p> <p></p> <p>Você também pode verificar o status via CLI Symbiotic, executando:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py isop INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia isop INSERT_OPERATOR_ADDRESS\n</code></pre> <p>E a saída se parece com:</p> python3 symb.py isop INSERT_OPERATOR_ADDRESS Connected to chain ID 1 True"}, {"location": "node-operators/operators/onboarding/register-in-symbiotic/#submitting-metadata", "title": "Enviar Metadados", "text": "<p>Após o registro, você pode adicionar metadados (por exemplo, logotipo) para melhorar a visibilidade no site Symbiotic.</p> <p>Para enviar os metadados do operator, acesse o repositório de metadados Symbiotic:</p> MainNet <p>Repositório MainNet</p> <p>Crie um fork do repositório e, no diretório <code>operators</code>, crie uma pasta com o endereço do seu operator. Dentro dela, adicione <code>logo.png</code> e um arquivo <code>info.json</code> com os campos abaixo (substitua pelos seus valores):</p> info.json<pre><code>{\n    \"name\": \"INSERIR_SEU_NOME_DO_OPERATOR\",\n    \"description\": \"INSERIR_SUA_DESCRIÇÃO_DO_OPERATOR\",\n    \"tags\": [\n        \"operator\"\n    ],\n    \"links\": [\n        {\n            \"type\": \"website\",\n            \"name\": \"Website\",\n            \"url\": \"https://INSERIR_SEU_URL_DO_SITE\"\n        },\n        {\n            \"type\": \"website\",\n            \"name\": \"X\",\n            \"url\": \"https://INSERIR_SEU_URL_X\"\n        }\n    ]\n}\n</code></pre> <p>Note</p> <p>O parâmetro <code>links</code> é um array. Adicione quantos links forem necessários.</p> <p>Por fim, abra um pull request. A equipe Symbiotic revisará e fará o merge.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/", "title": "Executar um Nó Operator", "text": "<p>A configuração de um node operator é um passo importante para participar da rede Tanssi. Você tem duas opções de configuração: usar Docker ou Systemd. Qualquer que seja o caminho que você escolher, fornecemos tutoriais passo a passo para guiá-lo pelo processo e garantir que seu nó atenda aos requisitos necessários para validar as transações da rede Tanssi e fornecer segurança ao ecossistema.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/#requisitos-de-hardware", "title": "Requisitos de Hardware", "text": "<p>Para executar um node operator com sucesso, hardware de alto desempenho é essencial. Configurações subótimas podem levar a atrasos, indisponibilidade e, por fim, perdas de recompensas e/ou penalidades. Como o processo de validação depende muito do desempenho de um único thread, é recomendável priorizar CPUs com fortes capacidades de um único thread em vez de contagens de núcleos mais altas.</p> <p>Hardware recomendado:</p> <ul> <li>Configuração Recomendada - Hardware bare metal executando linux debian ou ubuntu</li> <li>CPUs Recomendadas - Intel Ice Lake ou mais recente (série Xeon ou Core) ou AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito núcleos físicos @ 3,4 GHz com hyperthreading desativado (SMT para processadores AMD)</li> <li>NVMe Recomendado - SSD NVMe de 500 GB</li> <li>RAM Recomendada - 32 GB ECC RAM</li> <li>Rede Recomendada - Conexão de 1 Gbps</li> </ul> <p>Warning</p> <p>Como operator, você é responsável tanto pelo seu próprio stake quanto pelo de seus delegadores. Manter o desempenho do seu nó, mantê-lo atualizado e garantir sua segurança são cruciais para maximizar as recompensas e construir uma forte reputação na rede Tanssi.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/#portas-de-rede-necessarias", "title": "Portas de Rede Necessárias", "text": "<p>Um operator de sucesso deve ser capaz de sincronizar e interagir com uma rede ponto a ponto (P2P). Para garantir a comunicação adequada dentro do ecossistema Tanssi, certifique-se de que a seguinte porta esteja aberta para entrada:</p> Rede Porta Tanssi Chain 30333 (TCP)"}, {"location": "node-operators/operators/onboarding/run-an-operator/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/", "title": "Executar um Nó Operator Usando Docker", "text": ""}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#introduction", "title": "Introdução", "text": "<p>Os operators são fundamentais no ecossistema Tanssi, fornecendo segurança e validação para redes baseadas em Tanssi. Como operator, você participa do consenso que protege a rede e ganha recompensas.</p> <p>Conforme apresentado na seção de integração, executar o nó é o primeiro passo da sua participação ativa no protocolo.</p> <p>Este guia mostra como iniciar um operator Tanssi usando a imagem oficial com Docker em sistemas Linux.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#checking-prerequisites", "title": "Verificando Pré-Requisitos", "text": ""}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#installing-docker", "title": "Instalando o Docker", "text": "<p>Para começar, você precisará de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instalação:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execução bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#pull-docker-image", "title": "Puxar a Imagem Docker", "text": "<p>Uma imagem Docker é construída e publicada em cada versão, contendo todas as dependências necessárias e o binário do operator.</p> <p>A imagem combina o binário estável mais recente do nó cliente com o arquivo de especificação do orquestrador Tanssi.</p> <p>Execute o comando a seguir para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>O comando fará download/extrair a imagem e exibirá o status após a execução:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#set-up-data-directory", "title": "Configure o diretório de dados", "text": "<p>Executar um nó requer sincronizar com a cadeia Tanssi e armazenar seu estado.</p> <p>Crie o diretório onde o nó armazenará os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando a seguir se quiser rodar o nó com o usuário atualmente logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diretório é um parâmetro no comando de inicialização do Docker. Se decidir criá-lo em outro lugar, ajuste o comando.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#generate-node-key", "title": "Gerar a Chave do Nó", "text": "<p>Para gerar e armazenar as chaves de sessão em disco (referenciadas no comando de inicialização), execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#start-your-node", "title": "Inicie Seu Nó", "text": "<p>Para iniciar seu nó, execute a imagem Docker com <code>docker run</code>.</p> <p>Substitua <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome legível e <code>INSERT_YOUR_IP_ADDRESS</code> pelo IP público.</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#run-flags", "title": "Flags de Execução", "text": "<p>As flags usadas no comando <code>docker run</code> podem ser ajustadas conforme suas preferências e configuração de hardware. Algumas das principais são:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node’s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-docker/#syncing-your-node", "title": "Sincronizando Seu Nó", "text": "<p>Na primeira execução, o processo de sincronização exibirá muitos logs do nó e da cadeia sendo sincronizada. Alguns erros iniciais são esperados e desaparecem quando a cadeia alcança o último bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] 💤 Idle (0 peers), best: #0 (0x4a2b…7de3), finalized #0 (0x4a2b…7de3), ⬇ 0 ⬆ 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] ✨ Imported #14139635 (0x8c41…8df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] 💤 Idle (8 peers), best: #14139635 (0x8c41…8df6), finalized #14139632 (0xa9a8…cab9), ⬇ 32.7kiB/s ⬆    <p>Quando a sincronização terminar, seu nó estará pronto para as próximas etapas.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/", "title": "Executar um Nó Operator Usando Systemd", "text": ""}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#introduction", "title": "Introdução", "text": "<p>Os operators são cruciais no ecossistema Tanssi, fornecendo segurança e validação para redes baseadas em Tanssi. Como operator, você participa do consenso que protege a rede e ganha recompensas.</p> <p>Conforme apresentado na seção de integração, executar o nó é o primeiro passo da sua participação ativa no protocolo.</p> <p>Neste guia, você aprenderá a iniciar um operator Tanssi usando o binário estável mais recente e gerenciar o serviço com Systemd em sistemas Linux.</p> <p>O artigo segue a boa prática de executar o serviço com uma conta não-root e conceder a essa conta acesso de gravação a um diretório específico. Adapte as etapas conforme sua configuração e políticas de segurança.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Você precisará de acesso a um computador Ubuntu Linux com Landlock habilitado e privilégios de root. Também precisará de:</p> <ul> <li>Arquivos binários do nó - o operator precisa de três binários: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code></li> </ul> <p>As instruções usam a versão estável mais recente. Você pode compilar seu próprio arquivo a partir do código fonte.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#check-landlock", "title": "Verificar Suporte Landlock", "text": "<p>Os operators Tanssi usam o recurso Landlock do kernel Linux como medida de segurança para restringir o acesso a recursos do sistema.</p> <p>Verifique o suporte Landlock executando:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>A saída esperada é similar a:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>Se o Landlock estiver desabilitado, atualize o kernel para a versão 5.13 ou superior.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#download-latest-release", "title": "Baixar a Versão Mais Recente", "text": "<p>Baixe os binários mais recentes e torne-os executáveis:</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#set-up-systemd-service", "title": "Configure o serviço Systemd", "text": "<p>O Systemd é um sistema de gerenciamento para Linux que controla serviços (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.</p> <p>Os comandos a seguir criam uma nova conta, o diretório e movem os arquivos previamente baixados para o local correto.</p> <ol> <li> <p>Crie uma nova conta para executar o serviço:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Crie um diretório para armazenar os arquivos e dados necessários:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Defina a propriedade da pasta para a conta que executará o serviço, garantindo permissão de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Mova os binários para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dancelight-data\n</code></pre> </li> </ol>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#generate-node-key", "title": "Gerar a chave do nó", "text": "<p>Para gerar e armazenar em disco as chaves de sessão que serão referenciadas no comando de inicialização, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#create-systemd-configuration", "title": "Criar o arquivo de configuração do Systemd", "text": "<p>O próximo passo é criar o arquivo de configuração do Systemd.</p> <p>Crie o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configuração do serviço, substituindo a tag <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome legível e <code>INSERT_YOUR_IP_ADDRESS</code> pelo seu endereço IP público. Esse nome ajuda a relacionar entradas de log e métricas ao nó que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Serviço systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Serviço systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=dancelight \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-flags", "title": "Flags de Execução", "text": "<p>As flags usadas no <code>ExecStart</code> podem ser ajustadas conforme preferências e hardware. Algumas das principais:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node’s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"}, {"location": "node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-the-service", "title": "Execute o serviço", "text": "<p>Por fim, habilite o serviço e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Você pode verificar se o serviço está ativo e rodando corretamente executando:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  ● network.service - \"Network systemd service\"        Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)        Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago       Main PID: 4045278 (container-chain)         Tasks: 44 (limit: 9462)        Memory: 6.5G        CGroup: /system.slice/network.service                └─4045278 4045278 /var/lib/network-data/container-chain- ...    <p>Verifique os logs, se necessário, com o comando a seguir:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"}, {"location": "node-operators/operators/operational-tasks/", "title": "Tarefas Operacionais", "text": "<p>A manutenção do seu operator exige manutenção regular para garantir desempenho consistente e gerenciamento seguro da conta. Atualizações regulares são essenciais para manter seu nó compatível com as últimas alterações no protocolo Tanssi. Ao mesmo tempo, ferramentas como contas proxy fornecem uma camada extra de segurança, permitindo que você delegue tarefas específicas sem expor as credenciais da sua conta principal. Esta seção fornece as etapas para manter suas operações suaves, confiáveis e seguras.</p>"}, {"location": "node-operators/operators/operational-tasks/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/", "title": "Configurar uma Conta Proxy de Operator", "text": ""}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#introduction", "title": "Introdução", "text": "<p>Contas proxy podem ser configuradas para executar um número limitado de ações em nome de contas primárias e ajudar a manter as contas subjacentes seguras. Como operator na Tanssi, é benéfico usar contas proxy para interagir com a rede em vez da sua conta.</p> <p>O tipo de proxy <code>SessionKeyManagement</code> permite que a conta gire chaves de sessão em nome da conta primária. Ele transforma a proxy em uma “hot wallet” que executa tarefas de manutenção regulares em nome da sua “cold wallet” de operator. Para maior segurança, você pode rotacionar a conta proxy regularmente.</p> <p>Contas proxy também ajudam a aplicar o princípio do menor privilégio para controle de acesso. Por exemplo, se você tiver vários membros na equipe, pode conceder a eles apenas o acesso mínimo necessário para executar suas funções via uma conta proxy específica.</p> <p>Este tutorial orienta na configuração de uma conta proxy <code>SessionKeyManagement</code> no Dancelight especificamente para ações de operator e demonstra como rotacionar suas novas chaves usando o proxy.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisará:</p> <ul> <li> <p>Abrir o portal do desenvolvedor</p> Tanssi MainNetDancelight TestNet <p>Portal do desenvolvedor da Mainnet</p> <p>Portal do desenvolvedor da TestNet</p> </li> <li> <p>Criar ou ter duas contas acessíveis no portal do desenvolvedor</p> </li> <li>Ambas as contas precisam estar financiadas com tokens</li> </ul> <p>Se precisar de ajuda para importar suas contas no portal do desenvolvedor, consulte o guia Conectando ao Portal do Desenvolvedor.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#create-a-proxy-account", "title": "Criar uma Conta Proxy", "text": "<p>Há algumas maneiras de criar contas proxy no portal do desenvolvedor, seja na página Extrinsics ou na página Accounts. Porém, é necessário usar a página Extrinsics para criar um proxy com atraso de tempo. O atraso fornece uma camada extra de segurança especificando um período baseado no número de blocos. Essa configuração impede que a conta proxy execute uma transação até que o período termine, permitindo que a conta primária que controla o proxy revise ou cancele transações pendentes.</p> <p>Você também pode criar um proxy do tipo <code>Any</code>, que concede controle total e irrestrito da conta primária ao proxy. A conta proxy pode transferir fundos e realizar qualquer ação arbitrária. A demonstração a seguir mostra como configurar um proxy <code>SessionKeyManagement</code>, mais restritivo do que um proxy <code>Any</code>, pois limita a funcionalidade a atividades relacionadas ao mapeamento de chaves de sessão.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-extrinsics", "title": "Usando a Seção Extrinsics", "text": "<p>Para começar a criar sua conta proxy, acesse a aba Developer e selecione Extrinsics no menu. Em seguida, siga estes passos:</p> <ol> <li>Selecione a conta primária</li> <li>No menu submit the following extrinsic, selecione proxy</li> <li>Escolha o extrínseco addProxy</li> <li>Em AccountIdLookupOf, selecione Id</li> <li>Selecione a conta delegate para o proxy</li> <li>No menu proxyType, selecione SessionKeyManagement</li> <li>Opcionalmente, adicione um atraso usando um número de blocos para fornecer uma camada adicional de segurança para a conta primária revisar a transação pendente</li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Em seguida, você será solicitado a autorizar e assinar a transação. Clique em Sign and Submit para criar a relação de proxy. Quando a transação for enviada com sucesso, você receberá notificações confirmando a transação.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-accounts", "title": "Usando a Seção Accounts", "text": "<p>Outro método para criar um proxy é pela seção Accounts do portal do desenvolvedor. Para isso, navegue até a página Accounts e siga estes passos:</p> <ol> <li>Selecione os três pontos verticais ao lado da conta primária</li> <li>Selecione Add proxy</li> </ol> <p></p> <p>Note</p> <p>Se a conta já tiver um proxy, Manage proxies aparecerá como opção em vez de Add proxy.</p> <p>Uma janela pop-up aparecerá onde você pode inserir as informações necessárias, como a conta primária, a conta proxy e o tipo de proxy, para criar uma conta proxy. Primeiro, clique em Add proxy.</p> <p></p> <p>Depois, siga estes passos:</p> <ol> <li>Selecione a conta que deseja definir como proxy</li> <li>Selecione o tipo de proxy</li> <li>Clique em Submit e assine a transação</li> </ol> <p></p> <p>Na próxima seção, você aprenderá como verificar se sua conta proxy foi configurada com sucesso.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#verify-your-proxy-account", "title": "Verificar sua Conta Proxy", "text": "<p>Você pode verificar se sua conta proxy foi configurada com sucesso de duas maneiras: pela página Accounts ou pela página Chain state.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-chain-state", "title": "Usando a Seção Chain State", "text": "<p>Para verificar suas contas proxy na seção Chain state do portal do desenvolvedor, siga estes passos:</p> <ol> <li>No menu selected state query, selecione proxy</li> <li>Escolha a entrada proxies</li> <li>Selecione ou cole sua conta primária/proxy</li> <li>Clique no botão + para enviar a consulta</li> </ol> <p></p> <p>O resultado aparecerá na página mostrando informações sobre seus proxies, incluindo o endereço da conta delegate/proxy, o tipo de proxy, o período de atraso se um foi especificado e o valor total em bond de todos os seus proxies, expresso em Planck.</p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-accounts-section", "title": "Usando a Seção Accounts", "text": "<p>Você também pode verificar suas contas proxy na seção Accounts do portal do desenvolvedor. Para isso, navegue até a página Accounts e siga estes passos:</p> <ol> <li>Clique nos três pontos verticais ao lado da conta primária</li> <li>Selecione Manage proxy</li> </ol> <p>Note</p> <p>Deve haver um símbolo de proxy próximo à conta primária. Para o mesmo efeito, passe o mouse sobre o ícone e clique em Manage proxies.</p> <p></p> <p>Uma janela pop-up aparecerá onde você pode ver uma visão geral das suas contas proxy.</p> <p></p>"}, {"location": "node-operators/operators/operational-tasks/proxy-accounts/#execute-a-proxy-transaction", "title": "Executar uma Transação via Proxy", "text": "<p>Agora que você criou uma conta proxy e verificou que ela foi configurada com sucesso, pode executar uma transação usando o proxy em nome da sua conta primária. O exemplo a seguir define chaves para um nó. A configuração de proxy exibida é um exemplo realista de como você pode configurar seu próprio proxy para sua conta primária no portal do desenvolvedor.</p> <p>Para executar uma transação, volte à página Extrinsics e siga estes passos:</p> <ol> <li>Selecione a conta proxy em using the select account para enviar a transação</li> <li>No menu submit the following extrinsic, selecione proxy</li> <li>Escolha o extrínseco proxy</li> <li>Em AccountIdLookupOf, selecione Id</li> <li>No menu real, selecione a conta primária</li> <li>Selecione a chamada Session</li> <li>Escolha a entrada setKeys</li> <li>Insira as chaves do nó que deseja mapear para a conta de operator</li> <li>Insira <code>0x</code> em proof</li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Uma janela pop-up solicitará que você autorize e assine a transação; clique em Sign and Submit.</p> <p>Pronto! Você executou uma transação usando uma conta proxy em nome da sua conta de operator primária.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/", "title": "Atualizar um Node Operator", "text": "<p>Manter seu nó atualizado é fundamental para manter a compatibilidade com as últimas alterações do protocolo Tanssi e garantir o desempenho ideal. Nós desatualizados podem levar à dessincronização, redução de eficiência ou até mesmo à incapacidade de participar do protocolo. Ao se manter atualizado com os lançamentos de clientes, você pode garantir que seu nó opere com segurança e confiabilidade dentro da rede.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/#explore-o-que-esta-secao-aborda", "title": "Explore o Que Esta Seção Aborda", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/", "title": "Atualize Seu Nó em Execução via Docker", "text": ""}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#introduction", "title": "Introdução", "text": "<p>A manutenção do seu nó atualizado é uma parte importante de ser um operator Tanssi. Isso não apenas ajuda a garantir que seu nó permaneça em bom estado, mas também contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualização do seu node operator Tanssi que foi configurado usando o Docker. Ele pressupõe que você já configurou sua conta e lançou um node operator usando o Systemd.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes", "title": "Atualizando Nós Docker", "text": "<p>A atualização do seu nó é tão simples quanto parar o contêiner em execução e reiniciá-lo com a nova tag de versão.</p> <p>Primeiro, obtenha o ID do contêiner do seu node operator Tanssi com o seguinte comando:</p> <pre><code>docker ps -a\n</code></pre> <p>O ID do contêiner é a primeira coluna e, se você estiver executando vários contêineres Docker, poderá identificá-lo pelo nome da imagem <code>moondancelabs/starlight</code>. Você pode executar o comando de parada da seguinte forma:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>A sua interação com o terminal se assemelhará ao seguinte:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/dancelight-chain:2 \"/chain-network/tans…\" 56 seconds ago  Up 56 seconds             determined_darwin      docker stop aa751703d6aa  aa751703d6aa    <p>Para reiniciar o nó, use o mesmo comando que usou ao iniciá-lo pela primeira vez. O comando fará o pull da imagem e o nó retomará a sincronização de blocos de onde parou quando o processo Docker foi interrompido.</p> Tanssi MainNetDancelight TestNet GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag", "title": "Especifique uma Tag de Versão", "text": "<p>Para usar uma tag de versão específica, anexe-a ao nome da imagem. Por exemplo, para obter a versão marcada como <code>latest</code> (que é o padrão), anexe <code>:latest</code> a <code>moondancelabs/starlight</code>.</p> <p>E é só isso! Você atualizou com sucesso seu nó Tanssi.</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/", "title": "Atualize seu Nó em Execução via Systemd", "text": ""}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction", "title": "Introdução", "text": "<p>A manutenção do seu nó atualizado é uma parte importante de ser um operator Tanssi. Isso não só ajuda a garantir que seu nó permaneça saudável, mas também contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualização do seu node operator Tanssi que foi configurado usando o Systemd. Ele pressupõe que você já configurou sua conta e iniciou um node operator usando Systemd.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node", "title": "Atualizando Seu Nó Systemd", "text": "<p>Se você estiver executando seu operator via o serviço Systemd, você deve tomar medidas para atualizar seu nó corretamente. Em resumo, você precisará parar o serviço, substituir o binário Tanssi pela versão atualizada e reiniciar o serviço.</p> <p>Você pode parar seu serviço Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Em seguida, navegue até o diretório onde seus binários Tanssi são armazenados e remova-os.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>Se você não alterou os nomes de arquivo binários Tanssi, eles serão nomeados <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code>. Caso contrário, você pode substituir <code>tanssi-relay*</code> no comando abaixo pelos nomes corretos de seus arquivos binários Tanssi.</p> <pre><code>rm tanssi-relay*\n</code></pre> <p>Para baixar a versão mais recente e alterar as permissões para que o serviço Tanssi possa usá-la, execute o comando correspondente ao seu ambiente:</p> GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <p>Você pode reiniciar seu serviço Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>O nó retomará a sincronização de blocos de onde parou quando o serviço Systemd foi interrompido. Para verificar se está funcionando corretamente, você pode usar o seguinte comando para verificar os logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>E é isso! Você atualizou com sucesso seu nó Tanssi.</p>"}, {"location": "node-operators/sequencers/", "title": "Sequencers Tanssi", "text": "<p>Os Sequencers desempenham um papel fundamental na manutenção da atividade e do desempenho do ecossistema Tanssi. Eles são responsáveis por produzir blocos, executar transações e garantir o bom funcionamento da rede. Esta seção fornece tudo o que você precisa para começar, desde a configuração inicial até as melhores práticas operacionais e o gerenciamento de contas.</p>"}, {"location": "node-operators/sequencers/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/offboarding/", "title": "Desativação", "text": "<p>A desativação como Sequencer requer seguir os procedimentos adequados para garantir uma transição tranquila. Esta seção fornece instruções claras para remover suas chaves de sessão e cancelar a delegação de sua participação auto-vinculada, permitindo que você recupere seus fundos com segurança e desconecte sua conta da rede.</p> <p>O que você aprenderá:</p> <ul> <li>Removendo sua autodelegação - etapas para remover sua participação auto-vinculada e garantir que seu Sequencer não seja mais listado como participante elegível</li> <li>Removendo as chaves de sessão - como remover suas chaves de sessão, interrompendo adequadamente a conexão entre seu nó e sua conta</li> </ul> <p>Retornando como um Sequencer</p> <p>Se você decidir retornar como um Sequencer Tanssi no futuro, poderá embarcar novamente facilmente seguindo as etapas descritas no guia Onboarding.</p>"}, {"location": "node-operators/sequencers/offboarding/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/offboarding/account/", "title": "Sair como um Sequencer Tanssi", "text": ""}, {"location": "node-operators/sequencers/offboarding/account/#introduction", "title": "Introdução", "text": "<p>Aos Sequencers, pode chegar o momento de sair graciosamente da rede. A desativação da sua conta envolve um processo de duas etapas para garantir que seu nó seja devidamente dissociado da sua conta e que você receba sua garantia de volta.</p> <p>Este guia mostrará como encerrar suas operações como um Sequencer Tanssi corretamente. Isso inclui a não delegação de sua autodelegação para reaver sua garantia e o desmapeamento de suas chaves de sessão para cortar a conexão entre seu nó e sua conta. Naturalmente, este guia assume que você é um Sequencer Tanssi existente com um nó Sequencer e chaves de sessão mapeadas.</p>"}, {"location": "node-operators/sequencers/offboarding/account/#request-undelegation", "title": "Solicitar a Não Delegação", "text": "<p>Ao configurar seu Sequencer Tanssi, você precisou enviar uma garantia de delegação (pelo menos <code>10000</code> TANSSI para Tanssi MainNet). Para recebê-la de volta e remover seu Sequencer da lista de candidatos elegíveis, você precisará seguir etapas semelhantes às do processo de integração.</p>"}, {"location": "node-operators/sequencers/offboarding/account/#viewing-existing-stake", "title": "Visualizar a Participação Existente", "text": "<p>Antes de não delegar, é útil primeiro ver quanto você apostou, pois precisará fornecer esse valor mais tarde. Para fazer isso, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=_blank}, clique na aba Desenvolvedor, selecione Estado da Cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o módulo pooledStaking</li> <li>Selecione a consulta pools</li> <li>Insira sua conta de Sequencer</li> <li>Certifique-se de que o controle deslizante include option esteja ativado</li> <li>No campo option, você seleciona JoiningShares</li> <li>Clique no botão + ao lado do campo extrínseco </li> </ol> <p>Observe que JoiningShares retorna apenas o valor inicial que você delegou ao configurar seu Sequencer. Para obter o valor total apostado, você precisará repetir as etapas acima para ManualRewardShares ou ManualRewardSharesHeldStake se você não selecionou Autocompounding, e AutoCompoundingShares ou AutoCompoundingSharesHeldStake se você configurou Autocompounding. Em seguida, adicione seu valor de ações de autocompounding ou manuais ao JoiningShares para obter sua delegação total pendente.</p> <p>Como exemplo, a participação total de um Sequencer de autocompounding pode ser calculada adicionando JoiningShares a AutoCompoundingShares. Observe esse valor, pois você precisará dele na próxima seção.</p>"}, {"location": "node-operators/sequencers/offboarding/account/#submit-undelegation-request", "title": "Enviar Solicitação de Não Delegação", "text": "<p>Acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Extrínsecos no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione a conta de onde você deseja enviar a transação. Esta conta deve ser sua conta de Sequencer existente que você inicialmente delegou</li> <li>Selecione o módulo pooledStaking</li> <li>Selecione o extrínseco requestUndelegate</li> <li>Insira sua conta, que é, novamente, a mesma conta da qual você está enviando o extrínseco e a conta que você deseja desativar como um Sequencer</li> <li>Escolha o pool de destino que você usou originalmente ao configurar sua delegação ( Autocompounding ou Manual)</li> <li>Selecione Stake ou Shares no menu suspenso</li> <li>Insira a quantia a ser removida da aposta. Se você selecionou Shares, basta inserir o número de Shares. Se você selecionou Stake, precisará enviar o valor, incluindo as doze casas decimais usadas pela Rede Tanssi. Como lembrete, o valor mínimo da aposta é <code>10000</code> TANSSI. Se você delegou o valor mínimo e não acumulou recompensas adicionais, precisará inserir <code>10000000000000000</code></li> <li>Clique em Enviar Transação e assine e envie a transação de sua carteira</li> </ol> <p></p>"}, {"location": "node-operators/sequencers/offboarding/account/#execute-pending-request", "title": "Executar a Solicitação Pendente", "text": "<p>Você precisará esperar antes de executar a solicitação pendente. No caso da Tanssi MainNet, o período de espera é configurado para pelo menos two sessões. Cada sessão é composta por <code>3600</code> blocos e se traduz em cerca de 6 hora por sessão. Portanto, two sessões correspondem a aproximadamente twelve horas.</p> <p>Antes de executar a solicitação pendente, você precisará recuperar a sessão na qual enviou a solicitação para delegar. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o módulo pooledStaking</li> <li>Selecione a consulta pendingOperations</li> <li>Insira sua conta de Sequencer</li> <li>Desative o controle deslizante include option</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A solicitação pendente será exibida na parte inferior da página </li> </ol> <p>No exemplo na imagem acima, a solicitação de não delegação para sair do pool de autocompounding foi enviada durante a sessão <code>5.037</code>. Portanto, a solicitação pode ser executada a partir da sessão <code>5.039</code>. Anote a operação e o índice da sessão em que você enviou a solicitação, pois você precisará de ambos os valores para executar a solicitação pendente.</p> <p>Você pode executar outra consulta na página Estado da cadeia para verificar a sessão atual. Para fazer isso, você pode:</p> <ol> <li>Selecione o módulo session</li> <li>Selecione a consulta currentIndex</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A sessão atual será exibida na parte inferior da página</li> </ol> <p></p> <p>Se pelo menos duas sessões se passaram desde a sessão em que você enviou o extrínseco, a solicitação estará pronta para ser executada. Para fazer isso, selecione Extrínsecos no menu suspenso Desenvolvedor e siga estas etapas:</p> <ol> <li>Selecione a conta da qual você deseja enviar o extrínseco</li> <li>Selecione o módulo pooledStaking</li> <li>Selecione o extrínseco executePendingOperations</li> <li>Para delegator, insira sua conta, que é a mesma conta da qual você enviou a solicitação de autodelegação</li> <li>Para operation, selecione Leaving</li> <li>Para candidate, insira a mesma conta que você fez no campo delegator</li> <li>Para at, insira o índice da sessão em que você enviou a solicitação de delegado</li> <li>Clique em Enviar Transação e assine e envie a transação de sua carteira</li> </ol> <p></p>"}, {"location": "node-operators/sequencers/offboarding/account/#verify", "title": "Verifique se Sua Conta Não Está na Lista de Candidatos Elegíveis", "text": "<p>Se você quiser, pode verificar se seu Sequencer não está mais na lista de candidatos elegíveis. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o módulo pooledStaking e a consulta sortedEligibleCandidates</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>Uma lista dos candidatos elegíveis e suas apostas será exibida na parte inferior da página. Você pode pesquisar seu endereço para garantir que ele não exista na lista </li> </ol>"}, {"location": "node-operators/sequencers/offboarding/account/#unmap-session-keys", "title": "Desmapear Chaves de Sessão", "text": "<p>As chaves de sessão são usadas para realizar operações de rede, como assinar blocos, enquanto sua conta de Sequencer mantém os fundos apostados e tem uma identidade na cadeia. Ao desmapear a chave de sessão para sua conta, você interrompe a associação entre sua conta de Sequencer e seu nó de Sequencer.</p> <p>A etapa de desmapeamento é tomada apenas como parte do processo de desativação. Se você precisar girar/alterar suas chaves de sessão, precisará seguir a geração e mapeamento de novas chaves de sessão. Você não deve remover suas chaves durante o processo de rotação da chave de sessão.</p> <p>Para desmapear suas chaves de sessão, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Extrínsecos no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione sua conta de Sequencer Tanssi</li> <li>Selecione o módulo session</li> <li>Selecione o extrínseco purgeKeys</li> <li>Clique em Enviar Transação e assine e envie a transação de sua carteira</li> </ol> <p></p> <p>Usando o método <code>session.keyOwner</code>, você pode verificar se suas chaves de sessão foram desmapeadas de sua conta conforme o esperado. Para fazer isso no portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o módulo session</li> <li>Selecione a consulta keyOwner</li> <li>Insira <code>nmbs</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira suas chaves de sessão codificadas em hexadecimal</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A consulta não deve retornar nada</li> </ol> <p></p> <p>E é isso! Você desativou com sucesso um Sequencer Tanssi. Se mudar de ideia a qualquer momento e quiser se integrar novamente como um Sequencer Tanssi, você pode seguir as etapas no guia de integração.</p>"}, {"location": "node-operators/sequencers/onboarding/", "title": "Onboarding", "text": "<p>A sua jornada como um Sequencer começa aqui. Siga estes passos para configurar o seu nó e preparar a sua conta para a participação ativa na rede Tanssi.</p> <p>Executar um sequenciador</p> <p>Configure o nó usando Systemd ou Docker.</p> <p>Configurar sua conta</p> <p>Mapeie sua conta para as chaves de sessão do seu nó.</p> <p>Autodelegar ativos</p> <p>Delegue ativos para a sua própria conta para se tornar elegível a sequenciamento.</p> <p>Configurar uma identidade on-chain</p> <p>Crie uma identidade para melhorar a visibilidade e o reconhecimento do seu sequenciador.</p>"}, {"location": "node-operators/sequencers/onboarding/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/", "title": "Configure Sua Conta para Produzir Blocos na Tanssi", "text": ""}, {"location": "node-operators/sequencers/onboarding/account-setup/#introduction", "title": "Introdução", "text": "<p>Antes de começar a produzir blocos em redes powered by Tanssi, você precisará configurar sua conta e estabelecer sua elegibilidade.</p> <p>Você deve ter iniciado um nó Sequencer para realizar as etapas de configuração da conta neste guia.</p> <p>Você precisará configurar sua conta gerando chaves de sessão e mapeando essas chaves de sessão para sua conta. Esta conta é aquela para a qual os delegadores escolherão delegar e onde suas recompensas serão distribuídas. Opcionalmente, você pode configurar uma conta proxy para segurança adicional.</p> <p>Para estabelecer a elegibilidade, você deve se delegar como um Sequencer e atender aos requisitos mínimos de garantia.</p> <p>Seguindo as etapas descritas neste guia, você aprenderá tudo o que precisa saber para começar a produzir blocos no ecossistema Tanssi.</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#important-variables", "title": "Variáveis Importantes", "text": "<p>Ao estabelecer a elegibilidade para produzir blocos, existem algumas variáveis a serem observadas:</p> <ul> <li>Autodelegação mínima - há um valor mínimo que você deve autodelegar para ser considerado elegível</li> <li>Sessão - um período que tem um conjunto constante de Sequencers</li> <li>Sequencers de rede por sessão - o número de Sequencers atribuídos a uma rede powered by Tanssi por sessão</li> </ul> Tanssi MainNet Variável Valor Autodelegação mínima 10000 TANSSI Sessão 3600 blocos Sequencers de rede por sessão 5 Sequencers Dancelight TestNet Variável Valor Autodelegação mínima 10000 STAR Sessão 3600 blocos Sequencers de rede por sessão 2 Sequencers"}, {"location": "node-operators/sequencers/onboarding/account-setup/#map-account", "title": "Mapear uma conta para seu nó Sequencer", "text": "<p>A primeira etapa é um processo de duas etapas que gera chaves de sessão e mapeia as chaves de sessão para sua conta. As chaves de sessão são usadas para realizar operações de rede, como assinar blocos, enquanto sua conta mantém os fundos apostados e tem uma identidade na cadeia. Ao mapear a chave de sessão para sua conta, você cria uma associação entre sua conta e seu Sequencer.</p> <p>Você precisará criar chaves de sessão para seus servidores primário e de backup. Cada um de seus servidores, seu primário e de backup, deve ter suas próprias chaves exclusivas. Como as chaves nunca saem de seus servidores, você pode considerá-las um ID exclusivo para aquele servidor.</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#generate-session-keys", "title": "Gerar chaves de sessão", "text": "<p>Antes de gerar chaves de sessão, você deve estar executando um nó Sequencer.</p> <p>Para gerar chaves de sessão, você enviará uma chamada RPC, usando o método <code>author_rotateKeys</code>, para o endpoint HTTP do seu nó. Como referência, se o endpoint HTTP do seu Sequencer estiver na porta <code>9945</code>, a chamada JSON-RPC pode ter esta aparência:</p> <pre><code>\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Suas chaves de sessão codificadas em hexadecimal serão impressas no terminal no campo <code>\"result\"</code>.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"result\":    \"0x76afaf334bd33b82d0b8fbd6a2845cb3b9b785edf1dce4ccefd4973fa79fed2b\",\"id\":1} <p>Certifique-se de anotar suas chaves de sessão; você precisará mapear suas chaves de sessão para sua conta na próxima seção.</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#map-session-keys", "title": "Mapear chaves de sessão", "text": "<p>Para executar a próxima etapa e mapear suas chaves de sessão para sua conta, acesse o portal do desenvolvedor, clique na aba Developer, selecione Extrinsics no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione sua conta, que deve ser a mesma conta que você autodelegou anteriormente</li> <li>Selecione o módulo session e o extrínseco setKeys</li> <li>Para keys, insira suas chaves de sessão</li> <li>Para proof, insira <code>0x</code></li> <li>Clique em Submit Transaction e assine e envie a transação de sua carteira</li> </ol> <p></p> <p>Usando o método <code>session.keyOwner</code>, você pode verificar se suas chaves de sessão foram mapeadas para sua conta conforme o esperado. Para fazer isso no portal do desenvolvedor, clique na aba Developer, selecione Chain state no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione o módulo session e a consulta keyOwner</li> <li>Insira <code>nmbs</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira suas chaves de sessão codificadas em hexadecimal</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A conta associada às chaves de sessão, que deve ser sua conta, será exibida na parte inferior da página</li> </ol> <p></p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#submit-self-delegation", "title": "Enviar Autodelegação", "text": "<p>A próxima etapa para se tornar elegível para produzir blocos em redes powered by Tanssi é delegar à sua própria conta. Para fazer isso, você precisará enviar um mínimo de tokens, conforme listado na seção variáveis importantes.</p> <p>Depois de enviar a solicitação para delegar, você precisará esperar um mínimo de sessões antes de poder executar a solicitação pendente. No caso da Tanssi MainNet, o número de sessões é configurado para two. Existem 3600 blocos em uma sessão. Portanto, two sessões são 7200 blocos, o que pode levar cerca de twelve horas.</p> <p>Os Sequencers são atribuídos a cada sessão. Os Sequencers que participam da sessão são escolhidos da lista de candidatos ordenada por participação total até que o número total de Sequencers necessários seja coberto. Portanto, você precisará garantir que sua participação total seja suficiente para preencher um dos slots, o que pode exigir mais do que a autodelegação mínima.</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#request-delegate", "title": "Solicitar Delegado", "text": "<p>Acesse o portal do desenvolvedor, clique na aba Developer, selecione Extrinsics no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione a conta da qual você deseja enviar a transação. Esta conta deve ser a mesma conta para a qual você está delegando e é a conta que você deseja se tornar um Sequencer</li> <li>Selecione o módulo pooledStaking e o extrínseco requestDelegate</li> <li>Insira sua conta, que é, novamente, a mesma conta da qual você está enviando a transação e a conta que você deseja se tornar um Sequencer</li> <li>Escolha o pool de destino. O pool pode ser o pool de composição automática, que compõe automaticamente as recompensas de delegação, ou o pool de recompensas manuais, no qual todas as ações relacionadas às recompensas são manuais</li> <li>Insira o valor a ser apostado. Este valor deve atender ao mínimo, que é 10000 TANSSI tokens para Tanssi MainNet. A Tanssi Network usa doze casas decimais, portanto, ao enviar o valor, certifique-se de adicionar as casas decimais à autodelegação. Para MainNet, o valor seria <code>10000000000000000</code></li> <li>Clique em Submit Transaction e assine e envie a transação de sua carteira </li> </ol>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#execute-pending-request", "title": "Executar a solicitação pendente", "text": "<p>Antes de executar a solicitação pendente, você precisará recuperar a sessão na qual você enviou a solicitação para delegar. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Developer, selecione Chain state no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione o módulo pooledStaking e a consulta pendingOperations</li> <li>Insira sua conta</li> <li>Desative o controle deslizante include option</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A solicitação pendente será exibida na parte inferior da página</li> </ol> <p></p> <p>No exemplo da imagem acima, a solicitação de delegação para ingressar no pool de composição automática foi enviada durante a sessão 4.829. Portanto, a solicitação pode ser executada a partir da sessão 4.831.</p> <p>Anote a operação e o número da sessão em que você enviou a solicitação, pois você precisará de ambos os valores para executar a solicitação pendente.</p> <p>Você pode executar outra consulta na página Chain state para verificar a sessão atual. Para fazer isso, você pode:</p> <ol> <li>Selecione o módulo session e a consulta currentIndex</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>A sessão atual será exibida na parte inferior da página</li> </ol> <p></p> <p>Se a solicitação puder ser executada, selecione Extrinsics no menu suspenso Developer e siga as etapas a seguir:</p> <ol> <li>Selecione a conta da qual você deseja enviar a transação</li> <li>Selecione o módulo pooledStaking e a transação executePendingOperations</li> <li>Para delegator, insira sua conta, que é a mesma conta da qual você enviou a solicitação de autodelegação</li> <li>Para operation, selecione o tipo de operação a ser executada. Este deve ser JoiningAutoCompounding ou JoiningManualRewards, dependendo do pool de destino selecionado no momento do envio da solicitação de autodelegação</li> <li>Para candidate, insira a mesma conta que você fez no campo delegator</li> <li>Para at, insira o id da sessão em que você enviou a solicitação de delegação</li> <li>Clique em Submit Transaction e assine e envie a transação de sua carteira</li> </ol> <p></p> <p>Agora, você concluiu toda a configuração da conta necessária para ser elegível para produzir blocos!</p>"}, {"location": "node-operators/sequencers/onboarding/account-setup/#verify", "title": "Verifique se Sua Conta Está na Lista de Candidatos Elegíveis", "text": "<p>Se você seguiu todas as etapas deste guia e sincronizou totalmente seu Sequencer, agora você está elegível para produzir blocos. Para verificar se você está na lista de candidatos elegíveis, você pode acessar o portal do desenvolvedor, clicar na aba Developer, selecionar Chain state no menu suspenso e seguir as etapas a seguir:</p> <ol> <li>Selecione o módulo pooledStaking e a consulta sortedEligibleCandidates</li> <li>Clique no botão + ao lado do campo extrínseco</li> <li>Uma lista dos candidatos elegíveis e sua participação será exibida na parte inferior da página. Você pode pesquisar seu endereço para garantir que está qualificado para produzir blocos</li> </ol> <p></p> <p>Lembre-se que você precisará estar entre os principais candidatos por participação total para produzir blocos, e isso se baseia no número de Sequencers necessários para cada rede e Tanssi.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/", "title": "Executar um Nó Sequencer", "text": "<p>A configuração de um nó Sequencer é um passo importante para participar da rede Tanssi. Você tem duas opções: Docker ou Systemd. Seja qual for o caminho escolhido, fornecemos tutoriais passo a passo para orientá-lo durante o processo e garantir que seu nó atenda aos requisitos necessários para produzir blocos e manter uma conexão segura com a rede.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/#requisitos-de-hardware", "title": "Requisitos de Hardware", "text": "<p>Para executar um nó Sequencer com sucesso, o uso de hardware de alto desempenho é essencial. Configurações subótimas podem levar a atrasos, rodadas de autoria perdidas e perda de recompensas. Como a produção e o processo de importação de blocos dependem fortemente do desempenho de um único thread, recomenda-se priorizar CPUs com fortes capacidades de thread único em vez de contagens de núcleos mais altas.</p> <p>Hardware Recomendado:</p> <ul> <li>CPUs Recomendadas - Intel Xeon E-2386/2388 ou Ryzen 9 5950x/5900x</li> <li>NVMe Recomendado - 1 TB NVMe</li> <li>RAM Recomendada - 32 GB RAM</li> </ul> <p>Warning</p> <p>Como um Sequencer, você é responsável por sua própria participação e pela de seus delegadores. Manter o desempenho do seu nó, mantê-lo atualizado e garantir sua segurança são essenciais para maximizar as recompensas e construir uma forte reputação na rede Tanssi.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/#portas-de-rede-necessarias", "title": "Portas de Rede Necessárias", "text": "<p>Para produção de blocos bem-sucedida, seu nó deve sincronizar e interagir com duas redes peer-to-peer (P2P). Para garantir a comunicação adequada dentro do ecossistema Tanssi, certifique-se de que as seguintes portas estejam abertas para entrada:</p> Rede Porta Tanssi Chain 30334 (TCP) Rede Designada 30333 (TCP)"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/", "title": "Executar um Sequencer em Tanssi Usando Docker", "text": ""}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#introduction", "title": "Introdução", "text": "<p>Uma das principais propostas do Tanssi é oferecer produção de blocos descentralizada e sem confiança para suas redes. O runtime do Tanssi gerencia a atribuição de sequenciadores para todas as redes ativas no ecossistema.</p> <p>O algoritmo de atribuição distribui o conjunto disponível de sequenciadores a cada sessão, designando-os para uma cadeia aleatória. Assim, eles produzem blocos para a mesma rede por um período relativamente curto, aumentando a segurança geral do ecossistema.</p> <p>Para isso, o binário do Tanssi (software usado para rodar nós) já possui um mecanismo embutido que alterna automaticamente a produção de blocos para a cadeia designada sem exigir alterações do operador. O binário inclui a lógica para sincronizar a nova cadeia e produzir blocos quando a sessão muda. Portanto, os sequenciadores precisam executar o binário do Tanssi, e não o das redes individuais (como fazem os nós completos).</p> <p>Neste guia, você aprenderá como iniciar um Sequencer Tanssi para fazer parte do pool compartilhado de Sequencers usando Docker em um computador Linux. No entanto, ele pode ser adaptado a outros sistemas operacionais.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": ""}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#installing-docker", "title": "Instalando o Docker", "text": "<p>Para começar, você precisará de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instalação:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execução bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#pulling-docker-image", "title": "Puxando a Imagem Docker", "text": "<p>Uma imagem Docker é construída e publicada em cada lançamento, contendo todas as dependências necessárias que um Sequencer Tanssi precisa e o próprio arquivo binário.</p> <p>Uma imagem Docker combina o binário correspondente à versão estável mais recente do nó cliente, junto com o arquivo de especificação do orquestrador Tanssi.</p> <p>O seguinte comando para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <p>O comando fará o download e extrairá a imagem e mostrará o status após a execução:</p> docker pull moondancelabs/tanssi  Using default tag: latest      latest: Pulling from moondancelabs/tanssi      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       d9dcf3cddfc5: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/tanssi      docker.io/moondancelabs/tanssi"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#download-tanssi-specs", "title": "Baixar o arquivo de especificação da cadeia Tanssi", "text": "<p>O binário do nó também inclui o código necessário para executar um nó da cadeia de orquestração do Tanssi. Ao iniciar um sequenciador, é necessário fornecer o arquivo de especificação dessa cadeia como parâmetro.</p> <p>Baixe o arquivo de especificação da cadeia de orquestração Tanssi executando:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#setup-data-directory", "title": "Configurar o diretório de dados", "text": "<p>Executar um sequenciador ou um nó de appchain exige sincronizar duas cadeias: a cadeia de orquestração do Tanssi e a appchain para a qual ele trabalha.</p> <p>Crie o diretório onde o nó armazenará os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando abaixo se quiser rodar o sequenciador com o usuário logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diretório é um parâmetro no comando de inicialização do Docker. Se optar por criar o diretório em outro lugar, ajuste o comando.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#generate-node-key", "title": "Gerar a Chave do Nó", "text": "<p>A partir da versão runtime 700, os nós sequenciadores do Tanssi não geram as chaves de sessão automaticamente na inicialização. Para gerar e armazenar em disco as chaves de sessão que serão referenciadas no comando de start, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#start-up-command", "title": "Comando de Inicialização", "text": "<p>Para iniciar seu nó, você deve executar a imagem Docker com o comando <code>docker run</code>.</p> <p>Observe que o comando contém duas seções, divididas por <code>-- \\</code>:</p> <ul> <li>Seção do protocolo Tanssi - contém os flags para executar o nó Tanssi</li> <li>Seção do Sequencer - contém os flags para executar o nó Sequencer. É abstrato o suficiente para ser adaptado dinamicamente em Runtime à cadeia específica que o nó servirá</li> </ul> <p>Dê um nome legível a cada seção, substituindo as tags <code>INSERT_YOUR_TANSSI_NODE_NAME</code> e <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> nos flags <code>--name</code>. Esses nomes serão úteis para conectar as entradas de registro e as métricas com o nó que as gera.</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#run-flags", "title": "Flags de Execução", "text": "<p>Os flags usados no comando <code>docker run</code> podem ser ajustados de acordo com suas preferências e configuração de hardware. Os seguintes são alguns dos mais notáveis:</p> <ul> <li><code>--name INSERT_NAME</code> - nome legível para este nó</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o nó ouve</li> <li><code>--unsafe-rpc-external</code> - expõe o serviço RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (nó atua como completo mantendo todo o estado), <code>archive-canonical</code> (mantém apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados serão mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (nó completo mantendo todos os blocos), <code>archive-canonical</code> (mantém apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita saída detalhada de logs</li> </ul> <p>Warning</p> <p>O parâmetro <code>--unsafe-rpc-external</code> permite acesso externo à interface RPC do seu nó, tornando-a acessível de qualquer endereço IP. Certifique-se de que controles de segurança adequados estejam configurados.</p> <p>Para ver a lista completa de flags disponíveis, descrição e valores possíveis, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run moondancelabs/tanssi --help\n</code></pre> <pre><code>docker run moondancelabs/tanssi --help\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#syncing-your-node", "title": "Sincronizando Seu Nó", "text": "<p>A primeira vez que seu nó é iniciado, o processo de sincronização exibe muitas informações de registro da configuração do nó e do próprio nó. Alguns erros devem ser exibidos no início do processo, desaparecendo assim que a cadeia é sincronizada com o último bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] 💤 Idle (0 peers), best: #0 (0x4a2b…7de3), finalized #0 (0x4a2b…7de3), ⬇ 0 ⬆ 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] ✨ Imported #14139635 (0x8c41…8df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] 💤 Idle (8 peers), best: #14139635 (0x8c41…8df6), finalized #14139632 (0xa9a8…cab9), ⬇ 32.7kiB/s ⬆    <p>Quando a sincronização com o orquestrador Tanssi for concluída, o nó ainda precisará ser sincronizado com a rede a que foi designado. A sincronização com a cadeia servida pelo nó Sequencer acontecerá toda vez que o Sequencer for rotacionado.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/", "title": "Executar um Nó de Sequencer com Systemd", "text": ""}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#introduction", "title": "Introdução", "text": "<p>Uma das principais propostas do Tanssi é oferecer produção de blocos descentralizada e sem confiança para suas redes. O runtime do Tanssi gerencia a atribuição de sequenciadores para todas as redes ativas no ecossistema.</p> <p>O algoritmo de atribuição distribui o conjunto disponível de sequenciadores a cada sessão, designando-os para uma cadeia aleatória. Assim, eles produzem blocos para a mesma rede por um período relativamente curto, aumentando a segurança geral do ecossistema.</p> <p>Para isso, o binário do Tanssi (software usado para rodar nós) já possui um mecanismo embutido que alterna automaticamente a produção de blocos para a cadeia designada sem exigir alterações do operador. O binário inclui a lógica para sincronizar a nova cadeia e produzir blocos quando a sessão muda. Portanto, os sequenciadores precisam executar o binário do Tanssi, e não o das redes individuais (como fazem os nós completos).</p> <p>Neste guia, você aprenderá como iniciar um Sequencer Tanssi para fazer parte do pool compartilhado de Sequencers usando o binário estável mais recente e gerenciando o serviço com Systemd em sistemas Linux.</p> <p>O artigo segue a boa prática de executar o serviço com uma conta não root e conceder a essa conta acesso de escrita a um diretório específico. Você pode adaptar as etapas e instruções deste artigo à configuração da sua infraestrutura, preferências e políticas de segurança.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#checking-prerequisites", "title": "Verificando os Pré-requisitos", "text": "<p>Para começar, você precisará de um computador executando Ubuntu Linux com privilégios de root. Você também precisará de:</p> <ul> <li>Arquivo binário do nó - as instruções neste guia executam a versão estável mais recente oficial do <code>tanssi-node</code>. No entanto, você pode compilar seu próprio arquivo a partir do código-fonte</li> <li>Arquivo de especificação da rede Tanssi - o arquivo de especificação pode ser baixado deste repositório público do GitHub</li> </ul>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-latest-release", "title": "Baixar a Última Versão", "text": "<p>Para começar, faça o download e torne executável a versão mais recente do binário executando o seguinte comando:</p> <p>Note</p> <p>Recomenda-se usar as versões binárias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-tanssi-specs", "title": "Baixar o arquivo de especificação da cadeia Tanssi", "text": "<p>O binário do nó também inclui o código necessário para executar um nó da cadeia de orquestração do Tanssi. Ao iniciar um sequenciador, é necessário fornecer o arquivo de especificação dessa cadeia como parâmetro.</p> <p>Baixe o arquivo de especificação da cadeia de orquestração Tanssi executando:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#setup-systemd-service", "title": "Configurar o serviço Systemd", "text": "<p>O Systemd é um sistema de gerenciamento para Linux que controla serviços (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.</p> <p>Os comandos a seguir configuram uma nova conta, o diretório e movem os arquivos baixados para o local correto.</p> <p>Crie uma nova conta para executar o serviço:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Crie um diretório para armazenar os arquivos e dados necessários:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Defina a propriedade da pasta para a conta que executará o serviço, garantindo permissão de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Mova o arquivo de especificação da cadeia para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Por fim, mova o binário para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-node /var/lib/dancelight-data\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#generate-node-key", "title": "Gerar a Chave do Nó", "text": "<p>A partir da versão runtime 700, os nós sequenciadores do Tanssi não geram as chaves de sessão automaticamente na inicialização. Para gerar e armazenar em disco as chaves de sessão que serão referenciadas no comando de start, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o parâmetro <code>--unsafe-force-node-key-generation</code> no comando de inicialização, embora essa não seja a prática recomendada.</p>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#create-systemd-configuration", "title": "Criar o Arquivo de Configuração do Systemd", "text": "<p>O próximo passo é criar o arquivo de configuração do Systemd.</p> <p>Você pode criar o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor de texto favorito (vim, emacs, nano etc.) e adicione a configuração do serviço, substituindo as tags <code>INSERT_YOUR_TANSSI_NODE_NAME</code> e <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> por nomes legíveis nos flags <code>--name</code>. Esses nomes ajudam a conectar entradas de log e métricas ao nó que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/tanssi-data/container \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/tanssi-data/relay \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--keystore-path=/var/lib/tanssi-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Dancelight systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/dancelight-data/container \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/dancelight-data/relay \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--keystore-path=/var/lib/dancelight-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-flags", "title": "Flags de Execução", "text": "<p>Os flags usados no comando <code>ExecStart</code> podem ser ajustados conforme suas preferências e configuração de hardware. Alguns dos mais importantes são:</p> <ul> <li><code>--name INSERT_NAME</code> - nome legível para este nó</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o nó ouve</li> <li><code>--unsafe-rpc-external</code> - expõe o serviço RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (nó atua como completo mantendo todo o estado), <code>archive-canonical</code> (mantém apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados serão mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (nó completo mantendo todos os blocos), <code>archive-canonical</code> (mantém apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita saída detalhada de logs</li> </ul> <p>Warning</p> <p>O parâmetro <code>--unsafe-rpc-external</code> permite acesso externo à interface RPC do seu nó, tornando-a acessível de qualquer endereço IP. Certifique-se de que controles de segurança adequados estejam configurados.</p> <p>Para ver a lista completa de flags disponíveis, descrição e valores possíveis, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node  --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node  --help\n</code></pre>"}, {"location": "node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-the-service", "title": "Executar o Serviço", "text": "<p>Por fim, habilite o serviço e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Você pode verificar se o serviço está em execução corretamente:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> <p>Se precisar verificar os logs, use:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"}, {"location": "node-operators/sequencers/operational-tasks/", "title": "Tarefa Operacional", "text": "<p>Manter seu Sequencer em funcionamento é mais do que apenas a configuração - requer manutenção regular para garantir desempenho consistente e gerenciamento seguro de suas contas. As atualizações regulares são essenciais para manter seu nó compatível com as últimas mudanças do protocolo Tanssi, enquanto ferramentas como contas proxy fornecem uma camada extra de segurança, permitindo que você delegue certas tarefas sem expor suas credenciais de conta primárias. Esta seção fornece os passos necessários para manter suas operações tranquilas, confiáveis e seguras.</p>"}, {"location": "node-operators/sequencers/operational-tasks/#explore-esta-secao", "title": "Explore Esta Seção", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/", "title": "Configurar uma Conta Proxy", "text": ""}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/#introduction", "title": "Introdução", "text": "<p>Contas proxy podem ser configuradas para realizar um número limitado de ações em nome de contas primárias e ajudar a manter as contas subjacentes seguras. Como Sequencer na Tanssi, é uma boa ideia aproveitar as contas proxy para interagir com a rede em vez de sua conta Sequencera.</p> <p>O tipo de proxy de staking permite convenientemente que a conta proxy gerencie atividades de staking, como delegar e rotacionar chaves de sessão, em nome da conta Sequencera primária, transformando-a efetivamente em uma \"hot wallet\" para realizar tarefas regulares de manutenção em nome de sua conta Sequencera \"cold wallet\". Para maior segurança, você pode rotacionar regularmente a conta proxy.</p> <p>Contas proxy também podem ajudá-lo a implementar o princípio de privilégio mínimo para controle de acesso. Por exemplo, se você tiver vários membros da equipe, poderá fornecer a eles o acesso mínimo necessário para realizar suas tarefas por meio de uma conta proxy específica.</p> <p>Este tutorial irá guiá-lo pela configuração de uma conta proxy de staking no Dancelight especificamente para operações como um Sequencer. Em seguida, demonstrará como iniciar uma delegação usando o novo proxy de staking criado.</p>"}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/#checking-prerequisites", "title": "Verificando Pré-requisitos", "text": "<p>Para acompanhar este tutorial, você precisará ter:</p> <ul> <li>O portal do desenvolvedor aberto e conectado ao Dancelight</li> <li>Criar ou ter duas contas acessíveis no portal do desenvolvedor</li> <li>Ambas as contas precisarão ser financiadas, e a conta do Sequencer precisará de pelo menos a autodelegação mínima necessária para se tornar um Sequencer ativo (10000 STAR para Dancelight)</li> </ul> <p>Se você precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia Conectando-se ao Portal do Desenvolvedor.</p>"}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/#creating-a-staking-proxy-account", "title": "Criando uma Conta Proxy de Staking", "text": "<p>Há algumas maneiras de criar contas proxy no portal do desenvolvedor, seja na página Extrinsics ou na página Accounts. No entanto, para criar um proxy com atraso de tempo, você precisará usar a página Extrinsics. Um atraso de tempo fornece uma camada adicional de segurança aos proxies, especificando um período de atraso com base no número de blocos. Isso impedirá que a conta proxy execute uma transação até que o período de atraso termine. O atraso dá tempo para que a conta primária que controla o proxy revise as transações pendentes e fornece um período limitado de tempo para cancelar quaisquer ações.</p> <p>Você também tem a opção de criar um proxy do tipo Any, que concede à conta proxy controle total e irrestrito sobre a conta primária. Isso significa que a conta proxy pode transferir fundos e realizar qualquer ação arbitrária. A demonstração a seguir mostrará como configurar um proxy Staking, que é mais restritivo do que um proxy Any, pois limita as funções às atividades relacionadas ao staking, como delegar, não delegar e mapear chaves de sessão.</p> <p>Para começar a criar sua conta proxy, vá para a aba Developer e selecione Extrinsics no menu suspenso. Em seguida, você precisará seguir as seguintes etapas:</p> <ol> <li>Selecione a conta primária</li> <li>No menu suspenso submit the following extrinsic, selecione proxy</li> <li>Escolha a extrínseca addProxy</li> <li>Escolha Id no menu suspenso AccountIdLookupOf</li> <li>Selecione a conta de delegate para o proxy</li> <li>No menu suspenso proxyType, escolha Staking</li> <li>Opcionalmente, você pode adicionar um atraso de tempo usando um número especificado de blocos para adicionar uma camada adicional de segurança para que a conta primária revise a transação pendente</li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Você será solicitado a autorizar e assinar a transação. Clique em Sign and Submit para criar o relacionamento proxy. Depois que a transação for enviada com sucesso, você receberá algumas notificações confirmando a transação.</p> <p>Como mencionado anteriormente, você também pode criar um proxy na página Accounts. Para fazer isso, navegue até a página Accounts e siga as seguintes etapas:</p> <ol> <li>Selecione os três pontos verticais próximos à conta primária</li> <li>Selecione Add proxy</li> </ol> <p></p> <p>Note</p> <p>Se a conta já tiver um proxy, Manage proxies será exibido como uma opção em vez de Add proxy.</p> <p>Uma janela pop-up aparecerá e você poderá inserir as informações necessárias, como a conta proxy/primária, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em Add proxy.</p> <p></p> <p>Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione a conta que você gostaria de definir como um proxy</li> <li>Selecione o tipo de proxy</li> <li>Clique em Submit e assine a transação</li> </ol> <p></p> <p>Na próxima seção, você aprenderá como verificar se sua conta proxy foi configurada com sucesso.</p>"}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/#verifying-your-proxy-account", "title": "Verificando Sua Conta Proxy", "text": "<p>Você pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: ou na página Accounts ou na página Chain state.</p> <p>Para verificar suas contas proxy na página Chain state, você pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso selected state query, selecione proxy</li> <li>Escolha a extrínseca proxies</li> <li>Selecione sua conta primária/proxy</li> <li>Clique no botão + para enviar a consulta</li> </ol> <p></p> <p>O resultado aparecerá na página mostrando informações sobre todos os seus proxies, incluindo o endereço da conta delegate/proxy, o tipo de proxy, o período de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.</p> <p>Você também pode verificar suas contas proxy na página Accounts. Para fazer isso, navegue até a página Accounts e deve haver um símbolo de Proxy ao lado da conta primária. Passe o mouse sobre o ícone e clique em Manage proxies para revisar seus proxies.</p> <p></p> <p>Uma janela pop-up aparecerá onde você pode ver uma visão geral de todas as suas contas proxy.</p> <p></p>"}, {"location": "node-operators/sequencers/operational-tasks/proxy-accounts/#executing-a-proxy-transaction", "title": "Executando uma Transação Proxy", "text": "<p>Agora que você criou uma conta proxy e verificou que ela foi configurada com sucesso, você pode executar uma transação usando a conta proxy de staking em nome de sua conta Sequencera, também conhecida como conta primária ou conta que está sendo proxyada. O exemplo a seguir demonstrará como iniciar uma autodelegação. A configuração de proxy mostrada é um exemplo realista de como você pode ter seu próprio proxy configurado para sua conta primária do portal do desenvolvedor.</p> <p>Para executar uma transação, você pode navegar de volta para a página Extrinsics e seguir as seguintes etapas:</p> <ol> <li>Selecione a conta proxy para enviar a transação no menu suspenso using the select account</li> <li>No menu submit the following extrinsic, selecione proxy</li> <li>Escolha a extrínseca proxy</li> <li>Escolha Id no menu suspenso AccountIdLookupOf</li> <li>Selecione a conta primária no menu suspenso real</li> <li>Selecione a chamada pooledStaking</li> <li>Escolha a extrínseca requestDelegate</li> <li>Digite o endereço do candidate, que é a conta do Sequencer</li> <li>Selecione AutoCompounding ou ManualRewards no campo pool</li> <li>Digite o valor a ser apostado. Esse valor deve atender ao mínimo, que, para Dancelight, é 10000 STAR tokens. Você precisará enviar o valor incluindo as doze casas decimais que a Tanssi Network usa, portanto, para um valor de 10000, você precisará digitar <code>10000000000000000</code></li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Uma janela pop-up aparecerá para que você autorize e assine a transação. Digite sua senha para a conta proxy e clique em Sign and Submit. Para confirmar a solicitação de delegação, você precisará executar a solicitação pendente após duas sessões. Consulte as instruções para executar solicitações pendentes para obter um guia passo a passo. Você também pode mapear suas chaves de sessão para sua conta de Sequencer via proxy.</p> <p>Depois de mapear suas chaves de sessão e executar a solicitação de delegação pendente, você pode verificar se seu Sequencer está na lista de candidatos elegíveis.</p> <p>É isso! Você executou com sucesso uma transação usando uma conta proxy em nome de sua conta Sequencera primária.</p>    {{ trans(\"disclaimer.third_party\") }}"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/", "title": "Atualizar Nó de Sequencers", "text": "<p>A manutenção do seu nó atualizado é fundamental para manter a compatibilidade com as últimas alterações do protocolo Tanssi e garantir o desempenho ideal. Nós desatualizados podem levar à dessincronização, redução da eficiência ou até mesmo à incapacidade de participar da produção de blocos. Ao manter-se atualizado com os lançamentos de clientes, você pode garantir que seu nó opere de forma segura e confiável na rede.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/#explore-o-que-esta-secao-cobre", "title": "Explore o Que Esta Seção Cobre", "text": "<p>:::INSERT_GENERATED_CARDS:::</p>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/", "title": "Atualize seu Nó em Execução via Docker", "text": ""}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#introduction", "title": "Introdução", "text": "<p>Manter seu nó atualizado é uma parte importante de ser um sequencer Tanssi. Não só ajuda a garantir que seu nó sequencer permaneça saudável, mas também contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualização do seu sequencer Tanssi que foi configurado usando o Docker. Ele pressupõe que você já configurou sua conta e lançou um sequencer usando Docker.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes", "title": "Atualizando Nós Docker", "text": "<p>Se você estiver executando seu sequencer com o Docker, atualizar seu nó é tão simples quanto parar o contêiner em execução e reiniciá-lo com a nova tag de versão.</p> <p>Primeiro, obtenha a ID do contêiner do seu nó sequencer Tanssi com o seguinte comando:</p> <pre><code>docker ps -a\n</code></pre> <p>A ID do contêiner é a primeira coluna e, se você estiver executando vários contêineres Docker, pode identificá-lo pelo nome da imagem de <code>moondancelabs/tanssi</code>. Você pode executar o comando de parada da seguinte forma:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>A sua interação com o terminal será semelhante ao seguinte:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/tanssi:v0.6.1 \"/tanssi/tanssi-node…\" 56 seconds ago  Up 56 seconds             focused_chaum      docker stop aa751703d6aa  aa751703d6aa    <p>Para reiniciar o nó, você pode usar o mesmo comando que usou ao iniciar seu nó pela primeira vez. O comando extrai a imagem e o nó retomará a sincronização de blocos de onde parou quando o processo Docker foi interrompido.</p> GenéricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-skylake\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-znver3\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag", "title": "Especificando uma Tag de Versão", "text": "<p>Se você quiser especificar uma tag de versão específica, você pode fazer isso substituindo a tag de versão anexada ao nome da imagem. Por exemplo, se você quisesse buscar a versão <code>3</code>, você substituiria o <code>2</code> em <code>moondancelabs/tanssi</code>.</p> <p>E é isso! Você atualizou com sucesso seu nó Tanssi.</p>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/", "title": "Atualize Seu Nó em Execução via Systemd", "text": ""}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction", "title": "Introdução", "text": "<p>Manter seu nó atualizado é uma parte importante de ser um sequencer Tanssi. Isso não só ajuda a garantir que seu nó sequencer permaneça saudável, como também contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualização do seu nó sequencer Tanssi que foi configurado usando o Systemd. Ele pressupõe que você já configurou sua conta e lançou um nó sequencer usando Systemd.</p> <p>Assine as notificações de lançamento</p> <p>Ficar informado sobre novas versões do cliente é essencial para manter o nó atualizado. Os mantenedores do nó podem assinar as notificações do GitHub para serem alertados sobre novas versões.</p> <p>Para assinar, acesse o repositório Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a opção Releases.</p>"}, {"location": "node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node", "title": "Atualizando Seu Nó Systemd", "text": "<p>Se você estiver executando seu sequencer através do serviço Systemd, você precisará seguir algumas etapas para atualizar corretamente seu nó. Em suma, você precisará parar o serviço, substituir o binário Tanssi pela versão atualizada e, em seguida, iniciar o serviço.</p> <p>Você pode parar seu serviço Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Em seguida, navegue até o diretório onde seu binário Tanssi está armazenado e remova-o.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>Seu arquivo binário Tanssi provavelmente será nomeado <code>tanssi-node</code>. Caso contrário, você pode substituir <code>tanssi-node</code> abaixo pelo nome correto do seu arquivo binário Tanssi.</p> <pre><code>rm tanssi-node\n</code></pre> <p>Para baixar a versão mais recente e alterar as permissões para que o serviço Tanssi possa usá-la, execute o seguinte comando que corresponde ao seu ambiente:</p> GenéricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <p>Você pode reiniciar seu serviço Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>O nó retomará a sincronização de blocos de onde parou quando o serviço Systemd foi interrompido. Para verificar se está funcionando corretamente, você pode usar o seguinte comando para verificar os logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>E é isso! Você atualizou seu nó Tanssi com sucesso.</p>"}]}