{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ai-resources/ai-resources/","title":"AI Resources","text":"<p>Tanssi provides <code>.txt</code> files containing the documentation content and navigation structure, optimized for use with large language models (LLMs) and AI tools. These resources help build AI assistants, power code search, or enable custom tooling trained on Tanssi\u2019s documentation.</p> <p>Each category file includes foundational content from the Basics and Reference categories to ensure LLMs have the necessary context.</p>"},{"location":"ai-resources/ai-resources/#download-llm-files","title":"Download LLM Files","text":"Category Description File Actions Index Navigation index of all Tanssi documentation pages <code>llms.txt</code> Full Documentation Full content of all documentation pages <code>llms-full.txt</code> Basics Tanssi's framework, architecture, and core components to help form overall general knowledge base <code>llms-basics.txt</code> Reference Reference material including network endpoints, JSON RPC methods, and contract or token addresses <code>llms-reference.txt</code> Appchain How to launch and manage an appchain through the dApp or the developer portal <code>llms-appchain.txt</code> Custom Runtime Customize your appchain runtime <code>llms-custom-runtime.txt</code> EVM Template Use the EVM template for launching complete Ethereum-compatible appchains and know their associated tooling (wallet, integrations, etc.) <code>llms-evm-template.txt</code> Substrate Template Use the baseline Substrate template and associated tooling (wallets, integrations, etc.) for launching appchains <code>llms-substrate-template.txt</code> Operators How to set up and run a node to secure the Tanssi ecosystem <code>llms-operators.txt</code> Sequencers How to run a sequencer to provide appchains with block production services <code>llms-sequencers.txt</code> <p>Note</p> <p>The <code>llms-full.txt</code> file may exceed the input limits of some language models due to its size. If you encounter limitations, consider using the files by category.</p>"},{"location":"builders/","title":"Builders","text":"<p>Explore everything you need to build, deploy, and manage networks within the Tanssi ecosystem. From development tools to account management and network connectivity, the content in this section enables you to move confidently from concept to implementation.</p>"},{"location":"builders/#build-a-tanssi-powered-network","title":"Build a Tanssi-Powered NetworkWhere to Start?Customize Your Network","text":"<ul> <li> <p>  Build a network from scratch using a template</p> <p> Configure an existing Substrate-based runtime to be Tanssi compatible</p> </li> <li> <p>  Leverage preexisting modules to add functionality</p> <p> Create your own custom module</p> <p> Integrate external modules from other providers</p> </li> </ul>"},{"location":"builders/#deploy-and-manage-a-tanssi-powered-network","title":"Deploy and Manage a Tanssi-Powered NetworkReady to Deploy?Post-Deployment Actions","text":"<ul> <li> <p>  Deploy your network with the Tanssi dApp</p> </li> <li> <p>  Pay for block production services</p> <p> Mint tokens for your network's economy</p> <p> Manage the Sudo account for administrative control</p> </li> </ul>"},{"location":"builders/#interact-with-a-tanssi-powered-network","title":"Interact with a Tanssi-Powered NetworkTanssi Network ReferencesTools for Tanssi Network Development","text":"<ul> <li> <p>  Access network endpoints</p> </li> <li> <p>  Explore tools for Ethereum API integration</p> <p> Leverage Substrate tools for advanced network control</p> <p> Enhance functionality of your app with integrations</p> </li> </ul>"},{"location":"builders/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/account-management/","title":"Account Management","text":"<p>On-chain account management gives users and developers greater flexibility and control over how their accounts interact with a decentralized network. You can fine-tune your account configurations for seamless integration within the ecosystem by managing roles, permissions, and identities directly on-chain.</p> <p>This section outlines some of the tools and features related to account management.</p>"},{"location":"builders/account-management/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/account-management/identity/","title":"Set Up an On-Chain Identity","text":""},{"location":"builders/account-management/identity/#introduction","title":"Introduction","text":"<p>The Substrate Identity module is an out-of-the-box solution for adding personal information to your on-chain account. Establishing an identity makes it easier for your account to be recognized by others, as your display name will automatically populate when someone pastes your address into a field on the developer portal.</p> <p>The identity you configure goes beyond a simple display name. Personal information can include default fields such as your legal name, display name, website, Twitter handle, Discord, and Riot (now known as Element) name. You can also use custom fields to include any other relevant information.</p> <p>This guide will demonstrate setting up an identity with a display name and additional parameters, enhancing your visibility and recognizability.</p>"},{"location":"builders/account-management/identity/#general-definitions","title":"General Definitions","text":"<p>To store your information on-chain, you must bond some funds, which will eventually be returned once the identity has been cleared. There are two categories of fields: default and custom. A basic deposit amount is reserved upon identity creation, and a storage deposit is required for each additional byte of data stored on-chain.</p> <ul> <li> <p>Default fields include - your legal name, display name, website, Twitter handle, Discord, Riot (now known as Element) name</p> </li> <li> <p>Custom fields include - any other relevant information</p> </li> <li> <p>Subaccounts - You can link subaccounts underneath a primary account. As an example, a sequencer service that's running multiple different sequencer nodes can establish subaccounts to demonstrate an official link between the nodes</p> </li> </ul> Tanssi MainNetDancelight TestNet Variable Definition Value Basic deposit The amount held on deposit for setting an identity 0.33333333 TANSSI Deposit per byte The amount held on deposit per byte of on-chain storage used setting an identity 0.0001 TANSSI Max additional fields Maximum number of additional fields that may be stored in an ID 100 Max subaccounts Maximum number of subaccounts that can be defined under an account identity 100 Variable Definition Value Basic deposit The amount held on deposit for setting an identity 0.33333333 STAR Deposit per byte The amount held on deposit per byte of on-chain storage used setting an identity 0.0001 STAR Max additional fields Maximum number of additional fields that may be stored in an ID 100 Max subaccounts Maximum number of subaccounts that can be defined under an account identity 100"},{"location":"builders/account-management/identity/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this guide, you will need the following:</p> Tanssi MainNetDancelight TestNet <ul> <li>The developer portal open and connected to Tanssi MainNet.</li> <li>At least one account funded with <code>TANSSI</code> tokens.</li> </ul> <ul> <li>The developer portal open and connected to Dancelight.</li> <li>At least one account funded with <code>STAR</code> tokens.</li> </ul> <p>If you need help importing your accounts into the developer portal, please check out the Connecting to the developer portal guide.</p>"},{"location":"builders/account-management/identity/#get-started","title":"Get Started","text":"<p>Depending on the information to be included, there are a couple of different ways to set and clear an identity using the developer portal. If you intend to register your identity using only the default fields, you can follow the instructions for Managing an Identity via the Accounts page. This is the recommended way to set and manage your identity.</p> <p>If you want to add custom fields beyond the default fields, follow the instructions for Managing an Identity via the Extrinsics page.</p> <p>Note</p> <p>Please note that using the Accounts page on the developer portal is recommended to manage your identity as it provides an easy-to-use interface that enforces character limits. If you use the Extrinsics page, please be aware that your input for each field (i.e., name, email, etc.) must be 32 characters or less; otherwise, your information will be cut off.</p>"},{"location":"builders/account-management/identity/#manage-via-accounts","title":"Manage an Identity via Accounts","text":""},{"location":"builders/account-management/identity/#set-identity-accounts","title":"Set an Identity","text":"<p>To get started with setting an identity using the Accounts page, head to the Accounts tab of the developer portal.</p> <p>You should already have an account connected, so you can click on your account name to verify and note your balances. After you send the transaction to set an identity, the deposit(s) you submitted will be moved from your transferable balance to your reserved balance.</p> <p></p> <p>To set your identity, you'll need to:</p> <ol> <li>Click on the three vertical dots next to the account you would like to set an identity for</li> <li>A menu will pop up. Click Set on-chain identity</li> </ol> <p></p> <p>Next, the menu to register and set your identity will pop up, and you can start filling in your information. You are not required to enter information for every single field; you can choose to fill in just one field or all of them; it's up to you. For this example:</p> <ol> <li>Set your display name</li> <li>Click on the include field toggle for email and then enter in your email</li> <li>Click on the include field toggle for web and then enter in your website URL</li> <li>Click on the include field toggle for Twitter and then enter in your Twitter handle</li> <li>Review the prior data fields and click Set Identity</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, sign it.</p> <p>You should see status notifications pop up in the top right-hand corner. Once the transaction has been confirmed, you can click on your account name again, and the panel will slide out on the right side of the page. Your balances will have changed, and you'll also see your new identity information.</p> <p></p> <p>If the identity information matches what you entered, you've successfully set an identity!</p> <p>Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to change your identity, you can go through the process of setting your identity again. Please note that you must ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"builders/account-management/identity/#manage-via-extrinsics","title":"Manage an Identity via Extrinsics","text":""},{"location":"builders/account-management/identity/#set-identity-extrinsics","title":"Set an Identity","text":"<p>To register an identity using the extrinsics page, navigate to the Extrinsics page of the developer portal. Please ensure your input does not exceed 32 characters for each identity field. To complete your identity, take the following steps:</p> <ol> <li>Select your account</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the setIdentity(info) function</li> <li>Select Raw as the data format to enter your Display Name</li> <li>Enter the data for Display in the selected format</li> <li>Select Raw as the data format to enter your web address</li> <li>Enter your website URL in the selected format</li> <li>Select Raw as the data format to enter your email</li> <li>Enter your email address in the selected format</li> <li>Select Raw as the data format to enter your Twitter handle</li> <li>Enter your Twitter in the selected format. Enter the username only, starting with the <code>@</code> symbol</li> <li>Review the prepared fields and press Submit Transaction</li> </ol> <p></p> <p>Optionally, if you would like to enter custom fields, take the following steps:</p> <ol> <li>Scroll to the top and click on Add item</li> <li>Two fields will appear: the first for the field name and the second for the value. Select Raw as the data format to enter the field name</li> <li>Enter the field name in the specified format</li> <li>Select Raw as the data format to enter the custom value</li> <li>Enter the custom value in the specified format</li> </ol> <p></p> <p>Finally, once all of your identity information has been added, you can scroll to the bottom of the page and click Submit Transaction.</p> <p>You will then be prompted to sign the transaction. Remember, an additional deposit is required for each additional custom field. If everything looks good, sign the transaction.</p> <p>You should see status notifications pop up in the top right-hand corner confirming the transaction. If successful, you've set an identity! Congratulations! To ensure everything went through and your identity information looks good, you can verify your identity.</p>"},{"location":"builders/account-management/identity/#confirm-identity-extrinsics","title":"Confirm an Identity","text":"<p>To verify the addition of your identity information, you can click on the Developer tab and then navigate to Chain state.</p> <p>On the Chain State page, make sure Storage is selected. Then you can start to request your identity information:</p> <ol> <li>Set selected state query to identity</li> <li>Select the identityOf(AccountId) function</li> <li>Select your account</li> <li>Click the + button to get your identity information</li> </ol> <p></p> <p>You can see now that you've successfully set an identity! Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to change your identity, you can go through the process of setting your identity again. Please note that you must ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit unless custom fields are used, but you will need to pay gas fees.</p>"},{"location":"builders/account-management/identity/#confirm-identity-extrinsics","title":"Clear an Identity","text":"<p>To clear your identity, take the following steps from Extrinsics tab of the developer portal:</p> <ol> <li>Select your account from the using the selected account dropdown</li> <li>Select identity from the submit the following extrinsic dropdown</li> <li>Then select the clearIdentity() function</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to sign the transaction. If everything looks good, sign it. You should see status notifications in the top right-hand corner confirming the transaction.</p> <p>To confirm that your identity information has been successfully removed, revisit the steps outlined in the Confirm an Identity section. This time, instead of displaying your identity details, the response should indicate none, confirming that no identity information is currently linked to your account. Additionally, when you check your balances, you will find that the deposit initially made for setting your identity has been credited back to your transferable balance. This completes the process of clearing your identity.</p> <p></p>"},{"location":"builders/account-management/proxy-accounts/","title":"Proxy Accounts","text":""},{"location":"builders/account-management/proxy-accounts/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and are helpful for keeping the underlying accounts safe. Your proxy account can act as a \"hot wallet\" to interact with the network on behalf of your \"cold wallet\" account. For added safety, you can regularly rotate the proxy account. </p> <p>Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum level of access required to carry out their duties via a specific type of proxy account. </p> <p>This tutorial will walk you through configuring a proxy account on Dancelight, the Tanssi TestNet, specifically for balance transfers. Then, it will demonstrate performing a balance transfer using the newly created proxy.</p>"},{"location":"builders/account-management/proxy-accounts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>Polkadot.js Apps open and connected to Dancelight.</li> <li>Create or have two accounts accessible on the developer portal.</li> <li>At least one of the accounts will need to be funded with <code>STAR</code> tokens.</li> </ul> <p>If you need help importing your accounts into Polkadot.js Apps, please check out the Connecting to Polkadot.js guide.</p>"},{"location":"builders/account-management/proxy-accounts/#general-definitions","title":"General Definitions","text":"<p>When setting up a proxy account, a bond for the proxy is taken out of your free balance and moved to your reserved balance. The bond is required as adding a proxy requires on-chain storage space, and it is recalculated for each proxy you add or remove. The bond is returned to your free balance after all proxies are removed from your account.</p> <p>The deposit is calculated based on a deposit base and a deposit factor:</p> <ul> <li>Deposit base - the amount to be reserved for an account to have a proxy list.</li> <li>Deposit factor - the additional amount to be reserved for every proxy the primary account has.</li> </ul> <p>The equation for calculating the deposit is:</p> <pre><code>deposit base + deposit factor * number of proxies\n</code></pre> <p>You can find each of the relevant variables below.</p> Tanssi MainNetDancelight TestNet Variable Value Deposit base 0.1008 TANSSI Deposit factor 0.0033 TANSSI Max proxies 32 proxies Variable Value Deposit base 0.1008 STAR Deposit factor 0.0033 STAR Max proxies 32 proxies"},{"location":"builders/account-management/proxy-accounts/#proxy-types","title":"Proxy Types","text":"<p>When creating a proxy account, you must choose a type of proxy that will define how the proxy can be used. The available options are:</p> <ul> <li><code>Any</code> - allows the proxy account to use any function supported by the proxy pallet. There is no filtering of calls.</li> <li><code>NonTransfer</code> - this type of proxy account is allowed to submit any type of transaction with the exception of balance transfers.</li> <li><code>Balances</code> - allows the proxy account to only make transactions related to sending funds.</li> <li><code>Governance</code> - allows the proxy account to only make transactions related to the governance pallet, such as voting or creating democracy proposals. Note, governance is not yet enabled on Tanssi. You can create governance proxy accounts but they will not be able to take any actions until governance is enabled. </li> <li><code>Registrar</code> - allows the proxy account to only make transactions related to the registrar pallet.</li> <li><code>SudoRegistrar</code> - allows the proxy account to only make transactions related to the registrar pallet that need to be called by Sudo.</li> <li><code>CancelProxy</code> - allows the proxy account to reject and remove any announced proxy calls.</li> <li><code>Staking</code> - allows the proxy account to perform staking-related transactions, such as sequencer and <code>session()</code> functions.</li> <li><code>SessionKeyManagement</code> - allows the proxy account to make key management related transactions included in the session pallet.</li> </ul> <p>For this guide, you will be setting up a proxy account using the balances proxy type. Since this type enables the proxy to spend funds on behalf of the primary account, you should exercise caution and only provide access to accounts you trust. The proxy will have access to transfer all of the funds within the primary account, and if not trusted, the proxy could drain the primary account. Ensure that you maintain oversight of your proxy accounts and remove any proxies that are no longer needed.</p>"},{"location":"builders/account-management/proxy-accounts/#creating-a-proxy-account","title":"Creating a Proxy Account","text":"<p>There are a couple of ways you can create proxy accounts in Polkadot.js Apps, either from the Extrinsics page or the Accounts page. However, to create a time-delayed proxy, you will need to use the Extrinsics page. A time delay provides an additional layer of security to proxies by specifying a delay period based on the number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions, potentially for malicious actions, and cancel if necessary before execution.</p> <p>The following demo will showcase configuring a Balances proxy, which allows for transferring funds, making it perfect for demonstration purposes. After configuring your Balances proxy you can try transferring funds from the primary account via proxy. </p> <p>To get started creating your proxy account, head to the Developer tab and select Extrinsics from the dropdown. Next, you will need to take the following steps:</p> <ol> <li>Select the primary account.</li> <li>From the submit the following extrinsic dropdown, select proxy.</li> <li>Choose the addProxy extrinsic.</li> <li>Choose Id from the AccountIdLookupOf dropdown.</li> <li>Select the delegate account for the proxy.</li> <li>From the proxyType dropdown, choose Balances.</li> <li>Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction.</li> <li>Click Submit Transaction.</li> </ol> <p></p> <p>You will then be prompted to authorize and sign the transaction. Click Sign and Submit to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.</p> <p>As previously mentioned, you can also create a proxy from the Accounts page. To do so, navigate to the Accounts page and take the following steps:</p> <ol> <li>Select the three vertical dots next to the primary account.</li> <li>Select Add proxy.</li> </ol> <p></p> <p>Note</p> <p>If the account already has a proxy, Manage proxies will be displayed as an option instead of Add proxy.</p> <p>A pop-up will appear and you can enter in the required information, such as the proxied/primary account, the proxy account, and type of proxy to create a proxy account. First click Add Proxy.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Select the account you would like to set as a proxy.</li> <li>Select the proxy type.</li> <li>Click Submit and sign the transaction.</li> </ol> <p></p> <p>In the next section, you will learn how to verify that your proxy account was set up successfully.</p>"},{"location":"builders/account-management/proxy-accounts/#verifying-your-proxy-account","title":"Verifying Your Proxy Account","text":"<p>You can verify that your proxy account has been successfully set up in a couple of ways: either through the Accounts page or via the Chain state page.</p> <p>To check your proxy accounts from the Chain state page, you can take the following steps:</p> <ol> <li>From the selected state query dropdown, select proxy.</li> <li>Choose the proxies extrinsic.</li> <li>Select your primary/proxied account.</li> <li>Click on the + button to send the query.</li> </ol> <p></p> <p>The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Planck.</p> <p>You can also check your proxy accounts from the Accounts page. To do so, navigate to the Accounts page, and there should be a Proxy symbol next to the primary account. Hover over the icon and click on Manage proxies to review your proxies.</p> <p></p> <p>A pop-up will appear where you can see an overview of all of your proxy accounts.</p> <p></p>"},{"location":"builders/account-management/proxy-accounts/#executing-a-proxy-transaction","title":"Executing a Proxy Transaction","text":"<p>Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy account on behalf of the primary account.</p> <p>To execute a transaction, you can navigate back to the Extrinsics page and take the following steps:</p> <ol> <li>Select the proxy account to submit the transaction from the using the select account dropdown.</li> <li>From the submit the following extrinsic menu, select proxy.</li> <li>Choose the proxy extrinsic.</li> <li>Choose Id from the AccountIdLookupOf dropdown.</li> <li>Select the primary account from the real dropdown.</li> <li>Select the balances call.</li> <li>Choose the transferKeepAlive extrinsic.</li> <li>Choose Id from the AccountIdLookupOf dropdown.</li> <li>In the dest field, enter the address you would like to send funds to.</li> <li>In the value field, enter the amount of STAR tokens to send. For this example, you can send <code>2</code> STAR tokens.</li> <li>Click Submit Transaction.</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click Sign and Submit.</p> <p>If the transaction successfully went through, you should see a couple of notification pop-ups. If you head over to the Accounts page, you'll see that your primary account balance has decreased. If you check the account balance where you sent the funds, you'll notice the balance there has increased.</p> <p></p> <p>That's it! You've successfully executed a transaction using a proxy account on behalf of your primary account.</p>"},{"location":"builders/account-management/proxy-accounts/#removing-a-proxy-account","title":"Removing a Proxy Account","text":"<p>Similarly to adding a proxy account, there are a couple of ways that you can remove a proxy account, either from the Extrinsics page or the Accounts page. Regardless of which page you use, you can elect to remove a single proxy account or all proxies associated with your primary account.</p> <p>To remove a proxy from the Extrinsics page, you can take the following steps:</p> <ol> <li>From the using the selected account dropdown, select your primary account.</li> <li>Then select proxy.</li> <li>Choose removeProxy to remove a single proxy or removeProxies to remove all associated proxies.</li> <li>Choose Id from the AccountIdLookupOf dropdown.</li> <li>If removing a single proxy, enter the proxy account to remove in the delegate field.</li> <li>Select the proxyType to remove, in this case choose Balances.</li> <li>Optionally, select a delay period in block numbers.</li> <li>Click Submit Transaction.</li> </ol> <p></p> <p>A pop-up will appear asking you to authorize and sign the transaction. You can sign and send the transaction from the primary or proxy account, but the call to remove the proxy must be sent from the primary account. Enter your password and click Sign and Submit.</p> <p>To check that the proxy or proxy accounts have been removed, follow the steps in the Verifying your Proxy Account section.</p> <p>As previously mentioned, you can also remove a proxy from the Accounts page. To do so, on the Accounts page, select the three vertical dots next to the primary account and select Manage Proxies.</p> <p></p> <p>A pop-up will appear showing an overview of your proxy accounts. To remove all proxies, you can click on Clear all, then you will automatically be prompted to enter your password and submit the transaction. To remove a single proxy, take the following steps:</p> <ol> <li>Click the X button next to the proxy to remove</li> <li>Press Submit</li> </ol> <p></p> <p>On the transaction confirmation screen, take the following steps:</p> <ol> <li>Ensure that you do not use a proxy for this call (as this example is a balances proxy, the call to remove the proxy needs to come from the primary account rather than the proxy account).</li> <li>Enter your password for the respective account.</li> <li>Press Sign and Submit.</li> </ol> <p></p> <p>Once the transaction has successfully been submitted, you can review your current proxies, or if you removed all proxies, you will notice the proxy icon is no longer being displayed next to the primary account. And that's it! You've successfully created a proxy, reviewed all proxy accounts associated with your primary account, executed a proxy transaction, and removed a proxy account!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/build/","title":"Build Your Network","text":"<p>Launching your Tanssi-powered network gives you the flexibility to choose between pre-configured templates or fully customized solutions. Whether you're aiming for simplicity or fine-tuned control, Tanssi provides the tools and guidance to bring your vision to life. This section covers everything from selecting a template to customizing modules, testing, and deploying your network.</p>"},{"location":"builders/build/#the-path-to-deployment","title":"The Path to Deployment","text":"<p>Deploying a network with Tanssi can be straightforward or highly customizable, depending on your requirements. The diagram below provides a clear breakdown of these options to guide your decision.</p> <pre><code>flowchart TD\n    Start[Choose a template]\n    Start --&gt; Path1[Template is sufficient]\n    Start --&gt; Path2[Template needs customization]\n\n    Path1 --&gt; Deploy1[Deploy via Tanssi dApp]\n\n    Path2 --&gt; Fork[Fork the Tanssi repository]\n    Fork --&gt; Customize[Customize your network]\n    Customize --&gt; Test[Run tests]\n    Test --&gt; Deploy2[Deploy via Tanssi dApp]</code></pre> <p>Now that you\u2019ve explored the deployment paths, the next step is to learn more about each template so you can choose the one that best fits your needs.</p>"},{"location":"builders/build/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/build/customize/","title":"Customize Your Tanssi-Powered Network","text":"<p>Tailor your network to meet your application's unique requirements. This section provides guidance on modifying and extending your network's functionality, offering instructions and best practices to help align it with your project's goals.</p>"},{"location":"builders/build/customize/#process-for-customizing-your-network","title":"Process for Customizing Your Network","text":"<p>The diagram below provides a simplified outline of the essential steps to get started with building and customizing your Tanssi-powered network.</p> <pre><code>flowchart LR\n    A[Install software prerequisites] --&gt; B[Create and add modules]\n    B --&gt; C[Customize and generate chain specs]</code></pre> <p>To proceed, check out the following section where you can find detailed, step-by-step guides for each of these stages.</p>"},{"location":"builders/build/customize/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/build/customize/adding-built-in-module/","title":"Adding a Built-in Module","text":""},{"location":"builders/build/customize/adding-built-in-module/#introduction","title":"Introduction","text":"<p>Substrate is a powerful and modular software development framework included in the Polkadot SDKs for building blockchains. It provides a comprehensive set of tools and libraries that abstract complex blockchain functionalities, allowing developers to focus on building innovative features and applications by focusing on the runtime, which contains the core logic and the rules of the state transition for the use case.</p> <p>What sets Substrate apart is its modular architecture, which enables the seamless integration of built-in modules and the creation of custom ones, facilitating the development of blockchain protocols.</p> <p>For cases requiring only EVM (Ethereum Virtual Machine) compatibility, the template provided in the Tanssi repository fulfills the requirements without further modifications. However, teams aiming to build a Substrate network must add and configure both built-in and custom modules within the runtime. This involves compiling, generating the chain specification, and deploying through the Tanssi protocol to transform it into a live Tanssi-powered network.</p> <p>This article focuses on the necessary steps for adding a built-in module to the EVM template.</p>"},{"location":"builders/build/customize/adding-built-in-module/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow the steps in this guide, you will need to have the following:</p> <ul> <li>A healthy development environment with the Rust compiler and Cargo package manager</li> <li>The Tanssi repository, cloned from GitHub</li> </ul> <p>You can read more about how to install the required components in the prerequisites article.</p> <p>As this article is based on the EVM template, make sure that it compiles correctly before continuing by executing the following command:</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre>"},{"location":"builders/build/customize/adding-built-in-module/#adding-a-built-in-module-to-runtime","title":"Adding a Built-in Module to the Runtime","text":"<p>As introduced in the modularity article, the Substrate framework already includes many built-in modules addressing a wide range of functionalities, ready to be used in your runtime.</p> <p>Modules are meant to provide the functionality needed in very different use cases such as DeFi, NFTs, or any other, and, therefore, they are basic building blocks that are inherently abstract and can be configured according to the specific needs of the Tanssi-powered network.</p> <p>To add a module, the following steps are necessary:</p> <ol> <li>Make the dependency available within the project by declaring it in Cargo, the Rust language package manager</li> <li>Make the standard (<code>std</code>) features of the module available to the compiler</li> <li>Configure the module</li> <li>Add the module to the runtime</li> <li>Add the default configuration to the chain specification</li> </ol> <p>In the following example, the popular Substrate module <code>pallet-assets</code> is added to the runtime of the provided EVM template, found in the Tanssi repository, specifically in the folder <code>container-chains/templates/frontier/</code>.</p>"},{"location":"builders/build/customize/adding-built-in-module/#declare-dependency","title":"Declare the Dependency","text":"<p>Every package contains a manifest file named <code>Cargo.toml</code> stating, among other things, all the dependencies the package relies on, and the Tanssi-powered network runtime is no exception.</p> <p>Therefore, the first step, is to declare the dependency and make it available to the runtime, open the <code>Cargo.toml</code> file located in the folder <code>container-chains/templates/frontier/runtime</code> with a text editor and add the module, referencing the code in the Polkadot SDK:</p> <pre><code>[dependencies]\n...\npallet-assets = { \n   git = \"https://github.com/moondance-labs/polkadot-sdk\", \n   branch = \"tanssi-polkadot-stable2503\", \n   default-features = false \n}\n...\n</code></pre> <p>Note</p> <p>Our engineering team actively contributes to the Substrate development by fixing issues and enhancing functionalities. As a result, the Tanssi fork repository frequently stays ahead of the official one. That is why this example references a built-in module from a Tanssi repository instead of the official one.</p>"},{"location":"builders/build/customize/adding-built-in-module/#standard-features","title":"Make the Standard Features Available to the Compiler","text":"<p>In Cargo, the \u201cfeatures\u201d flags provide a mechanism to tell the compiler to include or leave out certain portions of code, which is a useful mechanism to optimize compile time, minimize binary file sizes, or disable certain behavior (for example, not including unit testing or benchmarking functionality in the runtime intended for production).</p> <p>To compile the standard features for the Assets module within the runtime, the same <code>Cargo.toml</code> file in the <code>runtime</code> folder must be edited, enabling the flag. Everything listed in this section will ensure that it is available to the compiler when building the runtime binary, which is ultimately the file containing all the information to run your Tanssi-powered network initially.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-assets/std\",\n   ...\n]\n</code></pre>"},{"location":"builders/build/customize/adding-built-in-module/#configure-the-module","title":"Configure the Module","text":"<p>With the dependency declared in the project, the module can now be configured and added to the runtime. To do so, you need to edit the <code>lib.rs</code> file that is located at:</p> <pre><code>container-chains/templates/frontier/runtime/src/lib.rs\n</code></pre> <p>The configuration of new modules requires implementing a configuration <code>trait</code> for the module (in this example, for Assets) in the runtime, expressed in Rust as follows:</p> <pre><code>// Implements pallet_assets::Config trait in the runtime\nimpl pallet_assets::Config for Runtime { ... }\n</code></pre> <p>Traits are a way of defining shared behavior in Rust, and in this case, they allow a new runtime to benefit from the functionality the Assets module provides only by implementing its configuration trait and parameters.</p> <p>Some of the parameters the trait needs to define might be constant values, in which case, they have to be defined and enclosed within the macro <code>parameter_types!</code>, which helps us to reduce the development effort by expanding the code and converting each of the constants into the correct struct type with functions that allow the runtime to read its type and values in a standardized way.</p> <p>The following code snippet shows an example of the constant definitions to be used in the configuration of the module:</p> <pre><code>parameter_types! {\n   // The amount of funds that must be reserved for an asset\n    pub const AssetDeposit: Balance = 100;\n   // The amount of funds that must be reserved when creating \n   // a new transfer approval\n    pub const ApprovalDeposit: Balance = 1;\n   // The basic amount of funds that must be reserved when adding metadata \n   // to your asset\n    pub const MetadataDepositBase: Balance = 10;\n   // The additional funds that must be reserved for the number of bytes \n   // you store in your metadata\n    pub const MetadataDepositPerByte: Balance = 1;\n\n   // Maximum length for the asset symbol and friendly name\n   pub const StringLimit: u32 = 50;\n}\n</code></pre> <p>It is important to note that every built-in module has a different purpose, and, therefore, each of them has different needs in terms of the parameters that must be configured. The following code snippet implements the trait and configures the module Assets, using types and the constants defined previously in the <code>parameter_types!</code> macro:</p> <pre><code>// Implementing the Assets config trait for the runtime\nimpl pallet_assets::Config for Runtime {\n\n   // Stores the balances in an unsigned integer of 128bits\n    type Balance = u128;\n   // The id of an asset can be defined as an unsigned integer of 64 bits\n    type AssetId = u64;\n   // Uses module Balances as mechanism for currency operations\n    type Currency = Balances;\n\n   // Configure the module by referencing the previously\n   // defined constants\n\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n   // More configuration\n   ...\n}\n</code></pre> View the complete script <pre><code>parameter_types! {\n    // The amount of funds that must be reserved for an asset\n    pub const AssetDeposit: Balance = 100;\n    // The amount of funds that must be reserved when creating \n    // a new transfer approval\n    pub const ApprovalDeposit: Balance = 1;\n    // The basic amount of funds that must be reserved when adding metadata \n    // to your asset\n    pub const MetadataDepositBase: Balance = 10;\n    // The additional funds that must be reserved for the number of bytes \n    // you store in your metadata\n    pub const MetadataDepositPerByte: Balance = 1;\n    // Maximum lenght for the asset symbol and friendly name\n    pub const StringLimit: u32 = 50;\n}\n\n// Implementing the Assets config trait for the runtime\nimpl pallet_assets::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n\n    // Stores the balances in an unsigned integer of 128bits\n    type Balance = u128;\n    // The id of an asset can be defined as an unsigned integer of 64 bits\n    type AssetId = u64;\n    // Uses module Balances as mechanism for currency operations\n    type Currency = Balances;\n\n    // Configure the module by referencing the previously\n    // defined constants\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n    // More configuration\n    type AssetIdParameter = u64;\n    // Defines the allowed origins to create assets\n    type CreateOrigin = \n        frame_support::traits::AsEnsureOriginWithArg&lt;frame_system::EnsureSigned&lt;AccountId&gt;&gt;;\n    // Root can create assets\n    type ForceOrigin = EnsureRoot&lt;AccountId&gt;;\n    type AssetAccountDeposit = frame_support::traits::ConstU128&lt;1&gt;;\n    type Freezer = ();\n    type Extra = ();\n    type WeightInfo = pallet_assets::weights::SubstrateWeight&lt;Runtime&gt;;\n    type RemoveItemsLimit = frame_support::traits::ConstU32&lt;1000&gt;;\n    #[cfg(feature = \"runtime-benchmarks\")]\n    type BenchmarkHelper = ();\n    type CallbackHandle = ();\n}\n</code></pre> <p>The complete configuration of the module contains more parameters, to view a detailed description of each of them, refer to the official config trait for the Assets module documentation.</p>"},{"location":"builders/build/customize/adding-built-in-module/#add-module-to-runtime","title":"Add the Module to the Runtime","text":"<p>In the same <code>lib.rs</code> file referenced in the previous section, there is a segment enclosed in the macro <code>construct_runtime!()</code>. This is where the pallet must be added to be included in the runtime. Since the example is based on the EVM template, the runtime is already configured to include many modules, including the modules for system support, the modules to add the Ethereum compatibility layer, the modules to support the Tanssi protocol, balances, and now also Assets:</p> <pre><code>construct_runtime!(\n   pub enum Runtime where\n      Block = Block,\n      NodeBlock = opaque::Block,\n      UncheckedExtrinsic = UncheckedExtrinsic,\n   {\n      // System support stuff.\n      System: frame_system = 0,\n      ParachainSystem: cumulus_pallet_parachain_system = 1,\n      Timestamp: pallet_timestamp = 2,\n      ParachainInfo: parachain_info = 3,\n      Sudo: pallet_sudo = 4,\n      Utility: pallet_utility = 5,\n      ...\n      Balances: pallet_balances = 10,\n      // Assets module is added here\n      Assets: pallet_assets = 11,\n      ...\n   }\n</code></pre>"},{"location":"builders/build/customize/adding-built-in-module/#configure-chain-specs","title":"Configure the Module in the Chain Specification","text":"<p>Finally, add the configuration in the chain specification for the genesis state in the file <code>chain_spec.rs</code> located at:</p> <pre><code>container-chains/templates/frontier/node/src/chain_spec.rs\n</code></pre> <p>The function <code>testnet_genesis</code>, presented in the following code snippet, defines the initial state for the modules included in the runtime (such as initial funded accounts, for example). After adding the Assets module, it is necessary to initialize it as well, and in the following example, its default values are defined.</p> <p>More about the chain specification and how to configure it will be covered in the article Customizing Chain Specifications.</p> <pre><code>fn testnet_genesis(\n   endowed_accounts: Vec&lt;AccountId&gt;,\n   id: ParaId,\n   root_key: AccountId,\n) -&gt; container_chain_template_frontier_runtime::GenesisConfig {\n   container_chain_template_frontier_runtime::GenesisConfig {\n      system: container_chain_template_frontier_runtime::SystemConfig {\n         code: container_chain_template_frontier_runtime::WASM_BINARY\n               .expect(\"WASM binary was not build, please build it!\")\n               .to_vec(),\n      },\n      ...\n      // Add the default state for this module in the genesis state\n      assets: Default::default()\n      ...\n   }\n}\n</code></pre> <p>With the module included, this new runtime version has unlocked a new set of functionalities ready to be composed with even more of the Substrate built-in modules or custom-made ones.</p>"},{"location":"builders/build/customize/adding-custom-made-module/","title":"Adding a Custom-Made Module","text":""},{"location":"builders/build/customize/adding-custom-made-module/#introduction","title":"Introduction","text":"<p>By providing a comprehensive library of pre-built modules addressing many common requirements, the framework greatly simplifies the process of building a blockchain and accelerates the deployment and evolution into a Tanssi-powered network. However, addressing an innovative use case usually requires a development effort to fully meet the requirements, and, in Substrate, adding custom logic translates into writing and integrating runtime modules.</p> <p>The example presented in the Modularity article shows a simple lottery module exposing two transactions:</p> <ul> <li>Buy tickets - this function manages a user's entry into the lottery. In essence, it verifies that the participant has a sufficient balance, is not already participating, and takes care of transferring funds to register the user for the lottery</li> <li>Award prize - this function that handles a user entering into the lottery. At a high level, it fetches a pseudo-random number to obtain a winner and handles the award distribution</li> </ul> <p>The implementation of those transactions also uses storage, emits events, defines custom errors, and relies on other modules to handle currency (to charge for the tickets and transfer the total amount to the winner) and randomize the winner selection.</p> <p>In this article, the following steps, necessary to build and add the example module to the runtime, will be covered:</p> <ol> <li>Create the lottery module files (package)</li> <li>Configure the module's dependencies</li> <li>Adding custom logic</li> <li>Configure the runtime with the new module</li> </ol> <p>It is important to note that none of the code presented in this article is intended for production use.</p>"},{"location":"builders/build/customize/adding-custom-made-module/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow the steps in this guide, you will need to have the following:</p> <ul> <li>Clone the Tanssi repository from Github</li> <li>Rust compiler and Cargo package manager</li> </ul> <p>You can read more about how to install Rust and Cargo is in the prerequisites article.</p>"},{"location":"builders/build/customize/adding-custom-made-module/#creating-lottery-module-files","title":"Creating the Lottery Module Files","text":"<p>Before starting your coding process, it's essential to create the files containing your logic. Substrate modules are abstract and intended for reuse across different runtimes with various customizations. To achieve this, you'll use Cargo, Rust's package manager, to create the module as a new package.</p> <p>As mentioned in the prerequisites section, the first step is to clone the Tanssi repository and, from the root folder, navigate to <code>pallets</code>, where the module will be created.</p> <pre><code>cd container-chains/pallets\n</code></pre> <p>Next, create the module package with Cargo:</p> <pre><code>cargo new lottery-example\n</code></pre> <p>By default, Cargo creates the new package in a folder with the provided name (<code>lottery-example</code>, in this case), containing a manifest file, <code>Cargo.toml</code>, and a <code>src</code> folder with a <code>main.rs</code> file. To respect the naming convention used in Substrate, the <code>main.rs</code> file is renamed to <code>lib.rs</code>:</p> <pre><code>mv lottery-example/src/main.rs lottery-example/src/lib.rs\n</code></pre> <p>Once you've executed all the commands, the module is created and ready to contain the custom logic that you'll be adding in the following sections.</p>"},{"location":"builders/build/customize/adding-custom-made-module/#configure-module-dependencies","title":"Configure the Module's Dependencies","text":"<p>Since the module functions as an independent package, it has its own Cargo.toml file where you must specify the module's attributes and dependencies.</p> <p>For instance, you can use attributes to specify details like the module's name, version, authors, and other pertinent information. For example, in the the <code>lottery-example</code> module, the <code>Cargo.toml</code> file can be configured as follows:</p> <pre><code>[package]\nname = \"module-lottery-example\"\nversion = \"4.0.0-dev\"\ndescription = \"Simple module example\"\nauthors = [\"\"]\nhomepage = \"\"\n...\n</code></pre> <p>This file also defines the module's dependencies, such as the core functionality that allows seamless integration with the runtime and other modules, access to storage, event emission, and more.</p> <p>The full example of the <code>Cargo.toml</code> file sets, besides the attributes, the dependencies required by Substrate:</p> View the complete Cargo.toml file <pre><code>[package]\nname = \"module-lottery-example\"\nversion = \"4.0.0-dev\"\ndescription = \"Simple module example\"\nauthors = [\"\"]\nhomepage = \"\"\nedition = \"2021\"\npublish = false\n\n[package.metadata.docs.rs]\ntargets = [\"x86_64-unknown-linux-gnu\"]\n\n[dependencies]\ncodec = { package = \"parity-scale-codec\", version = \"3.6.1\", default-features = false, features = [\n    \"derive\",\n] }\nscale-info = { version = \"2.5.0\", default-features = false, features = [\"derive\"] }\nframe-benchmarking = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    optional = true, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-support = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-system = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\n\n[dev-dependencies]\nsp-core = { version = \"21.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-io = { version = \"23.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-runtime = { version = \"24.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\n\n[features]\ndefault = [\"std\"]\nstd = [\n    \"codec/std\",\n    \"frame-benchmarking?/std\",\n    \"frame-support/std\",\n    \"frame-system/std\",\n    \"scale-info/std\",\n]\nruntime-benchmarks = [\"frame-benchmarking/runtime-benchmarks\"]\ntry-runtime = [\"frame-support/try-runtime\"]\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#adding-custom-logic","title":"Adding Custom Logic","text":"<p>As presented in the custom-made module section of the modularity article, creating a module involves implementing the following attribute macros, of which the first three are mandatory:</p> <ul> <li><code>#[frame_support::pallet]</code> - this attribute is the entry point that marks the module as usable in the runtime</li> <li><code>#[pallet::pallet]</code> - applied to a structure that is used to retrieve module information easily</li> <li><code>#[pallet::config]</code> - is a required attribute to define the configuration for the data types of the module</li> <li><code>#[pallet::call]</code> -  this macro is used to define functions that will be exposed as transactions, allowing them to be dispatched to the runtime. It is here that the developers add their custom transactions and logic</li> <li><code>#[pallet::error]</code> - as transactions may not be successful (insufficient funds, as an error example), and for security reasons, a custom module can never end up throwing an exception, all the possible errors are to be identified and listed in an enum to be returned upon an unsuccessful execution</li> <li><code>#[pallet::event]</code> - events can be defined and used as a means to provide more information to the user</li> <li><code>#[pallet::storage]</code> - this macro is used to define elements that will be persisted in storage. As resources are scarce in a blockchain, it should be used wisely to store only sensible information</li> </ul>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-basic-structure","title":"Implementing the Module Basic Structure","text":"<p>The first two mandatory macros, <code>#[frame_support::pallet]</code> and <code>#[pallet::pallet]</code>, provide the basic structure of the module and are required to enable the module to be used in a Substrate runtime.</p> <p>The following snippet shows the general structure of a custom Substrate module.</p> <pre><code>#[frame_support::pallet(dev_mode)]\npub mod pallet {\n    ...\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    // All the logic goes here\n}\n</code></pre> <p>The next step would be to add the third mandatory macro (<code>#[pallet::config]</code>) and all the custom logic, as shown in the following sections.</p>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-module-configuration","title":"Implementing the Module Configuration","text":"<p>To make the modules highly adaptable, their configuration is abstract enough to allow them to be adapted to the specific requirements of the use case the runtime implements.</p> <p>The implementation of the <code>#[pallet::config]</code> macro is mandatory and sets the module's dependency on other modules and the types and values specified by the runtime-specific settings.</p> <p>In the custom <code>lottery-example</code> module you are building, the module depends on other modules to manage the currency and the random function to select the winner. The module also reads and uses the ticket price and the maximum number of participants directly from the runtime settings.  Consequently, the configuration needs to include these dependencies:</p> <ul> <li>Events - the module depends on the runtime's definition of an event to be able to emit them</li> <li>Currency - the <code>lottery-example</code> module needs to be able to transfer funds, hence, it needs the definition of the currency system from the runtime</li> <li>Randomness - this module is used to fairly select the winner of the prize from the list of participants. It generates the random numbers using the past block hashes and the current block's number as seed</li> <li>Ticket cost - the price to charge the buyers that participate in the lottery</li> <li>Maximum number of participants - the top limit of participants allowed in each lottery round</li> <li>Module Id - the module unique identifier is required to access the module account to hold the participant's funds until transferred to the winner</li> </ul> <p>The implementation of the described configuration for this example is shown in the following code snippet:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n\n    // Event definition\n    type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n        + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n    // Currency \n    type Currency: Currency&lt;Self::AccountId&gt;;\n\n    // Randomness\n    type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n    // Ticket cost\n    #[pallet::constant]\n    type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n    // Maximum number of participants\n    #[pallet::constant]\n    type MaxParticipants: Get&lt;u32&gt;;\n\n    // Module Id\n    #[pallet::constant]\n    type PalletId: Get&lt;PalletId&gt;;\n}\n</code></pre> <p>This abstract definition of dependencies is crucial to avoid coupling to a specific use case and to enable the modules to serve as basic building blocks for Substrate networks.</p>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-transactions","title":"Implementing Transactions","text":"<p>Calls represent the behavior a runtime exposes in the form of transactions that can be dispatched for processing, exposing the custom logic added to the module.</p> <p>Every call is enclosed within the <code>#[pallet::call]</code> macro, and present the following elements:</p> <ul> <li>Call Index - is a mandatory unique identifier for every dispatchable call</li> <li>Weight - is a measure of computational effort an extrinsic takes when being processed. More about weights is in the Polkadot documentation</li> <li>Origin - identifies the signing account making the call</li> <li>Result - the return value of the call, which might be an <code>Error</code> if anything goes wrong</li> </ul> <p>The following snippet presents the general structure of the mentioned macro implementation and the call elements:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn one_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn another_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    // Other calls\n}\n</code></pre> <p>In this <code>lottery-example</code> module, we defined two calls with the following logic:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        // 2. Checks that the user has enough balance to afford the ticket price\n        // 3. Checks that the user is not already participating\n        // 4. Adds the user as a new participant for the prize\n        // 5. Transfers the ticket cost to the module's account, to be hold until transferred to the winner\n        // 6. Notify the event\n\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        // 2. Gets a random number from the randomness module\n        // 3. Selects the winner from the participants lit\n        // 4. Transfers the total prize to the winner's account\n        // 5. Resets the participants list, and gets ready for another lottery round\n\n    }\n}\n</code></pre> <p>These calls also emit events to keep the user informed and can return errors should any of the validations go wrong.</p> <p>Here is the complete implementation of the calls with the custom lottery logic:</p> View the complete calls code <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let buyer = ensure_signed(origin)?;\n\n        // 2. Checks that the user has enough balance to afford the ticket price\n        ensure!(\n            T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n            Error::&lt;T&gt;::NotEnoughCurrency\n        );\n\n        // 3. Checks that the user is not already participating\n        if let Some(participants) = Self::get_participants() {\n            ensure!(\n                !participants.contains(&amp;buyer),\n                Error::&lt;T&gt;::AccountAlreadyParticipating\n            );\n        }\n\n        // 4. Adds the user as a new participant for the prize\n        match Self::get_participants() {\n            Some(mut participants) =&gt; { \n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }, \n            None =&gt; {\n                let mut participants = BoundedVec::new();\n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }\n        };\n\n        // 5. Transfers the ticket cost to the module's account\n        // to be hold until transferred to the winner\n        T::Currency::transfer(\n            &amp;buyer, \n            &amp;Self::get_pallet_account(), \n            T::TicketCost::get(), \n            ExistenceRequirement::KeepAlive)?;\n\n        // 6. Notify the event\n        Self::deposit_event(Event::TicketBought { who: buyer });\n        Ok(())\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let _who = ensure_root(origin)?;\n\n        match Self::get_participants() {\n            Some(participants) =&gt; { \n\n                // 2. Gets a random number from the randomness module\n                let nonce = Self::get_and_increment_nonce();\n                let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                    .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                // 3. Selects the winner from the participants lit\n                let winner_index = random_number as usize % participants.len();\n                let winner = participants.as_slice().get(winner_index).unwrap();\n\n                // 4. Transfers the total prize to the winner's account\n                let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                T::Currency::transfer(\n                    &amp;Self::get_pallet_account(), \n                    &amp;winner, \n                    prize, \n                    ExistenceRequirement::AllowDeath)?;\n\n                // 5. Resets the participants list, and gets ready for another lottery round\n                Participants::&lt;T&gt;::kill();\n\n                // 6. Notify the event\n                Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n            }, \n            None =&gt; {\n                // Notify the event (No participants)\n                Self::deposit_event(Event::ThereAreNoParticipants);\n            }\n        };\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-custom-errors","title":"Implementing Custom Errors","text":"<p>The <code>#[pallet::error]</code> macro is used to annotate an enumeration of potential errors that could occur during execution. It is crucial for security to ensure that all error situations are handled gracefully without causing the runtime to crash.</p> <p>The following example of this macro implementation shows the errors that might occur in the lottery module:</p> <pre><code>// Errors inform users that something went wrong.\n#[pallet::error]\npub enum Error&lt;T&gt; {\n    NotEnoughCurrency,\n    AccountAlreadyParticipating,\n    CanNotAddParticipant,\n}\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-events","title":"Implementing Events","text":"<p>The <code>#[pallet::event]</code> macro is applied to an enumeration of events to inform the user of any changes in the state or important actions that happened during the execution in the runtime.</p> <p>As an example, for the <code>lottery-example</code> module, this macro could be configured with the following events:</p> <pre><code>#[pallet::event]\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\npub enum Event&lt;T: Config&gt; {\n    /// Event emitted when a ticket is bought\n    TicketBought { who: T::AccountId },\n    /// Event emitted when the prize is awarded\n    PrizeAwarded { winner: T::AccountId },\n    /// Event emitted when there are no participants\n    ThereAreNoParticipants,\n}\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#implementing-storage","title":"Implementing Storage for State Persistence","text":"<p>The <code>#[pallet::storage]</code> macro initializes a runtime storage structure. In the heavily constrained environment of blockchains, deciding what to store and which structure to use can be critical in terms of performance. More on this topic is covered in the Substrate documentation.</p> <p>In this example, the <code>lottery-example</code> module needs a basic value storage structure to persist the list of participants in a bounded capacity vector (BoundedVec). This can be initialized as follows:</p> <pre><code>#[pallet::storage]\n#[pallet::getter(fn get_participants)]\npub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n    _,\n    BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n    OptionQuery\n&gt;;\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#complete-module","title":"The Complete Module","text":"<p>To put all the pieces together, after implementing all the required macros and adding the custom logic, the module is now complete and ready to be used in the runtime.</p> View the complete module file <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre>"},{"location":"builders/build/customize/adding-custom-made-module/#configure-runtime","title":"Configure the Runtime","text":"<p>Finally, with the module finished, it can be included in the runtime. By doing so, the transactions <code>buy_tickets</code> and <code>award_prize</code> will be callable by the users. This also means that the Polkadot.js API will be decorated with this module and all the available calls that it contains.</p> <p>To configure the runtime, open the <code>lib.rs</code> file, which contains the definition for the runtime of the included template and is located (in case of using the EVM-compatible) in the folder:</p> <pre><code>*/container-chains/templates/frontier/runtime/src/\n</code></pre> <p>To add the lottery module, configure the modules as follows:</p> <pre><code>// Add the configuration for randomness module. No parameters needed.\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {\n}\n\n// Custom module id\nparameter_types! {\n    pub const PalletId: PalletId = PalletId(*b\"loex5678\");\n}\n\n// Add configuration for the lottery module\nimpl pallet_lottery_example::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type Currency = Balances;\n    type TicketCost = ConstU128&lt;1000000000000000&gt;;\n    type PalletId = PalletId;\n    type MaxParticipants = ConstU32&lt;500&gt;;\n    type MyRandomness = RandomCollectiveFlip;\n}\n</code></pre> <p>With the modules configured, add the macro <code>construct_runtime!</code> (that defines the modules that will be included when building the runtime) and the randomness and lottery modules.</p> <pre><code>construct_runtime!(\n    pub struct Runtime {\n        ...\n        // Include the custom logic from the pallet-template in the runtime.\n        RandomCollectiveFlip: pallet_insecure_randomness_collective_flip,\n        Lottery: pallet_lottery_example,\n        ...\n    }\n)\n</code></pre> <p>With everything set, the network now has support for a basic implementation of a lottery.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/build/customize/adding-external-module/","title":"Adding an External Module","text":""},{"location":"builders/build/customize/adding-external-module/#introduction","title":"Introduction","text":"<p>Developers building on top of the Templates offered by Tanssi might want to add some external modules/dependencies into their runtime to expand certain functionality.</p> <p>The Tanssi repository and the templates take all the dependencies from a fork of the official Polkadot SDK repository. This fork is maintained by the Tanssi engineering team, which usually contributes actively to Substrate development by fixing issues and enhancing functionalities, and, as a result, the fork repository frequently stays temporarily ahead of the official one.</p> <p>A double reference issue may arise when adding an external dependency, such as a pallet from a third party. This happens if a Tanssi module references a dependency from the Polkadot SDK fork repository, and the third party references the same dependency from the official Polkadot SDK repository. To solve this issue, the references to the dependencies must be unified.</p>"},{"location":"builders/build/customize/adding-external-module/#solving-dependencies-conflicts-diener","title":"Solving Dependencies Conflicts with Diener","text":"<p>To efficiently handle the dependencies and their origins, you can check out the tool diener.</p> <p>If the <code>diener</code> executable file, the cloned Polkadot SDK repository, and your Tanssi fork are located in the same folder, step into the Tanssi fork folder and execute the following command:</p> <pre><code>../diener patch --crates-to-patch ../polkadot-sdk \\\n    --target https://github.com/paritytech/polkadot-sdk \\\n    --point-to-git https://github.com/moondance-labs/polkadot-sdk \\\n    --point-to-git-branch tanssi-polkadot-stable2503\n</code></pre> <p>This command applies the changes to the <code>Cargo.toml</code> file, patching the dependencies, and solving the double reference issues.</p> <p>You can visit the diener documentation to learn more about the tool and other extra functions it offers.</p>"},{"location":"builders/build/customize/adding-external-module/#double-reference-issue","title":"Example of the Double Reference Issue","text":"<p>To illustrate the situation, the following steps add a demo external module to a custom runtime based on the baseline Tanssi-powered network template. One way to follow this tutorial is to clone the Tanssi Github repository, which will act as the root repository of the project.</p> <p>This tutorial will generate a multiple reference compile-time error. Finally, the steps will show you how to fix the compile error by patching the dependencies with the tool <code>diener</code>, the runtime will compile successfully and work as intended.</p>"},{"location":"builders/build/customize/adding-external-module/#add-third-party-dependency","title":"Add a Third-Party Dependency","text":"<p>Similarly to what is described in the built-in module article, adding a third-party module requires the following steps:</p> <ol> <li>Declare the dependency in the root <code>Cargo.toml</code> file</li> <li>Make the standard features available to the compiler</li> <li>Configure and add the module to the runtime</li> </ol> <p>Should the third-party module reference any dependency already referenced from a distinct source or version, compilation will fail.</p> <p>The following diagram shows how two different references to the same dependency are being included in the runtime, causing the compilation to fail:</p> <p></p> <p>To resolve this issue, it will be necessary to apply a patch so that the references for the dependency are unified:</p> <p></p>"},{"location":"builders/build/customize/adding-external-module/#declaring-dependency","title":"Declaring the Dependency","text":"<p>The first step to reproduce the double reference issue is to declare the dependency in the <code>Cargo.toml</code> file located in the repository's root folder, under the section <code>[dependencies]</code>. For this example, a simple toggle module is used.</p> <p>This <code>toggle</code> module, built for testing and educational purposes, adds basic logic to the runtime, allowing users to switch a state between true and false.</p> <pre><code>[dependencies]\n...\npallet-toggle = { \n    git = \"https://github.com/papermoonio/pallet-toggle\", \n    default-features = false \n}\n...\n</code></pre>"},{"location":"builders/build/customize/adding-external-module/#add-standard-features","title":"Make the Standard Features Available to the Compiler","text":"<p>Having declared the module in the workspace <code>Cargo.toml</code> file, the dependency can now be added to the specific template <code>Cargo.toml</code> file, which, for this example that uses the Tanssi GitHub repo, is located in the folder <code>container-chains/templates/simple/runtime</code>.</p> <pre><code>[dependencies]\n...\npallet-toggle = { workspace = true }\n...\n</code></pre> <p>In the same <code>Cargo.toml</code> file, add the following features.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-toggle/std\",\n   ...\n]\n...\nruntime-benchmarks = [\n    ...,\n    \"pallet-toggle/runtime-benchmarks\",\n]\n\ntry-runtime = [\n    ...,\n    \"pallet-toggle/try-runtime\",\n]\n</code></pre>"},{"location":"builders/build/customize/adding-external-module/#configure-module-in-the-runtime","title":"Configure and Add the Module to the Runtime","text":"<p>Next, add the following snippet to the <code>lib.rs</code> file inside the runtime folder. This configures the module and adds the module within the <code>construct_runtime!</code> macro.</p> <pre><code>...\nimpl pallet_toggle::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = pallet_toggle::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n\nconstruct_runtime!(\n    pub enum Runtime\n    {\n        ...\n        ...\n        Toggle: pallet_toggle,\n    }\n);\n</code></pre>"},{"location":"builders/build/customize/adding-external-module/#compile-runtime","title":"Compile Runtime","text":"<p>After completing the preceding steps, the module is declared a dependency in the project, configured, and added to the runtime.</p> <p>Compile the template using the following command:</p> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>The terminal output will display an error, similar to the following, caused by different modules referencing different versions of the same dependency:</p> <pre><code>error: failed to select a version for `syn`.\n</code></pre>"},{"location":"builders/build/customize/adding-external-module/#patch-dependencies","title":"Patch Dependencies","text":"<p>Finally, executing the <code>diener</code> command will add a <code>patch</code> section to your workspace <code>Cargo.toml</code> file, overriding the dependencies and unifying origins and versions.</p> <p>This is what the execution in the terminal looks like:</p> ../diener patch --crates-to-patch ../polkadot-sdk \\      --target https://github.com/paritytech/polkadot-sdk \\      --point-to-git https://github.com/moondance-labs/polkadot-sdk \\      --point-to-git-branch tanssi-polkadot-v1.3.0       [2024-01-10T23:26:27Z INFO diener] Running diener v0.4.7       [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bridge-runtime-common.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-header-chain'      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-runtime'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core-hashing'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api-proc-macro' .      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-debug-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-externalities'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-std'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-storage'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-runtime-interface'.    <p>As shown in the terminal output, <code>diener</code> adds a patch for the dependencies, creating a <code>patch</code> section in your <code>toml</code> overriding their origin:</p> <pre><code>[patch.\"https://github.com/paritytech/polkadot-sdk\"]\nbridge-runtime-common = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-header-chain = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-runtime = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\n...\n</code></pre> <p>Finally, compiling will succeed, and the module will be built into your runtime.</p>"},{"location":"builders/build/customize/customizing-chain-specs/","title":"Customizing Chain Specifications","text":""},{"location":"builders/build/customize/customizing-chain-specs/#introduction","title":"Introduction","text":"<p>The chain specification refers to a set of parameters and configurations that define the characteristics and behavior of a new Tanssi-powered network. It defines the initial settings and state that all nodes participating in the network must agree on to reach consensus and produce blocks. Many initial settings cannot be changed after the network is launched without generating a completely different chain.</p> <p>The specification contains two main sections:</p> <ul> <li>The client specification - includes the network parameters, for example, the boot nodes the client connects with when joining the network</li> <li>The genesis state - represents the initial state upon which all transactions and state transitions take place. It includes details like the initial registered accounts and their balances, as well as the account with administrator privileges (sudo, if applicable), among other relevant information</li> </ul> <p>This information the chain specification contains can be stored in a Rust file (which can be found in the templates included in the Tanssi repository) or in a JSON file.</p> <p>This article covers the sections and attributes within a chain specification file and explains how to obtain it, in case you want to launch your Tanssi network by uploading a customized specifications file.</p> <p>Editor\u2019s Note (2025 Update)</p> <p>This guide explains how to customize chain specification files in Substrate-based networks. Some fields (e.g. relay chain, parachain id) come from the Substrate SDK and are included for compatibility or template purposes.</p> <p>These attributes do not mean that a Tanssi-powered network is a Polkadot parachain. Tanssi is an independent appchain infrastructure protocol, built with Substrate and aligned with Ethereum-backed security. You may encounter Polkadot-related terms in configuration files because of Substrate\u2019s shared origins, but Tanssi-powered appchains do not require Polkadot slots or relay chain mechanics.</p>"},{"location":"builders/build/customize/customizing-chain-specs/#client-specification","title":"The Client Specification","text":"<p>The client specification contains the configuration of the network and other settings (excluding those related to the runtime state): </p> <ul> <li>Name - name for the specifications</li> <li>Id - a unique simple id for the network used to define the storage path in the node</li> <li>Fork Id - optional parameter for a network fork identifier</li> <li>Chain Type - a parameter that can be set to define the chain type and display additional information or enable additional features (it can be set to Development, Local, Live, or a custom type)</li> <li>Boot Nodes - set of boot nodes that will be used when the new node joins the network and syncs</li> <li>Telemetry Endpoints - an optional list of endpoints to send information and monitor the operation of the network</li> <li>Protocol Id - a unique name defining the network protocol</li> <li>Relay Chain - defines the id of the orchestration chain the Tanssi network interacts with</li> <li>Parachain Id - sets a unique id that identifies the Tanssi network</li> <li>Code Substitutes - an emergency feature to replace the runtime when a Tanssi network is unable to perform a runtime upgrade</li> <li>Properties - key-value properties that can be customized and are useful to improve the user experience</li> </ul> <p>In the <code>properties</code> attribute, the following settings are used by various front-end libraries, including the Polkadot.js API:</p> <ul> <li>Token Symbol - a name for your Tanssi network's own token symbol</li> <li>SS58 Format - an integer that uniquely identifies the accounts in your network. SS58 encoding transforms the underlying 32-byte account to a network-specific representation. This attribute doesn't apply nor interfere with the ECDSA Ethereum accounts on EVM-compatible networks</li> <li>Token Decimals - represent how divisible a token can be, and what is the smallest representation of the token. It's set to <code>18</code> for EVM-compatible networks</li> <li>Is Ethereum - a boolean identifying the network as EVM compatible or not</li> </ul>"},{"location":"builders/build/customize/customizing-chain-specs/#genesis-state","title":"The Genesis State","text":"<p>All the sequencers assigned to the Tanssi network must agree on the initial state so they can execute the incoming extrinsics, arrive at the same results, and finally reach a consensus on the new valid state.</p> <p>This genesis state will define the starting point of the Tanssi network. It includes an initial value for the elements that the modules included in the runtime need to persist and the initial runtime Wasm code, which is stored on-chain.</p> <p>For example, in the templates included, the chain specification defines the initial accounts and token balances in the <code>Balances</code> module. In addition, the template also has a sudo account (which should be modified) for the <code>Sudo</code> module, which provides unique privileges to the given account, and that can be offboarded once an on-chain democracy module is plugged in.</p>"},{"location":"builders/build/customize/customizing-chain-specs/#generating-json-chain-specs","title":"Generating a JSON Chain Specification File","text":"<p>The following commands will build and generate the chain specification for the EVM-compatible template based on the configuration expressed in the <code>chain_spec.rs</code>, located in the <code>*/container-chains/templates/frontier/node/src/chain_spec.rs</code>. This example can be adapted to any other template or custom runtime.</p> <p>To build and generate the chain specifications, take the following steps:</p> <ol> <li> <p>Clone the Tanssi code hosted on GitHub</p> <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre> </li> <li> <p>Step into the project folder</p> <pre><code>cd tanssi\n</code></pre> </li> <li> <p>Build the Tanssi EVM-compatible network template</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> <p>This step is quite verbose and might take a while to complete. The following screenshot shows the terminal after successfully finishing the building process (note that the completion time is above 35 minutes):</p> <p></p> </li> <li> <p>Generate the chain specification</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec &gt; chain_spec.json\n</code></pre> </li> </ol> <p>After executing the last step, the terminal displays only a log line:</p> <p></p> <p>And now the <code>chain_spec.json</code> file containing the client specification and the genesis state is created in the current folder.</p> <p>Note</p> <p>The JSON chain specifications can be generated in two different versions: the human readable, which is the one generated following the previous steps, and the raw version, which is the one needed to deploy the network through Tanssi. More about how to generate the raw version later in this article.</p>"},{"location":"builders/build/customize/customizing-chain-specs/#editing-json-chain-specs","title":"Editing the JSON Chain Specification File","text":"<p>The generated <code>chain_spec.json</code> file reflects the parameters set in the Rust chain specifications file. Being a JSON file, it is easy to read and, should any parameter need to be changed, easy to edit.</p> <p>For example, the following code snippet shows some of the attributes of the client specifications:</p> <pre><code>{\n    // Set the name for the specification of this network\n    \"name\": \"Frontier network 1000\",\n    // Set an id for the specifications of this network\n    \"id\": \"frontier_network_1000\",\n    // Network will be live\n    \"chainType\": \"Live\",\n    \"bootNodes\": [\n        // boot nodes will be added automatically during deployment\n    ],\n    // Optional attribute, defaults to null\n    \"telemetryEndpoints\": null,\n    // Set a protocol identifier for this network\n    \"protocolId\": \"network-chain-1000\",\n    // Set properties to define the token and the ethereum compatibility\n    \"properties\": {\n        \"isEthereum\": true,\n        \"ss58Format\": 42,\n        \"tokenDecimals\": 18,\n        \"tokenSymbol\": \"UNIT\"\n    },\n    // Set the stagenet relay chain\n    \"relay_chain\": \"westend_moonbase_relay_stagenet\",\n    // Set the parachain id reserved in the relay chain\n    \"para_id\": 3333,\n    // No need\n    \"codeSubstitutes\": {},\n    \"genesis\": { \n        ... \n    }\n}\n</code></pre> <p>The other important section of the file is within the <code>genesis</code> attribute, which contains the genesis state. In the following JSON snippet, the default values and configuration for some modules are presented as an example:</p> <pre><code>{\n    ...\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            // Sets the account that will bear sudo privileges\n            \"sudo\": {\n                \"key\": \"0xf24ff3a9cf04c71dbc94d0b566f7a27b94566cac\"\n            },\n            // Sets the initial balances for some accounts\n            \"balances\": {\n                \"balances\": [\n                [\n                    \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x773539d4ac0e786233d90a233654ccee26a613d9\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0xf24ff3a9cf04c71dbc94d0b566f7a27b94566cac\",\n                    1208925819614629174706176\n                ]\n                ]\n            },\n            // Sets balances for EVM accounts\n            \"evm\": {\n                \"accounts\": {\n                \"0x1000000000000000000000000000000000000001\": {\n                    \"nonce\": \"0x1\",\n                    \"balance\": \"0xd3c21bcecceda1000000\",\n                    \"storage\": {},\n                    \"code\": [\n                    0\n                    ]\n                },\n                \"0x6be02d1d3665660d22ff9624b7be0551ee1ac91b\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                },\n                \"0xd43593c715fdd31c61141abd04a99fd6822c8558\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                }\n                }\n            },\n        }\n    }\n    ...\n}\n</code></pre> <p>An example of a non-manually editable attribute is the Wasm runtime (in the genesis state section), which is a hexadecimal representation of a binary blob generated by the compiler. Still, apart from this, most of the properties are easy to edit before launching the network.</p>"},{"location":"builders/build/customize/customizing-chain-specs/#generating-raw-specs-file","title":"Generating a Raw JSON Chain Specification File","text":"<p>One final step before deploying the Tanssi network is converting the JSON specification file to a raw format, which is a compact, less-readable version of the same file, required to initialize a node.</p> <p>After going through the steps to generate the JSON chain Specification File and editing its values, the following command will convert the chain specs file into the required raw format:</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec --chain=chain_spec.json --raw &gt; raw_chain_spec.json\n</code></pre> <p>Now that this file has been configured and customized and is in the correct raw JSON format, it can be uploaded to initialize a new network in Tanssi.</p>"},{"location":"builders/build/customize/prerequisites/","title":"Prerequisites for Building a Network","text":""},{"location":"builders/build/customize/prerequisites/#introduction","title":"Introduction","text":"<p>Deploying a network through Tanssi is a fairly straightforward step, where the only requirement is to have a valid chain specification to upload.</p> <p>Even though Tanssi provides chain specifications for the available templates, it could be necessary to generate a new one to match any changes the use case might need to be implemented in the runtime.</p> <p>The following sections of this article will cover the minimal required software and its installation process to get a suitable development environment to compile a Substrate node and generate the chain specification.</p>"},{"location":"builders/build/customize/prerequisites/#installing-rust","title":"Installing Rust","text":"<p>Rust is a modern, portable, and performant programming language that is the base of the Substrate blockchain development framework.  </p> <p>To compile the Tanssi network, the rust compiler, <code>rustc</code>, and the package manager, <code>cargo</code>, must be installed on the system.</p> <p>In accordance with the instructions in the official Rust documentation, for Linux or macOS systems, run the following command:</p> LinuxMacOS <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>When the installation process is completed, running the following command verifies that the newly installed compiler works correctly by showing the version number:</p> LinuxMacOS <pre><code>rustc --version\n</code></pre> <pre><code>rustc --version\n</code></pre> <p>There are other methods to install Rust, such as using a package manager. Other options can be found on the Rust official site.</p>"},{"location":"builders/build/customize/prerequisites/#installing-git","title":"Installing Git","text":"<p>Git is recommended to clone the code repository of Tanssi, where the node templates can be found. Git is likely shipped within the default OS installation configuration or included in other tools, such as Xcode in MacOS.</p> <p>If Git is not present on the system, the following command will install it using a package manager:</p> LinuxMacOS <pre><code>apt-get install git\n</code></pre> <pre><code>brew install git\n</code></pre> <p>To check the correct installation of Git, running the following command in a terminal should display the Git version:</p> LinuxMacOS <pre><code>git --version\n</code></pre> <pre><code>git --version\n</code></pre>"},{"location":"builders/build/customize/prerequisites/#building-tanssi-template","title":"Building a Tanssi Template","text":"<p>To build a Substrate node, such as the templates included in the Tanssi repository, it is necessary to install additional development components in the system:</p> LinuxMacOS <pre><code>apt-get install -y build-essential protobuf-compiler clang libssl-dev pkg-config\n</code></pre> <pre><code>brew install protobuf openssl\n</code></pre> <p>With these essential tools installed, the development environment should be ready to work with Substrate and build the node with the following commands: </p> <ol> <li>Clone the Tanssi code hosted on GitHub <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre></li> <li>Step into the project folder <pre><code>cd tanssi\n</code></pre></li> <li>Build the Tanssi network template</li> </ol> Baseline EVMBaseline Substrate <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>Having a healthy development environment will be necessary to build a customized runtime and to finally generate the chain specification file that will be used to deploy your Tanssi network.</p>"},{"location":"builders/build/templates/","title":"Network Templates","text":"<p>Kickstart your network development with our comprehensive templates. Designed for rapid deployment, these templates provide a strong foundation for both EVM and non-EVM solutions, accelerating your production journey.</p>"},{"location":"builders/build/templates/#choose-a-template","title":"Choose a Template","text":"<p>Tanssi provides two templates to jumpstart the development process:</p> <ul> <li> <p>Baseline Tanssi network template - a template that provides the basic platform to start adding custom logic     </p> <p> Learn about what this template provides</p> <p> Start building with this template</p> </li> <li> <p>Baseline Tanssi EVM (Ethereum Virtual Machine) network template - a template that provides full Ethereum compatibility     </p> <p> Learn about what this template provides</p> <p> Start building with this template</p> </li> </ul> <p>To learn about the minimum requirements for your chain to function on Tanssi and what modules are automatically included, check out the Template Overview page.</p>"},{"location":"builders/build/templates/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/build/templates/custom-runtime/","title":"Custom Runtime","text":""},{"location":"builders/build/templates/custom-runtime/#introduction","title":"Introduction","text":"<p>For teams working on an existing Substrate framework project, it will be necessary to include some required modules and configurations into the runtime. This will ensure that the existing runtime can gracefully become a Tanssi network runtime, aligning with the protocol rules.</p> <p>Failing to do so might lead to reduced interoperability and unnecessary exposure to vulnerabilities.</p>"},{"location":"builders/build/templates/custom-runtime/#minimum-requirements","title":"Minimum Requirements","text":"<p>Already existing Substrate runtimes need to implement at least the framework for communicating within the Tanssi ecosystem, along with Tanssi-specific modules.</p> <p>Nevertheless, teams might have already implemented certain modules that can collide with some functionalities related to Tanssi, for example, block production, block authority assignment, and consensus.</p> <p>The following modules are included by default in many popular templates and must be removed along with their configuration:</p> <pre><code>Authorship: pallet_authorship = 20,\nCollatorSelection: pallet_collator_selection = 21,\nSession: pallet_session = 22,\nAura: pallet_aura = 23,\nAuraExt: cumulus_pallet_aura_ext = 24,\n</code></pre> <p>In any case, make sure to check your runtime and remove all the modules that might interfere with the block production as a service feature before starting the registration process.</p>"},{"location":"builders/build/templates/custom-runtime/#adding-cumulus-support","title":"Integrating Your Stand-Alone Chain","text":"<p>If your existing runtime is set up as a stand-alone chain, you'll need to add a consensus mechanism to integrate into the Tanssi ecosystem. Check any of the available templates in the Tanssi repository for a reference setup or the framework documentation.</p>"},{"location":"builders/build/templates/custom-runtime/#adding-tanssi-support","title":"Adding Tanssi Protocol Support","text":"<p>To support the Tanssi protocol, it will be necessary to add two modules through the following steps:</p> <ol> <li> <p>Include the dependencies in the <code>Cargo.toml</code> manifesto (usually located in the root folder). Open the <code>Cargo.toml</code> file and add the modules in the <code>dependencies</code> section</p> <pre><code>[dependencies]\n...\npallet-cc-authorities-noting = { \n    git = \"https://github.com/moondance-labs/tanssi\", \n    branch = \"master\", default-features = false \n}\npallet_authorities_noting = {\n    git = \"https://github.com/moondance-labs/moonkit\",\n    branch = \"tanssi-polkadot-v0.9.43\", default-features = false\n}\n...\n</code></pre> </li> <li> <p>Configure the modules. Open the file <code>lib.rs</code> located in the folder <code>*/runtime/src</code> and add the configuration for both modules:</p> <pre><code>impl pallet_author_inherent::Config for Runtime {\n    type AuthorId = NimbusId;\n    type AccountLookup = tp_consensus::NimbusLookUp;\n    type CanAuthor = pallet_cc_authorities_noting::CanAuthor&lt;Runtime&gt;;\n    type SlotBeacon = tp_consensus::AuraDigestSlotBeacon&lt;Runtime&gt;;\n    type WeightInfo =\n        pallet_author_inherent::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n\nimpl pallet_cc_authorities_noting::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type SelfParaId = parachain_info::Pallet&lt;Runtime&gt;;\n    type RelayChainStateProvider =\n        cumulus_pallet_parachain_system::RelaychainDataProvider&lt;Self&gt;;\n    type AuthorityId = NimbusId;\n    type WeightInfo =\n        pallet_cc_authorities_noting::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n</code></pre> <p>Note that this configuration is agnostic from the use case</p> </li> <li> <p>Declare the modules as part of the runtime. In the same <code>lib.rs</code> file, located in the folder <code>*/runtime/src</code>, add the modules to the construction of the runtime:</p> <pre><code>construct_runtime!(\npub enum Runtime where\n    Block = Block,\n    NodeBlock = opaque::Block,\n    UncheckedExtrinsic = UncheckedExtrinsic,\n{\n    ...\n    // Tanssi network\n    AuthoritiesNoting: pallet_cc_authorities_noting = 50,\n    AuthorInherent: pallet_author_inherent = 51,\n    ...\n}\n);\n</code></pre> </li> <li> <p>Make sure your Header is configured as follows:</p> <pre><code>type Header = generic::Header&lt;BlockNumber, BlakeTwo256&gt;;\n/// An index to a block.\npub type BlockNumber = u32; \n</code></pre> </li> <li> <p>Add the block executor, to allow the operators in the Tanssi network to validate that the authors are the sequencers assigned by Tanssi (and not a malicious actor)</p> <pre><code>cumulus_pallet_parachain_system::register_validate_block! {\n    Runtime = Runtime,\n    BlockExecutor = pallet_author_inherent::BlockExecutor::&lt;Runtime, Executive&gt;\n    CheckInherents = CheckInherents,\n}\n</code></pre> </li> </ol>"},{"location":"builders/build/templates/evm/","title":"Baseline EVM Template","text":""},{"location":"builders/build/templates/evm/#introduction","title":"Introduction","text":"<p>Tanssi's EVM (Ethereum Virtual Machine) network template is designed for teams developing their applications on top of EVM smart contracts. It includes all the essential components needed for a full Ethereum-compatible network:</p> <ul> <li>EVM - adds an Ethereum Virtual Machine execution layer for EVM-based smart contract applications</li> <li>Etherum JSON RPC Support - Tanssi-powered EVM networks are fully Ethereum JSON RPC compliant. Consequently, all Ethereum-based tools like MetaMask, Ethers.js, Viem, Hardhat, Foundry and more, work seamlessly out of the box</li> <li>Unified Accounts - allows Tanssi-powered EVM networks to feature Ethereum-styled ECDSA accounts</li> </ul>"},{"location":"builders/build/templates/evm/#evm-network-template","title":"EVM Network Template","text":"<p>The template already includes the necessary configuration for seamless integration with the Tanssi protocol and the security provider of choice, for example, Symbiotic on Ethereum. Therefore, this template requires no additional changes in the runtime if the application is built on top of the EVM.</p> <p>This means that this template is ready to be deployed as-is through Tanssi, unlocking many features, such as:</p> <ul> <li>Utilize Tanssi's block production as a service</li> <li>Get deterministic transaction finality in seconds</li> <li>Choose the security provider that best fits your needs. For example, leverage Ethereum-grade security from Symbiotic</li> <li>Build dApps interacting with your network through an API</li> <li>Connect any Ethereum wallet, such as Metamask and Ledger</li> <li>Use well-known Ethereum libraries like Ethers.js, Web3.js, Web3.py, and more</li> <li>Deploy EVM smart contracts with tools like Remix, Hardhat, Foundry, and more</li> </ul>"},{"location":"builders/build/templates/evm/#included-modules","title":"Included Modules","text":"<p>Besides the modules and configurations that make the Tanssi EVM network template compatible with the Tanssi protocol, it also includes many modules to provide basic functionalities.</p> <p>To reach full Ethereum compatibility, these specific modules are also included:</p> <ul> <li>EVM - it adds support for unmodified EVM bytecode execution on a Tanssi-powered network. It uses the Rust-based SputnikVM as the underlying EVM engine</li> <li>Ethereum - it works alongside the EVM module to provide full emulation for Ethereum block processing. Among many other tasks, it is responsible for creating emulated Ethereum blocks for Ethereum-specific components such as EVM logs</li> </ul> <p>Both modules are part of the Frontier project, which is the backbone of Ethereum-compatible Tanssi-powered networks.</p>"},{"location":"builders/build/templates/overview/","title":"Templates Overview","text":""},{"location":"builders/build/templates/overview/#introduction","title":"Introduction","text":"<p>Networks deployed through Tanssi are fully customizable blockchains benefiting from a shared set of sequencers and the security of a provider of their choice. The templates presented in this article implement the necessary functionalities and configurations to support the Tanssi protocol, making development easier.</p>"},{"location":"builders/build/templates/overview/#base-setup-supporting-tanssi","title":"Base Setup to Support the Tanssi Protocol","text":"<p>Tanssi networks must implement the following modules to support the protocol and benefit safely from Tanssi's block production as a service:</p> <ul> <li>Author Noting - registers the set of sequencers assigned to the network by Tanssi</li> <li>Author Inherent - allows the sequencer authoring the block to include its identity to get validated and rewarded</li> </ul> <p>If you don't include these modules in the Tanssi network's runtime, there won't be a method to confirm that the blocks are being generated by trustworthy sequencers designated by the Tanssi orchestrator. This could create a vulnerability for malicious actors to exploit and compromise the network. For more information about Tanssi's block production as a service please refer to the Block Production Services article.</p> <p>Besides block production, there are other essential aspects for any network covered in the templates, such as:</p> <ul> <li>Consensus - networks have the necessary functionality to allow the sequencers to produce blocks, gossip and validate them, and coordinate with the security provider to get notified about the block's finality</li> <li>Networks Interoperability - handles the ingestion and dispatch of incoming downward and lateral messages, allowing a Tanssi network to communicate and interoperate with the other chains within the ecosystem</li> <li>Runtime Upgrades - a runtime upgrade in a Tanssi network must be informed to the security provider's operators to allow them to check on the blocks produced by the sequencers of the Tanssi networks</li> </ul>"},{"location":"builders/build/templates/overview/#included-modules","title":"Included Modules","text":"<p>Besides the necessary modules to support the operation of a Tanssi network, many other modules provide functional behavior that the users can interact with.</p> <p>These are some of the functional modules exposing a behavior to the users that are included in the templates and ready to use:</p> <ul> <li>Balances - the Balances module provides functions for handling accounts and balances for the Tanssi network native currency</li> <li>Utility - the Utility module provides functions to execute multiple calls in a single dispatch. Besides batching transactions, this module also allows the execution of a call from an alternative signed origin</li> <li>Proxy - the Proxy module provides functions to delegate to other accounts (proxies) the permission to dispatch calls from a proxied origin</li> <li>Maintenance Mode - the Maintenance Mode module allows the Tanssi network to be set to a mode where it doesn't execute balance/asset transfers or other transactions. This could be useful when upgrading the runtime in an emergency, when executing large storage migrations, or when a security vulnerability is discovered</li> <li>Tx Pause - the Tx Pause module allows a valid origin (typically Root) to pause (and unpause) an entire module or a single transaction. A paused transaction (or all the transactions included in a paused module) will fail when called until it is unpaused. This module provides a higher degree of granularity compared to maintenance mode, making it particularly useful when a faulty or vulnerable transaction is identified in the runtime</li> <li>Multisig - the Multisig module enables transaction dispatches that require -typically- more than one signature. A multisig transaction defines a set of authorized accounts and a threshold for its approval, requiring consensus among multiple parties</li> </ul>"},{"location":"builders/build/templates/overview/#getting-started","title":"Start Building","text":"<p>To start building on top of the provided templates, be it the baseline Tanssi network template or the baseline EVM (Ethereum Virtual Machine) template, the recommended approach is to fork the Tanssi repository and start adding built-in modules or custom-made modules on top of the latest release tag.</p> <p>This approach comes with some advantages, such as:</p> <ul> <li>Building on top of the latest and stable release</li> <li>Get the Tanssi protocol already configured and included in the template runtime</li> <li>Keep your fork up-to-date by syncing with the Tanssi upstream repository</li> <li>Run the included tests, ensuring that block production on your Tanssi network works as intended</li> <li>Run a complete local environment with the included Zombienet configuration</li> </ul> <p>If the templates already cover your use case needs, or after building and testing your chain, you can continue with the Deploy Your Network via the Tanssi DApp article to know how to use the Tanssi dApp to register and get your chain up and running.</p>"},{"location":"builders/build/templates/substrate/","title":"Baseline Network Template","text":""},{"location":"builders/build/templates/substrate/#introduction","title":"Introduction","text":"<p>The Tanssi repository includes a bare minimum template that provides the necessary configuration to support the Tanssi protocol and some essential modules, such as the one that allows handling the Tanssi network's currency.</p> <p>This section covers this basic template, what it includes, and some aspects to consider when adding external dependencies.</p>"},{"location":"builders/build/templates/substrate/#baseline-network-template","title":"Baseline Network Template","text":"<p>Developing a network runtime typically involves two primary steps:</p> <ol> <li>Incorporating pre-existing built-in modules into the runtime</li> <li>Creating custom modules tailored to your specific application needs</li> </ol> <p>Since the provided template already includes the essential configurations for seamless integration with the Tanssi protocol and the security provider (for example, Symbiotic on Ethereum), teams interested in constructing an innovative Tanssi-powered network can use this template as a starting point for adding their custom logic.</p> <p>Here are some of the features that come with this template:</p> <ul> <li>Utilize Tanssi's block production as a service</li> <li>Choose the security provider that best fits your needs. For example, leverage Ethereum-grade security from Symbiotic</li> <li>Get deterministic transaction finality in seconds</li> <li>Build dApps interacting with your network through an API</li> </ul> <p>By leveraging these features in the template, you can kickstart your Tanssi network development and customize it to meet your specific requirements and innovations.</p>"},{"location":"builders/build/templates/substrate/#adding-extra-dependencies","title":"Adding Extra Dependencies","text":"<p>The Substrate network template includes all the required modules and configurations that make it compatible with the Tanssi protocol, and also many other modules that provide basic functionalities.</p> <p>This template is designed to serve as a foundation to build upon, as most use cases require expanded capabilities, adding existing or custom modules. To learn how to add new functionalities to your runtime, check the customize runtime section.</p>"},{"location":"builders/deploy/","title":"Deploy Your Appchain in Minutes","text":"<p>With Tanssi, launching your appchain is straightforward and efficient. The platform simplifies the process, so you can focus on building your application.</p>"},{"location":"builders/deploy/#quick-overview-of-deploying-via-the-tanssi-dapp","title":"Quick Overview of Deploying via the Tanssi DApp","text":"<p>Deploying a Tanssi-powered appchain via the Tanssi dApp is accomplished as a single, streamlined flow consisting of five distinct steps:</p> <ol> <li>Select a template and configure it</li> <li>Satisfy the required minimum token balances</li> <li>Reserve your Tanssi appchain ID</li> <li>Generate your custom appchain files</li> <li>Register your appchain on Tanssi</li> </ol> <p></p> <p>Note</p> <p>For Quick Trial appchains and Dedicated appchains deployments on the Tanssi TestNet, the Tanssi team will manually complete verification. After verification, it typically takes about ten minutes for your quick trial appchain to be ready and about two hours for a dedicated one. For Tanssi MainNet, the process will be fully decentralized and permissionless.</p> <p>To get started, visit Using the Tanssi DApp.</p>"},{"location":"builders/deploy/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/deploy/dapp/","title":"Deploy Your Appchain via the Tanssi DApp","text":""},{"location":"builders/deploy/dapp/#introduction","title":"Introduction","text":"<p>Tanssi aims to lower the barrier to entry for building decentralized appchains by streamlining the onboarding process and abstracting away the technical details of launching a Tanssi-powered appchain. The Tanssi dApp allows you to spin up an appchain in just minutes. This guide will walk you through the steps required to launch an appchain on Dancelight, the Tanssi TestNet, via the Tanssi dApp.</p>"},{"location":"builders/deploy/dapp/#quick-trial-vs-dedicated-appchains","title":"Quick Trials vs. Dedicated appchains","text":"<p>The Tanssi dApp supports the creation of two different types of appchains, namely:</p> <ul> <li>Quick trial - a temporary appchain that self-destructs after 48 hours</li> <li>Dedicated - a long-lasting appchain for Tanssi ecosystem builders</li> </ul> <p>Both types of Tanssi appchains behave identically, with the only difference being the ephemeral nature of the quick trials. Generally speaking, quick trial appchains are best for most builders who want to test out a Tanssi-powered appchain. However, if you require a long-lasting test environment, the Tanssi team will happily assist you with setting up a dedicated appchain. </p> <p>The screenshots and content in this guide will showcase quick trial appchains, but you can follow the same process to configure a dedicated Tanssi appchain.</p> <p></p>"},{"location":"builders/deploy/dapp/#prerequisites","title":"Prerequisites","text":""},{"location":"builders/deploy/dapp/#supported-wallets","title":"Supported Wallets","text":"<p>Since Tanssi is built with Substrate, you'll need to use a Substrate-compatible wallet to deploy and manage your Tanssi appchain. Supported wallets include:</p> <ul> <li>Talisman</li> <li>SubWallet</li> <li>Enkrypt</li> <li>Polkadot.js extension</li> </ul> <p>If you deploy a Tanssi-powered EVM appchain, your users won't need a Substrate wallet. They can interact with your Tanssi appchain using Ethereum-compatible wallets like MetaMask.</p> <p></p>"},{"location":"builders/deploy/dapp/#connect-wallet","title":"Connect Your Wallet to the DApp","text":"<p>To connect your wallet to the Tanssi dApp, click Connect Wallet in the upper-right corner. Select the desired wallet type. Then, take the following steps:</p> <ol> <li>Choose your account from the dropdown</li> <li>You'll be prompted to sign a message to log you into the Tanssi dApp. Go ahead and sign the message</li> </ol> <p></p> <p>Once connected, you'll see your address in the top-right corner. If you've connected multiple accounts and want to switch accounts, you can click on your address and choose an account from the dropdown menu.</p>"},{"location":"builders/deploy/dapp/#configure-your-appchain","title":"Configure Your Appchain","text":"<p>On the dApp Home page, click the Start Building button in the Launch Network block to start configuring your Tanssi appchain immediately. You have to choose between a Quick Trial or a Dedicated appchain. You can read more about the differences between these two available types on the Tanssi Testnet.</p> <p></p> <p>Next, select a template that best fits your use case and configure your Tanssi appchain's properties accordingly. You can choose from the EVM or Substrate template or upload a raw specification file. Please refer to the Templates documentation to learn more about the available templates.</p>"},{"location":"builders/deploy/dapp/#evm-template","title":"EVM Template","text":"<p>The EVM template provides all the necessary components to add an Ethereum compatibility layer to your Tanssi appchain. </p> <p>As part of the setup process, you'll need a unique EVM chain ID (EIP-155) that is distinct from all other EVM chains. You can verify that another chain does not already use your EVM chain ID on Chainlist. When launching your Tanssi appchain in production, it's critical that you open a PR to reserve your chain ID on the <code>ethereum-lists/chains</code> GitHub repository immediately after your RPC endpoint spins up. This is part of the validation process and is required for the PR to be accepted and merged.</p> <p>Note</p> <p>A registered EVM chain ID is only necessary for Tanssi appchains deployed on the MainNet. When testing or deploying on the TestNet, you can choose any available ID and move forward.</p> <p>To get started, select the EVM template from the left-side menu. Then take the following steps:</p> <ol> <li>In the Network Details section, provide your project's name, your unique EVM chain ID, and select the category that best fits your use case</li> <li>In the Gas Token section, enter the symbol of your appchain's native token. Decimal places are fixed to 18 digits, the same as Ether, to preserve compatibility across EVM tooling</li> <li>(Optional) You can adjust the EIP-1559 configurations in the Advanced settings. You can choose to change the Base fee per gas and Max base fee change</li> <li>In the Accounts section, provide the Ethereum-style address of the account you want to use as the sudo account and its corresponding initial balance. This account will be able to dispatch privileged functions that require Root permissions. There can only be one sudo account at a time. The sudo account can be changed at any time to a new one by the current sudo account. Once the Tanssi appchain is launched, you can easily migrate to a fully decentralized system using specific democracy-related modules</li> <li>(Optional) In the Advanced section, click on Add to add genesis accounts and balances. If you choose to skip this step, you can use the sudo account to create accounts and transfer funds at a later time</li> <li>(Optional) In the Genesis Smart Contracts, click on Add to add genesis smart contracts by providing an address to use and the bytecode for the smart contract. When providing the bytecode, you'll need to remove the <code>0x</code> from the beginning of the bytecode</li> <li>Once you have configured the template for your Tanssi appchain, select Continue and proceed to the Check Balances section</li> </ol> <p></p>"},{"location":"builders/deploy/dapp/#substrate-template","title":"Substrate Template","text":"<p>The Substrate template includes all the configurations for seamless integration with Tanssi. It can be used as the baseline specification to build a custom Tanssi-powered appchain leveraging the modularity and scalability of the Substrate framework.</p> <p>To get started, select the Substrate template from the left-side menu. Then take the following steps:</p> <ol> <li>In the Network Details section, enter your project's name and select the category that best fits your use case</li> <li>In the Gas Token section, enter the token decimals, symbol, and the SS58 address format</li> <li>In the Accounts section, provide the Substrate-style address of the account you want to use as the sudo account and its initial balance. This account will be able to dispatch privileged functions that require Root permissions. There can only be one sudo account at a time. The sudo account can be changed at any time to a new one by the current sudo account. Once the appchain is launched, you can easily migrate to a fully decentralized system using specific democracy-related modules</li> <li>(Optional) In the Advanced section, click on Add to add genesis accounts and balances. If you choose to skip this step, you can use the sudo account to create accounts and transfer funds at a later time</li> <li>Once you have configured the template for your Tanssi appchain, you can select Continue to proceed to the Check Balances section</li> </ol> <p></p>"},{"location":"builders/deploy/dapp/#custom","title":"Custom","text":"<p>If you already have a Substrate runtime built and have chosen to upload your own custom specification file, there are some requirements you should be aware of to ensure the runtime can evolve into a Tanssi-powered appchain and run properly.</p> <p>Your runtime must implement the following:</p> <ul> <li>The Cumulus SDK, as outlined in the Base Setup to Connect to Polkadot section of the Templates page</li> <li>Tanssi modules for block production, as outlined in the Base Setup to Support the Tanssi Protocol section of the Templates page</li> </ul> <p>Other required changes in the runtime include:</p> <ul> <li> <p>To verify the author's eligibility to produce a block, set the following type as shown in the snippet, in the <code>timestamp</code> module configuration section of the runtime:</p> <pre><code>type OnTimestampSet = tp_consensus::OnTimestampSet&lt;\n    &lt;Self as pallet_author_inherent::Config&gt;::SlotBeacon,\n    ConstU64&lt;{ SLOT_DURATION }&gt;,\n&gt;;\n</code></pre> </li> <li> <p>Remove all the modules related to block production and consensus (such as <code>Aura</code> and <code>Grandpa</code>), leaving Tanssi to take over the burden. If the starting point for your project was the parachain template, the following modules are included by default in the runtime and must be removed:</p> <pre><code>// Collator support. The order of these 4 are important and shall not change.\n#[runtime::pallet_index(20)]\npub type Authorship = pallet_authorship;\n#[runtime::pallet_index(21)]\npub type CollatorSelection = pallet_collator_selection;\n#[runtime::pallet_index(22)]\npub type Session = pallet_session;\n#[runtime::pallet_index(23)]\npub type Aura = pallet_aura;\n#[runtime::pallet_index(24)]\npub type AuraExt = cumulus_pallet_aura_ext;\n</code></pre> </li> </ul> <p>Finally, generate and edit the chain specification paying special attention to:</p> <ul> <li><code>para_id</code> - within this custom flow, a pre-registered appchain id is required. You can get an appchain ID moving forward with the registration to the Reserve your Network ID step. After you reserve the ID, start over the process to get back to this point</li> <li><code>is_ethereum</code> - to <code>true</code> if exposing Ethereum compatible RPC endpoints is needed</li> </ul> <p>And, depending on whether you are deploying a quick trial appchain or a dedicated one, also adjust these attributes:</p> Quick Trial AppchainDedicated Appchain <pre><code>{\n    ...\n    \"relay_chain\": \"rococo_flashbox_relay_testnet\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 1000\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <pre><code>{\n    ...\n    \"relay_chain\": \"rococo-local\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 0\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <p>Now, you can upload your custom raw specification file by selecting the Custom template and adding your JSON specification file.</p> <p></p> <p>Note</p> <p>The size of a raw chain specifications file should not exceed 2MB.</p>"},{"location":"builders/deploy/dapp/#check-balances","title":"Check Balances","text":"<p>Next, you'll need to verify that you have sufficient balance. If you don't, you can press Request Tokens and complete the following login with GitHub or Google. You'll need to complete a few quick onboarding questions, and then you'll be able to press Request Tokens again, and they will be delivered to your connected wallet. </p> <p></p> <p>If you're setting up a dedicated Tanssi appchain, you'll need to fill out an application form. The Tanssi team will review your application and send the necessary tokens within one business day. </p> <p>The required minimum balances to launch a Tanssi appchain are as follows:</p> Quick Trial AppchainDedicated Appchain Chain Balance Required Orchestration layer 70 UNIT Tanssi TestNet 100 SNAP Chain Balance Required Tanssi TestNet 100 STAR <p>Note</p> <p>Quick trial appchains use an additional orchestration layer, therefore two different tokens, SNAP and UNIT, will be sent to your account. For dedicated appchains only STAR tokens are required.</p>"},{"location":"builders/deploy/dapp/#reserve-appchain-id","title":"Reserve your Appchain ID","text":"<p>If you haven't already done so, you must to reserve your Tanssi appchain ID, which will identify your chain within the Tanssi ecosystem.</p> <p>To reserve your Tanssi appchain ID, you'll need to submit a transaction. Please make sure to use the account you plan to launch your Tanssi appchain with when submitting the transaction.</p> <ol> <li>To initiate the transaction, click on Reserve Network ID</li> <li>Your wallet will pop up, and you'll need to submit the transaction</li> </ol> <p></p> <p>Once the transaction has successfully gone through, your Tanssi appchain ID will be displayed on the dApp, and you'll be able to click Continue to proceed to the next step. You'll notice that some of your UNIT (or STAR if registering a dedicated Appchain) tokens have been removed from your transferable balance and are now reserved.</p> <p></p>"},{"location":"builders/deploy/dapp/#generate-appchain-files","title":"Generate Your Appchain Files","text":"<p>Before you can deploy your Tanssi appchain, you'll need to generate three configuration files:</p> <ul> <li>The raw chain specification - a compact version of the JSON specification file, which defines the initial settings and state that all nodes participating in the network must agree on to reach consensus and produce blocks</li> <li>The genesis state header - defines the initial state upon which all transactions and state transitions are executed</li> <li>The genesis Wasm - a WebAssembly (Wasm) blob that defines the runtime logic</li> </ul> <p>These files will automatically be generated for you based on your Tanssi appchain ID and your customized template configurations. All you need to do is click Generate, and the dApp will generate the required files for you.</p> <p></p> <p>Once the files have been generated, please click Continue to go on to the final step.</p>"},{"location":"builders/deploy/dapp/#deploy-your-appchain","title":"Deploy Your appchain","text":"<p>You're finally ready to take your last step towards preparing your appchain as it evolves into a Tanssi-powered appchain! For this final step, when registering a quick trial you'll need to submit two transactions: one to register your appchain on the orchestration layer and another to register your appchain on the Tanssi TestNet.</p> <p>To register your appchain on the orchestration layer, take the following steps:</p> <ol> <li>Click Register under the Register Network in Relay section</li> <li>Confirm the transaction in your wallet</li> </ol> <p></p> <p>Once the transaction has gone through successfully, the dApp will update to show that you have successfully registered your Tanssi appchain under the Register Network in Relay section.</p> <p>Lastly, to register your appchain on Tanssi, take the following steps:</p> <ol> <li>Click Register under the Register Network in Tanssi section</li> <li>Confirm the transaction in your wallet</li> </ol> <p></p> <p>Once the transaction has gone through successfully, the dApp will update to show that you have registered your Tanssi-powered appchain. Congratulations! On the dashboard, you can check the status of your deployment and view relevant information, such as the latest block information, RPC and WS endpoints, and more.</p> <p></p> <p>And that's it! You've successfully registered your Tanssi appchain! The launch process will automatically begin once the Tanssi team has verified your registration. Once your appchain is live, you can return to the Dashboard to view the RPC URL and other pertinent chain information.</p>"},{"location":"builders/interoperability/","title":"Interoperability","text":"<p>Explore the built-in cross-chain solutions available within the Tanssi ecosystem, enabling asset transfers and communication between Tanssi and Ethereum.</p>"},{"location":"builders/interoperability/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/interoperability/built-in-bridge/","title":"Using the Built-In Tanssi Bridge","text":""},{"location":"builders/interoperability/built-in-bridge/#introduction","title":"Introduction","text":"<p>The Tanssi protocol orchestrates infrastructure components, allowing developers to launch their customized appchains in minutes and providing them with out-of-the-box Ethereum-grade economic security. To make the whole process easy for developers, a top-of-class architecture was designed and implemented.</p> <p>The TANSSI token is the engine that enables the integration of different infrastructural components with external security providers and aligns incentives across various actors, including token holders, node operators, and appchain builders. To serve different use cases, the token has two versions: the Tanssi network's native currency, TANSSI (Substrate), and its ERC-20 version, on Ethereum.</p> <p>Users can convert from one version to the other of the token using a Tanssi built-in trustless bridge.</p> <p>In this guide, you'll learn how to move your assets from Tanssi to Ethereum and vice versa through a secure and user-friendly web interface available at the Tanssi dApp, making cross-chain transfers accessible for everyone.</p>"},{"location":"builders/interoperability/built-in-bridge/#prerequisites","title":"Prerequisites","text":"<p>Before using the Tanssi bridge, ensure you have:</p> <p>For bridging from Tanssi to Ethereum:</p> <ul> <li>A Substrate-compatible wallet, such as Talisman.</li> <li>TANSSI (Substrate) balance to transfer and pay the bridging fees.</li> <li>The Ethereum-type destination account.</li> </ul> <p>For bridging from Ethereum to Tanssi:</p> <ul> <li>An Ethereum-compatible wallet, such as MetaMask.</li> <li>TANSSI (ERC-20) balance to transfer.</li> <li>ETH balance to pay the bridging fees.</li> <li>The Substrate-type destination account.</li> </ul>"},{"location":"builders/interoperability/built-in-bridge/#bridge-to-ethereum","title":"Bridging TANSSI Tokens to Ethereum","text":"<p>If you want to convert your TANSSI (Substrate) tokens to TANSSI (ERC-20) on Ethereum, head to the Tanssi dApp, open the bridge section, and then follow these steps:</p> <ol> <li>Select Mainnet from the From dropdown.</li> <li>Click on Connect Wallet. A pop-up will appear, allowing you to select your preferred Substrate wallet and choose the corresponding account.</li> </ol> <p></p> <p>Now, with your wallet connected:</p> <ol> <li>Select the destination account from the Select recipient address dropdown, or choose the Enter a custom address item and enter the account where you want to receive the ERC-20 tokens manually.</li> <li>Enter the amount to bridge in the Balance field. The estimated bridge and transaction fees will be displayed along with the amount the destination account will receive.</li> <li>Click on Send and sign the transaction.</li> </ol> <p></p> <p>And that's it! Your tokens will be bridged when the next session starts. You can see how much time remains in the current session in the progress bar.</p> <p>Note</p> <ul> <li>You can easily add the TANSSI ERC-20 contract address to your wallet by clicking the + icon shown next to your balance.</li> <li>Fees to convert your TANSSI (Substrate) tokens to TANSSI (ERC-20) might fluctuate over time and must be paid using TANSSI.</li> </ul>"},{"location":"builders/interoperability/built-in-bridge/#bridge-to-tanssi","title":"Bridging ERC-20 TANSSI to Tanssi Network","text":"<p>If you want to convert your TANSSI (ERC-20) tokens to TANSSI (Substrate) native on the Tanssi network, head to the Tanssi dApp, open the bridge section, and then follow these steps:</p> <ol> <li>Select Ethereum from the From dropdown.</li> <li>Click on Connect Wallet, select your preferred Ethereum wallet, and choose the account.</li> </ol> <p></p> <p>Now, with your wallet connected:</p> <ol> <li>Enter the Substrate destination account in the Recipient field.</li> <li>Enter the amount to bridge in the Balance field. The estimated bridge and transaction fees will be displayed along with the amount the destination account will receive.</li> <li>Click on Send and sign the transaction.</li> </ol> <p></p> <p>And that's it! Your tokens will be bridged when the next session starts. You can see how much time remains in the current session in the progress bar.</p> <p>Note</p> <p>Fees to convert your TANSSI (ERC-20) tokens to TANSSI (Substrate) native on the Tanssi network might fluctuate over time and must be paid using ETH.</p>"},{"location":"builders/manage/","title":"Managing Your Tanssi-Powered Network","text":"<p>The Tanssi dApp and the developer portal serve different purposes when managing your network, offering unique benefits tailored to your needs:</p> <ul> <li> <p>Tanssi dApp - simplifies the entire network lifecycle, from deployment to basic management. By removing technical complexities, it enables a faster and more streamlined experience for creating and managing networks. Some actions that can be performed via the dApp include:</p> <ul> <li>Paying for block production services</li> <li>Managing tokens (i.e., minting and transferring tokens, updating balances, and more)</li> </ul> </li> <li> <p>Developer portal - built on Polkadot.js Apps, the developer portal provides advanced tools for network management, including runtime upgrades, token minting, and more. It is ideal for tasks requiring precise control and customization. Some actions that can be performed via the developer portal include:</p> <ul> <li>Managing the Sudo account</li> <li>Dispatching runtime upgrades</li> <li>Minting tokens</li> <li>Pausing transactions or enabling maintenance mode in emergencies</li> </ul> </li> </ul> <p>Jump into the sections below to explore how each tool helps you manage your Tanssi-powered network efficiently.</p>"},{"location":"builders/manage/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/manage/dapp/","title":"Using the Tanssi dApp To Manage Your Network","text":"<p>The Tanssi dApp is your go-to platform for handling the operational aspects of your network within the Tanssi ecosystem. Designed for ease of use, the dApp allows developers to streamline everyday tasks like managing tokens, paying for block production services, and overseeing essential network operations without needing deep technical knowledge or advanced configurations.</p>"},{"location":"builders/manage/dapp/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/manage/dapp/manage-tokens/","title":"Manage Tokens","text":""},{"location":"builders/manage/dapp/manage-tokens/#introduction","title":"Introduction","text":"<p>Any network deployed through Tanssi is sovereign and free to define the governance model that best fits its use case. The network governor has superpowers over the chain administration. Consequently, they can call privileged functions, such as updating the runtime and managing native token-related operations, among other actions.</p> <p>There are some actions related to the native token management that are available to the network governor on the Tanssi dApp:</p> <ul> <li>Mint tokens - mints new tokens, increasing the total supply</li> <li>Update balances - increases or decreases the balance of an account, affecting the total supply</li> <li>Transfer tokens - executes a forced token transfer from one account to another</li> <li>Configure gas dynamics - only available on EVM-compatible networks, this action changes the EIP-1559 configuration, affecting the transaction pricing mechanism</li> </ul> <p>In this guide, you'll learn how to execute the previously listed actions using the Tanssi dApp.</p>"},{"location":"builders/manage/dapp/manage-tokens/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>The account you used when registering the network, imported in any of the supported wallets</li> <li>Your network's Sudo account, also imported in any of the supported wallets</li> </ul> <p>Note</p> <p>The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.</p>"},{"location":"builders/manage/dapp/manage-tokens/#retrieving-registration-account","title":"Retrieving the Registration Account","text":"<p>If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the Chain state section on the Polkadot.js Apps connected to the orchestrator chain for quick trial networks or dedicated networks, and take the following steps:</p> <ol> <li>Select the registrar storage module</li> <li>Select registrarDeposit</li> <li>Insert your network ID</li> <li>Press + icon</li> </ol> <p>You'll see the registration account at the bottom.</p> <p></p> <p>Note</p> <p>The dApp will show your network in the dashboard only if you have the registration account properly set.</p>"},{"location":"builders/manage/dapp/manage-tokens/#retrieving-sudo-account","title":"Retrieving the Sudo Account","text":"<p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/dapp/manage-tokens/#accesing-token-management-panel","title":"Accessing the Token Management Panel","text":"<p>The Tanssi dApp implements a smooth interface, allowing the network governor to access and execute privileged functions. To do so, head to the Tanssi dApp, and then:</p> <ol> <li>Click on the Manage button</li> <li>Click on the Token Management button.</li> </ol> <p></p> <p>Now you have direct access to the actions presented in the introduction:</p> <ol> <li>Mint Tokens</li> <li>Update Balances</li> <li>Transfer Tokens</li> <li>Configure Gas Dynamics </li> </ol> <p></p> <p>Note</p> <p>If you don't see your network's details on the dashboard, make sure to comply with the prerequisites.</p>"},{"location":"builders/manage/dapp/manage-tokens/#minting-tokens","title":"Minting Tokens","text":"<p>The network governor can mint new tokens, increasing its total supply. To do so, in the Token Management panel, click on the Mint tokens button, and then:</p> <ol> <li> <p>Insert the address that will hold the newly minted tokens</p> <p>Note</p> <p>The destination address must be Ethereum type if the chain is EVM-compatible and a Substrate type otherwise.</p> </li> <li> <p>Insert the amount of tokens to mint</p> </li> <li>Click on Mint</li> </ol> <p></p> <p>You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account's balance will have been increased by the desired amount.</p>"},{"location":"builders/manage/dapp/manage-tokens/#updating-balances","title":"Updating Balances","text":"<p>The network governor can increase or decrease the balance of any account, thus affecting the total supply. To do so, in the Token Management panel, click on the Update Balances button, and then:</p> <ol> <li> <p>Insert the address that will hold the newly minted tokens. Once you enter the address, its current balance will be displayed</p> <p>Note</p> <p>The destination address must be Ethereum type if the chain is EVM-compatible and a Substrate type otherwise.</p> </li> <li> <p>Insert the new balance the address will hold</p> </li> <li>Click on Update</li> </ol> <p></p> <p>You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account's balance will reflect exactly the desired amount, regardless of previous holdings.</p>"},{"location":"builders/manage/dapp/manage-tokens/#forced-transfers","title":"Executing Forced Transfers","text":"<p>The network governor can reassign balances, forcing a token transfer from one account to another. To do so, in the Token Management panel, click on the Transfer Tokens button, and then:</p> <ol> <li>Insert the origin address that will transfer its tokens</li> <li> <p>Insert the destination address that will receive the tokens</p> <p>Note</p> <p>The origin and destination addresses must be Ethereum type if the chain is EVM-compatible and Substrate type otherwise.</p> </li> <li> <p>Insert the amount of tokens to transfer</p> </li> <li>Click on Transfer</li> </ol> <p></p> <p>You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account will have received the number of tokens from the origin address.</p>"},{"location":"builders/manage/dapp/manage-tokens/#setting-gas","title":"Setting Gas Dynamics","text":"<p>Note</p> <p>This option only applies to EVM-compatible networks.</p> <p>The governor of a Tanssi-powered EVM-compatible network can change its EIP-1559 configuration, affecting the transaction pricing mechanism. To do so, in the Token Management panel, click on the Gas Dynamics button, and then:</p> <ol> <li>Insert the new base fee, expressed in Wei units (10<sup>-18</sup>)</li> <li>Insert the elasticity value</li> <li>Click on Update Dynamics</li> </ol> <p></p> <p>You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the network's fee mechanism will run with the new transaction pricing parameters.</p>"},{"location":"builders/manage/dapp/register-external-assets/","title":"Register External Assets","text":""},{"location":"builders/manage/dapp/register-external-assets/#introduction","title":"Introduction","text":"<p>Cross-chain asset transfer is crucial because it enables the seamless movement of digital assets across different networks, enhancing interoperability, liquidity, and user experience. To enable asset transfers to and from two networks, first, a bidirectional channel must be open between them. Thanks to the Tanssi dApp, opening a channel is an easy and quick task. Please refer to the Manage Cross-Chain Communication Channels article to know how to do it.</p> <p>Note</p> <p>Opening a bidirectional communication channel requires approval from both networks governors.</p> <p>Once your network's communication channels are established, you can register other chain's assets (external assets) to start operating. This guide will walk you through the process of registering external assets using the Tanssi dApp.</p>"},{"location":"builders/manage/dapp/register-external-assets/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Dedicated) running runtime 500 or above</li> <li>The account you used when registering the network, imported in any of the supported wallets</li> <li>Your network's Sudo account, also imported in any of the supported wallets</li> </ul> <p>Note</p> <p>The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.</p>"},{"location":"builders/manage/dapp/register-external-assets/#retrieving-registration-account","title":"Retrieving the Registration Account","text":"<p>If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the Chain state section on the Polkadot.js Apps connected to the orchestrator chain for quick trial networks or dedicated networks, and take the following steps:</p> <ol> <li>Select the registrar storage module</li> <li>Select registrarDeposit</li> <li>Insert your network ID</li> <li>Press + icon</li> </ol> <p>You'll see the registration account at the bottom.</p> <p></p> <p>Note</p> <p>The dApp will show your network in the dashboard only if you have the registration account properly set.</p>"},{"location":"builders/manage/dapp/register-external-assets/#retrieving-sudo-account","title":"Retrieving the Sudo Account","text":"<p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/dapp/register-external-assets/#accesing-external-assets-management-panel","title":"Accessing the External Assets Registration Panel","text":"<p>The Tanssi dApp makes it easy for the network governor to manage cross-chain communication configurations. It allows requesting new channels, accepting incoming channel opening requests, closing existing channels, managing external assets, and more. To access the cross-chain management panel, head to the Tanssi dApp, and then: </p> <ol> <li>Click on the Manage button</li> <li>Click on the XCM button</li> </ol> <p></p> <p>Note</p> <p>If you don't see your network's details on the dashboard, make sure to comply with the prerequisites.</p> <p>The panel will show your network's cross-chain configuration along with several available actions. Regarding external assets, the relevant elements you are presented with are:</p> <ol> <li>Registered Assets panel - this section will group and present to you all registered assets your network already has available</li> <li>Registered Assets List - already registered external assets will be displayed in this section, along with their associated information such as asset name, symbol, ID, total supply, and network ID where it is native</li> <li>Asset Registration - this option allows you to select other available external assets and register them. The following section explains how to do it</li> </ol> <p></p>"},{"location":"builders/manage/dapp/register-external-assets/#register-external-asset","title":"Register an External Asset","text":"<p>Provided your network has already established bidirectional communicaction channels with another network, the network governor can register external assets.</p> <p>To do so, click on Asset Registration and then:</p> <ol> <li>Select at least one of the available assets from the list</li> <li>Click on Register</li> </ol> <p>You'll be asked to sign the transaction, and once it's gone through, the external asset will be available locally. </p> <p></p> <p>Note</p> <p>The dApp only presents well-known assets from well-known networks of the ecosystem. If the asset you need to register is not listed, you'll have to do it using the developer portal.</p>"},{"location":"builders/manage/dapp/services-payment/","title":"Block Production Services Payment","text":""},{"location":"builders/manage/dapp/services-payment/#introduction","title":"Introduction","text":"<p>As presented in the Block Production as a Service article, there are two main costs associated that the network governor must cover: </p> <ul> <li>Sequencers assignment - for the assignment of sequencers by the Tanssi protocol, which happens once per session</li> <li>Block production - for each block that is produced on the network's behalf</li> </ul> <p>In this guide, you'll learn how to use the Tanssi dApp to top-up your account and keep your network's liveness.</p>"},{"location":"builders/manage/dapp/services-payment/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>The account you used when registering the network, imported in any of the supported wallets</li> </ul> <p>If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the Chain state section on the Polkadot.js Apps connected to the orchestrator chain for quick trial networks or dedicated networks, and take the following steps:</p> <ol> <li>Select the registrar storage module</li> <li>Select registrarDeposit</li> <li>Insert your network ID</li> <li>Press + icon</li> </ol> <p>You'll see the registration account at the bottom.</p> <p></p> <p>Note</p> <p>The dApp will show your network in the dashboard only if you have the registration account properly set.</p>"},{"location":"builders/manage/dapp/services-payment/#topping-up","title":"Topping-Up Your Network's Credits","text":"<p>Following a pay-as-you-go model, the networks must have funds allocated to pay for the services, which, over time, will be deducted and burned by the Tanssi protocol upon every session change for the cost of the sequencer's assignment and for every block for the cost of producing the block.</p> <p>You can check your network's current balance and top it up using the Tanssi dApp. To do so, head to the Tanssi dApp and connect the network's registration account to the dApp. The site will display a card showing your network status. This card includes the projected liveness forecast underneath the Block Production section and the Top Up button.</p> <p></p> <p>Clicking on the Top Up button displays a sidebar where the following information can be seen:</p> <ul> <li>Current balance - the current balance allocated for the network's block production service</li> <li>Available balance - the balance available in the network's registration account, which is connected to the dApp</li> <li>Current cost - current cost per sequencer's assignment and cost per block</li> <li>Projected forecast - the estimated day when the network runs out of funds and stops being served</li> </ul> <p>To extend the network's projected runway, take the following actions:</p> <ol> <li>Insert the amount of tokens to buy block production services</li> <li>Click Top Up</li> </ol> <p></p> <p>You will be asked to sign the transaction, and after it's gone through, your network will benefit from an extended horizon of liveness.</p> <p>Warning</p> <p>If your network doesn't have enough funds to cover the sequencer's assignment and one session's worth of blocks, it will stall.</p>"},{"location":"builders/manage/dapp/xcm-channels/","title":"Manage Cross-Chain Communication Channels","text":""},{"location":"builders/manage/dapp/xcm-channels/#introduction","title":"Introduction","text":"<p>As presented in the Native Cross-Chain Communication article from the Learn section, all Tanssi-powered networks have an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication feature is possible thanks to the unique infrastructure the networks are built on top of, leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.</p> <p>The first step to enable communication between networks is opening a channel. The process of opening a channel starts by sending a request to the network you want to establish communications with. Once the request has been accepted by the destination chain's governor, a channel will be opened. </p> <p>In this guide, you'll learn how to use the Tanssi dApp to manage your network's cross-chain communication channels.</p>"},{"location":"builders/manage/dapp/xcm-channels/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Dedicated) running runtime 500 or above</li> <li>The account you used when registering the network, imported in any of the supported wallets</li> <li>Your network's Sudo account, also imported in any of the supported wallets</li> </ul> <p>Note</p> <p>The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.</p>"},{"location":"builders/manage/dapp/xcm-channels/#retrieving-registration-account","title":"Retrieving the Registration Account","text":"<p>If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the Chain state section on the Polkadot.js Apps connected to the orchestrator chain for quick trial networks or dedicated networks, and take the following steps:</p> <ol> <li>Select the registrar storage module</li> <li>Select registrarDeposit</li> <li>Insert your network ID</li> <li>Press + icon</li> </ol> <p>You'll see the registration account at the bottom.</p> <p></p> <p>Note</p> <p>The dApp will show your network in the dashboard only if you have the registration account properly set.</p>"},{"location":"builders/manage/dapp/xcm-channels/#retrieving-sudo-account","title":"Retrieving the Sudo Account","text":"<p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/dapp/xcm-channels/#accesing-channel-management-panel","title":"Accessing the Channel Management Panel","text":"<p>The Tanssi dApp makes it easy for the network governor to manage cross-chain communication configurations. It allows requesting new channels, accepting incoming channel opening requests, closing existing channels, managing external assets, and more. To access the cross-chain management panel, head to the Tanssi dApp, and then: </p> <ol> <li>Click on the Manage button</li> <li>Click on the XCM button</li> </ol> <p></p> <p>Note</p> <p>If you don't see your network's details on the dashboard, make sure to comply with the prerequisites.</p> <p>The panel will show your network's communication channels status along with several available actions. The elements you are presented with are:</p> <ol> <li> <p>Sovereign account - is a keyless account that belongs to the network in a different consensus system, the relay chain in this case. It can only be used by the network's governor. </p> <p>Before opening a new channel, the network's sovereign account in the relay chain must be funded with enough tokens to be locked as a channel deposit.</p> <p>In this section, you can see your network's sovereign account balance, copy its address, and deposit tokens</p> </li> <li> <p>Incoming/Outgoing channel requests - every channel request needs to be accepted by the counterpart before any message can be sent. </p> <p>In this section, you can see the list of pending outgoing requests and cancel them. You can also see any incoming channel requests your network might have received and accept the channel</p> </li> <li> <p>Established channels - Once the destination chain's governor has accepted the channel request, the channel becomes open and available for message transmission.</p> <p>In this section, you can see the list of accepted channels your network has, the direction in which the messages flow through the channel, and cancel the channel</p> </li> <li> <p>Request to open new channels - this option allows you to select an existing network within the ecosystem and request a channel to be opened. The next section explains how to do it</p> </li> </ol> <p></p>"},{"location":"builders/manage/dapp/xcm-channels/#request-new-channel","title":"Request to Open New Channel","text":"<p>Provided that your network has enough funds for the deposit in its relay chain's sovereign account, the network governor can request to open a new channel with any other network. </p> <p>To do so, click on HRMP Channels and then:</p> <ol> <li>Select the network you want to establish a channel with</li> <li>Click on Request Channel</li> </ol> <p>You'll be asked to sign the transaction, and once it's gone through, the destination chain will receive the request. </p> <p></p>"},{"location":"builders/manage/developer-portal/","title":"Using the Developer Portal","text":"<p>The developer portal empowers you to efficiently manage your Tanssi-powered network operations, security, and customization. With intuitive tools at your disposal, you can ensure smooth management and tailor your network to meet your project's unique requirements.</p>"},{"location":"builders/manage/developer-portal/#how-to-connect-to-the-developer-portal","title":"How to Connect to the Developer Portal","text":"<p>Before getting started, you need to retrieve your network's WS URL. This information is available on your network's Dashboard in the Tanssi dApp underneath the Properties section.</p> <p></p> <p>Now you're ready to connect your Tanssi-powered network to the developer portal. Navigate to Polkadot.js Apps and click on the chain information in the top left corner to switch to your network.</p> <p></p> <p>To configure your network, take these steps:</p> <ol> <li>Scroll down the left-side menu til you see Development. Click on that to expand the options</li> <li>Click on Local Node</li> <li>Enter in your RPC URL in the custom endpoint input field</li> <li>Click the save button. The portal will reload and you should be connected to your network</li> </ol> <p></p> <p>Now that you have your network loaded on the developer portal, you can dive into the following guides to start managing your network.</p>"},{"location":"builders/manage/developer-portal/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/manage/developer-portal/impersonate/","title":"Using Sudo to Impersonate Other Accounts","text":""},{"location":"builders/manage/developer-portal/impersonate/#introduction","title":"Introduction","text":"<p>Sudo is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This allows you to perform privileged actions while managing your network, such as impersonating other accounts.</p> <p>In this guide, you'll learn how to use Sudo to impersonate other accounts. For example, this guide will use the Sudo account to pose as an arbitrary account and transfer funds from said account.</p> <p>Warning</p> <p>The balance transfer demonstrated in this guide is dubious, and it is shown only as an example of using Sudo.</p>"},{"location":"builders/manage/developer-portal/impersonate/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/impersonate/#using-the-sudo-as-method","title":"Using the Sudo As Method","text":"<p>As you know, the Sudo account can perform privileged functions, including impersonating other accounts. When submitting a call via <code>sudoAs</code>, the runtime will first authenticate the Sudo key and then dispatch the desired function call with the <code>Signed</code> origin from a given account. In the following example, the <code>sudoAs</code> method will orchestrate sending some tokens to another account. While the result is similar to using Sudo with a <code>forceBalanceTransfer</code> call, the following example uses a regular balance transfer call where the origin is the sender's account rather than the Sudo account.</p> <p>To make a <code>sudoAs</code> call to impersonate another account, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Ensure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the Sudo pallet</li> <li>Select the sudoAs method</li> <li>Select or paste in the desired account to impersonate</li> <li>Select the desired pallet for the call to submit. In this case, it is the balances pallet</li> <li>Select the transferAllowDeath method</li> <li>Specify the destination account for the balance transfer</li> <li>Specify the number of tokens to send</li> <li>Press SubmitSudo and confirm the resulting pop-up</li> </ol> <p></p> <p>The other account had a starting balance of <code>1,000</code> tokens before the call, and subsequently dropped to <code>995</code> as expected.</p> <p></p>"},{"location":"builders/manage/developer-portal/impersonate/#using-sudo-and-the-dispatch-as-utility","title":"Using Sudo and the Dispatch As Utility","text":"<p>The following section will demonstrate using Sudo to dispatch calls from an arbitrary origin. When submitting a call in this manner, the runtime will first authenticate the Sudo key and then dispatch the call using the <code>utility</code> pallet and the <code>dispatchAs</code> function, allowing the transaction's origin to be exactly what you'd like.  </p> <p>To do so, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, you have not associated the Sudo account with Polkadot.js Apps. Ensure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the Sudo pallet</li> <li>Select the Sudo method</li> <li>Select the desired pallet for the call to submit. In this case, it is the utility pallet</li> <li>Select the dispatchAs method</li> <li>Select system from the dropdown</li> <li>Select the signed origin, which sets the origin of the transaction to be the specified account rather than root</li> <li>Select the desired pallet for the call to submit. In this case, it is the balances pallet</li> <li>Select the transferAllowDeath method</li> <li>Specify the destination account for the balance transfer</li> <li>Specify the number of tokens to send</li> <li>Press SubmitSudo and confirm the resulting pop-up</li> </ol> <p></p> <p>The other account had a starting balance of <code>995</code> tokens prior to the call and dropped to <code>990</code> as expected.</p> <p></p> <p>And that's it! The Developer Portal section has plenty more guides on how to manage your Tanssi network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/manage/developer-portal/maintenance/","title":"Enabling Maintenance Mode","text":""},{"location":"builders/manage/developer-portal/maintenance/#introduction","title":"Introduction","text":"<p>The Maintenance pallet is a module that is designed for use only in emergencies that present existential threats to the network. Enabling maintenance mode on your network will suspend the processing of all regular transactions, including EVM interactions. Block production continues at a regular cadence and allows governance and staking functions to continue. </p> <p>Maintenance mode filters (ignores) all calls outside of governance and staking. Once maintenance mode is exited, your chain will process any pending transactions that queued up while your chain was in maintenance mode. Maintenance mode is intended to be used only as a temporary, emergency measure. </p> <p>For example, imagine discovering a critical exploit on your network that could result in significant financial losses if malicious actors exploit it. While you can address the issue by implementing a runtime upgrade, the process takes time\u2014precious time during which your network remains vulnerable to attack. One potential solution is to activate maintenance mode on your network, complete the runtime upgrade, and exit maintenance mode once the fix has been verified.</p> <p>Warning</p> <p>Enabling maintenance mode on a production network can significantly impact the contracts on your chain. While maintenance mode is enabled, no smart contract transactions are processed, so it's critical to consider the potential ramifications before activating it. </p>"},{"location":"builders/manage/developer-portal/maintenance/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/maintenance/#enabling-maintenance-mode","title":"Enabling Maintenance Mode","text":"<p>As you know, the Sudo account can perform privileged functions, such as enabling and disabling maintenance mode. To enter maintenance mode and stop regular transaction processing, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the maintenanceMode pallet</li> <li>Select the enterMaintenanceMode method</li> <li>Press Submit Sudo and confirm the transaction in the resulting pop-up</li> </ol> <p></p> <p>To verify that maintenance mode has been enabled, you can check the Explorer section under the Network tab and review the recent events. </p> <p></p>"},{"location":"builders/manage/developer-portal/maintenance/#exiting-maintenance-mode","title":"Exiting Maintenance Mode","text":"<p>To exit maintenance mode and return your network to normal operation, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the maintenanceMode pallet</li> <li>Select the resumeNormalOperation method</li> <li>Press Submit Sudo and confirm the transaction in the resulting pop-up</li> </ol> <p></p> <p>To verify that maintenance mode has been disabled, you can check in the Explorer section under the Network tab and review the recent events. </p> <p></p> <p>Remember that using maintenance mode is an emergency action that should only be activated when your chain is at dire risk. It may be worthwhile to establish a policy for your network that sets specific circuit breaker triggers to determine when maintenance mode will be enabled. Establishing a policy in advance will also streamline decision-making during a potential emergency.  </p> <p>And that's it! The Developer Portal section has plenty more guides on how to manage your Tanssi-powered network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/manage/developer-portal/minting/","title":"Using Sudo to Mint Native Tokens","text":""},{"location":"builders/manage/developer-portal/minting/#introduction","title":"Introduction","text":"<p>Sudo is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This enables you to perform privileged actions in the course of managing your network, such as minting new native tokens.</p> <p>In this guide, you'll learn how to use Sudo to properly mint new native tokens. This comprehensive guide shows how to check the balance of an existing account prior to assigning it a new balance with Sudo access.</p>"},{"location":"builders/manage/developer-portal/minting/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/minting/#minting-tokens","title":"Minting Tokens","text":"<p>As you know, the Sudo account has the ability to perform privileged functions, including minting additional tokens. When setting up your network on the Tanssi dApp, you can specify genesis account balances. In other words, you have the ability to endow accounts with initial balances upon launching your Tanssi network. However, you can also mint new tokens after launch with the help of the Sudo account.</p> <p>Note</p> <p>This tutorial demonstrates assigning arbitrary token balances on a TestNet network that has no value. You should carefully consider the ramifications of creating additional tokens on your own Tanssi-powered network.</p>"},{"location":"builders/manage/developer-portal/minting/#checking-existing-account-balance","title":"Checking Existing Account Balance","text":"<p>The next section will demonstrate how to assign arbitrary token balances to accounts using the Sudo account. This process will overwrite the specified account's existing balance, so verifying the account is empty is a good practice before continuing. To check an account's balance, take the following steps:</p> <ol> <li>Navigate to the Developer tab of Polkadot.js Apps and click on Chain State</li> <li>Select the system pallet to query</li> <li>Select account</li> <li>Paste in the account address or select it from the dropdown</li> <li>Press + icon</li> <li>You'll see the balance information returned at the bottom, including free, reserved, and frozen balances</li> </ol> <p></p>"},{"location":"builders/manage/developer-portal/minting/#assigning-balances-with-sudo","title":"Assigning Balances with Sudo","text":"<p>To assign an account balance to an account, make sure to have your Sudo account accessible in Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Navigate to the Developer Tab of Polkadot.js Apps for your Tanssi network</li> <li>Click on Sudo. If you do not see Sudo in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps</li> <li>Select the balances pallet</li> <li>Select the forceSetBalance method</li> <li>Paste in the account address to endow with tokens or select it from the dropdown</li> <li>Enter the amount of tokens to endow the account with. In this example, we specify <code>9000000000000000000</code> for nine native tokens. Remember that Tanssi-powered EVM networks have 18 decimals, while Substrate or custom networks configure the decimals when launching the chain. If you're unsure how many decimals your network has, navigate to the Settings tab and click on Metadata</li> <li>Press Submit Sudo and confirm the transaction in your wallet</li> </ol> <p></p> <p>And that's it! The Developer Portal section has plenty more guides on how to manage your Tanssi network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/manage/developer-portal/pause-transactions/","title":"Pausing Transactions","text":""},{"location":"builders/manage/developer-portal/pause-transactions/#introduction","title":"Introduction","text":"<p>The Transaction Pause module is one of the built-in modules included in the Polkadot SDK, and it is available in any Tanssi-powered network based on the official templates version 400 or higher.</p> <p>This module allows a network governor to temporarily avoid executing a set of hand-picked transactions while the rest of the transactions carry on as usual. This feature is helpful in several scenarios, such as disabling functionality in which a security threat has been discovered, enabling seasonal functionality only when needed, and enabling a set of transactions exactly on a launch date.</p> <p>In an emergency scenario, when a critical exploit is discovered, this module allows the network to isolate and stop only the affected functionality, effectively minimizing the overall impact. </p> <p>Warning</p> <p>At the time of this writing, this module hasn't yet been audited; therefore, it is not recommended for production use. </p>"},{"location":"builders/manage/developer-portal/pause-transactions/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated) featuring the Transaction Pause module. Any new network deployment based on one of the templates will do; otherwise, make sure to include the module in your custom-made network runtime</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/pause-transactions/#modules-transaction-names","title":"Module and Transaction Names","text":"<p>The Transaction Pause module works by filtering the execution of specific transactions contained in the modules included in the network runtime. To do so, it keeps an internal list of the banned transactions identified by module and transaction name. This list is case-sensitive and works only when there is an exact match between one item in the paused transactions list and the transaction being processed. Therefore, using the exact names of the modules and the transactions is crucial.</p> <p>To find out the names of the modules available in your runtime, you need to read the <code>construct_runtime!()</code> section in the <code>lib.rs</code> file of your network runtime in your project repository. If your network is based on one of the official templates, you'll find the file in the Tanssi repository:</p> <ul> <li>For networks based on the EVM template: the lib.rs file</li> <li>For networks based on the Substrate template: the lib.rs file</li> </ul> <p>The following snippet is an example of how the <code>construct_runtime!()</code> section looks like. The module names are those located to the left of the colon.</p> <pre><code>construct_runtime!(\n    pub enum Runtime\n    {\n        ...\n        Migrations: pallet_migrations = 7,\n        MaintenanceMode: pallet_maintenance_mode = 8,\n        TxPause: pallet_tx_pause = 9,\n        Balances: pallet_balances = 10,\n        Multisig: pallet_multisig = 16,      \n        ...\n   }\n</code></pre> <p>To identify the transaction names included in a module, you need to refer to its source code. Modules built in Substrate identify their transactions using a macro <code>#[pallet::call_index(INDEX)]</code>, where <code>INDEX</code> is a number. In the case of a built-in module, the code is located within the FRAME folder of the Polkadot-SDK repository. For example, if you want to know about the transaction names in the <code>Balances</code> module, refer to its lib.rs file and look for the function names below the <code>#[pallet::call_index(INDEX)]</code> macros. The following snippet is the transaction <code>transfer_allow_death</code> of the module <code>Balances</code>, which is the one used as an example in this guide:</p> <pre><code>#[pallet::call_index(0)]\npub fn transfer_allow_death(\n    origin: OriginFor&lt;T&gt;,\n    dest: AccountIdLookupOf&lt;T&gt;,\n    #[pallet::compact] value: T::Balance,\n) -&gt; DispatchResult {\n    // Code\n    Ok(())\n}\n</code></pre>"},{"location":"builders/manage/developer-portal/pause-transactions/#frequently-used-modules-transactions","title":"Some Frequently Used Modules and Transactions","text":"<p>When using any of the built-in Substrate modules, the name with which it's referenced within the runtime is entirely up to the developer, but the transaction names aren't customizable. Here is a list of some of the most commonly used modules with the most commonly used transactions they contain. Those are the transaction names to be used in this Transaction Pause module.</p> pallet-ethereum \u2014 This module, along with the EVM module, provides full Ethereum compatibility to the network Transaction Name Description <code>transact</code> Executes an Ethereum call pallet_balances \u2014 This module provides functionality for handling accounts and balances for the network native currency Transaction Name Description <code>transfer_allow_death</code> Executes a balance transfer, deleting the sender's account when its final balance goes below the minimal requirement for existence <code>transfer_keep_alive</code> Executes a balance transfer, keeping the sender's account alive even when its final balance goes below the minimal requirement for existence <code>transfer_all</code> Transfer all non-locked balances to a destination <code>burn</code> Burns balance from the origin's account, reducing the total issuance pallet_assets \u2014 This module provides functionality for handling fungible tokens Transaction Name Description <code>create</code> Issues a new class of fungible assets <code>start_destroy</code> Starts the process of destroying a fungible asset class <code>destroy_accounts</code> Destroys all accounts associated with a given asset for which the destroy process was started <code>destroy_approvals</code> Destroys all approvals associated with a given asset for which the destroy process was started <code>finish_destroy</code> Completes the destroy process of a given asset for which the destroy process was started <code>mint</code> Mints assets <code>burn</code> Burns assets <code>transfer</code> Executes an asset transfer deleting the sender's account when its final balance goes below the minimal requirement for existence <code>transfer_keep_alive</code> Executes an asset transfer keeping the sender's account alive even when its final balance goes below the minimal requirement for existence <code>freeze</code> Disallows transfers of an asset from a specific account <code>thaw</code> Allows again transfers of an asset from a specific account <code>freeze_asset</code> Disallows transfers of an asset <code>thaw_asset</code> Allows again transfers of an asset <code>set_metadata</code> Sets the metadata for an asset <code>clear_metadata</code> Clears the metadata for an asset pallet_nfts \u2014 This module provides functions for handling non-fungible tokens Transaction Name Description <code>create</code> Issues a new collection of non-fungible items <code>destroy</code> Destroys a collection of non-fungible items <code>mint</code> Mints an item in an NFT collection <code>burn</code> Destroys an item from an NFT collection <code>transfer</code> Transfers an NFT <code>lock_item_transfer</code> Disallow the transfer of an item <code>unlock_item_transfer</code> Allows again the transfer of a locked item <code>set_attribute</code> Sets an attribute for an NFT collection or an item <code>clear_attribute</code> Clears an attribute for an NFT collection or an item <code>set_metadata</code> Sets the metadata for an item <code>clear_metadata</code> Clears the metadata for an item <code>set_collection_metadata</code> Sets the metadata for a collection of non-fungible items <code>clear_collection_metadata</code> Clears the metadata for a collection of non-fungible items <code>set_price</code> Sets the price for an item <code>buy_item</code> Buy an item, provided that it's up for sale pallet_multisig \u2014 This module provides functions for dealing with multi-signature schemas Transaction Name Description <code>as_multi_threshold_1</code> Registers a multi-signature call with a single approval <code>as_multi</code> Registers a multi-signature call to be made from a composite account if approved by the specified minimum threshold of the other signatories <code>approve_as_multi</code> Registers approval for a multi-signature call and dispatches the call when the threshold of signatories is reached <code>cancel_as_multi</code> Cancels a pre-existing, ongoing multi-signature transaction"},{"location":"builders/manage/developer-portal/pause-transactions/#pausing-transactions","title":"Pausing Transactions","text":"<p>As you know, the Sudo account can perform privileged actions, such as network upgrades, minting new tokens, and, in this case, pausing and unpausing transactions.</p> <p>To pause a transaction, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the txPause module</li> <li>Select the pause method</li> <li>Insert the module name that contains the transaction that will be paused</li> <li>Insert the transaction name that will be paused</li> <li>Press Submit Sudo and confirm the transaction in the resulting pop-up</li> </ol> <p>In this example, the transaction paused is <code>transfer_allow_death</code> from the <code>Balances</code> module:</p> <p></p> <p>To verify that the transaction has been effectively paused, try executing it. You should get an error.</p> <p></p> <p>Warning</p> <p>The <code>pause</code> transaction doesn't verify the module or transaction names and is case-sensitive, so any misspelling will go unnoticed, and the transaction will execute successfully. You should always verify that the transaction has been effectively paused.</p>"},{"location":"builders/manage/developer-portal/pause-transactions/#unpausing-transactions","title":"Unpausing Transactions","text":"<p>To unpause a transaction and return it to normal operation, navigate to the Developer tab of Polkadot.js Apps for your Tanssi-powered network and click on Sudo. If you do not see Sudo in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Select the txPause module</li> <li>Select the unpause method</li> <li>Insert the module name that contains the transaction that will be unpaused</li> <li>Insert the transaction name that will be unpaused</li> <li>Press Submit Sudo and confirm the transaction in the resulting pop-up</li> </ol> <p>In this example, the transaction to unpause is <code>transfer_allow_death</code> from the <code>Balances</code> module:</p> <p></p> <p>The <code>unpause</code> transaction executes successfully only if the module and transaction parameters have been previously paused; otherwise, it fails. After the successful unpausing, the transaction can be called and executed again.</p> <p>And that's it! The Developer Portal section has plenty more guides on how to manage your Tanssi network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/","title":"Smart EVM - Whitelist Contract Deployments","text":""},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#introduction","title":"Introduction","text":"<p>EVM-compatible Tanssi-powered networks benefit from a unique feature: the network governor can define which accounts are authorized to deploy smart contracts, forbidding the action for any other non-whitelisted account.</p> <p>This feature brings several key benefits that might be a great fit for different use cases or contexts. Some of those benefits are:</p> <ul> <li>Enhanced Security - by restricting deployment to trusted accounts, the risk of deploying malicious or vulnerable smart contracts is reduced</li> <li>Quality Assurance - known and vetted accounts can be required to follow specific coding standards and undergo thorough testing before deployment</li> <li>Regulatory Compliance - uses cases that are highly regulated can limit deployment to ensure that smart contracts meet legal and compliance requirements</li> <li>Spam and Abuse Prevention - prevent bad actors from deploying large numbers of unnecessary or harmful contracts</li> </ul> <p>In this guide, you'll learn how to use the Sudo account to manage the whitelisted accounts that can deploy smart contracts on your network.</p>"},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An EVM-compatible Tanssi-powered network (Quick Trial or Dedicated) running runtime 700 or above. Any new network deployment based on the EVM template will do</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#getting-started","title":"Getting Started","text":"<p>To follow the next sections of this guide, head to Polkadot.js Apps for your Tanssi network. The Polkadot.js Apps link for your Tanssi network can be found in your Tanssi Dashboard underneath the Tooling section.</p> <p></p> <p>Once in Polkadot.js Apps, navigate to the Developer tab and click on Sudo.</p> <p>Note</p> <p>If you do not see Sudo in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps.</p>"},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#whitelist-accounts","title":"Whitelisting Accounts","text":"<p>To define the accounts that will have authorization to deploy smart contracts, get your Polkadot.js Apps started and then take the following steps:</p> <ol> <li>Select the parameters pallet. setParameter will be automatically selected in the functions selector and ContractDeployFilter in the keyValue parameter</li> <li>Two options will be available in the ContractDeployFilter selector: AllowedAddressesToCreate and AllowedAddressesToCreateInner. Select the AllowedAddressesToCreate option if you want to whitelist the accounts for smart contract deployments and the latter to whitelist the accounts for indirect  (via a smart contract call) smart contract deployments</li> <li>Toggle the Include option switch</li> <li>Select the Whitelisted option</li> <li>Insert the whitelisted account</li> <li>If you need to insert more than one account, click on Add item</li> <li>Press Submit Sudo and confirm the transaction in your wallet</li> </ol> <p></p> <p>These same steps can be repeated at any moment to remove an account from the whitelist or to add new ones.</p>"},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#restoring-permission","title":"Restoring Permissions to Deploy Smart Contracts","text":"<p>If you previously authorized some accounts to deploy smart contracts and want to allow any account to deploy smart contracts (as long as they can cover regular transaction fees), then get your Polkadot.js Apps started and take the following steps:</p> <ol> <li>Select the parameters pallet. setParameter will be automatically selected in the functions selector and ContractDeployFilter in the keyValue parameter</li> <li>Two options will be available in the ContractDeployFilter selector: AllowedAddressesToCreate and AllowedAddressesToCreateInner. Select the AllowedAddressesToCreate option if you want to clear the whitelist for smart contract deployments and the latter to clear the whitelist for indirect  (via a smart contract call) smart contract deployments</li> <li>Toggle the Include option switch</li> <li>Select the All option</li> <li>Press Submit Sudo and confirm the transaction in your wallet</li> </ol> <p></p>"},{"location":"builders/manage/developer-portal/smart-contracts-creation-filter/#query-whitelisted-accounts","title":"Query the Whitelisted Accounts","text":"<p>To get the current configuration containing the whitelisted accounts that can deploy smart contracts, go to Polkadot.js Apps (as explained in the Getting Started section), navigate to the Developer tab, click on Chain state, and take the following steps:</p> <ol> <li>Select the parameters storage</li> <li>Select the parameters(ContainerChainTemplateFrontierRuntimeParametersKey) option</li> <li>Make sure that the Include option switch is on</li> <li>Make sure that the ContractDeployFilter option is selected</li> <li>Two options will be available in the ContractDeployFilter selector: AllowedAddressesToCreate and AllowedAddressesToCreateInner. Select the AllowedAddressesToCreate option if you want to query the whitelist for smart contract deployments and the latter to query the whitelist for indirect (via a smart contract call) smart contract deployments</li> <li>Click the + button</li> <li>The current configuration will be displayed</li> </ol> <p></p>"},{"location":"builders/manage/developer-portal/sudo/","title":"Managing Your Network's Sudo Account","text":""},{"location":"builders/manage/developer-portal/sudo/#introduction","title":"Introduction","text":"<p>Sudo is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. There can only be a single Sudo account at a time. However, the Sudo keys can be rotated to give Sudo privileges to a new account.</p> <p>All Tanssi-powered networks come with the Sudo pallet by default, and you're required to designate an account as the Sudo address when launching your network. This enables you to perform privileged actions to manage your chain, such as upgrading your runtime or minting new native tokens. While the Sudo pallet is required to launch your Tanssi network on the TestNet, you can decommission the Sudo pallet and transition to decentralized governance after the MainNet launch.</p> <p>In the following guide, you'll learn how to view the current Sudo account for your network and how to change it, alongside importing it into Polkadot.js Apps. There are similar guides in this section explaining how to use the Sudo account to perform privileged actions, such as upgrading your runtime and minting native tokens. </p>"},{"location":"builders/manage/developer-portal/sudo/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered network (Quick Trial or Dedicated)</li> <li>Your network's Sudo account connected to your network's Polkadot.js Apps</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps","title":"Configuring Polkadot.js Apps","text":"<p>After navigating to Polkadot.js Apps for your network, you'll need to add your Sudo account. Injecting your Sudo account into Polkadot.js Apps from a browser extension is considered safer than storing accounts directly in the browser. However, you can still import your Sudo account directly into the browser's cache. This method does not require the use of any extensions. To import an account into Polkadot.js in this manner, take the following steps:</p> <ol> <li>Click on Settings</li> <li>Under in-browser account creation select Allow local in-browser account creation</li> <li>Press Save</li> </ol> <p></p> <p>Then, head back to the accounts tab and press Account. You'll then be able to replace the pre-generated private key with that of your Sudo account.</p> <p></p> <p>Warning</p> <p>In-browser key storage is not suitable for production environments. This example is provided for demonstration purposes only in a TestNet environment.</p>"},{"location":"builders/manage/developer-portal/sudo/#changing-the-sudo-account","title":"Changing the Sudo Account","text":"<p>Changing your Tanssi-powered network's Sudo account is a straightforward process. Also known as rotating your Sudo keys, this process will remove Sudo access from the existing Sudo account and grant it to the new account. There can only be one Sudo account at any time. However, you are free to change the Sudo account as often as you would like.</p> <p>Prior to getting started, make sure that you have your existing Sudo account accessible in Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Navigate to the Developer Tab of Polkadot.js Apps for your network</li> <li>Click on Sudo. If you do not see Sudo in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps</li> <li>Select the Set Sudo key heading</li> <li>Select the new account you'll transfer Sudo privileges to</li> <li>Press Reassign and confirm the transaction in your wallet</li> </ol> <p></p> <p>Note</p> <p>Ensure that you have access to the new Sudo account. Once Sudo is transferred, it cannot be undone without access to the current Sudo key.</p> <p>And that's it! The Developer Portal section has plenty more guides on how to manage your Tanssi network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/manage/developer-portal/upgrade/","title":"Upgrading Your Appchain Runtime with Sudo","text":""},{"location":"builders/manage/developer-portal/upgrade/#introduction","title":"Introduction","text":"<p>Sudo is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This enables you to perform privileged actions in the course of managing your appchain, such as upgrading your Tanssi-powered appchain's runtime.</p> <p>In this guide, you'll learn how to use Sudo to upgrade your appchain's runtime. With Sudo access, upgrading your chain is a quick and easy process. Note that appchain teams in production will have the option to phase out Sudo access and rely on governance to process runtime upgrades.</p>"},{"location":"builders/manage/developer-portal/upgrade/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the example in this guide, you will need to have the following:</p> <ul> <li>A Tanssi-powered appchain (Quick Trial, Dedicated, or MainNet).</li> <li>Your appchain's Sudo account connected to your appchain's developer portal. You can refer to the Managing Sudo guide for instructions on injecting your Sudo account into the developer portal.</li> <li>The new Wasm runtime binary file, built with a higher version than the current one.</li> </ul> <p>If you're unsure what your Tanssi network's Sudo account is, you can find it in your Tanssi Dashboard underneath the Properties section.</p> <p></p> <p>Warning</p> <p>It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.</p>"},{"location":"builders/manage/developer-portal/upgrade/#obtaining-wasm-runtime","title":"Obtaining the Wasm Runtime","text":"<p>If your chain is based on one of the official templates, you can download the official Wasm runtime binary file from the table below. The official releases are published in the releases section in the Tanssi repository.</p> Version EVM Template Substrate Template 1400 Download EVM V1400 Wasm file Download Substrate V1400 Wasm file 1300 Download EVM V1300 Wasm file Download Substrate V1300 Wasm file 1201 Download EVM V1201 Wasm file Download Substrate V1201 Wasm file 1100 Download EVM V1100 Wasm file Download Substrate V1100 Wasm file 1000 Download EVM V1000 Wasm file Download Substrate V1000 Wasm file 900 Download EVM V900 Wasm file Download Substrate V900 Wasm file 800 Download EVM V800 Wasm file Download Substrate V800 Wasm file 700 Download EVM V700 Wasm file Download Substrate V700 Wasm file 600 Download EVM V600 Wasm file Download Substrate V600 Wasm file 500 Download EVM V500 Wasm file Download Substrate V500 Wasm file 400 Download EVM V400 Wasm file Download Substrate V400 Wasm file 300 Download EVM V300 Wasm file Download Substrate V300 Wasm file 200 Download EVM V200 Wasm file Download Substrate V200 Wasm file 101 Download EVM V101 Wasm file Download Substrate V101 Wasm file 100 Download EVM V100 Wasm file Download Substrate V100 Wasm file <p>You should always upgrade the runtime following the releases in an orderly fashion, applying one release after another without skipping any of them. To do so, you need to know your appchain's current runtime version, which you'll find in your Tanssi Dashboard underneath the Properties section. For example, if your runtime version is <code>1000</code>, you should upgrade first to <code>1100</code>, then <code>1201</code>, then <code>1300</code>, and so on until the latest available version.</p> <p>Warning</p> <p>Applying the upgrades in order ensures that the changes (migrations) in the internal data structures are applied, preserving data consistency. Doing otherwise might stall your appchain.</p> <p>Note</p> <p>If you are compiling the runtime manually, make sure to use the Wasm version <code>compact</code> and <code>compressed</code>, which is optimized and lighter.</p>"},{"location":"builders/manage/developer-portal/upgrade/#upgrading-your-runtime","title":"Upgrading Your Runtime","text":"<p>To get started, head to the developer portal for your Tanssi appchain, which can be found in your Tanssi Dashboard underneath the Tooling section.</p> <p></p> <p>Warning</p> <p>If your appchain was deployed using an official template and the intended upgrade is a custom runtime, make sure to have changed the default spec name (frontier-template or container-chain-template) to a different one before building the Wasm file. You'll also need to execute the <code>setCodeWithoutChecks</code> extrinsic instead of <code>setCode</code>.</p> <p>With your Wasm runtime ready to upload and your Sudo account accessible in the developer portal, take the following steps:</p> <ol> <li>Navigate to the Developer tab of the developer portal for your Tanssi appchain.</li> <li>Click on Sudo. If you do not see Sudo in this menu, then you have not associated the Sudo account with the developer portal. Make sure that your Sudo account is injected by your wallet and connected to the developer portal.</li> <li>Select the system pallet.</li> <li>Select setCode.</li> <li>Toggle the fileUpload switch to enable uploading your Wasm runtime file.</li> <li>Upload your Wasm runtime.</li> <li>Press Submit Sudo and confirm the transaction in your wallet.</li> </ol> <p></p> <p>You can verify that your runtime upgrade was successful by checking the runtime version in the upper left-hand corner. In this case, you can see that the Tanssi-powered appchain's runtime was successfully upgraded to version <code>400</code>.</p> <p></p> <p>And that's it! The developer portal section has plenty more guides on how to manage your Tanssi appchain.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/tanssi-network/","title":"Network Essentials","text":"<p>Learn about the Tanssi network, the available TestNets, and key functionalities and aspects to get started with development and interaction with it.</p>"},{"location":"builders/tanssi-network/#network-overview","title":"Network Overview","text":"<ul> <li>TANSSI token: the utility token native to the Tanssi networks, and its ERC-20 representation.</li> <li>Dancelight: the official Tanssi TestNet for rapid network deployment and experimentation.</li> <li>Tanssi-powered networks: networks built on the Tanssi platform, leveraging its capabilities to create custom blockchains.</li> <li>Demo EVM network: a sample Ethereum-compatible network that demonstrates a fully operational Tanssi-powered network.</li> </ul>"},{"location":"builders/tanssi-network/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/tanssi-network/#additional-resources","title":"Additional ResourcesNetwork Toolkit","text":"<p>Dive into tools and resources designed to streamline the development process when building dApps on Tanssi and Tanssi-powered networks.</p>"},{"location":"builders/tanssi-network/endpoints/","title":"Network Endpoints","text":""},{"location":"builders/tanssi-network/endpoints/#network-endpoints","title":"Network Endpoints","text":"<p>Tanssi networks have two endpoints available for users to connect to: one for HTTPS and one for WSS.</p>"},{"location":"builders/tanssi-network/endpoints/#tanssi-mainnet","title":"Tanssi MainNet","text":"<p>The Tanssi Network MainNet HTTPS and WSS endpoints are as follows:</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"},{"location":"builders/tanssi-network/endpoints/#dancelight","title":"Dancelight","text":"<p>The Tanssi TestNet HTTPS and WSS endpoints are as follows:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"},{"location":"builders/tanssi-network/endpoints/#demo-evm-network","title":"Demo EVM Network","text":"<p>The demo EVM network HTTPS and WSS endpoints are as follows:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"builders/tanssi-network/mainnet/","title":"Get Started with the Tanssi Network MainNet","text":""},{"location":"builders/tanssi-network/mainnet/#introduction","title":"Introduction","text":"<p>Tanssi Network MainNet is live, allowing developers to swiftly onboard and launch their appchains within minutes.</p> <p>This quick reference page offers all the essentials you need to get started on the Tanssi Network.</p>"},{"location":"builders/tanssi-network/mainnet/#tanssi-token","title":"TANSSI Token","text":"<p>TANSSI tokens serve as the native currency within the Tanssi Network. To initiate the deployment of a network on Tanssi, you'll need to obtain TANSSI tokens.</p>"},{"location":"builders/tanssi-network/mainnet/#tanssi-network-endpoints","title":"Network Endpoints","text":"<p>Tanssi MainNet has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi/\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"},{"location":"builders/tanssi-network/mainnet/#tanssi-block-explorers","title":"Block Explorers","text":"<p>For Tanssi MainNet, you can use the following block explorer:</p> <ul> <li>Tanssi Network Subscan</li> <li>Polkadot.js Apps</li> </ul> <p>Support for additional block explorers is in the works and as more explorers support Tanssi MainNet, this section will be updated accordingly.</p>"},{"location":"builders/tanssi-network/tanssi-token/","title":"TANSSI Token","text":""},{"location":"builders/tanssi-network/tanssi-token/#introduction","title":"Introduction","text":"<p>The Tanssi network token is the utility token that powers the Tanssi protocol. Considering Tanssi's architecture, the token exists in two distinct yet interconnected representations: native substrate and Ethereum ERC-20. The two versions can be bridged between each other through the Tanssi-Ethereum bridge.</p> <p>In this guide, the token's utility and the differences between its two representations are covered, which is crucial for network operators, stakers, appchain managers, and general users who want to participate in the Tanssi ecosystem.</p>"},{"location":"builders/tanssi-network/tanssi-token/#token-utility","title":"Token Utility","text":"<p>Tanssi is a decentralized infrastructure protocol that makes deploying appchains with custom logic easy. It allows developers to focus on the use case instead of diverting time and energy to manage the numerous components required for a network to run smoothly.</p> <p>Running a healthy decentralized protocol not only requires a robust governance mechanism to ensure that decisions are made transparently but also aligning incentives and coordinating among several ecosystem actors, including appchain developers, node operators, sequencer operators, data availability and RPC providers, as well as general users. The Tanssi token serves as the backbone, providing the economic mechanisms necessary to coordinate, incentivize proper behavior, and secure the entire ecosystem. It enables a verifiable and code-enforced protocol evolution through a fully on-chain decision-making process.</p> <p>The token has several utilities:</p> <ul> <li>On-chain governance: token holders can use the token to propose and vote in governance decisions, such as software upgrades, how to spend treasury funds, change protocol rules, and more.</li> <li>Appchain deployment: use the token to register and launch your appchain in minutes.</li> <li>Sequencing as a service payment: use the token to keep your appchain live.</li> <li>Sequencing and operator services rewarding: get tokens as rewards for your nodes' services.</li> <li>Staking on sequencers: token holders can stake on sequencers, getting rewards with no risk of slashing.</li> <li>Staking on operators: token holders can stake on operators, getting rewards for their validation services.</li> <li>Fees payment: use the token to pay the fees for interacting with the Tanssi network.</li> </ul> <p>Note</p> <p>All transaction fees on Tanssi are paid using the token, with the full amount going directly to fund the protocol's treasury account. These funds can only be spent via governance.</p>"},{"location":"builders/tanssi-network/tanssi-token/#token-representations","title":"Token Representations","text":"<p>The Tanssi network is built using the Substrate framework, leveraging its modular architecture and high performance. Therefore, the native token is of a Substrate type. The protocol's minting and burning mechanisms happen on the Tanssi network side, or, in other words, happen on the Substrate token representation.</p> <p>Additionally, the Tanssi protocol relies on external security providers, such as Symbiotic, to secure the ecosystem through restaked assets. This restaking mechanism is implemented on Ethereum; therefore, an ERC-20 version of the token also exists to cover user cases on the Ethereum side.</p> <p>Leveraging Tanssi's built-in bridging capabilities, the token can be converted to (and from) the ERC-20  representation on Ethereum. When the token is bridged to Ethereum, the tokens are locked in the bridge's sovereign account, and a message is sent to the Ethereum contract to mint the equivalent amount in ERC-20. This lock-and-mint mechanism ensures the ERC-20 version is created through a trustless bridging mechanism, maintaining a 1:1 relationship with the native token.</p> <pre><code>flowchart LR\n    subgraph Tanssi_Network [\"Tanssi Network\"]\n        Tanssi_Substrate[\"$TANSSI (Substrate)\"]\n        Tanssi_Substrate_Utility[\"\u2713 On-chain governance\n        \u2713 Appchain deployment\n        \u2713 Sequencers rewarding\n        \u2713 Staking on sequencers\n        \u2713 Fees payment\n        \"]\n        Tanssi_Substrate --&gt; Tanssi_Substrate_Utility\n    end\n\n    subgraph Ethereum_Network [\"Ethereum\"]\n        Tanssi_ERC20[\"$TANSSI (ERC-20)\"]\n        Tanssi_ERC20_Utility[\"\u2713 Operator services rewarding\n        \u2713 Staking on operators\n        &lt;pre&gt; &lt;/pre&gt;\n        \"]\n        Tanssi_ERC20 --&gt; Tanssi_ERC20_Utility\n    end\n\n    Bridge[\"Trustless Bridge\"]\n\n    Tanssi_Network &lt;--&gt; Bridge &lt;--&gt; Ethereum_Network\n\n    %% Apply custom style to utility nodes\n    classDef utility_style fill: transparent, stroke: transparent, text-align: start;\n    class Tanssi_Substrate_Utility,Tanssi_ERC20_Utility utility_style;\n    %% Make utility arrows transparent\n    linkStyle 0 stroke:transparent,fill:transparent;\n    linkStyle 1 stroke:transparent,fill:transparent;</code></pre>"},{"location":"builders/tanssi-network/tanssi-token/#tanssi-substrate","title":"Tanssi (Substrate) - Native Token","text":"<p>The native Tanssi token exists on the Tanssi network as a Substrate-based asset and is the original form of the token that powers the core protocol operations.</p> <p>This token uses as Sr25519 subtrate-type account, so it requires a wallet such as Talisman or any other substrate-compatible wallet.</p> <p>Note</p> <p>The Tanssi (Substrate) native token has twelve (12) decimal places.</p>"},{"location":"builders/tanssi-network/tanssi-token/#tanssi-erc-20","title":"Tanssi (ERC-20) - Ethereum Representation","text":"<p>Tanssi's ERC-20 version is a standard Ethereum token that represents the native token on the Ethereum network. This version is created through the trustless bridging mechanism, utilizing a lock-and-mint strategy, thereby maintaining a 1:1 relationship with the native token. </p> <p>This token, like any other Ethereum asset, uses an ECDSA account, so it requires a wallet such as Metamask or any other Ethereum-compatible wallet.</p> <p>Note</p> <p>The Tanssi (ERC-20) has twelve (12) decimal places.</p>"},{"location":"builders/tanssi-network/tanssi-token/#substrate-erc-20-comparison","title":"Tanssi (Substrate) and Tanssi (ERC-20) Comparison","text":"<p>To better understand the differences between the two token representations, the following table provides a summary of their main features:</p> Feature Tanssi (Substrate) Tanssi (ERC-20) Network Tanssi Network Ethereum MainNet Token Standard Native Substrate asset ERC-20 standard token Decimal Places Twelve (12) decimals Twelve (12) decimals Account Type Sr25519 ECDSA Compatible Wallets Talisman, SubWallet, and others MetaMask, Talisman, and other Ethereum-compatible wallets Primary Utilities - On-chain governance participation- Appchain registration and deployment- Sequencing services payment- Transaction fees on Tanssi network- Staking on sequencers- Sequencer operation rewards - Operator validation rewards- Staking on operators Staking Options Sequencer staking (for keeping appchain liveness) Operator staking (for validating/securing the entire Tanssi ecosystem) Bridge Conversion Can be bridged to ERC-20, paying fees in $TANSSI (Substrate) Can be bridged to Substrate, paying fees in $ETH"},{"location":"builders/tanssi-network/testnet/","title":"TestNet","text":"<p>Dancelight, the official Tanssi TestNet, allows developers to experiment with blockchain applications in a controlled environment before going live. It provides the tools to configure networks, interact with test versions of protocols, and troubleshoot issues to ensure a smoother transition to production.</p> <p>When you're ready to see how your project could thrive in a real-world setting, try out the demo EVM environment. Fully compatible with Ethereum, this Tanssi-powered setup showcases key features and offers an immersive experience, giving you a glimpse into the full potential of your customized solution.</p>"},{"location":"builders/tanssi-network/testnet/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/tanssi-network/testnet/dancelight/","title":"Get Started with Dancelight","text":""},{"location":"builders/tanssi-network/testnet/dancelight/#introduction","title":"Introduction","text":"<p>Dancelight is the first public Tanssi TestNet and is designed to streamline the deployment of decentralized networks. It allows teams to swiftly onboard and launch their appchains within minutes, providing a robust environment for testing and development.</p> <p>This quick reference page offers all the essentials you need to get started on Dancelight.</p>"},{"location":"builders/tanssi-network/testnet/dancelight/#testnet-tokens","title":"TestNet Tokens","text":"<p>STAR tokens serve as the native currency within the Dancelight Network. To initiate the deployment of a network on Dancelight, you'll need to obtain STAR tokens. Follow these steps:</p> <ol> <li>Visit the Tanssi Network website.</li> <li>Complete the form by providing basic information and your Substrate-based address.</li> <li>Within one business day of submitting the form, you'll receive STAR tokens for testing.</li> </ol> <p>Note</p> <p>STAR tokens have no value. Please don't submit unnecessary requests.</p>"},{"location":"builders/tanssi-network/testnet/dancelight/#dancelight-network-endpoints","title":"Network Endpoints","text":"<p>Dancelight has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"},{"location":"builders/tanssi-network/testnet/dancelight/#dancelight-block-explorers","title":"Block Explorers","text":"<p>For Dancelight, you can use the following block explorer:</p> <ul> <li>Subscan.</li> <li>The developer portal.</li> </ul> <p>Support for additional block explorers is in the works and as more explorers support Dancelight, this section will be updated accordingly.</p>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/","title":"Demo EVM Tanssi Network","text":""},{"location":"builders/tanssi-network/testnet/demo-evm-network/#introduction","title":"Introduction","text":"<p>Explore the functionalities of a fully Ethereum-compatible network deployed through Tanssi by interacting with the demo EVM network on Dancelight.</p> <p>This quick reference page offers all the essentials you need to interact with this demo network.</p>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/#faucet","title":"Faucet for TestNet Tokens","text":"<p>You can access TANGO tokens, the native currency of the EVM demo network, at the faucet on the Tanssi dApp. You can receive up to 100 TANGO tokens every 12 hours.</p> <p>To request tokens from the faucet, head to the Tanssi dApp and press Add to MetaMask.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Press Request Tokens</li> <li>Select the account you'd like to receive TANGO tokens and press Next</li> <li>Press Connect</li> </ol> <p></p> <p>Note</p> <p>TANGO tokens have no value. Please don't spam the faucet with unnecessary requests.</p> <p>Your tokens will be disbursed shortly, and you can verify your TANGO token balance by looking up your address on the explorer.</p>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/#network-endpoints","title":"Network Endpoints","text":"<p>The demo EVM network HTTPS and WSS endpoints are as follows:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/#block-explorers","title":"Block Explorers","text":"<p>For the demo EVM network, you can use any of the following explorers:</p> <ul> <li>Polkadot.js Apps (Substrate API)</li> <li>Blockscout (Ethereum API)</li> <li>Expedition (Ethereum API)</li> </ul>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/#chain-id","title":"Chain ID","text":"<p>The demo EVM network has a chain ID of: <code>5678</code>, which is <code>0x162E</code> in hex.</p>"},{"location":"builders/tanssi-network/testnet/demo-evm-network/#quick-start","title":"Quick Start","text":"<p>You can interact with a Tanssi-powered EVM network using standard Ethereum libraries, like Ethers.js, Web3.js, and Web3.py. To quickly get started, you'll need to create a provider connected to a Tanssi EVM network:</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from \"ethers\";\n\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insert your RPC URL here\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/', \n    chainId: 5678, // 0x162E in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <pre><code>const Web3 = require('web3');\n\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <pre><code>from web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/')) \n</code></pre>"},{"location":"builders/toolkit/","title":"Toolkit","text":"<p>The Toolkit section is your all-in-one resource hub for building, deploying, and managing Tanssi-powered networks. It brings together Ethereum and Substrate tools, such as libraries, development environments, precompiles, JSON-RPC methods, and more. Whether you're enhancing an existing network or implementing new features, this toolkit gives you everything you need to simplify the development and operation of your network.</p> <p>Tip</p> <p>If you are working with an EVM-compatible network, you can use Substrate tools to interact with the lower-level functionalities of your network. Using this, you can interact with custom runtime modules, query storage, manage governance, or work with features unique to Substrate.</p>"},{"location":"builders/toolkit/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/","title":"Ethereum Tools","text":"<p>Developing on Tanssi-powered EVM-compatible chains requires understanding how to interact with the blockchain effectively. Whether you're building decentralized applications (dApps), deploying smart contracts, or querying blockchain data, using the right tools and workflows is essential.</p> <p>This section offers an overview of the key tools and workflows that developers use to interact with these networks, helping to enhance your development workflow.</p> <p>Ready to dive in? Check out some of the following tools:</p> <ul> <li>Development environments - Remix, Foundry, and Hardhat</li> <li>Libraries - Ethers.js, viem, and Web3.js</li> <li>Wallets - MetaMask, SubWallet, and Talisman</li> </ul>"},{"location":"builders/toolkit/ethereum-api/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/rpc/","title":"JSON-RPC API Methods","text":""},{"location":"builders/toolkit/ethereum-api/rpc/#standard-rpc-methods","title":"Standard Ethereum JSON-RPC Methods","text":"<p>As Tanssi's EVM Compatibility is derived from Frontier and closely modeled after Moonbeam's Ethereum compatibility, Tanssi nodes support a wide variety of standard supported Ethereum JSON-RPC methods.</p> <p>Nevertheless, not all Ethereum JSON-RPC methods are supported; some of those supported return default values (those related to Ethereum's PoW consensus mechanism in particular). This guide provides a comprehensive list of supported Ethereum JSON-RPC methods on Tanssi. Developers can quickly reference this list to understand the available functionality for interfacing with Tanssi EVM networks.</p> <p>The basic JSON-RPC methods from the Ethereum API supported by Tanssi are:</p> <ul> <li>eth_protocolVersion \u2014 returns <code>1</code> by default</li> <li>eth_syncing \u2014 returns an object with data about the sync status or <code>false</code></li> <li>eth_hashrate \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_coinbase \u2014 returns the latest block author. Not necessarily a finalized block</li> <li>eth_mining \u2014 returns <code>false</code> by default</li> <li>eth_chainId \u2014 returns the chain ID used for signing at the current block</li> <li>eth_gasPrice \u2014 returns the base fee per unit of gas used. This is currently the minimum gas price for each network</li> <li>eth_accounts \u2014 returns a list of addresses owned by the client</li> <li>eth_blockNumber \u2014 returns the highest available block number</li> <li>eth_getBalance \u2014 returns the balance of the given address</li> <li>eth_getStorageAt \u2014 returns the content of the storage at a given address</li> <li>eth_getBlockByHash \u2014 returns information about the block of the given hash, including <code>baseFeePerGas</code> on post-London blocks</li> <li>eth_getBlockByNumber \u2014 returns information about the block specified by block number, including <code>baseFeePerGas</code> on post-London blocks</li> <li>eth_getBlockReceipts \u2014 returns all transaction receipts for a given block</li> <li>eth_getTransactionCount \u2014 returns the number of transactions sent from the given address (nonce)</li> <li>eth_getBlockTransactionCountByHash \u2014 returns the number of transactions in a block with a given block hash</li> <li>eth_getBlockTransactionCountByNumber \u2014 returns the number of transactions in a block with a given block number</li> <li>eth_getUncleCountByBlockHash \u2014  returns <code>\"0x0\"</code> by default</li> <li>eth_getUncleCountByBlockNumber \u2014 returns <code>\"0x0\"</code> by default</li> <li>eth_getCode \u2014 returns the code at the given address at the given block number</li> <li>eth_sendTransaction \u2014 creates a new message call transaction or a contract creation, if the data field contains code. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_sendRawTransaction \u2014 creates a new message call transaction or a contract creation for signed transactions. Returns the transaction hash or the zero hash if the transaction is not yet available</li> <li>eth_call \u2014 executes a new message call immediately without creating a transaction on the blockchain, returning the value of the executed call</li> <li>eth_estimateGas \u2014 returns an estimated amount of gas necessary for a given transaction to succeed. You can optionally specify a <code>gasPrice</code> or <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code></li> <li>eth_feeHistory \u2014 returns <code>baseFeePerGas</code>, <code>gasUsedRatio</code>, <code>oldestBlock</code>, and <code>reward</code> for a specified range of up to 1024 blocks</li> <li>eth_getTransactionByHash \u2014 returns the information about a transaction with a given hash. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockHashAndIndex \u2014 returns information about a transaction at a given block hash and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionByBlockNumberAndIndex \u2014 returns information about a transaction at a given block number and a given index position. EIP-1559 transactions have <code>maxPriorityFeePerGas</code> and <code>maxFeePerGas</code> fields</li> <li>eth_getTransactionReceipt \u2014 returns the transaction receipt of a given transaction hash</li> <li>eth_getUncleByBlockHashAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getUncleByBlockNumberAndIndex \u2014 returns <code>null</code> by default</li> <li>eth_getLogs \u2014 returns an array of all logs matching a given filter object</li> <li>eth_newFilter \u2014 creates a filter object based on the input provided. Returns a filter ID</li> <li>eth_newBlockFilter \u2014 creates a filter in the node to notify when a new block arrives. Returns a filter ID</li> <li>eth_getFilterChanges \u2014 polling method for filters (see methods above). Returns an array of logs that occurred since the last poll</li> <li>eth_getFilterLogs \u2014 returns an array of all the logs matching the filter with a given ID</li> <li>eth_uninstallFilter \u2014 uninstall a filter with a given ID. It should be used when polling is no longer needed. Filters timeout when they are not requested using <code>eth_getFilterChanges</code> after some time</li> </ul>"},{"location":"builders/toolkit/ethereum-api/rpc/#custom-json-rpc-methods","title":"Custom JSON-RPC Methods","text":"<p>Tanssi nodes support two custom JSON-RPC endpoints: <code>frnt_isBlockFinalized</code> and <code>frnt_isTxFinalized</code>. Tanssi features deterministic finality (as opposed to probabilistic like Bitcoin's finality), which means that at any point of time, the answer to whether a block or transaction is finalized or not can be answered with a definitive yes or no. Tanssi has built these two custom endpoints to provide valuable functionality for checking the finality of on-chain events.</p> frnt_isBlockFinalized - checks for the finality of the block given by its block hash ParametersReturnsExample <ul> <li><code>block_hash</code> string - the hash of the block, accepts either Substrate-style or Ethereum-style block hash as its input</li> </ul> <p>boolean - <code>true</code> if the block is finalized, <code>false</code> if the block is not finalized or not found</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> frnt_isTxFinalized - checks for the finality of a transaction given its EVM transaction hash ParametersReturnsExample <ul> <li><code>tx_hash</code> string - the EVM transaction hash of the transaction </li> </ul> <p>boolean - <code>true</code> if the transaction is finalized, <code>false</code> if the transaction is not finalized or not found</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/","title":"Development Environments","text":"<p>Establishing an effective development environment is crucial for building, testing, and deploying smart contracts efficiently. Development environments simplify the process of building blockchain applications by abstracting away many of the underlying complexities involved in interacting with blockchain networks. They provide the necessary tools and frameworks to:</p> <ul> <li>Write, compile, test, and deploy Solidity smart contracts</li> <li>Simulate blockchain interactions locally for testing and debugging</li> <li>Automate workflows for faster deployments</li> </ul> <p>Each development environment helps you achieve the same goal, building and deploying blockchain applications, but they do so in unique ways. For instance, browser-based IDEs like Remix provide a fast and accessible way to start coding, while tools like Foundry and Hardhat cater to developers who prefer specific workflows, such as a Solidity-first or JavaScript-integrated approach. Choose the one that aligns best with your needs and development style.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/","title":"Using Foundry to Deploy to Your EVM Network","text":""},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#introduction","title":"Introduction","text":"<p>Foundry is an Ethereum development environment written in Rust that helps developers manage dependencies, compile projects, run tests, deploy contracts, and interact with blockchains from the command line. Foundry can directly interact with the Ethereum API of Tanssi-powered EVM networks, so it can be used to deploy and interact with smart contracts on your Tanssi network.</p> <p>There are four tools that make up Foundry:  </p> <ul> <li>Forge - compiles, tests, and deploys contracts</li> <li>Cast - a command line interface for interacting with contracts</li> <li>Anvil - a local TestNet node for development purposes that can fork preexisting networks</li> <li>Chisel - a Solidity REPL for quickly testing Solidity snippets</li> </ul> <p>This guide will cover how to use Foundry to compile, deploy, and debug Ethereum smart contracts on the demo EVM network. You can follow the same steps to perform these actions on your Tanssi EVM network by replacing the RPC URL and Chain ID shown in the examples.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you will need the following:</p> <ul> <li>An account with funds</li> <li>Foundry installed</li> </ul>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#creating-a-foundry-project","title":"Creating a Foundry Project","text":"<p>You will need to create a Foundry project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Install Foundry with the below commands. The Windows instructions are noticeably different as you'll have to install Rust and then build Foundry from source</p> UbuntuMacOSWindows <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> <p>After installing, you may need to restart your terminal session or add <code>foundryup</code> to your PATH.</p> </li> <li> <p>Create the project, which will create a folder with three folders within it:</p> <pre><code>forge init foundry\n</code></pre> </li> </ol> <p>You may get an error, such as <code>The target directory is a part of or on its own an already initialized git repository, and it requires clean working and staging areas, including no untracked files.</code> To solve this, you can add files and make a commit if you are maintaining this project within a GitHub repository. Otherwise, you can make a dummy commit without pushing. If you run <code>forge init foundry</code> once more, you'll no longer have the error.</p> <p>With the default project created, you should see three folders.  </p> <ul> <li><code>lib</code> - all of the project's dependencies in the form of git submodules</li> <li><code>src</code> - where to put your smart contracts (with functionality)</li> <li><code>test</code> - where to put the forge tests for your project, which are written in Solidity</li> </ul> <p>In addition to these three folders, a git project will also be created along with a prewritten <code>.gitignore</code> file with relevant file types and folders ignored.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#the-src-folder","title":"The Source Folder","text":"<p>The preconfigured <code>foundry</code> repo includes <code>Counter.sol</code> in the <code>src</code> folder, as well as a <code>Counter.s.sol</code> in the <code>script</code> folder and <code>Counter.t.sol</code> in the <code>test</code> folder. You should delete these files to avoid errors when trying to compile and deploy <code>MyToken.sol</code>. You can do so with the following command:</p> <pre><code>rm src/Counter.sol script/Counter.s.sol test/Counter.t.sol\n</code></pre> <p>In the following steps, you will be deploying an ERC-20 contract. In the contracts directory, you can create the <code>MyToken.sol</code> file:</p> <pre><code>cd src\ntouch MyToken.sol\n</code></pre> <p>Open the file and add the following contract to it:</p> <pre><code>pragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p>Before you attempt to compile, install OpenZeppelin contracts as a dependency. You may have to commit previous changes to git beforehand. By default, Foundry uses git submodules instead of npm packages, so the traditional npm import path and command are not used. Instead, use the name of OpenZeppelin's GitHub repository:</p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#compiling-solidity","title":"Compiling Solidity","text":"<p>Once all dependencies have been installed, you can compile the contract:</p> <pre><code>forge build\n</code></pre> <p></p> <p>After compilation, two folders will be created: <code>out</code> and <code>cache</code>. The ABI and bytecode for your contracts will be contained within the <code>out</code> folder. These two folders are already ignored by the <code>.gitignore</code> included in the default Foundry project initialization.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#deploying-the-contract","title":"Deploying the Contract","text":"<p>Deploying the contract with Forge takes a single command, but you will need to include an RPC endpoint, a funded private key, and constructor arguments. <code>MyToken.sol</code> asks for an initial supply of tokens in its constructor, so the following command includes 100 as a constructor argument. You can deploy the <code>MyToken.sol</code> contract using the following command modified for the correct network:</p> <pre><code>forge create --rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--constructor-args 100 \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <p>After a few seconds, the contract is deployed, and you should see the address in the terminal.</p> <p></p> <p>Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#interacting-with-the-contract","title":"Interacting with the Contract","text":"<p>Foundry includes Cast, a CLI for performing Ethereum RPC calls.</p> <p>Try to retrieve your token's name using Cast, where <code>INSERT_YOUR_CONTRACT_ADDRESS</code> is the address of the contract that you deployed in the previous section:</p> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>You should get this data in hexadecimal format:</p> <pre><code>0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>This is far from readable, but you can use Cast to convert it into your desired format. In this case, the data is text, so you can convert it into ASCII characters to see \"My Token\":</p> <p></p> <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>You can also mutate data with Cast as well. Try burning tokens by sending them to the zero address.</p> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--chain 5678 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre> <p>The transaction will be signed by your EVM account and be broadcast to the network. The output should look similar to:</p> <p></p> <p>Congratulations, you have successfully deployed and interacted with a contract using Foundry!</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#forking-with-anvil","title":"Forking with Anvil","text":"<p>As previously mentioned, Anvil is a local TestNet node for development purposes that can fork preexisting networks. Forking the demo EVM network allows you to interact with live contracts deployed on the network.</p> <p>To fork the demo EVM network from the command line, you can run the following command from within your Foundry project directory. You can also replace the RPC URL with the RPC URL of your Tanssi EVM network.</p> <pre><code>anvil --fork-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Your forked instance will have 10 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at <code>http://127.0.0.1:8545/</code>. The output in your terminal should resemble the following:</p> <p></p> <p>To verify you have forked the network, you can query the latest block number and compare it to the current block number of the demo EVM network.</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545 \n</code></pre> <p>If you convert the <code>result</code> from hex to decimal, you should get the latest block number from the time you forked the network.</p> <p>From here, you can deploy new contracts to your forked instance of the demo EVM network (or any other Tanssi-powered EVM network) or interact with contracts already deployed. Building off of the previous example in this guide, you can make a call using Cast to check the balance of the minted MYTOK tokens in the account you deployed the contract with:</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS  \"balanceOf(address)(uint256)\" \\\n INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#using-chisel","title":"Using Chisel","text":"<p>Chisel is a Solidity REPL or shell. It allows a developer to write Solidity directly in the console for testing small snippets of code, letting developers skip the project setup and contract deployment steps for what should be a quick process.  </p> <p>Since Chisel is mainly useful for quick testing, it can be used outside of a Foundry project. But, if executed within a Foundry project, it will keep the configurations within <code>foundry.toml</code> when running.  </p> <p>For this example, you will be testing out some of the features of <code>abi</code> within Solidity because it is complex enough to demonstrate how Chisel could be useful. To get started using Chisel, run the following in the command line to start the shell:</p> <pre><code>chisel\n</code></pre> <p>In the shell, you can write Solidity code as if it were running within a function:</p> <pre><code>bytes memory myData = abi.encode(100, true, \"Build with Tanssi\");\n</code></pre> <p>Let's say you were interested in how <code>abi</code> encoded data because you're looking into how to most efficiently store data on the blockchain and thus save gas. To view how the <code>myData</code> is stored in memory, you can use the following command while in the Chisel shell:</p> <pre><code>!memdump\n</code></pre> <p><code>memdump</code> will dump all of the data in your current session. You'll likely see something like this below. If you aren't good at reading hexadecimal or if you don't know how ABI encoding works, then you might not be able to find where the <code>myData</code> variable has been stored.</p> <p></p> <p>Fortunately, Chisel lets you easily figure out where this information is stored. Using the <code>!rawstack</code> command, you can find the location in the stack where the value of a variable is:</p> <pre><code>!rawstack myData\n</code></pre> <p>In this situation, since <code>myData</code> is over 32 bytes in length, the memory pointer is displayed instead. But that's exactly what's needed since you already know the entirety of the stack from the <code>!memdump</code> command.</p> <p></p> <p>The <code>!rawstack</code> command shows that the <code>myData</code> variable is stored at <code>0x80</code>, so when comparing this with the memory dump retrieved from the <code>!memdump</code> command, it looks like <code>myData</code> is stored like this:  </p> <pre><code>[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0\n[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064\n[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001\n[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060\n[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000011\n[0x120:0x140]: 0x4275696c6420776974682054616e737369000000000000000000000000000000\n</code></pre> <p>At first glance, this makes sense since <code>0xa0</code> has a value of <code>0x64</code>, which is equal to 100, and <code>0xc0</code> has a value of <code>0x01</code>, which is equal to true. If you want to learn more about how ABI-encoding works, the Solidity documentation for ABI is helpful. In this case, there are a lot of zeros in this method of data packing, so as a smart contract developer, you might instead try to use structs or pack the data together more efficiently with bitwise code.  </p> <p>Since you're done with this code, you can clear the state of Chisel so that it doesn't mess with any future logic that you want to try out (while running the same instance of Chisel):  </p> <pre><code>!clear\n</code></pre> <p>There's an even easier way to test with Chisel. When writing code that ends with a semicolon, <code>;</code>, Chisel will run it as a statement, storing its value in Chisel's runtime state. But if you only needed to see how the ABI-encoded data was represented, then you could get away with running the code as an expression. To try this out with the same <code>abi</code> example, write the following in the Chisel shell:  </p> <pre><code>abi.encode(100, true, \"Build with Tanssi\")\n</code></pre> <p>You should see something like the following:  </p> <p></p> <p>While it doesn't display the data in the same way, you still get the contents of the data, and it also further breaks down how the information is coded, such as letting you know that the <code>0xa0</code> value defines the length of the data.  </p> <p>By default, when you leave the Chisel shell, none of the data persists. But you can instruct Chisel to do so. For example, you can take the following steps to store a variable:</p> <ol> <li> <p>Store a <code>uint256</code> in Chisel</p> <pre><code>uint256 myNumber = 101;\n</code></pre> </li> <li> <p>Store the session with <code>!save</code>. For this example, you can use the number <code>1</code> as a save ID</p> <pre><code>!save 1\n</code></pre> </li> <li> <p>Quit the session <pre><code>!quit\n</code></pre></p> </li> </ol> <p>Then to view and interact with your stored Chisel states, you can take the following steps:</p> <ol> <li> <p>View a list of saved Chisel states</p> <pre><code>chisel list\n</code></pre> </li> <li> <p>Load your stored state by providing the <code>chisel load</code> command followed by the ID of the state</p> <pre><code>chisel load 1\n</code></pre> </li> <li> <p>View the <code>uint256</code> saved in Chisel from the previous set of steps</p> <pre><code>!rawstack myNumber\n</code></pre> </li> </ol> <p></p> <p>You can even fork networks while using Chisel:</p> <pre><code>!fork https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Then, for example, you can query the balance of the Alice account on the demo EVM network:  </p> <pre><code>0x44236223aB4291b93EEd10E4B511B37a398DEE55.balance\n</code></pre> <p></p> <p>If you want to learn more about Chisel, download Foundry and refer to its official reference page.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/foundry/#foundry-with-hardhat","title":"Foundry with Hardhat","text":"<p>Often, there will be the case where a project that you wish to integrate with has all of its setup within Hardhat, making it an arduous task to convert the entirety of the project into Foundry. This additional work is avoidable by creating a hybrid project that uses both Hardhat and Foundry features together. This is possible with Hardhat's hardhat-foundry plugin.  </p> <p>To convert your preexisting Foundry project to a hybrid project, you will essentially have to install a Hardhat project into the same folder:  </p> <pre><code>npm init\nnpm install --save-dev hardhat @nomicfoundation/hardhat-foundry\nnpx hardhat init\n</code></pre> <p>For more information, please refer to our documentation on Creating a Hardhat Project.</p> <p>After initializing the new Hardhat project, a few new folders and files should appear: <code>contracts</code>, <code>hardhat.config.js</code>, <code>scripts</code>, and <code>test/Lock.js</code>. You'll need to make a few modifications to create a hybrid project:</p> <ol> <li> <p>Edit the <code>hardhat.config.js</code> file within your repository. Open it up, and at the top, add the following:  </p> <pre><code>require('@nomicfoundation/hardhat-foundry');\n</code></pre> <p>After adding the <code>hardhat-foundry</code> plugin, the typical <code>contracts</code> folders for Hardhat will not work because now Hardhat expects all smart contracts to be stored within Foundry's <code>src</code> folder</p> </li> <li> <p>Move all smart contracts within the <code>contracts</code> folder into the <code>src</code> folder, and then delete the <code>contracts</code> folder</p> </li> <li> <p>Edit the <code>foundry.toml</code> file to ensure that dependencies installed via Git submodules and npm can be compiled by the Forge tool. Edit the <code>profile.default</code> to ensure that the <code>libs</code> entry has both <code>lib</code> and <code>node_modules</code>:  </p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', 'node_modules']\nsolc = '0.8.20'\nevm_version = 'london'\n</code></pre> </li> </ol> <p>Now both <code>forge build</code> and <code>npx hardhat compile</code> should work regardless of the dependencies.  </p> <p>Both <code>forge test</code> and <code>npx hardhat test</code> should now be able to access all smart contracts and dependencies. <code>forge test</code> will only test the Solidity tests, whereas <code>npx hardhat test</code> will only test the JavaScript tests. If you would like to use them in conjunction, then you can create a new script within your <code>package.json</code> file:  </p> <pre><code>\"scripts\": {\n    \"test\": \"npx hardhat test &amp;&amp; forge test\"\n}\n</code></pre> <p>You can run this command with:  </p> <pre><code>npm run test\n</code></pre> <p>Finally, while not necessary, it could be worthwhile to move all JavaScript scripts from the <code>scripts</code> folder into Foundry's <code>script</code> folder and delete the <code>scripts</code> folder so that you don't have two folders that serve the same purpose.</p> <p>Congratulations, you have successfully deployed and interacted with smart contracts on your Tanssi EVM network using Foundry! For more information, be sure to check out the Foundry Book.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/","title":"Using Hardhat to Deploy to Your EVM Network","text":""},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#introduction","title":"Introduction","text":"<p>Hardhat is an Ethereum development environment that helps developers manage and automate the recurring tasks inherent to building smart contracts and dApps. Hardhat can be used with any EVM network to build, compile, and deploy smart contracts, thanks to the seamless compatibility of Tanssi-powered EVM networks.</p> <p>This guide will cover how to use Hardhat to compile, deploy, and interact with Ethereum smart contracts deployed to the demo Tanssi EVM network. This guide can be adapted for your own Tanssi-powered EVM network by simply adding the RPC URL of your Tanssi network to your EVM Wallet and switching networks to it.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you'll need to have MetaMask installed and configured to work with your Tanssi EVM network. You can follow this guide to configure MetaMask for Tanssi with the demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project","title":"Creating a Hardhat Project","text":"<p>You must create a Hardhat project if you don't already have one. You can create one by completing the following steps:</p> <ol> <li> <p>Create a directory for your project</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>Initialize the project, which will create a <code>package.json</code> file</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install Hardhat</p> <pre><code>npm install hardhat\n</code></pre> </li> <li> <p>Create a project</p> <pre><code>npx hardhat init\n</code></pre> <p>Note</p> <p><code>npx</code> is used to run executables installed locally in your project. Although Hardhat can be installed globally, installing it locally in each project is recommended so you can control the version on a project-by-project basis.</p> </li> <li> <p>A menu will appear allowing you to create a new project or use a sample project. For this example, you can choose Create an empty hardhat.config.js</p> </li> </ol> npx hardhat init 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 8888888888\u00a0\u00a08888b.\u00a0\u00a0888d888\u00a0.d88888\u00a088888b.\u00a0\u00a0\u00a08888b.\u00a0\u00a0888888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888P\"\u00a0\u00a0d88\"\u00a0888\u00a0888\u00a0\"88b\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0.d888888\u00a0888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0.d888888\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0Y88b\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0Y88b. 888\u00a0\u00a0\u00a0\u00a0888\u00a0\"Y888888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"Y88888\u00a0888\u00a0\u00a0888\u00a0\"Y888888\u00a0\u00a0\"Y888 \ud83d\udc77 Welcome to Hardhat v2.22.2 \ud83d\udc77\u200d \u00a0What do you want to do? \u2026 \u00a0\u00a0Create a JavaScript project  \u00a0\u00a0Create a TypeScript project  \u00a0\u00a0Create a TypeScript project (with Viem)  \u00a0\u00a0Quit  <p>This will create a Hardhat config file (<code>hardhat.config.js</code>) in your project directory.</p> <p>Once you have your Hardhat project, you can also install the Ethers plugin. This provides a convenient way to use the Ethers.js library to interact with the network. To install it, run the following command:</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers\n</code></pre> <p>Additionally, you'll need to install the <code>hardhat-ignition-ethers</code> plugin to enable deployment of smart contracts with Hardhat Ignition. You can install it with the following command:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ignition-ethers\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#the-contract-file","title":"The Contract File","text":"<p>With your empty project created, you will create a <code>contracts</code> directory next. You can do so by running the following command:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts\n</code></pre> <p>The smart contract that you'll deploy as an example will be called <code>Box</code>, it will let you store a value that can be retrieved later. In the <code>contracts</code> directory, you can create the <code>Box.sol</code> file:</p> <pre><code>touch Box.sol\n</code></pre> <p>Open the file and add the following contract to it:</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitted when the stored value changes\n    event ValueChanged(uint256 newValue);\n\n    // Stores a new value in the contract\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // Reads the last stored value\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#hardhat-configuration-file","title":"The Hardhat Configuration File","text":"<p>Before you can deploy the contract to your Tanssi network, you'll need to modify the Hardhat configuration file and create a secure file to store your private key in.</p> <p>You can modify the <code>hardhat.config.js</code> file to use either the Tanssi demo EVM network or your own Tanssi network:</p> <pre><code>// 1. Import the Ethers and Hardhat Ignition plugins required to interact with the contract\nrequire('@nomicfoundation/hardhat-ethers');\nrequire('@nomicfoundation/hardhat-ignition-ethers');\n\n// 2. Add your private key that is funded with tokens of your Tanssi network\n// This is for example purposes only - **never store your private keys in a JavaScript file**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\nmodule.exports = {\n  // 3. Specify the Solidity version\n  solidity: '0.8.1',\n  networks: {\n    // 4. Add the network specification for your Tanssi EVM network\n    dancelight: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Fill in the EVM ChainID for your Tanssi network\n      accounts: [privateKey]\n    }\n  }\n};\n</code></pre> <p>Congratulations! You are now ready for deployment!</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#compiling-solidity","title":"Compiling Solidity","text":"<p>To compile the contract you can simply run:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 8 Solidity files successfully (evm target: paris). <p>After compilation, an <code>artifacts</code> directory is created: it holds the bytecode and metadata of the contract, which are <code>.json</code> files. Adding this directory to your <code>.gitignore</code> is a good idea.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#deploying-the-contract","title":"Deploying the Contract","text":"<p>To deploy the contract, you'll use Hardhat Ignition, a declarative framework for deploying smart contracts. Hardhat Ignition is designed to make managing recurring tasks surrounding smart contract deployment and testing easy. For more information, be sure to check out the Hardhat Ignition docs. </p> <p>To set up the proper file structure for your Ignition module, create a folder named <code>ignition</code> and a subdirectory called <code>modules</code>.  Then add a new file to it called <code>Box.js</code>. You can take all three of these steps with the following command:</p> <pre><code>mkdir ignition ignition/modules &amp;&amp; touch ignition/modules/Box.js\n</code></pre> <p>Next, you can write your Hardhat Ignition module. To get started, take the following steps:</p> <ol> <li>Import the <code>buildModule</code> function from the Hardhat Ignition module</li> <li>Export a module using <code>buildModule</code></li> <li>Use the <code>getAccount</code> method to select the deployer account</li> <li>Specify custom gas price and gas limit settings for the deployment</li> <li>Deploy the <code>Box</code> contract</li> <li>Return an object from the module. This makes the <code>Box</code> contract accessible for interaction in Hardhat tests and scripts</li> </ol> <pre><code>// 1.  Import the `buildModule` function from the Hardhat Ignition module\nconst { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');\n\n// 2. Export a module using `buildModule`\nmodule.exports = buildModule('BoxModule', (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Specify custom gas price and gas limit settings for the deployment\n  const customGasPrice = 50000000000n;\n  const customGasLimit = 1000000;\n\n  // 5. Deploy the `Box` contract using the selected deployer account and custom gas settings\n  const box = m.contract('Box', [], {\n    from: deployer,\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // 6. Return an object from the module including references to deployed contracts. This makes the deployed `Box` contract accessible for interaction in tests and scripts\n  return { box };\n});\n</code></pre> <p>To run the script and deploy the <code>Box.sol</code> contract, use the following command, which requires you to specify the network name as defined in your <code>hardhat.config.js</code>. Hardhat will deploy the contract to a local hardhat network by default if you don't specify a network.  </p> <pre><code>npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight\n</code></pre> <p>You'll be prompted to confirm the network you wish to deploy to. After a few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal. If you're deploying to another Tanssi network, make sure that you specify the correct network. The network name must match how it's defined in <code>hardhat.config.js</code>. After a few seconds, the contract is deployed, and you should see the address in the terminal.</p>  npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight \u2705 Confirm deploy to network dancelight (5678)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed \ud83d\ude80 Deployed Addresses BoxModule#Box - 0xa84caB60db6541573a091e5C622fB79e175E17be <p>Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/hardhat/#interacting-with-the-contract","title":"Interacting with the Contract","text":"<p>To interact with your newly deployed contract on your Tanssi network, you can launch the Hardhat <code>console</code> by running:</p> <pre><code>npx hardhat console --network dancelight\n</code></pre> <p>Next, you can take the following steps, entering one line at a time:</p> <ol> <li> <p>Create a local instance of the <code>Box.sol</code> contract</p> <pre><code>const Box = await ethers.getContractFactory('Box');\n</code></pre> </li> <li> <p>Connect the local instance to the deployed contract, using the address of the contract</p> <pre><code>const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');\n</code></pre> </li> <li> <p>Interact with the attached contract. For this example, you can call the <code>store</code> method and store a simple value</p> <pre><code>await box.store(5);\n</code></pre> </li> </ol> <p>Your EVM account will sign the transaction and broadcast it to the network. The output should look similar to:</p> npx hardhat console --network dancelight Welcome to Node.js v20.9.0. Type \".help\" for more information.  const Box = await ethers.getContractFactory('Box'); undefined  const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be'); undefined  await box.store(5); ContractTransactionResponse {     provider: HardhatEthersProvider { ... },     blockNumber: null,     blockHash: null,     index: undefined,     hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',     type: 2,     to: '0xa84caB60db6541573a091e5C622fB79e175E17be',     from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',     nonce: 87,     gasLimit: 45881n,     gasPrice: 1107421875n,     maxPriorityFeePerGas: 1n,     maxFeePerGas: 1107421875n,     data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',     value: 0n,     chainId: 5678n,     signature: Signature { r: \"0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc\", s: \"0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d\", yParity: 0, networkV: null },     accessList: [],     blobVersionedHashes: null     }  await box.retrieve(); 5n <p>Notice your address labeled <code>from</code>, the contract's address, and the <code>data</code> being passed. Now, you can retrieve the value by running:</p> <pre><code>await box.retrieve();\n</code></pre> <p>You should see <code>5</code> or the value you initially stored.</p> <p>Note</p> <p>If you run the retrieve command immediately after storing the value, you may see the old value. Rerunning the retrieval command after waiting a moment will return the correct value.</p> <p>Congratulations, you have successfully deployed and interacted with a contract using Hardhat!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/dev-env/remix/","title":"Using Remix to Deploy to Your Tanssi EVM Network","text":""},{"location":"builders/toolkit/ethereum-api/dev-env/remix/#introduction","title":"Introduction","text":"<p>Developers building dApps on top of Tanssi-powered EVM networks can use Remix, one of the most popular Ethereum development environments, to build, compile, and deploy their smart contracts. Remix can be used with any EVM network, thanks to the seamless compatibility of Tanssi-powered EVM networks.</p> <p>This guide walks through the process of creating and deploying a Solidity-based smart contract to the Tanssi demo EVM network using the Remix IDE. This guide can be adapted for your own Tanssi EVM network by simply adding the RPC URL of your network to your EVM Wallet and switching networks to it.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/remix/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For this guide, you'll need to have MetaMask installed and configured to work with your Tanssi EVM network. You can follow this guide to configure MetaMask for Tanssi with the demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/remix/#getting-started-with-remix","title":"Getting Started with Remix","text":"<p>Now, you can head to Remix to get started. On the main screen, navigate to the File Explorer tab.</p> <p></p> <p>Next, you can create a new file to save the Solidity smart contract. To do so, take the following steps:</p> <ol> <li>Press the Create New File button on the left-hand side of File Explorer</li> <li>Enter your desired filename, such as <code>MyToken.sol</code></li> </ol> <p></p> <p>Next, paste the following smart contract into the editor tab:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/audit/2023-03/contracts/token/ERC20/ERC20.sol';\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator.\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p></p> <p>This is a simple ERC-20 contract based on the current OpenZeppelin ERC-20 template. It creates <code>MyToken</code> with symbol <code>MYTOK</code> and mints the entirety of the initial supply to the creator of the contract.</p> <p>To compile your smart contract, take the following steps:</p> <ol> <li>Navigate to the Solidity compiler tab</li> <li>Press the Compile MyToken.sol button</li> </ol> <p></p> <p>Your contract is now compiled and ready to be deployed to your Tanssi network.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/remix/#deploying-a-contract-to-your-network-using-remix","title":"Deploying a Contract to Your Network Using Remix","text":"<p>Now you can deploy the contract by navigating to the Deployment sidebar option. You need to change the topmost ENVIRONMENT dropdown from JavaScript VM to Injected Web3. This tells Remix to use the MetaMask injected provider, which will point it to your Tanssi-powered EVM network, so long as the selected network in your MetaMask is your Tanssi EVM network. If you need to change your network in MetaMask, you can easily do so, and Remix will update your account balances to reflect the network change.</p> <p></p> <p>As soon as you select Injected Web3, you will be prompted to allow Remix to connect to your MetaMask account. Then, take the following steps:</p> <ol> <li>Select the account(s) that you would like to use with Remix</li> <li>Press Next</li> <li>Press Connect</li> </ol> <p></p> <p>Back on Remix, you should see the account you wish to use for deployment is now managed by MetaMask. To deploy your token contract, take the following steps:</p> <ol> <li>Next to the Deploy button, specify an initial supply of 8 million tokens. Since this contract uses the default of 18 decimals, the value to put in the box is <code>8000000000000000000000000</code>. Once you have entered this value, press Deploy</li> <li>Confirm the contract deployment transaction in MetaMask.</li> </ol> <p></p> <p>After you press Confirm and the deployment is complete, you will see the transaction listed in MetaMask. The contract will appear under Deployed Contracts in Remix. You can access the address of the deployed contract by pressing the copy button.</p> <p></p> <p>Once the contract is deployed, you can interact with it from within Remix. To familiarize yourself with interacting with a smart contract from Remix, take the following steps:</p> <ol> <li>Expand the contract under the Deployed Contracts section</li> <li>Paste in your address (the address that deployed the token contract) next to the balanceOf method and press balanceOf. You should see the entirety of the balance of the ERC-20 belonging to that address</li> <li>Press Decimals to see the number of decimal points the token has</li> <li>Press Name to see the name you assigned the token</li> <li>Press Symbol to see the token symbol</li> <li>Press Initial Supply and you should see <code>8000000000000000000000000</code></li> <li>Copy the contract address by clicking the button next to the contract name and address. You'll need it in the next section</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/dev-env/remix/#interacting-with-an-erc-20-on-your-network-from-metamask","title":"Interacting with an ERC-20 on Your Network from MetaMask","text":"<p>Now, open MetaMask to add the newly deployed ERC-20 tokens. Make sure you are connected to the account that deployed the token contract. Additionally, make sure you have copied the contract's address from Remix.</p> <p>To add the token to MetaMask, take the following steps:</p> <ol> <li>Click on the Tokens tab as shown below</li> <li>Press Import tokens</li> </ol> <p></p> <p>Then, take the following steps:</p> <ol> <li>Paste the copied contract address into the Token contract address field. The Token symbol and Token decimal fields should be automatically populated</li> <li>Press Next</li> </ol> <p></p> <p>After clicking Next, you will need to confirm that you want to add these tokens to your MetaMask account. Click Import and you should see a balance of 8 million MyTokens in MetaMask:</p> <p></p> <p>Now you can send some of these ERC-20 tokens to the other account that you have set up in MetaMask. Click Send to initiate the transfer of 500 MyTokens and select the destination account.</p> <p>After clicking Next, you will be asked to confirm (similar to what is pictured below).</p> <p></p> <p>Click Confirm and, after the transaction is complete, you will see a confirmation and a reduction of the MyToken account balance from the sender account in MetaMask.</p> <p></p> <p>You can also look up the transaction on your Tanssi network's explorer to verify the transaction status.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/","title":"Using thirdweb on Tanssi","text":""},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#introduction","title":"Introduction","text":"<p>thirdweb is a complete Web3 development framework that provides everything you need to develop smart contracts, build dApps, and more.</p> <p>With thirdweb, you can access tools to help you through every phase of the dApp development cycle. You can create your own custom smart contracts or use any of thirdweb's prebuilt contracts to get started quickly. From there, you can use thirdweb's CLI to deploy your smart contracts. Then you can interact with your smart contracts by creating a Web3 application using the language of your choice, including but not limited to React and TypeScript. </p> <p>This guide will show you some of the thirdweb features you can use to develop smart contracts and dApps on Tanssi EVM networks. To check out all of the features thirdweb has to offer, please refer to the thirdweb documentation site. </p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#create-contract","title":"Create Contract","text":"<p>To create a new smart contract using the thirdweb CLI, follow these steps:</p> <ol> <li> <p>In your CLI, run the following command:</p> <pre><code>npx thirdweb create contract\n</code></pre> </li> <li> <p>Input your preferences for the command line prompts:</p> <ol> <li>Give your project a name</li> <li>Choose your preferred framework: Hardhat or Foundry</li> <li>Name your smart contract</li> <li>Choose the type of base contract: Empty, ERC20, ERC721, or ERC1155</li> <li>Add any desired extensions</li> </ol> </li> <li>Once created, navigate to your project\u2019s directory and open in your preferred code editor</li> <li> <p>If you open the <code>contracts</code> folder, you will find your smart contract; this is your smart contract written in Solidity</p> <p>The following is code for an <code>ERC721Base</code> contract without specified extensions. It implements all of the logic inside the <code>ERC721Base.sol</code> contract; which implements the <code>ERC721A</code> standard.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@thirdweb-dev/contracts/base/ERC721Base.sol';\n\ncontract Contract is ERC721Base {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps\n    ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}\n}\n</code></pre> <p>This contract inherits the functionality of <code>ERC721Base</code> through the following steps:</p> <ul> <li>Importing the <code>ERC721Base</code> contract</li> <li>Inheriting the contract by declaring that your contract is an <code>ERC721Base</code> contract</li> <li>Implementing any required methods, such as the constructor</li> </ul> </li> <li> <p>After modifying your contract with your desired custom logic, you can deploy it to a Tanssi EVM network using Deploy. That will be covered in the next section!</p> </li> <li>After modifying your contract with your desired custom logic, you can deploy it to a Tanssi EVM network using Deploy. That will be covered in the next section!</li> </ol> <p>Alternatively, you can deploy a prebuilt contract for NFTs, tokens, or marketplace directly from the thirdweb Explore page:</p> <ol> <li> <p>Go to the thirdweb Explore page</p> <p></p> </li> <li> <p>Choose the type of contract you want to deploy from the available options: NFTs, tokens, marketplace, and more</p> </li> <li>Follow the on-screen prompts to configure and deploy your contract</li> </ol> <p>For more information on different contracts available on Explore, check out thirdweb\u2019s documentation on prebuilt contracts.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#deploy-contract","title":"Deploy Contract","text":"<p>Deploy is thirdweb's tool that allows you to easily deploy a smart contract to any EVM compatible network without configuring RPC URLs, exposing your private keys, writing scripts, and other additional setup such as verifying your contract. Deploy is thirdweb's tool that allows you to easily deploy a smart contract to any EVM compatible network without configuring RPC URLs, exposing your private keys, writing scripts, and other additional setup such as verifying your contract.</p> <ol> <li> <p>To deploy your smart contract using deploy, navigate to the <code>contracts</code> directory of your project and execute the following command:</p> <pre><code>npx thirdweb deploy\n</code></pre> <p>Executing this command will trigger the following actions:</p> <ul> <li>Compiling all the contracts in the current directory</li> <li>Providing the option to select which contract(s) you wish to deploy</li> <li>Uploading your contract source code (ABI) to IPFS</li> </ul> </li> <li> <p>When it is completed, it will open a dashboard interface to finish filling out the parameters</p> <ul> <li><code>_name</code> - contract name</li> <li><code>_symbol</code> - symbol or \"ticker\"</li> <li><code>_royaltyRecipient</code> - wallet address to receive royalties from secondary sales</li> <li><code>_royaltyBps</code> - basis points (bps) that will be given to the royalty recipient for each secondary sale, e.g. 500 = 5%</li> </ul> </li> <li> <p>Select the desired network, e.g., the Tanssi demo EVM network or your own network</p> </li> <li> <p>Manage additional settings on your contract\u2019s dashboard as needed such as uploading NFTs, configuring permissions, and more</p> <p></p> </li> </ol> <p>For additional information on Deploy, please reference thirdweb\u2019s documentation.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#create-application","title":"Create Application","text":"<p>thirdweb offers SDKs for a range of programming languages, such as React, React Native, TypeScript, and Unity. You'll start off by creating an application and then you can choose which SDK to use:</p> <ol> <li> <p>In your CLI run the following command:</p> <pre><code>npx thirdweb create --app\n</code></pre> </li> <li> <p>Input your preferences for the command line prompts:</p> <ol> <li>Give your project a name</li> <li>Choose your preferred framework: Next.js, Vite, or React Native. For this example, select Vite</li> </ol> </li> <li> <p>Use the React or TypeScript SDK to interact with your application\u2019s functions. This will be covered in the following section on interacting with a contract</p> </li> </ol>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#specify-client-id","title":"Specify Client ID","text":"<p>Before you launch your dApp (locally or publicly deployed), you must have a thirdweb Client ID associated with your project. A thirdweb Client ID is synonymous with an API key. You can create a free API key by signing into your thirdweb account, navigating to Settings, and clicking on API Keys.</p> <p>Press Create API Key then take the following steps:</p> <ol> <li>Give your API key a name</li> <li>Enter the allowed domains that the API key should accept requests from. It's recommended that you allow only necessary domains, but for development purposes, you can select Allow all domains</li> <li>Press Next and confirm the prompt on the next page</li> </ol> <p></p> <p>Note</p> <p>The respective name for your Client ID variable will vary with the framework you've chosen, e.g., Vite will be <code>VITE_TEMPLATE_CLIENT_ID</code>, Next.js will be <code>NEXT_PUBLIC_TEMPLATE_CLIENT_ID</code>, and React Native will be <code>EXPO_PUBLIC_THIRDWEB_CLIENT_ID</code>.</p> <p>Finally, specify your Client ID (API Key) in your <code>.env</code> file. Your <code>.env</code> file must be located at the root directory of the project (e.g., not the <code>src</code> folder).</p> <p>If you generated your thirdweb app with Vite, you'll have a <code>client.ts</code> file that looks like the below. As long you've created a <code>.env</code> file with your thirdweb API Key (Client ID) defined in <code>VITE_TEMPLATE_CLIENT_ID</code>, you can leave the <code>client.ts</code> as is and proceed to the next section.</p> client.ts<pre><code>import { createThirdwebClient } from 'thirdweb';\n\n// Replace this with your client ID string.\n// Refer to https://portal.thirdweb.com/typescript/v5/client on how to get a client ID\nconst clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;\n\nexport const client = createThirdwebClient({\n  clientId: clientId,\n});\n</code></pre> <p>Note</p> <p>If you don't create a Client ID and specify is correctly in your <code>.env</code> file, you'll get a blank screen when trying to build the web app. There is no error message shown without digging into the console, so ensure you've set your Client ID correctly first and foremost.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#run-locally","title":"Run Locally","text":"<p>To run your dApp locally for testing and debugging purposes, use the command: </p> <pre><code>yarn dev\n</code></pre> <p>The app will compile and specify the localhost and port number for you to visit in your browser.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#configure-chain","title":"Configure Chain","text":"<p>thirdweb offers a small number of chains from <code>@thirdweb/chains</code> and does not include Tanssi networks in that list, so you'll need to specify the network details including chain ID and RPC URL. You can create a custom chain with <code>defineChain</code> as follows:</p> chains.ts<pre><code>    import { defineChain } from 'thirdweb';\n    const tanssi = defineChain({\n      id: 5678,\n      rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n    });\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#thirdweb-sdk","title":"thirdweb SDK","text":"<p>The following sections will provide an overview of fundamental methods of the thirdweb SDK and how to interact with them. Each code snippet will showcase the relevant import statements and demonstrate using the method in a typical scenario. This guide is intended to be a quick reference guide to the most common thirdweb methods that dApp developers will use. However, it does not include information on each and every thirdweb offering. For details on the entirety of thirdweb's offerings, be sure to visit the thirdweb documentation site.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#accounts-and-wallets","title":"Accounts and Wallets","text":"<p>thirdweb distinguishes between accounts and wallets in the SDK. In the eyes of the thirdweb SDK, an account always has a single blockchain address and can sign messages, transactions, and typed data, but it cannot be \"connected\" or \"disconnected.\" In contrast, a wallet contains one or more accounts, can be connected or disconnected, and delegates the signing tasks to its accounts. </p> <p>The below code snippet demonstrates how to initialize and connect a MetaMask wallet using the thirdweb SDK, then sign and send a transaction, retrieving the transaction hash. This process is applicable to any of the 300+ wallet connectors supported by the SDK.</p> initialize.ts <pre><code>import { sendTransaction } from 'thirdweb';\n// MetaMask wallet used for example, the pattern is the same for all wallets\nimport { createWallet } from 'thirdweb/wallets';\n\n// Initialize the wallet. thirdweb supports 300+ wallet connectors\nconst wallet = createWallet('io.metamask');\n\n// Connect the wallet. This returns a promise that resolves to the connected account\nconst account = await wallet.connect({\n  // Pass the client you created with `createThirdwebClient()`\n  client,\n});\n\n// Sign and send a transaction with the account. Returns the transaction hash\nconst { transactionHash } = await sendTransaction({\n  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send\n  transaction,\n  // Pass the account to sign the transaction with\n  account,\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#get-contract","title":"Get Contract","text":"<p>To connect to your contract, use the SDK\u2019s <code>getContract</code> method. As an example, you could fetch data from an incrementer contract on the Tanssi demo EVM network.</p> <pre><code>import { getContract } from 'thirdweb';\nimport { client } from './client';\n\nconst myContract = getContract({\n  client,\n  chain: tanssi,\n  address: 0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D, // Incrementer contract address on demo EVM network\n  abi: '[{\"inputs\":[],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]';\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#calling-contract-functions","title":"Calling Contract Functions","text":"<p>To call a contract in the latest version of the SDK, you can use <code>prepareContractCall</code>.</p> <pre><code>import { prepareContractCall, toWei } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Pass the method signature that you want to call\n  method: 'function mintTo(address to, uint256 amount)',\n  // Pass the params for that method.\n  // Their types are automatically inferred based on the method signature\n  params: ['0x123...', toWei('100')],\n});\n</code></pre> <p>Returning to our incrementer contract, preparing a call to increment the contract looks like the following:</p> <pre><code>import { prepareContractCall } from 'thirdweb';\n\nconst tx = prepareContractCall({\n  contract,\n  // Pass the method signature that you want to call\n  method: 'function increment()',\n  // Increment takes no params so we are leaving an empty array\n  params: [],\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#preparing-raw-transactions","title":"Preparing Raw Transactions","text":"<p>You can also prepare a transaction directly with encoded data. To do so, you'll use thirdweb's <code>prepareTransaction</code> method and specify the <code>to</code>, <code>value</code>, <code>chain</code>, and <code>client</code> values directly. </p> <pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  // The account that will be the receiver\n  to: '0x456...',\n  // The value is the amount of ether you want to send with the transaction\n  value: toWei('1'),\n  // The chain to execute the transaction on. This assumes you already set up\n  // the Tanssi demo EVM network as a custom chain, as shown in the configure chain section\n  chain: tanssi,\n  // Your thirdweb client\n  client,\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#read-contract-state","title":"Reading Contract State","text":"<p>Use the <code>readContract</code> function to call any read functions on your contract by passing in the Solidity method signature and any parameters.</p> <pre><code>import { readContract } from 'thirdweb';\n\nconst balance = await readContract({\n  contract: contract,\n  method: 'function balanceOf(address) view returns (uint256)',\n  params: ['0x123...'],\n});\n</code></pre> <p>For a function that takes no parameters, such as the number function that returns the current number stored in the incrementer contract, you simply need to provide the function name as follows: </p> <pre><code>import { readContract } from 'thirdweb';\n\nconst number = await readContract({\n  contract: contract,\n  method: 'number',\n  params: [],\n});\n</code></pre> <p>Did you know? With the thirdweb CLI, you can easily generate functions for all of the possible calls to a contract. To do so, run the following command in the command line: </p> <pre><code>npx thirdweb generate INSERT_CHAIN_ID/INSERT_CONTRACT_ADDRESS\n</code></pre> <p>Both the chain ID and the contract address are required. As an example, if you wanted to generate the functions for the incrementer contract on the Tanssi demo EVM network , you would use the following command:</p> <pre><code>npx thirdweb generate 5678/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D\n</code></pre> <p>The file generated with all of the corresponding methods will be placed in a directory labelled <code>thirdweb/CHAIN_ID/CONTRACT_ADDRESS</code>. In the example shown above, the output file is located at <code>thirdweb/5678/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D.ts</code>. For more information, see the thirdweb's docs on the CLI.</p>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#sending-a-transaction","title":"Sending a Transaction","text":"<p>Every transaction sent using the SDK must first be prepared. This preparation process is synchronous and lightweight, requiring no network requests. Additionally, it provides type-safe definitions for your contract calls.</p> <p>You can prepare a transaction as follows:</p> Prepare a transaction<pre><code>import { prepareTransaction, toWei } from 'thirdweb';\n\nconst transaction = prepareTransaction({\n  to: '0x1234567890123456789012345678901234567890',\n  chain: tanssi,\n  client: thirdwebClient,\n  value: toWei('1.0'),\n  gasPrice: 150n,\n});\n</code></pre> <p>After the transaction is prepared, you can send it as follows:</p> Send a transaction<pre><code>import { sendTransaction } from 'thirdweb';\n\nconst { transactionHash } = await sendTransaction({\n  account,\n  transaction,\n});\n</code></pre> <p>You can optionally use <code>sendAndConfirmTransaction</code> to wait for the transaction to be mined. This is relevant if you want to block the user from continuing until the transaction is confirmed. </p> Send and Confirm a Transaction<pre><code>import { sendAndConfirmTransaction } from 'thirdweb';\nimport { createWallet } from 'thirdweb/wallets';\n\nconst wallet = createWallet('io.metamask');\nconst account = await wallet.connect({ client });\n\nconst receipt = await sendAndConfirmTransaction({\n  transaction,\n  account,\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#transaction-utilites","title":"Transaction Utilities","text":"<p>thirdweb provides a number of helpful utility methods surrounding preparing and sending transactions. </p> <p>You can estimate the gas used by a transaction as follows: </p> Estimating gas<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasEstimate = await estimateGas({ transaction });\nconsole.log('estmated gas used', gasEstimate);\n</code></pre> <p>You can estimate the gas cost in Ether and Wei as follows: </p> Estimating gas cost<pre><code>import { estimateGas } from 'thirdweb';\n\nconst gasCost = await estimateGasCost({ transaction });\nconsole.log('cost in ether', gasCost.ether);\n</code></pre> <p>thirdweb also provides a handy way to simulate transactions and verify their integrity before actually submitting it to the blockchain. You can simulate a transaction as follows:</p> Simulate a transaction<pre><code>import { simulateTransaction } from 'thirdweb';\n\nconst result = await simulateTransaction({ transaction });\nconsole.log('simulation result', result);\n</code></pre> <p>You can encode transaction data to act on later by taking the following steps: </p> Encode transaction data<pre><code>import { encode } from 'thirdweb';\n\nconst data = await encode(transaction);\nconsole.log('encoded data', data);\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#connect-button","title":"ConnectButton","text":"<p>Perhaps the first and most important interaction users will have with your dApp is connecting their wallet. thirdweb provides an easy and highly customizable way for you to enable this. thirdweb provides a highly customizable <code>ConnectButton</code> to tailor it to your desired wallets. The <code>ConnectButton</code> accepts an optional <code>wallets</code> parameter with an array of wallets. You can add or remove wallets from the <code>wallets</code> array to change the options available to users. thirdweb also offers a <code>ConnectButton</code> Playground to customize and view changes for the <code>ConnectButton</code> in real-time, given the button's high degree of flexibility.</p> ConnectButton<pre><code>import { ConnectButton } from 'thirdweb/react';\nimport { createWallet, inAppWallet } from 'thirdweb/wallets';\n\nconst wallets = [\n  inAppWallet(),\n  createWallet('io.metamask'),\n  createWallet('com.coinbase.wallet'),\n  createWallet('me.rainbow'),\n];\n\nfunction Example() {\n  return (\n    &lt;div&gt;\n      &lt;ConnectButton client={client} wallets={wallets} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/dev-env/thirdweb/#deploy-application","title":"Deploy Application","text":"<p>As a reminder, you can build your example project locally by running:</p> <pre><code>yarn dev\n</code></pre> <p>To host your static web application on decentralized storage, run:</p> <pre><code>npx thirdweb deploy --app\n</code></pre> <p>Running this command builds your application for production and stores it using Storage, thirdweb's decentralized file management solution. It uploads your built application to IPFS, a decentralized storage network, and generates a unique URL that provides a persistent hosting location for your application on the web.</p> <p>If you have any further questions or encounter any issues during the process, please reach out to thirdweb support at support.thirdweb.com.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/libraries/","title":"Libraries","text":"<p>Libraries are essential tools for interacting with blockchain networks. They provide pre-built functions and abstractions that simplify tasks like reading and writing chain data. These libraries eliminate the need to handle raw blockchain requests, making it easier for developers to build and deploy decentralized applications while ensuring compatibility with Ethereum and other EVM-compatible networks.</p> <p>Some key capabilities of working with libraries include:</p> <ul> <li>Transaction management - create, sign, and broadcast transactions</li> <li>Smart contract interactions - simplify calling contract functions, decoding responses, and handling contract events</li> <li>Wallet integration - facilitate secure wallet integrations for transacting with the network</li> <li>Blockchain data parsing - decode and interpret complex data structures returned by smart contracts</li> <li>Event monitoring - listen to events emitted by contracts and trigger specific application actions</li> </ul>"},{"location":"builders/toolkit/ethereum-api/libraries/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/","title":"Ethers.js JavaScript Library","text":""},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#introduction","title":"Introduction","text":"<p>The Ethers.js library provides a set of tools to interact with Ethereum nodes with JavaScript, similar to Web3.js. Tanssi-powered EVM networks have an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Ethers.js, check their documentation site.</p> <p>In this guide, you'll learn how to use the Ethers.js library for your Tanssi EVM network. Next, to showcase the library in action, you'll use Ethers.js to send a transaction and deploy a contract on a Tanssi demo EVM appchain running on Dancelight. This guide can be adapted for your own Tanssi EVM appchain by simply changing the endpoint. </p> <p>If you prefer video tutorials, you can follow along with the corresponding videos at the top of this page for Sending Transactions with Ethers.js and Deploying Contracts with Ethers.js.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds in the Tanssi EVM network you are testing with</li> </ul>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#install-ethersjs","title":"Installing Ethers.js","text":"<p>For this guide, you'll need to install the Ethers.js library and the Solidity compiler. To install both NPM packages, you can run the following command:</p> npmyarn <pre><code>npm install ethers solc@0.8.0\n</code></pre> <pre><code>yarn add ethers solc@0.8.0\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#setting-up-the-ethers-provider","title":"Setting up the Ethers Provider","text":"<p>Throughout this guide, you'll create several scripts that provide various functionalities, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Ethers provider to interact with the network.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>ethers</code> library</li> <li>Define the <code>providerRPC</code> object, which can include the network configurations for any of the networks you want to send a transaction on. You'll include the <code>name</code>, <code>rpc</code>, and <code>chainId</code> for each network</li> <li>Create the <code>provider</code> using the <code>ethers.JsonRpcProvider</code> method</li> </ol> <pre><code>// 1. Import ethers\nimport { ethers } from \"ethers\";\n\n// 2. Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insert your RPC URL here\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n// 3. Create ethers provider\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <p>Save this code snippet as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.js</code> file by running:</p> <pre><code>touch balances.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function which wraps the <code>provider.getBalance</code> method</li> <li>Use the <code>provider.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>ethers.formatEther</code> function to transform the balance into a more readable number in ETH</li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balances\n  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 5. Call the balances function\nbalances();\n</code></pre> View the complete script <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define addresses\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balances\n  const balanceFrom = ethers.formatEther(\n    await provider.getBalance(addressFrom)\n  );\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>node balances.js\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in TANGO.</p> node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 20.0 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 1.0 TANGO"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 TANGO token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.js</code> file by running:</p> <pre><code>touch transaction.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object and the <code>wallet.sendTransaction</code> method</li> <li>Create the transaction object, which only requires the recipient's address and the amount to send. Note that <code>ethers.parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei - similar to using <code>ethers.parseUnits(value, 'ether')</code></li> <li>Send the transaction using the <code>wallet.sendTransaction</code> method and then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Add the Ethers provider logic here:\n// {...}\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 4. Create send function\nconst send = async () =&gt; {\n  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);\n\n  // 5. Create tx object\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // 6. Sign and send tx - wait for receipt\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// 7. Call the send function\nsend();\n</code></pre> View the complete script <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\nconst wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${wallet.address} to ${addressTo}`\n  );\n\n  // Create transaction\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // Send transaction and get hash\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.js</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> node transaction.js Attempting to send transaction from 0x44236223aB4291b93EEd10E4B511B37a398DEE55 to 0x8841701 Dba3639B254D9CEe712E49D188A1e941e      Transaction successful with hash: 0x29d87c00704b949cb4cc04fdc6c98d53b3c0ec4fb3ffe0c52864a73 b586f563c    node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 18.999958 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 2.0 TANGO"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the contract file from <code>compile.js</code></li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Save the <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create a contract instance with signer using the <code>ethers.ContractFactory</code> function, providing the <code>abi</code>, <code>bytecode</code>, and <code>wallet</code> as parameters</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract</li> <li>Within the <code>deploy</code> function, use the <code>incrementer</code> contract instance to call <code>deploy</code> and pass in the initial value. For this example, you can set the initial value to <code>5</code>. This will send the transaction for contract deployment. To wait for a transaction receipt you can use the <code>deployed</code> method of the contract deployment transaction</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Import the contract file\nimport contractFile from './compile';\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Save the bytecode and ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 6. Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Load contract info\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> node deploy.js Attempting to deploy from account: 0x44236223aB4291b93EEd10E4B511B37a398DEE55      Contract deployed at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Import the <code>contractFile</code> from the <code>compile.js</code> file, where the ABI of the contract is</li> <li>Set up the Ethers provider</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>get</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you'll call the <code>number</code> method, which requires no inputs, and <code>await</code>, which will return the requested value once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Import the ABI\nimport contractFile from './compile';\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract \n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node get.js\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 5"},{"location":"builders/toolkit/ethereum-api/libraries/ethersjs/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.js</code> and <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Open the <code>increment.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>contractFile</code> from the <code>compile.js</code> file, where the ABI of the contract is</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account, the <code>contractAddress</code> of the deployed contract, and the <code>_value</code> to increment by. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>increment</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you'll call the <code>increment</code> method, providing the value to increment by as an input, and <code>await</code>, which will return the requested value once the request promise resolves</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nimport contractFile from './compile';\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the increment function\nincrement();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node increment.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>increment.js</code> script to make sure that the value is changing as expected:</p> node increment.js Calling the increment by 3 function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2      Tx successful with hash: 0x8aa7ccb4613ac92713bcc6ff064f1b0c978e24b3f6acb6d6bfa730a10af522bb    node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 8    <p>Next you can open the <code>reset.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>contractFile</code> from the <code>compile.js</code> file, where the ABI of the contract is</li> <li>Set up the Ethers provider</li> <li>Define the <code>privateKey</code> for the origin account and the <code>contractAddress</code> of the deployed contract. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create a wallet using the <code>privateKey</code> and <code>provider</code> from the previous steps. The wallet instance is used to sign transactions</li> <li>Create an instance of the contract using the <code>ethers.Contract</code> function and passing in the <code>contractAddress</code>, <code>abi</code>, and <code>provider</code></li> <li>Create the asynchronous <code>reset</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>reset</code> method which doesn't require any inputs. You can use <code>await</code> which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Import the contract ABI\nimport contractFile from './compile';\n\n// 2. Add the Ethers provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(`Calling the reset function in contract at address: ${contractAddress}`);\n\n  // 7. sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Call the reset function\nreset();\n</code></pre> View the complete script <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node reset.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>reset.js</code> script to make sure that value is changing as expected:</p> node increment.js Calling the reset function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2      Tx successful with hash: 0xb689da50a43e98b5a83ff64757afbf100be12e2db6ff4d0504168f262cc08fb0    node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 0       The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/libraries/viem/","title":"viem TypeScript Ethereum Library","text":""},{"location":"builders/toolkit/ethereum-api/libraries/viem/#introduction","title":"Introduction","text":"<p>viem is a modular TypeScript library that allows developers to interact with abstractions over the JSON-RPC API, making it easy to interact with Ethereum nodes. Since Tanssi-powered EVM networks have an Ethereum API available that is fully compatible with Ethereum-style JSON-RPC invocations, developers can leverage this compatibility to interact with any Tanssi EVM network. For more information on viem, check out their documentation site.</p> <p>In this guide, you'll learn how to use viem to send a transaction and deploy a contract on the demo EVM network. This guide can be adapted for use with any Tanssi-powered EVM network.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds in the Tanssi EVM network you are testing with</li> </ul>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#installing-viem","title":"Installing viem","text":"<p>To get started, you'll need to create a basic TypeScript project. First, create a directory to store all of the files you'll be creating throughout this guide, and initialize the project with the following command:</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>For this guide, you'll need to install the viem library and the Solidity compiler. To install both packages, you can run the following command:</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.0\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.0\n</code></pre> <p>You can create a TypeScript configuration file by running:</p> <pre><code>npx tsc --init\n</code></pre> <p>Note</p> <p>This tutorial was created using Node.js v18.18.0.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#setting-up-a-viem-provider","title":"Set Up a viem Client (Provider)","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a viem client to interact with the network.</p> <p>You can create a viem client for reading chain data, like balances or contract data, using the <code>createPublicClient</code> function, or you can create a viem client for writing chain data, like sending transactions, using the <code>createWalletClient</code> function.</p> <p>Creating a viem client to interact with your Tanssi EVM network is a two-step process. First, you'll need to import the <code>defineChain</code> function from viem. This will allow you to specify the details of your Tanssi EVM network (or any arbitrary EVM chain). You'll then need to provide all of the chain details, as shown in the next section.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#for-reading-chain-data","title":"For Reading Chain Data","text":"<p>To create a client for reading chain data, you can take the following steps:</p> <ol> <li>Import the <code>createPublicClient</code>, <code>http</code>, and <code>defineChain</code>functions from <code>viem</code></li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Create the <code>client</code> using the <code>createPublicClient</code> function and pass in the network and the HTTP RPC endpoint</li> </ol> <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#for-writing-chain-data","title":"For Writing Chain Data","text":"<p>To create a client for writing chain data, you can take the following steps:</p> <ol> <li>Import the <code>createWalletClient</code>, <code>http</code>, and <code>defineChain</code> functions from <code>viem</code>, and the <code>privateKeyToAccount</code> function from <code>viem/accounts</code></li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Create your account using the <code>privateKeyToAccount</code> function</li> <li>Create the <code>client</code> using the <code>createWalletClient</code> function and pass in the account, network, and the HTTP RPC endpoint</li> </ol> <p>Remember</p> <p>This is for demo purposes only. Never store your private key in a TypeScript file.</p> <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport { createWalletClient, http, defineChain } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create your account using the privateKeyToAccount function\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\n\n//4. Create a wallet client for writing chain data\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Note</p> <p>To interact with browser-based wallets, you can use the following code to create an account. In this snippet, <code>demo</code> refers to the demo EVM network created with <code>defineChain</code>. <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: demo,\n  transport: custom(window.ethereum),\n});\n</code></pre></p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#send-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will check the balances of your accounts before trying to send a transaction. The second script will send the transaction. You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a <code>balances.ts</code> file by running:</p> <pre><code>touch balances.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>http</code>,<code>formatEther</code>, and <code>defineChain</code>functions from <code>viem</code> </li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a public viem client, which can be used for reading chain data, such as account balances</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function that wraps the <code>publicClient.getBalance</code> method</li> <li>Use the <code>publicClient.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>formatEther</code> function to transform the balance into a more readable number (in TANGO for the demo EVM network)</li> <li>Lastly, run the <code>balances</code> function</li> </ol> View balances.ts <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, formatEther, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'UNIT',\n    symbol: 'UNIT',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 5. Create balances function\nconst balances = async () =&gt; {\n  // 6. Fetch balances\n  const balanceFrom = formatEther(\n    await publicClient.getBalance({ address: addressFrom })\n  );\n  const balanceTo = formatEther(\n    await publicClient.getBalance({ address: addressTo })\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 7. Call the balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in TANGO.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 TANGO token from an origin address on the demo EVM network (from which you hold the private key) to another address. To get started, you can create a <code>transaction.ts</code> file by running:</p> <pre><code>touch transaction.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>parseEther</code>, and <code>defineChain</code> functions from <code>viem</code>, as well as the <code>privateKeyToAccount</code> function from <code>viem/accounts</code></li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a viem wallet client for writing chain data, which can be used along with your private key to send transactions. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Define the <code>addressTo</code> variable</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object and the <code>walletClient.sendTransaction</code> method</li> <li>Use the <code>walletClient.sendTransaction</code> function to sign and send the transaction. You'll need to pass in the transaction object, which only requires the recipient's address and the amount to send. Note that <code>parseEther</code> can be used, which handles the necessary unit conversions from Ether to Wei, similar to using <code>parseUnits(value, decimals)</code>. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>balances.ts</code> script directly after this one to check if the balances have been updated as expected</li> <li>Lastly, run the <code>send</code> function</li> </ol> View transaction.ts <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  parseEther,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create to address variable\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 6. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${account.address} to ${addressTo}`\n  );\n\n  // 7. Sign and send transaction\n  const hash = await walletClient.sendTransaction({\n    to: addressTo,\n    value: parseEther('1'),\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call the send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>npx ts-node transaction.ts\n</code></pre> <p>If the transaction was successful, in your terminal, you'll see the transaction hash has been printed out. You can also use the <code>balances.ts</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#deploy-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.ts</code> file by running:</p> <pre><code>touch compile.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.ts</code>:</p> <pre><code>touch deploy.ts\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, and <code>defineChain</code> functions from <code>viem</code>, the <code>privateKeyToAccount</code> function from <code>viem/accounts</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to deploy the <code>Incrementer</code> contract. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to read the transaction receipt for the deployment</li> <li>Load the contract <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract via the <code>walletClient.deployContract</code> method</li> <li>Use the <code>walletClient.deployContract</code> function to sign and send the transaction. You'll need to pass in the contract's ABI and bytecode, the account to deploy the transaction from, and the initial value for the incrementer. Use <code>await</code> to wait until the transaction is processed and the transaction hash is returned</li> <li>Use the <code>publicClient.readContract</code> function to get the transaction receipt for the deployment. Use <code>await</code> to wait until the transaction is processed and the contract address is returned</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> View deploy.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\nconst _initialNumber = 5;\n\n// 6. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${account.address}`);\n\n  // 7. Send transaction (initial value set to 5)\n  const contract = await walletClient.deployContract({\n    abi,\n    account,\n    bytecode,\n    args: [_initialNumber],\n  });\n\n  // 8. Get the transaction receipt for the deployment\n  const transaction = await publicClient.waitForTransactionReceipt({\n    hash: contract,\n  });\n\n  console.log(`Contract deployed at address: ${transaction.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that doesn't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.ts</code>:</p> <pre><code>touch get.ts\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>http</code>, and <code>defineChain</code> functions from <code>viem</code>, and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a public viem client for reading chain data, which will be used to read the current number of the <code>Incrementer</code> contract</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file</li> <li>Create the asynchronous <code>get</code> function</li> <li>Call the contract using the <code>publicClient.readContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and any arguments (if needed). You can use <code>await</code>, which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> View get.ts <pre><code>// 1. Update import\nimport { createPublicClient, http, defineChain } from 'viem';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await publicClient.readContract({\n    abi,\n    functionName: 'number',\n    address: contractAddress,\n    args: [],\n  });\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node get.ts\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/viem/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.ts</code> and <code>reset.ts</code>:</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p>Open the <code>increment.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>createWalletClient</code> <code>http</code>, and <code>defineChain</code> functions from <code>viem</code>, the  <code>privateKeyToAccount</code> from <code>viem/accounts'</code> and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract, the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file, and the <code>_value</code> to increment the contract by</li> <li>Create the asynchronous <code>increment</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and the <code>_value</code>. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been updated as expected</li> <li>Lastly, call the <code>increment</code> function</li> </ol> View increment.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\nconst _value = 3;\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'increment',\n    address: contractAddress,\n    args: [_value],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>increment.ts</code> script to make sure that value is changing as expected.</p> <p></p> <p>Next, you can open the <code>reset.ts</code> file and take the following steps to create the script:</p> <ol> <li>Update your imports to include the <code>createPublicClient</code>, <code>createWalletClient</code> <code>http</code>, and <code>defineChain</code> functions from <code>viem</code>, the  <code>privateKeyToAccount</code> from <code>viem/accounts'</code> and the <code>contractFile</code> from the <code>compile.ts</code> file you created in the Compile Contract Script section</li> <li>Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both <code>public</code> and <code>default</code> RPC URLs are required to be listed, even if they are the same</li> <li>Set up a viem wallet client for writing chain data, which will be used along with your private key to send a transaction. Note: This is for example purposes only. Never store your private keys in a TypeScript file</li> <li>Set up a public viem client for reading chain data, which will be used to wait for the transaction receipt</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract and the <code>abi</code> variable using the <code>contractFile</code> from the <code>compile.ts</code> file to increment the contract by</li> <li>Create the asynchronous <code>reset</code> function</li> <li>Call the contract using the <code>walletClient.writeContract</code> function, passing in the <code>abi</code>, the name of the function, the <code>contractAddress</code>, and an empty array for the arguments. You can use <code>await</code>, which will return the transaction hash once the request promise resolves</li> <li>Use the <code>publicClient.waitForTransactionReceipt</code> function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the <code>get.ts</code> script directly after this one to check that the current number has been reset to <code>0</code></li> <li>Lastly, call the <code>reset</code> function</li> </ol> View reset.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'reset',\n    address: contractAddress,\n    args: [],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.ts</code> script alongside the <code>reset.ts</code> script to make sure that value is changing as expected.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/libraries/web3js/","title":"Web3.js JavaScript Library","text":""},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#introduction","title":"Introduction","text":"<p>Web3.js is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with JavaScript. Tanssi-powered EVM networks have an Ethereum-like API that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Web3.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Web3.js, check out their documentation site.</p> <p>In this guide, you'll learn how to set up the Web3.js library for your Tanssi EVM network. Next, to showcase the library in action, you'll use the Web3.js library to send a transaction and deploy a contract on a Tanssi demo EVM network running on Dancelight. This guide can be adapted for your own Tanssi EVM network by simply changing the endpoint.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds in the Tanssi EVM network you are testing with</li> </ul>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#installing-web3js","title":"Installing Web3Js","text":"<p>For this guide, you'll need to install the Web3.js library and the Solidity compiler. To install both NPM packages, you can run the following command:</p> npmyarn <pre><code>npm install web3 solc@0.8.0\n</code></pre> <pre><code>yarn add web3 solc@0.8.0\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#setting-up-the-web3-provider","title":"Setting up the Web3 Provider","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Web3.js provider to interact with the network.</p> <p>To set up a Web3 provider, you can take the following steps:</p> <ol> <li>Import the <code>Web3</code> library.</li> <li>Create the Web3 provider and specify the RPC url. You can configure Web3.js to work with the Tanssi demo EVM network running on Dancelight, or your own Tanssi EVM network by simply changing the endpoint.</li> </ol> <pre><code>// 1. Import Web3\nconst Web3 = require('web3');\n\n// 2. Create Web3 provider and insert your RPC url\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <p>Save this code snippet as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a <code>balances.js</code> file by running:</p> <pre><code>touch balances.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>addressFrom</code> and <code>addressTo</code> variables</li> <li>Create the asynchronous <code>balances</code> function which wraps the <code>web3.eth.getBalance</code> method</li> <li>Use the <code>web3.eth.getBalance</code> function to fetch the balances for the <code>addressFrom</code> and <code>addressTo</code> addresses. You can also leverage the <code>web3.utils.fromWei</code> function to transform the balance into a more readable number in <code>TANGO</code></li> <li>Lastly, run the <code>balances</code> function</li> </ol> <pre><code>// 1. Add the Web3 provider logic here:\n// {...}\n\n// 2. Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Create balances function\nconst balances = async () =&gt; {\n  // 4. Fetch balance info\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 5. Call balances function\nbalances();\n</code></pre> View the complete script <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balance info\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call balances function\nbalances();\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>node balances.js\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in ETH.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 TANGO token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.js</code> file by running:</p> <pre><code>touch transaction.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>addressFrom</code>, including the <code>privateKey</code>, and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create the asynchronous <code>send</code> function, which wraps the transaction object, and the sign and send transaction functions</li> <li>Create and sign the transaction using the <code>web3.eth.accounts.signTransaction</code> function. Pass in the <code>gas</code>, <code>addressTo</code>, and <code>value</code> for the transaction along with the sender's <code>privateKey</code></li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>send</code> function</li> </ol> <pre><code>// 1. Add the Web3 provider logic here:\n// {...}\n\n// 2. Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_ADDRESS_TO'; // Change to address\n\n// 3. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // 4. Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // 5. Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// 6. Call send function\nsend();\n</code></pre> View the complete script <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// Call send function\nsend();\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>node transaction.js\n</code></pre> <p>If the transaction was successful, in your terminal, you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.js</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.js</code> file by running:</p> <pre><code>touch compile.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>fs</code> and <code>solc</code> packages</li> <li>Using the <code>fs.readFileSync</code> function, you'll read and save the file contents of <code>Incrementer.sol</code> to <code>source</code></li> <li>Build the <code>input</code> object for the Solidity compiler by specifying the <code>language</code>, <code>sources</code>, and <code>settings</code> to be used</li> <li>Using the <code>input</code> object, you can compile the contract using <code>solc.compile</code></li> <li>Extract the compiled contract file and export it to be used in the deployment script</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the contract file from <code>compile.js</code></li> <li>Set up the Web3 provider</li> <li>Define the <code>addressFrom</code>, including the <code>privateKey</code>, and the <code>addressTo</code> variables. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Save the <code>bytecode</code> and <code>abi</code> for the compiled contract</li> <li>Create the asynchronous <code>deploy</code> function that will be used to deploy the contract</li> <li>Create the contract instance using the <code>web3.eth.Contract</code> function</li> <li>Create the constructor and pass in the <code>bytecode</code> and the initial value for the incrementer. For this example, you can set the initial value to <code>5</code></li> <li>Create and sign the transaction using the <code>web3.eth.accounts.signTransaction</code> function. Pass in the <code>data</code> and the <code>gas</code> for the transaction along with the sender's <code>privateKey</code></li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, run the <code>deploy</code> function</li> </ol> <pre><code>// 1. Import the contract file\nconst contractFile = require('./compile');\n\n// 2. Add the Web3 provider logic here:\n// {...}\n\n// 3. Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// 4. Get the bytecode and API\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // 6. Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // 7. Create constructor tx\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // 8. Sign transacation and send\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 9. Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// 10. Call deploy function\ndeploy();\n</code></pre> View the complete script <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst contractFile = require('./compile');\n\n// Add the Web3 provider logic here\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// Get the bytecode and API\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // Create constructor tx with initial value of 5\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // Sign transacation and send\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// Call deploy function\ndeploy();\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>node deploy.js\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interactions that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Create the <code>contractAddress</code> variable using the address of the deployed contract</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and <code>contractAddress</code></li> <li>Create the asynchronous <code>get</code> function</li> <li>Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the <code>number</code> method, which doesn't require any inputs. You can use <code>await</code>, which will return the value requested once the request promise resolves</li> <li>Lastly, call the <code>get</code> function</li> </ol> <pre><code>// 1. Import the contract abi\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic here:\n// {...}\n\n// 3. Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> View the complete script <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node get.js\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3js/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.js</code> and <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p>Open the <code>increment.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Define the <code>privateKey</code> for the origin account, the <code>contractAddress</code> of the deployed contract, and the <code>_value</code> to increment by. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and <code>contractAddress</code></li> <li>Use the contract instance to build the increment transaction using the <code>methods.increment</code> function and passing in the <code>_value</code> as an input</li> <li>Create the asynchronous <code>increment</code> function</li> <li>Use the contract instance and the increment transaction you previously created to sign the transaction with the sender's private key. You'll use the <code>web3.eth.accounts.signTransaction</code> function and specify the <code>to</code> address, the <code>data</code>, and the <code>gas</code> for the transaction</li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, call the <code>increment</code> function</li> </ol> <pre><code>// 1. Import the contract abi\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build increment tx\nconst incrementTx = incrementer.methods.increment(_value);\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign Tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send Tx and Wait for Receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> View the complete script <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build increment tx\nconst incrementTx = incrementer.methods.increment(_value);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign Tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send Tx and Wait for Receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call increment function\nincrement();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node increment.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>increment.js</code> script to make sure that the value is changing as expected.</p> <p></p> <p>Next you can open the <code>reset.js</code> file and take the following steps to create the script:</p> <ol> <li>Import the <code>abi</code> from the <code>compile.js</code> file</li> <li>Set up the Web3 provider</li> <li>Define the <code>privateKey</code> for the origin account and the <code>contractAddress</code> of the deployed contract. The private key is required to create a wallet instance. Note: This is for example purposes only. Never store your private keys in a JavaScript file</li> <li>Create an instance of the contract using the <code>web3.eth.Contract</code> function and passing in the <code>abi</code> and <code>contractAddress</code></li> <li>Use the contract instance to build the reset transaction using the <code>methods.reset</code> function</li> <li>Create the asynchronous <code>reset</code> function</li> <li>Use the contract instance and the reset transaction you previously created to sign the transaction with the sender's private key. You'll use the <code>web3.eth.accounts.signTransaction</code> function and specify the <code>to</code> address, the <code>data</code>, and the <code>gas</code> for the transaction</li> <li>Send the signed transaction using the <code>web3.eth.sendSignedTransaction</code> method and pass in the raw transaction. Then use <code>await</code> to wait until the transaction is processed and the transaction receipt is returned</li> <li>Lastly, call the <code>reset</code> function</li> </ol> <pre><code>// 1. Import the contract abi\nconst { abi } = require('./compile');\n\n// 2. Add the Web3 provider logic here:\n// {...}\n\n// 3. Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Create Contract Instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Build reset tx\nconst resetTx = incrementer.methods.reset();\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 8. Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> View the complete script <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create Contract Instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build reset tx\nconst resetTx = incrementer.methods.reset();\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call reset function\nreset();\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>node reset.js\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.js</code> script alongside the <code>reset.js</code> script to make sure that the value is changing as expected.</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/libraries/web3py/","title":"Web3.py Python Library","text":""},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#introduction","title":"Introduction","text":"<p>Web3.py is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Tanssi EVM networks have an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Web3.py, check their documentation site.</p> <p>In this guide, you'll learn how to use setup the Web3.py library for your Tanssi-powered EVM network. Next, to showcase the library in action, you'll use Web3.py to send a transaction and deploy a contract on a Tanssi demo EVM appchain running on Dancelight. This guide can be adapted for your own Tanssi EVM appchain by simply changing the endpoint.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Python3 and a package manager like pip installed.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>An account with funds in the Tanssi EVM network you are testing with</li> </ul>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#install-web3py","title":"Installing Web3.py","text":"<p>For this guide, you'll need to install the Web3.py library and the Solidity compiler. To install both packages, you can run the following command:</p> <pre><code>pip3 install web3 py-solc-x\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#setting-up-the-web3py-provider","title":"Setting up the Web3.py Provider","text":"<p>Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Web3.py provider to interact with the network.</p> <p>To create a provider, you can take the following steps:</p> <ol> <li>Import the <code>web3</code> library</li> <li>Create the <code>web3</code> provider suing using the <code>Web3(Web3.HTTPProvider()))</code> method and providing the Tanssi EVM network URL</li> </ol> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\n# Insert your RPC URL here\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/')) \n</code></pre> <p>Save this code snippet, as you'll need it for the scripts that are used in the following sections.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#send-a-transaction","title":"Send a Transaction","text":"<p>During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.</p> <p>You can also use the balance script to check the account balances after the transaction has been sent.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#check-balances-script","title":"Check Balances Script","text":"<p>You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a <code>balances.py</code> file by running:</p> <pre><code>touch balances.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Set up the Web3 provider</li> <li>Define the <code>address_from</code> and <code>address_to</code> variables</li> <li>Get the balance for the accounts using the <code>web3.eth.get_balance</code> function and format the results using the <code>web3.from_wei</code></li> </ol> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 2. Create address variables\naddress_from = \"INSERT_ADDRESS_FROM\"\naddress_to = \"INSERT_ADDRESS_TO\"\n\n# 4. Fetch balance data\nbalance_from = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\"\n)\nbalance_to = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\"\n)\n\nprint(f\"The balance of { address_from } is: { balance_from } TANGO\")\nprint(f\"The balance of { address_to } is: { balance_to } TANGO\")\n</code></pre> <p>To run the script and fetch the account balances, you can run the following command:</p> <pre><code>python3 balances.py\n</code></pre> <p>If successful, the balances for the origin and receiving address will be displayed in your terminal in TANGO.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#send-transaction-script","title":"Send Transaction Script","text":"<p>You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a <code>transaction.py</code> file by running:</p> <pre><code>touch transaction.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the <code>rpc_gas_price_strategy</code>, which will be used in the following steps to get the gas price used for the transaction</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>address_to</code> variables. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Use the Web3.py Gas Price API to set a gas price strategy. For this example, you'll use the imported <code>rpc_gas_price_strategy</code></li> <li>Create and sign the transaction using the <code>web3.eth.account.sign_transaction</code> function. Pass in the <code>nonce</code> <code>gas</code>, <code>gasPrice</code>, <code>to</code>, and <code>value</code> for the transaction along with the sender's <code>private_key</code>. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function and pass in the sender's address. To predetermine the <code>gasPrice</code> you'll use the <code>web3.eth.generate_gas_price</code> function. For the <code>value</code>, you can format the amount to send from an easily readable format to Wei using the <code>web3.to_wei</code> function</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom web3 import Web3\nfrom web3.gas_strategies.rpc import rpc_gas_price_strategy\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variables\naccount_from = {\n    \"private_key\": \"INSERT_ YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_ PUBLIC_ADDRESS_OF_PK\",\n}\naddress_to = \"INSERT_ ADDRESS_TO\"\n\nprint(\n    f'Attempting to send transaction from { account_from[\"address\"] } to { address_to }'\n)\n\n# 4. Set the gas price strategy\nweb3.eth.set_gas_price_strategy(rpc_gas_price_strategy)\n\n# 5. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    {\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n        \"gasPrice\": web3.eth.generate_gas_price(),\n        \"gas\": 21000,\n        \"to\": Web3.to_checksum_address(address_to),\n        \"value\": web3.to_wei(\"1\", \"ether\"),\n    },\n    account_from[\"private_key\"],\n)\n\n# 6. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Transaction successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can run the following command in your terminal:</p> <pre><code>python3 transaction.py\n</code></pre> <p>If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.</p> <p>You can also use the <code>balances.py</code> script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#deploy-a-contract","title":"Deploy a Contract","text":"<p>The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named <code>Incrementer.sol</code>. You can get started by creating a file for the contract:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Next, you can add the Solidity code to the file:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>The <code>constructor</code> function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The <code>increment</code> function adds the <code>_value</code> provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the <code>reset</code> function resets the stored value to zero.</p> <p>Note</p> <p>This contract is a simple example for illustration purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#compile-contract-script","title":"Compile Contract Script","text":"<p>In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the <code>Incrementer.sol</code> contract. To get started, you can create a <code>compile.py</code> file by running:</p> <pre><code>touch compile.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Import the <code>solcx</code> package</li> <li>Optional - If you haven't already installed the Solidity compiler, you can do so with by using the <code>solcx.install_solc</code> function</li> <li>Compile the <code>Incrementer.sol</code> function using the <code>solcx.compile_files</code> function</li> <li>Export the contract's ABI and bytecode</li> </ol> <pre><code># 1. Import solcx\nimport solcx\n\n# 2. If you haven't already installed the Solidity compiler, uncomment the following line\n# solcx.install_solc()\n\n# 3. Compile contract\ntemp_file = solcx.compile_files(\n    \"Incrementer.sol\",\n    output_values=[\"abi\", \"bin\"],\n    # solc_version='0.8.19'\n)\n\n# 4. Export contract data\nabi = temp_file[\"Incrementer.sol:Incrementer\"][\"abi\"]\nbytecode = temp_file[\"Incrementer.sol:Incrementer\"][\"bin\"]\n</code></pre> <p>Note</p> <p>If you see an error stating that <code>Solc is not installed</code>, uncomment the step 2 described in the code snippet.</p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#deploy-contract-script","title":"Deploy Contract Script","text":"<p>With the script for compiling the <code>Incrementer.sol</code> contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called <code>deploy.py</code>:</p> <pre><code>touch deploy.py\n</code></pre> <p>Next, you will create the script for this file and complete the following steps:</p> <ol> <li>Add imports, including Web3.py and the ABI and bytecode of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and bytecode of the contract</li> <li>Build a constructor transaction using the contract instance and passing in the value to increment by. For this example, you can use <code>5</code>. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the constructor transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi, bytecode\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\n\nprint(f'Attempting to deploy from account: { account_from[\"address\"] }')\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# 5. Build constructor tx\nconstruct_txn = Incrementer.constructor(5).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    construct_txn, account_from[\"private_key\"]\n)\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Contract deployed at address: { tx_receipt.contractAddress }\")\n</code></pre> <p>To run the script, you can enter the following command into your terminal:</p> <pre><code>python3 deploy.py\n</code></pre> <p>If successful, the contract's address will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#read-contract-data","title":"Read Contract Data (Call Methods)","text":"<p>Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.</p> <p>To get started, you can create a file and name it <code>get.py</code>:</p> <pre><code>touch get.py\n</code></pre> <p>Then you can take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>contract_address</code> of the deployed contract</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Using the contract instance, you can then call the <code>number</code> function</li> </ol> <pre><code># 1. Import the ABI\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Making a call to contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Call Contract\nnumber = Incrementer.functions.number().call()\nprint(f\"The current number stored is: { number } \")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 get.py\n</code></pre> <p>If successful, the value will be displayed in the terminal.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/libraries/web3py/#interact-with-contract","title":"Interact with Contract (Send Methods)","text":"<p>Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them <code>increment.py</code> and <code>reset.py</code>:</p> <pre><code>touch increment.py reset.py\n</code></pre> <p>Open the <code>increment.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, the <code>contract_address</code> of the deployed contract, and the <code>value</code> to increment by. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the increment transaction using the contract instance and passing in the value to increment by. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the increment transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\nvalue = 3\n\nprint(\n    f\"Calling the increment by { value } function in contract at address: { contract_address }\"\n)\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build increment tx\nincrement_tx = Incrementer.functions.increment(value).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 increment.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>increment.py</code> script to make sure that value is changing as expected:</p> <p></p> <p>Next you can open the <code>reset.py</code> file and take the following steps to create the script:</p> <ol> <li>Add imports, including Web3.py and the ABI of the <code>Incrementer.sol</code> contract</li> <li>Set up the Web3 provider</li> <li>Define the <code>account_from</code>, including the <code>private_key</code>, and the <code>contract_address</code> of the deployed contract. The private key is required to sign the transaction. Note: This is for example purposes only. Never store your private keys in a Python file</li> <li>Create a contract instance using the <code>web3.eth.contract</code> function and passing in the ABI and address of the deployed contract</li> <li>Build the reset transaction using the contract instance. You'll then use the <code>build_transaction</code> function to pass in the transaction information including the <code>from</code> address and the <code>nonce</code> for the sender. To get the <code>nonce</code> you can use the <code>web3.eth.get_transaction_count</code> function</li> <li>Sign the transaction using the <code>web3.eth.account.sign_transaction</code> function and pass in the reset transaction and the <code>private_key</code> of the sender</li> <li>Using the signed transaction, you can then send it using the <code>web3.eth.send_raw_transaction</code> function and wait for the transaction receipt by using the <code>web3.eth.wait_for_transaction_receipt</code> function</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Calling the reset function in contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build reset tx\nreset_tx = Incrementer.functions.reset().build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>To run the script, you can enter the following command in your terminal:</p> <pre><code>python3 reset.py\n</code></pre> <p>If successful, the transaction hash will be displayed in the terminal. You can use the <code>get.py</code> script alongside the <code>reset.py</code> script to make sure that value is changing as expected:</p> <p></p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/","title":"Precompiles","text":"<p>Precompiles are built-in blockchain modules designed to handle specific tasks more efficiently than standard smart contracts. These modules are pre-deployed at fixed addresses and provide optimized solutions for operations like cryptographic functions, transaction batching, and token management.</p> <p>Since Tanssi-powered networks are Substrate-based, precompiled contracts can support both Ethereum-compatible functions and operations specific to the underlying Substrate chain. This dual approach ensures that developers can interact with familiar Ethereum tools while also taking advantage of the unique performance and flexibility offered by Substrate.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/#flow-of-interacting-with-precompiles","title":"Flow of Interacting with Precompiles","text":"<p>The flow below illustrates how user requests pass through the Ethereum interface, interact with precompiles, and ultimately access Substrate functionality, simplifying complex operations for seamless integration.</p> <pre><code>graph LR\n\n    A[User]\n    B[Ethereum Interface]\n    C[Precompile]\n    D[Substrate Interface]\n\n    A --&gt;|Interacts through| B\n    B --&gt;|Calls| C\n    C --&gt;|Accesses| D</code></pre>"},{"location":"builders/toolkit/ethereum-api/precompiles/#precompile-addresses-quick-reference","title":"Precompile Addresses Quick Reference","text":"Precompile Address Native Token ERC-20 <pre><code>0x0000000000000000000000000000000000000800</code></pre> Call Permit <pre><code>0x0000000000000000000000000000000000000802</code></pre> Proxy <pre><code>0x0000000000000000000000000000000000000805</code></pre> Batch Transactions <pre><code>0x0000000000000000000000000000000000000801</code></pre> <p>To find out more about each precompile, check out the guides listed in the following section.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/","title":"Interacting with the Batch Precompile","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#introduction","title":"Introduction","text":"<p>The Batch Precompile contract on Tanssi-powered EVM networks allows developers to combine multiple EVM calls into one.</p> <p>Currently, having users interact with multiple contracts would require multiple transaction confirmations in the user's wallet. An example would be approving a smart contract's access to a token and then immediately transferring it. With the Batch Precompile, developers can enhance user experience with batched transactions as it minimizes the number of transactions a user is required to confirm. Additionally, the gas fees paid by a user can be reduced since batching avoids multiple base gas fees (the initial 21000 units of gas spent to begin a transaction).</p> <p>The precompile interacts directly with Substrate's EVM pallet. The caller of the batch function will have their address act as the <code>msg.sender</code> for all subtransactions, but unlike delegate calls, the target contract will still affect its own storage. It is effectively the same as if the user signed multiple transactions but with only one confirmation.</p> <p>The Batch Precompile is located at the following address:</p> <pre><code>0x0000000000000000000000000000000000000801\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#the-batch-interface","title":"The Batch Solidity Interface","text":"<p><code>Batch.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> Batch.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Batch contract's address.\naddress constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000801;\n\n/// @dev The Batch contract's instance.\nBatch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Batch precompile\n/// @dev Allows to perform multiple calls throught one call to the precompile.\n/// Can be used by EOA to do multiple calls in a single transaction.\n/// @custom:address 0x0000000000000000000000000000000000000801\ninterface Batch {\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting following subcalls will still be attempted.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 79df4b9c\n    function batchSome(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, no more subcalls will be executed but\n    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector cf0491c7\n    function batchSomeUntilFailure(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, the entire batch will revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 96e292b8\n    function batchAll(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// Emitted when a subcall succeeds.\n    event SubcallSucceeded(uint256 index);\n\n    /// Emitted when a subcall fails.\n    event SubcallFailed(uint256 index);\n}\n</code></pre> <p>The interface includes the following functions:</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) \u2014 performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, following subcalls will still be attempted Parameters <ul> <li><code>to</code> - an array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchSomeUntilFailure(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) \u2014 performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, no following subcalls will be executed Parameters <ul> <li><code>to</code> - an array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> batchAll(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) \u2014 performs multiple calls atomically, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, all subcalls will revert Parameters <ul> <li><code>to</code> - an array of addresses to direct subtransactions to, where each entry is a subtransaction</li> <li><code>value</code> - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all the following subtransactions will default to a value of 0</li> <li><code>callData</code> - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. If this array is shorter than the to array, all of the following subtransactions will include no call data</li> <li><code>gasLimit</code> - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the to array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the to array, all of the following subtransactions will have all remaining gas forwarded</li> </ul> <p>The interface also includes the following required events:</p> <ul> <li>SubcallSucceeded(uint256 index) - emitted when a subcall of the given index succeeds</li> <li>SubcallFailed(uint256 index) - emitted when a subcall of the given index fails</li> </ul>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the Tanssi dApp. Or, you configure MetaMask for Tanssi with the demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#example-contract","title":"Example Contract","text":"<p>The contract <code>SimpleContract.sol</code> will be used as an example of batching contract interactions, but in practice, any contract can be interacted with.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the Batch Precompile using Remix. You'll need a copy of <code>Batch.sol</code> and <code>SimpleContract.sol</code>. To add the precompile to Remix and follow along with the tutorial, you will need to:</p> <ol> <li>Click on the File explorer tab</li> <li>Paste the <code>Batch.sol</code> contract into a Remix file named Batch.sol</li> <li>Paste the <code>SimpleContract.sol</code> contract into a Remix file named SimpleContract.sol</li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile both files in Remix:</p> <ol> <li>Make sure that you have the Batch.sol file open</li> <li>Click on the Compile tab, second from top</li> <li>To compile the contract, click on Compile Batch.sol</li> </ol> <p></p> <p>If the interface was compiled successfully, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#access-the-precompile","title":"Access the Precompile","text":"<p>Instead of deploying the Batch Precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contract is already deployed</li> <li>Make sure Injected Provider - MetaMask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - MetaMask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure Batch.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead, we are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Batch Precompile: <code>0x0000000000000000000000000000000000000801</code> and click At Address</li> </ol> <p></p> <p>The BATCH precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#deploy-example-contract","title":"Deploy Example Contract","text":"<p>On the other hand, <code>SimpleContract.sol</code> will be deployed as a new contract. Before starting this section, repeat the compilation step with the <code>SimpleContract.sol</code> file.</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix</li> <li>Make sure Injected Provider - MetaMask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - MetaMask, you might be prompted by MetaMask to connect your account to Remix</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure SimpleContract is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>Confirm the MetaMask transaction that appears by clicking Confirm</li> </ol> <p></p> <p>The SIMPLECONTRACT contract will appear in the list of Deployed Contracts.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#send-native-currency-via-precompile","title":"Send Native Currency via Precompile","text":"<p>Sending native currency with the Batch Precompile involves more than pressing a few buttons in Remix or MetaMask. For this example, you will be using the batchAll function to send native currency atomically.</p> <p>Transactions have a value field to specify the amount of native currency sent. In Remix, this is determined by the VALUE input in the DEPLOY &amp; RUN TRANSACTIONS tab. However, for the Batch Precompile, this data is provided within the value array input of the batch functions.</p> <p>Try transferring the native token of your network to two wallets of your choice via the Batch Precompile:</p> <ol> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, insert your addresses in the following format: <code>[\"INSERT_ADDRESS_1\", \"INSERT_ADDRESS_2\"]</code>, where the first address corresponds to the first wallet of your choice and the second address corresponds to the second wallet of your choice</li> <li>For the value input, insert the amount you wish to transfer in Wei for each address. For example, <code>[\"1000000000000000000\", \"2000000000000000000\"]</code> will transfer 1 native token to the first address and 2 native tokens to the second address</li> <li>For callData, insert <code>[]</code>. Call data is not relevant for simply transferring the native token</li> <li>For the gasLimit inputs, insert <code>[]</code></li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>Once the transaction is complete, you can check both of the accounts' balances, either in MetaMask or in your network's block explorer, a link to which can be found on the Tanssi dApp. Congratulations! You've now sent a batched transfer via the Batch Precompile.</p> <p>Note</p> <p>Typically if you wanted to send the native currency to or through a contract, you would have to set the value within the overall transaction object and interact with a payable function. However, since the Batch Precompile interacts directly with Substrate code, this is not a typical Ethereum transaction and is thus not necessary.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#find-a-contract-interactions-call-data","title":"Find a Contract Interaction's Call Data","text":"<p>Visual interfaces like Remix and handy libraries like Ethers.js hide the way that Ethereum transactions interact with Solidity smart contracts. The name and input types of a function are hashed into a function selector and the input data is encoded. These two pieces are then combined and sent as the transaction's call data. To send a subtransaction within a batch transaction, the sender needs to know its call data beforehand.</p> <p>Try finding a transaction's call data using Remix:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>Expand the setMessage function</li> <li>Enter the desired id, such as <code>1</code></li> <li>Enter the desired message, such as <code>\"tanssi\"</code></li> <li>Instead of sending the transaction, click the copy button next to the transact button to copy the call data</li> </ol> <p></p> <p>Now you have the transaction's call data! Considering the example values of <code>1</code> and <code>\"tanssi\"</code>, we can keep an eye out for their encoded values in the call data:</p> <pre><code>0x648345c8                                                        // function selector\n0000000000000000000000000000000000000000000000000000000000000001  // 1 id\n0000000000000000000000000000000000000000000000000000000000000040  // 32 byte offset\n000000000000000000000000000000000000000000000000000000000000000   // 32 byte length\n674616e7373690000000000000000000000000000000000000000000000000000 // \"tanssi\" in bytes\n</code></pre> <p>The call data can be broken into five lines where:</p> <ul> <li>The first line is the function selector</li> <li>The second line is equal to 1, which is the id that was provided</li> <li>What's left involves the message input. These last three lines are tricky since strings are a dynamic type with a dynamic length. The third line refers to an offset to define where the string's data starts. The fourth line refers to the length of the message in the following line, which is 32 bytes total - the \"tanssi\" message plus padding</li> </ul> <p>You can repeat the above steps to capture the call data for values of <code>2</code> and <code>\"hello\"</code> such that multiple subcalls can be submitted atomically with the Batch Precompile in the next section. </p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#function-interaction-via-precompile","title":"Function Interaction via Precompile","text":"<p>This section's example will be using the batchAll function that will ensure the transactions are resolved atomically. Keep in mind that there are also two other batch functions that can either continue subtransactions despite errors or halt subsequent subtransactions but not revert previous ones.</p> <p>Interacting with a function is very similar to sending a native currency, since they are both transactions. However, call data is required to provide input to functions properly and a sender may desire to limit the amount of gas spent in each subtransaction.</p> <p>The <code>callData</code> and <code>gasLimit</code> fields are more relevant for subtransactions that interact with contracts. For each function in the batch interface, the <code>callData</code> input is an array where each index corresponds to the call data for each recipient of the subtransaction, that is, each <code>to</code> input. If the size of the <code>callData</code> array is less than the <code>to</code> array, the remaining subtransactions will have no call data (functions with no inputs). The <code>gasLimit</code> input is an array that corresponds to the amount of gas that each can spend for each subtransaction. If its value at an index is 0 or the index is the size of the array or greater (and smaller than the <code>to</code> array's size), all of the remaining gas from the previous subtransaction is forwarded.</p> <p>To use the precompile to send an atomic batch transaction combining two contract interactions, take the following steps:</p> <ol> <li>Copy the <code>SimpleContract.sol</code> contract's address with the copy button on the right side of its header. Be sure also to have the call data from the previous section</li> <li>Expand the batch contract under Deployed Contracts</li> <li>Expand the batchAll function</li> <li>For the to input, paste the address <code>SimpleContract.sol</code> as follows: <code>[\"INSERT_SIMPLE_CONTRACT_ADDRESS\",\"INSERT_SIMPLE_CONTRACT_ADDRESS\"]</code>. Note that you'll need to repeat the address for as many transactions you are batching together, even if the contract address is the same</li> <li>For the value input, since <code>SimpleContract.sol</code> does not require any native currency to be paid to it, insert <code>[0,0]</code> for 0 Wei</li> <li>For the callData input, insert your call data from the previous section in the following format: <code>[\"INSERT_FIRST_CALL_DATA\",\"INSERT_SECOND_CALL_DATA\"]</code></li> <li>For the gasLimit input, insert <code>[]</code>. You can put in a gas limit value for each subcall, or leave it as an empty array</li> <li>Press transact</li> <li>Press Confirm in the MetaMask extension to confirm the transaction</li> </ol> <p></p> <p>If you used the same call data as the tutorial, you can check to make sure that the transaction has been successful as follows:</p> <ol> <li>Expand the <code>SimpleContract.sol</code> contract under Deployed Contracts</li> <li>To the right of the messages button, insert <code>1</code></li> <li>Press the blue messages button</li> </ol> <p></p> <p>The phrase \"tanssi\" should appear underneath it. You can repeat the above steps with an id of \"2\", and you should see \"hello\". Congratulations! You have interacted with a function with the Batch Precompile.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#combining-subtransactions","title":"Combining Subtransactions","text":"<p>So far, transferring native currency and interacting with functions have been separate, but they can be intertwined.</p> <p>The following four strings can be combined as inputs for a batch transaction. They will send 1 native token to the public Gerald (<code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code>) account and interact with a predeployed <code>SimpleContract.sol</code> contract twice. Here is a break-down:</p> <p>There are three subtransactions which correspond to three addresses in the <code>to</code> input array. The first is the public Gerald account and the following two are a <code>SimpleContract.sol</code> contract. You can replace the last two with your own instance of <code>SimpleContract.sol</code> if you wish. Or, replace only one: you can interact with multiple contracts in a single message.</p> <pre><code>[\n  \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\",\n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\", \n  \"0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39\"\n]\n</code></pre> <p>There will also be three values for the <code>value</code> array. The first address in the <code>to</code> input array indicates <code>1000000000000000000</code> wei or <code>1</code> UNIT of the native token. Remember that the native tokens of Tanssi-powered EVM networks have 18 decimal points just like Ethereum. The following two values are <code>0</code> because the function that their subtransactions are interacting with does not accept or require native currency.  </p> <pre><code>[\"1000000000000000000\", \"0\", \"0\"]\n</code></pre> <p>You will need three values for the <code>callData</code> array. Since transferring native currency does not require call data, the string is simply blank. The second and third values in the array correspond to invocations of setMessage that set messages to IDs 5 and 6.</p> <pre><code>[\n  \"0x\", \n  \"0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000\", \n  \"0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000\"\n]\n</code></pre> <p>The final input is for <code>gas_input</code>. This array will be left empty to forward all remaining gas to each subtransaction.</p> <pre><code>[]\n</code></pre> <p>Try sending a batched transaction with these inputs in Remix the same way you batched a function call.</p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/batch/#ethereum-development-libraries","title":"Ethereum Development Libraries","text":"<p>If you have followed the Ethers.js tutorial, you may find it difficult to find the call data for a function. The answer is hidden within Ether's <code>Interface</code> object, where the encodeFunctionData function allows you to input your function name and inputs to receive the resultant call data. Web3.js has a similar function, encodeFunctionCall.</p> <p>Note</p> <p>The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use case.</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Use ABI to create an interface\nconst yourContractInterface = new ethers.Interface(abi);\n\n// Find call data for the setMessage function\nconst callData = yourContractInterface.encodeFunctionData(\n  'INSERT_FUNCTION_NAME',\n  [\n    'INSERT_INPUT_1',\n    'INSERT_INPUT_2',\n    // ...\n  ]\n);\n</code></pre> <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Find call data for the setMessage function\nconst callData = web3.eth.abi.encodeFunctionCall(abi, [\n  'INSERT_INPUT_1',\n  'INSERT_INPUT_2',\n  // ...\n]);\n</code></pre> <pre><code># Import the ABI and bytecode\nfrom compile import abi, bytecode\n\n# Create contract instance\nyour_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# Encode the contract call\ncall_data = your_contract.encodeABI(\n    fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n)\n</code></pre> <p>Afterwards, you should be all set to interact with the Batch Precompile as one typically would with a contract in Ethers.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/","title":"Interacting with the Call Permit Precompile","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#introduction","title":"Introduction","text":"<p>The Call Permit Precompile on Tanssi-powered EVM networks allows a user to sign a permit, an EIP-712 signed message, for any EVM call and it can be dispatched by anyone or any smart contract. It is similar to the Permit Signing of ERC-20 approvals introduced in EIP-2612, except it applies to any EVM call instead of only approvals.</p> <p>When the call permit is dispatched, it is done so on behalf of the user who signed the permit and the user or contract that dispatches the permit is responsible for paying transaction fees. As such, the precompile can be used to perform gas-less transactions.</p> <p>For example, Alice signs a call permit and Bob dispatches it and performs the call on behalf of Alice. Bob pays for the transaction fees and as such, Alice doesn't need to have any of the native currency to pay for the transaction, unless the call includes a transfer.</p> <p>The Call Permit Precompile is located at the following address:</p> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#the-call-permit-interface","title":"The Call Permit Solidity Interface","text":"<p><code>CallPermit.sol</code> is a Solidity interface that allows developers to interact with the precompile's three methods.</p> CallPermit.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The CallPermit contract's address.\naddress constant CALL_PERMIT_ADDRESS = 0x0000000000000000000000000000000000000802;\n\n/// @dev The CallPermit contract's instance.\nCallPermit constant CALL_PERMIT_CONTRACT = CallPermit(CALL_PERMIT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Call Permit Interface\n/// @dev The interface aims to be a general-purpose tool to perform gas-less transactions. It uses the EIP-712 standard,\n/// and signed messages can be dispatched by another network participant with a transaction\n/// @custom:address 0x0000000000000000000000000000000000000802\ninterface CallPermit {\n    /// @dev Dispatch a call on the behalf of an other user with a EIP712 permit.\n    /// Will revert if the permit is not valid or if the dispatched call reverts or errors (such as\n    /// out of gas).\n    /// If successful the EIP712 nonce is increased to prevent this permit to be replayed.\n    /// @param from Who made the permit and want its call to be dispatched on their behalf.\n    /// @param to Which address the call is made to.\n    /// @param value Value being transferred from the \"from\" account.\n    /// @param data Call data\n    /// @param gaslimit Gaslimit the dispatched call requires.\n    ///     Providing it prevents the dispatcher to manipulate the gaslimit.\n    /// @param deadline Deadline in UNIX seconds after which the permit will no longer be valid.\n    /// @param v V part of the signature.\n    /// @param r R part of the signature.\n    /// @param s S part of the signature.\n    /// @return output Output of the call.\n    /// @custom:selector b5ea0966\n    function dispatch(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint64 gaslimit,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (bytes memory output);\n\n    /// @dev Returns the current nonce for given owner.\n    /// A permit must have this nonce to be consumed, which will\n    /// increase the nonce by one.\n    /// @custom:selector 7ecebe00\n    function nonces(address owner) external view returns (uint256);\n\n    /// @dev Returns the EIP712 domain separator. It is used to avoid replay\n    /// attacks across assets or other similar EIP712 message structures.\n    /// @custom:selector 3644e515\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n</code></pre> <p>The interface includes the following functions:</p> dispatch(address from, address to, uint256 value, bytes data, uint64[] gaslimit, uint256 deadline, uint8 v, bytes32 r, bytes32 s) \u2014 dispatches a call on the behalf of another user with a EIP-712 permit. This function can be called by anyone or any smart contract. The transaction will revert if the permit is not valid or if the dispatched call reverts or errors (such as out of gas). If successful, the nonce of the signer is increased to prevent this permit to be replayed Parameters <ul> <li><code>from</code> - the signer of the permit. The call will be dispatched on behalf of this address</li> <li><code>to</code> - the address the call is made to</li> <li><code>value</code> - the value being transferred from the <code>from</code> account</li> <li><code>data</code> - the call data, or action to be executed</li> <li><code>value</code> - the value being transferred from the <code>from</code> account</li> <li><code>gasLimit</code> - the gas limit the dispatched call requires. Providing an argument for this parameter prevents the dispatcher from manipulating the gas limit</li> <li><code>deadline</code> - the time in UNIX seconds after which the permit will no longer be valid. In JavaScript, you can get the current time in UNIX seconds by running <code>console.log(Date.now())</code> in a JavaScript script or a browser console</li> <li><code>v</code> - the recovery ID of the signature. The last one byte of the concatenated signature</li> <li><code>r</code> - the first 32 bytes of the concatenated signature</li> <li><code>s</code> - the second 32 bytes of the concatenated signature</li> </ul> nonces(address owner) \u2014 returns the current nonce for given owner Parameters <ul> <li><code>owner</code> - the address of the account to check</li> </ul> DOMAIN_SEPARATOR() \u2014 returns the EIP-712 domain separator which is used to avoid replay attacks. It follows the EIP-2612 implementation ParametersReturns <p>None</p> <p>The EIP-712 domain separator which is used to avoid replay attacks.</p> <p>The domain separator is defined in the EIP-712 standard and is calculated as:</p> <pre><code>keccak256(PERMIT_DOMAIN, name, version, chain_id, address)\n</code></pre> <p>The parameters of the hash can be broken down as follows:</p> <ul> <li>PERMIT_DOMAIN - is the <code>keccak256</code> of <code>EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)</code></li> <li>name - is the name of the signing domain and must be <code>'Call Permit Precompile'</code> exactly</li> <li>version - is the version of the signing domain. For this case version is set to <code>1</code></li> <li>chainId - is the chain ID of your network</li> <li>verifyingContract - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address</li> </ul> <p>When <code>dispatch</code> is called, the permit needs to be verified before the call is dispatched. The first step is to compute the domain separator. The calculation can be seen in Moonbeam's implementation or you can check out a practical example in OpenZeppelin's EIP712 contract.</p> <p>From there, a hash of the signature and the given arguments is generated which guarantees that the signature can only be used for the call permit. It uses a given nonce to ensure the signature is not subject to a replay attack. It is similar to OpenZeppelin's <code>ERC20Permit</code> contract, except the <code>PERMIT_TYPEHASH</code> is for a call permit, and the arguments match that of the dispatch function plus the nonce.</p> <p>The domain separator and the hash struct can be used to build the final hash of the fully encoded message. A practical example is shown in OpenZeppelin's EIP712 contract.</p> <p>With the final hash and the v, r, and s values, the signature can be verified and recovered. If successfully verified, the nonce will increase by one and the call will be dispatched.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#setup-the-example-contract","title":"Setup the Contracts","text":"<p>For this example, you'll learn how to sign a call permit that updates a message in a simple example contract, <code>SetMessage.sol</code>. Before you can generate the call permit signature, you'll need to deploy the contract and define the <code>dispatch</code> function arguments for the call permit.</p> <p>Once you've set up the example contract, then you can set up the Call Permit Precompile contract.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the Tanssi dApp. Or, you can configure MetaMask for Tanssi with the demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#example-contract","title":"Example Contract","text":"<p>The <code>SetMessage.sol</code> contract is a perfect example to demonstrate use of the Call Permit Precompile.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#remix-set-up","title":"Remix Set Up","text":"<p>You can use Remix to compile the example contract and deploy it. You'll need a copy of <code>SetMessage.sol</code> and <code>CallPermit.sol</code>. To add the contracts to Remix, you can take the following steps:</p> <ol> <li>Click on the File explorer tab </li> <li>Paste the <code>CallPermit.sol</code> contract into a Remix file named <code>CallPermit.sol</code></li> <li>Paste the <code>SetMessage.sol</code> contract into a Remix file named <code>SetMessage.sol</code></li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#compile-deploy-example-contract","title":"Compile &amp; Deploy the Example Contract","text":"<p>First, you'll need to compile the example contract:</p> <ol> <li>Click on the Compile tab</li> <li>Then to compile the interface, click on Compile SetMessage.sol</li> </ol> <p></p> <p>Then you can deploy it:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure SetMessage.sol is selected in the CONTRACT dropdown</li> <li>Click Deploy</li> <li>MetaMask will pop up and you'll need to Confirm the transaction</li> </ol> <p></p> <p>The contract will appear under the list of Deployed Contracts on the left side panel. Copy the contract address as you will need to use it to generate the call permit signature in the next section.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#compile-access-call-permit","title":"Compile &amp; Access the Call Permit Precompile","text":"<p>First you'll need to compile the Call Permit Precompile contract:</p> <ol> <li>Click on the Compile tab</li> <li>Then to compile the interface, click on Compile CallPermit.sol</li> </ol> <p></p> <p>Then, instead of deploying the contract, you'll just need to access it given the address of the precompile:</p> <ol> <li>Click on the Deploy and Run tab, directly below the Compile tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT drop down</li> <li>Ensure CallPermit.sol is selected in the CONTRACT dropdown. Since this is a precompiled contract, there is no deployment step. Rather you'll provide the address of the precompile in the At Address field</li> <li>Provide the address of the Call Permit Precompile for Tanssi-powered EVM networks: <code>0x0000000000000000000000000000000000000802</code> and click At Address</li> <li>The Call Permit Precompile will appear in the list of Deployed Contracts</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#generate-call-permit-signature","title":"Generate Call Permit Signature","text":"<p>In order to interact with the Call Permit Precompile, you have to have or generate a signature to dispatch the call permit. There are several ways you can generate the signature. This guide will show how to generate the signature using Ethers.js.</p> <p>Here's an overview of the steps that you'll need to take to obtain the signature:</p> <ol> <li>The <code>message</code> will be created and includes some of the data that is needed to create the call permit. It includes the arguments that will be passed into the <code>dispatch</code> function and the nonce of the signer</li> <li>A JSON structure of the data the user needs to sign will be assembled for the call permit and include all of the types for the <code>dispatch</code> arguments and the nonce. This will result in the <code>CallPermit</code> type and will be saved as the <code>primaryType</code></li> <li>The domain separator will be created using <code>\"Call Permit Precompile\"</code> exactly for the name, the version of your dApp or platform, the chain ID of the network the signature is to be used on, and the address of the contract that will verify the signature. Note that you'll need to specify the chain ID of your network in the script to generate the correct signature</li> <li>All of the assembled data will be signed using Ethers.js</li> <li>The signature will be returned and you can use Ethers.js <code>Signature.from</code> method to return the <code>v</code>, <code>r</code>, and <code>s</code> values of the signature</li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#call-permit-arguments","title":"The Call Permit Arguments","text":"<p>As seen in the Call Permit Interface section, the <code>dispatch</code> function takes the following parameters: <code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code>, <code>v</code>, <code>r</code>, and <code>s</code>.</p> <p>In order to get the signature arguments (<code>v</code>, <code>r</code>, and <code>s</code>), you'll need to sign a message containing the arguments for the remainder of the aforementioned parameters, plus the nonce of the signer.</p> <ul> <li><code>from</code> - the address of the account you want to sign the call permit with</li> <li><code>to</code> - the contract address for the <code>SetMessage.sol</code> contract</li> <li><code>value</code> - can be <code>0</code> for this example as you'll just be setting a message instead of transferring any funds</li> <li><code>data</code> - you can send any message you would like. You'll just need the hex representation of the message you want to set using the <code>SetMessage.sol</code> contract. This will contain the function selector of the <code>set</code> function and the string of the message. For this example, you can send <code>hello world</code>. To do so, you can use this hex representation:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li><code>gasLimit</code> - <code>100000</code> will be enough to send the dispatched call</li> <li><code>deadline</code> - you can get the current time in UNIX seconds by running <code>console.log(Date.now())</code> in a JavaScript script or a browser console. Once you have the current time, you should generously add additional seconds to represent when the call permit will expire</li> </ul> <p>The nonce of the signer will also be needed. If this is your first time signing a call permit the nonce will be <code>0</code>. You can also check the nonce in Remix:</p> <ol> <li>Expand the call permit contract</li> <li>Next to the nonces function, enter the address of the signer and click on nonces</li> <li>The result will be returned directly under the function</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#use-ethers-to-create-the-signature","title":"Use Ethers to Create the Signature","text":"<p>To generate the call permit signature using JavaScript and Ethers, you'll first need to create a project locally. You can do so with the following commands:</p> <pre><code>mkdir call-permit-example &amp;&amp; cd call-permit-example &amp;&amp; touch getSignature.js\nnpm init -y\n</code></pre> <p>You should now have a file where you can create the script to get the signature along with a <code>package.json</code> file. Open the <code>package.json</code> file, and below the <code>\"dependencies\"</code> section, add:</p> <pre><code>\"type\": \"module\"\n</code></pre> <p>Next, you can install Ethers.js:</p> <pre><code>npm i ethers\n</code></pre> <p>Remember</p> <p>Never reveal your private keys, as they give direct access to your funds. The following steps are for demonstration purposes only.</p> <p>In the <code>getSignature.js</code> file, you can copy and edit the following code snippet. In addition to the fields discussed above in the Call Permit arguments section, you'll need to insert the Chain ID of your network in the Domain Separator component to properly generate the signature. If you use an incorrect Chain ID, the generated signature will be invalid and no transaction can be dispatched.</p> getSignature.js <pre><code>import { ethers } from 'ethers';\n\nconst from = 'INSERT_FROM_ADDRESS';\nconst to = 'INSERT_TO_ADDRESS';\nconst value = 0;\nconst data =\n  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\nconst gaslimit = 100000;\nconst nonce = 'INSERT_SIGNERS_NONCE';\nconst deadline = 'INSERT_DEADLINE';\n\nconst createPermitMessageData = () =&gt; {\n  const message = {\n    from: from,\n    to: to,\n    value: value,\n    data: data,\n    gaslimit: gaslimit,\n    nonce: nonce,\n    deadline: deadline,\n  };\n\n  const typedData = {\n    types: {\n      CallPermit: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'gaslimit', type: 'uint64' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n      ],\n    },\n    primaryType: 'CallPermit',\n    domain: {\n      name: 'Call Permit Precompile',\n      version: '1',\n      chainId: INSERT-CHAIN-ID,\n      verifyingContract: '0x0000000000000000000000000000000000000802',\n    },\n    message: message,\n  };\n\n  return {\n    typedData,\n    message,\n  };\n};\n\nconst messageData = createPermitMessageData();\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst wallet = new ethers.Wallet(privateKey);\n\nconst signature = await wallet.signTypedData(messageData.typedData.domain, messageData.typedData.types, messageData.message);\n\nconsole.log(`Transaction successful with hash: ${signature}`);\n\nconst ethersSignature = ethers.Signature.from(signature);\nconst formattedSignature = {\n  r: ethersSignature.r,\n  s: ethersSignature.s,\n  v: ethersSignature.v,\n};\n\nconsole.log(formattedSignature);\n</code></pre> <p>To run the script, use the following command:</p> <pre><code>node getSignature.js\n</code></pre> <p>In the console, you should see the concatenated signature along with the values for the signature including the <code>v</code>, <code>r</code>, and <code>s</code> values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.</p> <p></p> <p>Note</p> <p>Take care when copying the <code>v</code>, <code>r</code>, and <code>s</code> values to the <code>dispatch</code> method of the precompile. The ordering of <code>v</code>, <code>r</code>, and <code>s</code> values in the precompile may not be the same as output by the script. </p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":"<p>Now that you have generated the call permit signature, you will be able to test out calling the <code>dispatch</code> function of the Call Permit Precompile.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/call-permit/#dispatch-a-call","title":"Dispatch a Call","text":"<p>When you send the <code>dispatch</code> function, you'll need the same arguments as you used to sign the call permit. To get started, go back to the Deploy and Run tab in Remix, and under the Deployed Contracts section, expand the call permit contract. Make sure that you're connected to the account that you want to consume the call permit and pay the transaction fees. Then take the following steps:</p> <ol> <li>For the from field, enter the account address you used to sign the call permit with</li> <li>Copy and paste the contract address of <code>SetMessage.sol</code></li> <li>Enter <code>0</code> for the value field</li> <li>Enter the hex representation of the function selector for the <code>set</code> function and the string you want to set as the message for the <code>SetMessage.sol</code> contract. For this example, <code>hello world</code> can be used:      <pre><code>0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000\n</code></pre></li> <li>Enter <code>100000</code> for the gasLimit field</li> <li>Enter the <code>deadline</code> you used when signing the call permit</li> <li>Copy the <code>v</code> value you should have retrieved while generating the call permit signature and paste it into the v field</li> <li>Copy the <code>r</code> value you should have retrieved while generating the call permit signature and paste it into the r field</li> <li>Copy the <code>s</code> value you should have retrieved while generating the call permit signature and paste it into the s field</li> <li>Click transact to send the transaction</li> <li>MetaMask should pop up and you can confirm the transaction</li> </ol> <p></p> <p>Once the transaction goes through, you can verify that the message was updated to <code>hello world</code>. To do so, you can:</p> <ol> <li>Expand the <code>SetMessage.sol</code> contract</li> <li>Click on get</li> <li>The result will appear below the function, and it should show <code>hello world</code></li> </ol> <p></p> <p>Congratulations! You've successfully generated a call permit signature and used it to dispatch a call on behalf of the call permit signer.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/","title":"Native Cross-Chain Token Transfers","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#introduction","title":"Introduction","text":"<p>As presented in the Native Cross-Chain Communication article from the Learn section, Tanssi-powered networks benefit from an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication allows safe and fast token transfers leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.</p> <p>The communication protocol enabling token transfers is built on Substrate and runs on a lower level than the EVM, making it harder for EVM developers to access.</p> <p>Nevertheless, EVM networks have an XCM precompile that fills the gap between execution layers, exposing a smart contract interface that abstracts away the underlying complexities, making the execution of cross-chain token transfers as easy as any other smart contract call.</p> <p>This guide will show you how to interact with the XCM Interface precompile to execute cross-chain token transfers through the Ethereum API.</p> <p>The XCM precompile is located at the following address:</p> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#the-xcm-solidity-interface","title":"The XCM Solidity Interface","text":"<p>The <code>XCMInterface.sol</code> interface on Tanssi EVM networks is a Solidity interface that allows developers to interact with the precompile's functions.</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 59df8416\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight) \n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector b489262e\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 4461e6f5\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector d7c89659\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n}\n</code></pre> <p>The interface includes the necessary data structures along with the following functions:</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem, weight) \u2014 sends assets to another EVM-compatible network using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the destination's network ID</li> <li><code>beneficiary</code> address - the ECDSA-type account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> <li><code>weight</code> Weight memory- the maximum gas to use in the whole operation. Setting uint64::MAX to <code>refTime</code> acts in practice as unlimited weight</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsToPara32(paraId, beneficiary, assets,feeAssetItem, weight) \u2014 sends assets to a Substrate network using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>paraId</code> uint32 - the destination's network ID</li> <li><code>beneficiary</code> bytes32 - the Substrate's SR25519-type account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> <li><code>weight</code> Weight memory - the maximum gas to use in the whole operation. Setting uint64::MAX to <code>refTime</code> acts in practice as unlimited weight</li> </ul> <ul> <li><code>paraId</code> - 888</li> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem, weight) \u2014 sends assets to the relay chain using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>beneficiary</code> bytes32 - the Substrate's sr25519-type account in the relay chain that will receive the tokens</li> <li><code>assets</code> AssetAddressInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> <li><code>weight</code> Weight memory - the maximum gas to use in the whole operation. Setting uint64::MAX to <code>refTime</code> acts in practice as unlimited weight</li> </ul> <ul> <li><code>beneficiary</code> - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06</li> <li><code>assets</code> - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul> transferAssetsLocation(dest, beneficiary, assets, feeAssetItem, weight) \u2014 sends assets using the underlying <code>transfer_assets()</code> transaction included in the XCM pallet module ParametersExample <ul> <li><code>dest</code> Location memory - the destination chain</li> <li><code>beneficiary</code> Location memory - the account in the destination chain that will receive the tokens</li> <li><code>assets</code> AssetLocationInfo[] memory - an array of assets to send</li> <li><code>feeAssetItem</code> uint32 - the index of the asset that will be used to pay fees</li> <li><code>weight</code> Weight memory - the maximum gas to use in the whole operation. Setting uint64::MAX to <code>refTime</code> acts in practice as unlimited weight</li> </ul> <ul> <li><code>dest</code> - [\"1\",[]]</li> <li><code>beneficiary</code> - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]</li> <li><code>assets</code> - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]</li> <li><code>feeAssetItem</code> - 0</li> <li><code>weight</code> - [9223372036854775807, 9223372036854775807]</li> </ul>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the Tanssi dApp. Or, you can configure MetaMask for Tanssi with the demo EVM network.</p> <p>Note</p> <p>It is necessary to have previously established communication channels with the destination chain before using this precompile's functionality. To do so, refer to the Manage Cross-Chain Communication Channels guide. Also, if the token being transferred is native to your network, the destination chain must have registered the foreign asset.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the XCM Interface precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>XCMInterface.sol</code></li> <li>Paste the file contents into a Remix file named <code>XcmInterface.sol</code></li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile XCMInterface.sol</li> </ol> <p></p> <p>When the compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. Once you select Injected Provider - Metamask, you may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure XCM - XCMInterface.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the precompile: <code>0x0000000000000000000000000000000000000804</code> and click At Address</li> </ol> <p></p> <p>The XCM Interface precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-evm-chains","title":"Send Tokens Over to Another EVM-Compatible Network","text":"<p>To send tokens over to an account in another EVM-compatible network, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara20 function</li> <li>Enter the network ID (paraId)</li> <li>Enter the 20-bytes (Ethereum-like) destination account (beneficiary)</li> <li> <p>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</p> <p>Note</p> <p>Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the Native Token ERC-20 Precompile will help you reference it through an ERC-20 interface.</p> </li> <li> <p>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on </p> </li> <li>Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (<code>refTime</code>) and the proof size (<code>proofSize</code>). In practice, setting refTime to <code>uint64::MAX</code> is equal to unlimited weight</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-substrate-chains","title":"Send Tokens Over to a Substrate Network","text":"<p>To send tokens over to an account in a Substrate network, please follow these steps:</p> <ol> <li>Expand the transferAssetsToPara32 function</li> <li>Enter the network ID (<code>paraId</code>)</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li> <p>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</p> <p>Note</p> <p>Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the Native Token ERC-20 Precompile will help you reference it through an ERC-20 interface.</p> </li> <li> <p>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on </p> </li> <li>Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to <code>uint64::MAX</code> is equal to unlimited weight</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-relay-chain","title":"Send Tokens Over to the Relay Chain","text":"<p>To send tokens over to an account in the relay chain, please follow these steps:</p> <ol> <li>Expand the transferAssetsToRelay function</li> <li>Enter the sr25519-type destination account (beneficiary)</li> <li> <p>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer</p> <p>Note</p> <p>Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the Native Token ERC-20 Precompile will help you reference it through an ERC-20 interface.</p> </li> <li> <p>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on </p> </li> <li>Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to <code>uint64::MAX</code> is equal to unlimited weight</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-locations","title":"Send Tokens Over Specific Locations","text":"<p>This function is more generic than the others, allowing the destination chain, destination account, and assets to be specified using XCM Multilocations. To send tokens to specific locations, please follow these steps:</p> <ol> <li>Expand the transferAssetsLocation function</li> <li>Enter the multilocation that specifies the destination chain. Note that any chain can be specified, regardless of its configuration or type</li> <li>Enter the Multilocation that specifies the destination account. Note that any account can be specified, regardless of its type (ECDSA, sr25519, or any other)</li> <li> <p>Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset and each asset is specified by its Multilocation and the total amount to transfer</p> <p>Note</p> <p>Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the Native Token ERC-20 Precompile will help you reference it through an ERC-20 interface.</p> </li> <li> <p>Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is <code>0</code>, the second is <code>1</code>, and so on </p> </li> <li>Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to <code>uint64::MAX</code> is equal to unlimited weight</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/","title":"Native Token ERC-20 Precompile","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#introduction","title":"Introduction","text":"<p>The native token ERC-20 precompiled contract on Tanssi-powered EVM networks allows developers to interact with the native protocol token through an ERC-20 interface. Although your network's native token is not an ERC-20 token, now you can interact with it as if it was a vanilla ERC-20.</p> <p>One of the main benefits of this precompile is that it removes the necessity of having a wrapped representation of the protocol token as an ERC-20 smart contract, such as WETH on Ethereum. Furthermore, it minimizes the need for multiple wrapped representations of the same protocol token. Consequently, dApps that need to interact with the protocol token via an ERC-20 interface can do so without needing a separate smart contract.</p> <p>Under the hood, the ERC-20 precompile executes specific Substrate actions related to the Substrate balances module, which is coded in Rust. The balances module provides functionality for handling the various types of balances.</p> <p>This guide will show you how to interact with UNIT tokens, the native protocol tokens for quick trial networks on Dancelight, via the ERC-20 precompile. You can follow along and adapt this guide to interacting with your own network.</p> <p>The precompile is located at the following address:</p> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>The <code>ERC20.sol</code> interface on Tanssi EVM networks follows the EIP-20 Token Standard, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events a token contract must implement to be interoperable with different applications.</p> ERC20.sol <pre><code>/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n</code></pre> <p>Note</p> <p>The ERC-20 precompile does not include <code>deposit</code> and <code>withdraw</code> functions and subsequent events expected from a wrapped token contract, such as WETH.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#interact-with-the-solidity-interface","title":"Interact with the Solidity Interface","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have your wallet configured to work with your Tanssi-powered EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the Tanssi dApp. Or, you can configure MetaMask for Tanssi with the demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#add-token-to-evm-wallet","title":"Add Token to an EVM Wallet","text":"<p>If you want to interact with your network's native token like you would with an ERC-20, you can add a custom token to your EVM-compatible wallet using the precompile address. This section will walk you through adding an external asset to MetaMask.</p> <p>To get started, open up MetaMask and make sure you are connected to your network and:</p> <ol> <li>Switch to the Assets tab</li> <li>Click on Import tokens</li> </ol> <p></p> <p>Now, you can create a custom token:</p> <ol> <li>Enter the precompile address for the token contract address - <code>0x0000000000000000000000000000000000000800</code>. When you enter the address, the Token Symbol and Token Decimal fields should automatically populate. If they do not, you can enter <code>UNIT</code> for the symbol and <code>18</code> for the decimal places. Recall that the default number of decimals for Tanssi EVM networks is <code>18</code>, the same as Ethereum's token decimals</li> <li>Click Next</li> </ol> <p></p> <p>MetaMask will prompt you to confirm the import. You can review the token details and click Import Tokens to import UNIT tokens into your wallet.</p> <p></p> <p>And that's it! You've successfully added the UNIT token as a custom ERC-20 token on your Tanssi EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the ERC-20 precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>ERC20.sol</code></li> <li>Paste the file contents into a Remix file named <code>IERC20.sol</code></li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile IERC20.sol</li> </ol> <p></p> <p>When compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the ERC-20 precompile, you will access the interface given the address of the precompiled contract:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the ERC-20 precompile: <code>0x0000000000000000000000000000000000000800</code> and click At Address</li> </ol> <p></p> <p>The IERC20 precompile will appear in the list of Deployed Contracts.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#get-basic-token-information","title":"Get Basic Token Information","text":"<p>The ERC-20 interface lets you quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can retrieve this information by following these steps:</p> <ol> <li>Expand the IERC20 contract under Deployed Contracts</li> <li>Click decimals to get the decimal places of your network's native protocol token</li> <li>Click name to get the name of the token</li> <li>Click symbol to get the symbol of the token</li> <li>Click totalSupply to obtain the total supply of native tokens on your network</li> </ol> <p></p> <p>The results of each function call are displayed under the respective functions.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#get-account-balance","title":"Get Account Balance","text":"<p>You can check the balance of any address on your network by calling the <code>balanceOf</code> function and passing in an address:</p> <ol> <li>Expand the balanceOf function</li> <li>Enter an address you would like to check the balance of for the owner</li> <li>Click call</li> </ol> <p></p> <p>Your balance will be displayed under the <code>balanceOf</code> function.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#approve-a-spend","title":"Approve a Spend","text":"<p>To approve a token spend allowance, you'll need to provide an address for the spender and the number of tokens the spender is allowed to spend. The spender can be an externally owned account (EOA) or a smart contract. For this example, you can approve the spender with an allowance of 1 UNIT token. To get started, please follow these steps:</p> <ol> <li>Expand the approve function</li> <li>Enter the address of the spender. You should have created two accounts before starting, so you can use the second account as the spender</li> <li>Enter the amount of tokens the spender can spend for the value. For this example, you can allow the spender to spend 1 UNIT token in Wei units (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>After the transaction is confirmed, you'll notice that the balance of your account has stayed the same. This is because you have only approved the allowance for the given amount, and the spender hasn't spent the funds. In the next section, you will use the <code>allowance</code> function to verify that the spender can spend 1 UNIT token on your behalf.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#get-allowance-of-spender","title":"Get Allowance of Spender","text":"<p>To check that the spender received the allowance approved in the Approve a Spend section, you can:</p> <ol> <li>Expand the allowance function</li> <li>Enter your address for the owner</li> <li>Enter the address of the spender that you used in the previous section</li> <li>Click call</li> </ol> <p></p> <p>Once the call is complete, the allowance of the spender will be displayed, which should be equivalent to 1 UNIT token (<code>1000000000000000000</code>).</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#send-transfer","title":"Send Transfer","text":"<p>To send tokens from your account directly to another account, you can call the <code>transfer</code> function by following these steps:</p> <ol> <li>Expand the transfer function</li> <li>Enter the address to send UNIT tokens to</li> <li>Enter the amount of UNIT tokens to send. For this example, you can send 1 UNIT token (<code>1000000000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>Once the transaction is complete, you can check your balance using the <code>balanceOf</code> function or by looking at MetaMask. You'll notice that your balance has decreased by 1 UNIT token. You can also use the <code>balanceOf</code> function to ensure that the recipients balance has increased by 1 UNIT token as expected.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/erc20/#send-transferfrom","title":"Send Transfer From Specific Account","text":"<p>So far, you have approved an allowance of 1 UNIT token for the spender and sent 1 UNIT token via the standard <code>transfer</code> function. The <code>transferFrom</code> function varies from the standard <code>transfer</code> function as it allows you to define the address to which you want to send the tokens. So you can specify an address with an allowance or your address as long as you have funds. For this example, you will use the spender's account to initiate a transfer of the allowed funds from the owner to the spender. The spender can send the funds to any account, but you can send the funds from the owner to the spender for this example.</p> <p>First, you need to switch to the spender's account in MetaMask. Once you switch to the spender's account, you'll notice that the selected address in Remix under the Accounts tab is now the spender's.</p> <p></p> <p>Next, you can initiate and send the transfer. To do so, take the following steps:</p> <ol> <li>Expand the transferFrom function</li> <li>Enter your address as the owner in the from field</li> <li>Enter the recipient address, which should be the spender's address, in the to field</li> <li>Enter the amount of UNIT tokens to send. Again, the spender is currently only allowed to send 1 UNIT token, so enter <code>1000000000000000000</code></li> <li>Click transact</li> </ol> <p></p> <p>Once the transaction is complete, you can check the balance of the owner and spender using the <code>balanceOf</code> function. The spender's balance should have increased by 1 UNIT token, and their allowance should now be depleted. To verify that the spender no longer has an allowance, you can call the <code>allowance</code> function by passing in the owner and spender's addresses. You should receive a result of 0.</p> <p></p> <p>And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/","title":"External Assets as ERC-20","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#introduction","title":"Introduction","text":"<p>As presented in the Native Cross-Chain Communication article, networks deployed through Tanssi can communicate and interoperate with any other network in the ecosystem. This multi-chain environment leads to a multi-asset world, where seamless transfer of assets, data, and value across different networks widens the possibilities to build use cases across diverse industries such as finance (DeFi), real-world assets (RWAs), and others.</p> <p>External assets are tokens native to another blockchain, or, in other words, assets whose reserve chain is not the chain you are interacting with. Tanssi networks can register external assets to enable their inflow. To do so, it is necessary to establish an XCM channel with the other chain and then register one of its native assets as an external asset. Registered external assets behave, to some extent, the same way as local ones.</p> <p>The ERC-20 assets precompile allows networks based on the Tanssi EVM template to access any registered external asset through the standard ERC-20 interface. Consequently, smart contracts deployed to the network can interact with such assets as they would with any other regular ERC-20.</p> <p>The address representing the ERC-20 contract is formed with the first thirty-six positions (eighteen bytes) set to the maximum value and the last four positions (two bytes) replaced with the hexadecimal representation of the registered asset identifier:</p> <pre><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF____\n</code></pre> <p>For example, for the asset whose ID is <code>1</code>, the last four positions must be replaced with <code>0001</code>, and for an asset with an ID of <code>10</code>, those four positions must be replaced with <code>000A</code>.</p> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#prerequisites","title":"Prerequisites","text":"<p>Tto follow along with the contents in this guide, you'll need:</p> <ul> <li>Access to a Tanssi EVM network running runtime 500 or above</li> <li>An established bidirectional XCM channel to another chain. To manage your network's channels, refer to the Manage Cross-Chain Communication Channels article</li> <li>A registered external asset. Once the XCM channels are open, asset registration can be easily done using the dApp as explained in the Register External Assets guide</li> <li>Finally, you'll need an EVM-compatible wallet configured to work with your network. You can also connect your wallet to the demo EVM network.</li> </ul> <p>The examples in this guide are based on the Tanssi demo EVM network, which already has open channels to other networks and registered external assets, as the following picture shows:</p> <ol> <li>The registered external asset (UNIT) which will be used in the following sections</li> <li>Other available external assets not yet registered</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#the-erc20-interface","title":"The ERC-20 Solidity Interface","text":"<p>The <code>ERC20.sol</code> interface on Tanssi EVM networks follows the EIP-20 Token Standard, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events a token contract must implement to be interoperable with different applications.</p> ERC20.sol <pre><code>/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n</code></pre> <p>Note</p> <p>The external assets ERC-20 precompile does not include <code>deposit</code> and <code>withdraw</code> functions and subsequent events expected from a wrapped token contract, such as WETH.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#add-token-to-evm-wallet","title":"Add Token to an EVM Wallet","text":"<p>If you want to interact with your network's registered external assets like you would with an ERC-20, you can add them to your wallet using the precompile address prefix and the asset ID. This section will walk you through adding an external asset to MetaMask.</p> <p>To get started, open up MetaMask and make sure you are connected to your network and:</p> <ol> <li>Switch to the Tokens tab</li> <li> <p>Click on Import tokens</p> <p></p> </li> </ol> <p>Before continuing, you'll need the token's address, which, considering that in this example the external asset has an ID of <code>1</code>, will be:</p> <pre><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001\n</code></pre> <ol> <li>Enter the precompile address for the token contract address. When you enter the address, the Token Symbol and Token Decimal fields should automatically populate. If they do not, you can enter <code>UNIT</code> for the symbol and <code>12</code> for the decimal places</li> <li>Click Next</li> </ol> <p></p> <p>MetaMask will prompt you to confirm the import. You can review the token details and click Import Tokens to import UNIT tokens into your wallet.</p> <p></p> <p>And that's it! You've successfully added the UNIT token external asset as a custom ERC-20 token on the Tanssi demo EVM network.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#interact-with-the-solidity-interface-via-remix","title":"Interact with the Solidity Interface via Remix","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the external assets ERC-20 precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>ERC20.sol</code></li> <li>Paste the file contents into a Remix file named <code>IERC20.sol</code></li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Compile the interface by clicking on Compile IERC20.sol</li> </ol> <p></p> <p>When compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the smart contract, you will access the interface through the address of external asset precompile:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step</li> <li>Make sure Injected Web3 is selected in the ENVIRONMENT dropdown. Once you select Injected Web3, you may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the correct account is displayed under ACCOUNT</li> <li>Ensure IERC20 - IERC20.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the ERC-20 precompile (which is <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001</code> in this example) and click At Address</li> <li>The IERC20 precompile will appear in the list of Deployed Contracts</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-basic-token-information","title":"Get Basic Token Information","text":"<p>The ERC-20 interface lets you quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can retrieve this information by following these steps:</p> <ol> <li>Expand the IERC20 contract under Deployed Contracts</li> <li>Click decimals to get the decimal places of your network's native protocol token</li> <li>Click name to get the name of the token</li> <li>Click symbol to get the symbol of the token</li> <li>Click totalSupply to obtain the total supply of native tokens on your network</li> </ol> <p></p> <p>The results of each function call are displayed under the respective functions.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-account-balance","title":"Get Account Balance","text":"<p>You can check the balance of any address on your network by calling the <code>balanceOf</code> function and passing in an address:</p> <ol> <li>Expand the balanceOf function</li> <li>Enter an address you would like to check the balance of for the owner</li> <li>Click call</li> </ol> <p></p> <p>Your balance will be displayed under the <code>balanceOf</code> function.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#send-transfer","title":"Send Transfer","text":"<p>To send tokens from your account directly to another account, you can call the <code>transfer</code> function by following these steps:</p> <ol> <li>Expand the transfer function</li> <li>Enter the address to send UNIT tokens to</li> <li>Enter the amount of UNIT tokens to send. For this example, you can send 1 UNIT token (<code>1000000000000</code>)</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to send the transaction</li> </ol> <p></p> <p>Once the transaction is complete, you can check your balance using the <code>balanceOf</code> function or by looking at MetaMask. You'll notice that your balance has decreased by 1 UNIT token. You can also use the <code>balanceOf</code> function to ensure that the recipients balance has increased by 1 UNIT token as expected.</p> <p>And that's it! You've successfully interacted with the external assets ERC-20 precompile using MetaMask and Remix!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/","title":"Interacting with the Proxy Precompile","text":""},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#introduction","title":"Introduction","text":"<p>The Proxy Precompile allows accounts to set proxy accounts via the Ethereum API. Proxy accounts can perform limited actions on behalf of the proxied account, such as governance, balance transfers, management or privileged transactions, and others.</p> <p>If a user wanted to provide another user access to a limited number of actions on their behalf, traditionally, the only method to do so would be to share that account's private key. However, Tanssi-powered EVM networks include the proxy module, providing an additional layer of security. With proxies, many accounts can perform actions for a primary account, and such permissions can be revoked at any time. This is best if, for example, a user wants to keep their wallet safe in cold storage but still wants to access parts of the wallet's functionality, like governance or staking.  </p> <p>Note</p> <p>The Proxy Precompile can only be called from an Externally Owned Account (EOA) or by the Batch Precompile.</p> <p>To learn more about proxy accounts and how to set them up for your own purposes without use of the Proxy Precompile, visit the Proxy Accounts page.</p> <p>The Proxy Precompile is located at the following address:</p> <pre><code>0x0000000000000000000000000000000000000805\n</code></pre> <p>Note</p> <p>There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with Moonbeam's Precompile Security Considerations.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#prerequisites","title":"Prerequisites","text":"<p>Tto follow along with the contents in this guide, you'll need:</p> <ul> <li>Access to a Tanssi-powered EVM network running runtime 700 or above</li> <li>An EVM-compatible wallet configured to work with your network. You can also connect your wallet to the demo EVM network</li> <li>An account with enough funds to pay the required fees and deposits</li> <li>A second account that you control to use as a proxy</li> </ul>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#the-proxy-solidity-interface","title":"The Proxy Solidity Interface","text":"<p><code>Proxy.sol</code> is an interface that allows developers to interact with the precompile's functions.</p> Proxy.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @author The Moonsong Labs Team\n/// @title Pallet Proxy Interface\n/// @title The interface through which solidity contracts will interact with the Proxy pallet\ninterface Proxy {\n    /// @dev Defines the proxy permission types.\n    /// The values start at `0` (most permissive) and are represented as `uint8`\n    enum ProxyType {\n        Any,\n        NonTransfer,\n        Governance,\n        Staking,\n        CancelProxy,\n        Balances,\n        AuthorMapping,\n        IdentityJudgement\n    }\n\n    /// @dev Register a proxy account for the sender that is able to make calls on its behalf\n    /// @custom:selector 74a34dd3\n    /// @param delegate The account that the caller would like to make a proxy\n    /// @param proxyType The permissions allowed for this proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function addProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Removes a proxy account from the sender\n    /// @custom:selector fef3f708\n    /// @param delegate The account that the caller would like to remove as a proxy\n    /// @param proxyType The permissions currently enabled for the removed proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function removeProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Unregister all proxy accounts for the sender\n    /// @custom:selector 14a5b5fa\n    function removeProxies() external;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 0d3cff86\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxy(\n        address real,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 685b9d2f\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param forceProxyType Specify the exact proxy type to be used and checked for this call\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxyForceType(\n        address real,\n        ProxyType forceProxyType,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Checks if the caller has an account proxied with a given proxy type\n    /// @custom:selector e26d38ed\n    /// @param real The real account that maybe has a proxy\n    /// @param delegate The account that the caller has maybe proxied\n    /// @param proxyType The permissions allowed for the proxy\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    /// @return exists True if a proxy exists, False otherwise\n    function isProxy(\n        address real,\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external view returns (bool exists);\n}\n</code></pre> <p>The interface includes the necessary data structures along with the following functions:</p> addProxy(delegate, proxyType, delay) \u2014 registers a proxy account for the sender after a specified number of <code>delay</code> blocks (generally zero). Will fail if a proxy for the caller already exists ParametersExample <ul> <li><code>delegate</code> address - the proxy address</li> <li><code>proxyType</code> ProxyType - the delegation type that defines the specific functions the proxy will be granted permission to execute</li> <li><code>delay</code> uint32 - number of blocks to wait until the proxy is enabled</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxy(delegate, proxyType, delay) \u2014 removes a registered proxy for the sender ParametersExample <ul> <li><code>delegate</code> address - the proxy address to remove</li> <li><code>proxyType</code> ProxyType - the delegation type to remove</li> <li><code>delay</code> uint32 - number of blocks to wait until the removal is in effect</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxies() \u2014 removes all of the proxy accounts delegated to the sender isProxy(real, delegate, proxyType, delay) \u2014 returns <code>true</code> if the delegate address is a proxy of type <code>proxyType</code>, for address <code>real</code>, with the specified <code>delay</code> ParametersExample <ul> <li><code>real</code> address - the account granting permissions to the proxy</li> <li><code>delegate</code> address - the proxy address</li> <li><code>proxyType</code> ProxyType - the delegation type</li> <li><code>delay</code> uint32 - number of blocks to wait</li> </ul> <ul> <li><code>delegate</code> - 0xbB8919d5DDfc85F4D15820a9e58018f1cfB39a2F</li> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> <p>The <code>proxyType</code> parameter is defined by the following <code>ProxyType</code> enum, where the values start at <code>0</code> with the most permissive proxy type and are represented as <code>uint8</code> values:</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#proxy-types","title":"Proxy Types","text":"<p>There are multiple types of proxy roles that can be delegated to accounts, represented in <code>Proxy.sol</code> through the <code>ProxyType</code> enum. The following list includes all of the possible proxies and the type of transactions they can make on behalf of the primary account:</p> <ul> <li>Any \u2014 the any proxy will allow the proxy account to make any type of transaction. Note that balance transfers are only allowed to EOAs, not contracts or Precompiles</li> <li>NonTransfer \u2014 the non-transfer proxy allows the proxy account to make any type of transaction where the <code>msg.value</code> is checked to be zero</li> <li>Governance - the governance proxy will allow the proxy account to make any type of governance related transaction</li> <li>CancelProxy - the cancel proxy will allow the proxy account to reject and remove delayed proxy announcements (of the primary account). Currently, this is not an action supported by the Proxy Precompile</li> <li>Balances - the balances proxy will allow the proxy account to only make balance transfers to EOAs</li> </ul> <p>Note</p> <p>The Solidity interface contains more proxy types than those listed above. The previous list includes only those proxy types implemented in the baseline EVM Template.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#interact-with-the-solidity-interface-via-remix","title":"Interact with the Solidity Interface via Remix","text":"<p>This section will walk you through the steps to create a proxy, verify its creation, and revoke the proxy privileges. These examples are based on the Tanssi demo EVM Network and use Metamask. This guide can be adapted for your own Tanssi-powered EVM network by adding the RPC URL of your network to the EVM Wallet of your choosing.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#remix-set-up","title":"Remix Set Up","text":"<p>You can interact with the Proxy precompile using Remix. To add the precompile to Remix, you will need to:</p> <ol> <li>Get a copy of <code>Proxy.sol</code></li> <li>Paste the file contents into a Remix file named <code>Proxy.sol</code></li> </ol>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#compile-the-contract","title":"Compile the Contract","text":"<p>Next, you will need to compile the interface in Remix:</p> <ol> <li>Click on the Compile tab, second from top</li> <li>Then to compile the interface, click on Compile Proxy.sol</li> </ol> <p></p> <p>When compilation is completed, you will see a green checkmark next to the Compile tab.</p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#access-the-contract","title":"Access the Contract","text":"<p>Instead of deploying the smart contract, you will access the interface through its address:</p> <ol> <li>Click on the Deploy and Run tab directly below the Compile tab in Remix</li> <li>Make sure Injected Provider - Metamask is selected in the ENVIRONMENT dropdown. You may be prompted by MetaMask to connect your account to Remix if it's not already connected</li> <li>Make sure the priimary account is displayed under ACCOUNT</li> <li>Ensure Proxy - Proxy.sol is selected in the CONTRACT dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the At Address field</li> <li>Provide the address of the Proxy precompile (which is <code>0x0000000000000000000000000000000000000805</code> in this example) and click At Address</li> <li>The Proxy precompile will appear in the list of Deployed Contracts</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#add-proxy","title":"Add a Proxy","text":"<p>You can add a proxies for your account calling the precompile functions. In the following example, you will add a proxy allowed to execute any transaction on your behalf:</p> <ol> <li>Expand the Proxy Precompile contract to see the available functions</li> <li>Find the addProxy function and press the button to expand the section</li> <li>Insert your second account's address as the delegate, <code>0</code> as proxyType, meaning <code>any</code>, and <code>0</code> as delay</li> <li>Click transact</li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to execute the transaction</li> </ol> <p>Note</p> <p>When constructing the transaction in Remix, the proxyType is represented as a <code>uint8</code>, instead of the expected enum <code>ProxyType</code>. In Solidity, enums are compiled as <code>uint8</code>, so when you pass in <code>0</code> for proxyType, you indicate the first element in the <code>ProxyType</code> enum, which is the <code>any</code> proxy.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#check-proxy","title":"Check a Proxy Existence","text":"<p>The function <code>isProxy</code> checks if a proxy account exists. After creating a proxy in the previous step, use the same parameters to verify that the proxy was successfully added:</p> <ol> <li>Expand the isProxy function</li> <li>Insert your primary account as real, your second account (proxy) as delegate, <code>0</code> as proxyType, and <code>0</code> as delay</li> <li>Click call</li> <li>The functions returns whether there is a proxy or not. In this example, the proxy exists, hence the function returns <code>true</code></li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/precompiles/proxy/#remove-proxy","title":"Remove a Proxy","text":"<p>You can revoke a proxy permission when it's no longer needed. After creating a proxy in the Add Proxy, step, it can be removed following these steps:</p> <ol> <li>Expand the removeProxy function</li> <li>Insert the proxy account as the delegate, <code>0</code> as proxyType, <code>0</code> and as delay</li> <li>Click transact </li> <li>MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to execute the transaction</li> </ol> <p>After the transaction is confirmed, if you repeat the steps to check for a proxy existence, the result should be <code>false</code>.</p> <p></p> <p>And that's it! You've successfully interacted with the Proxy precompile using MetaMask and Remix!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/wallets/","title":"Wallets","text":"<p>Wallets are digital tools that allow users to securely store, manage, and transact with their digital assets. They store the cryptographic keys required to access digital assets and enable one to execute transactions on blockchain networks.</p> <p>For EVM-compatible networks, you can use any wallet that supports EVM, with the flexibility to add custom network configurations, enabling seamless connection and interaction with your network.</p> <p>The pages in this section provide an overview of getting started with various wallet providers. It covers how to create and import accounts, connect to your network, and begin interacting with it.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/ethereum-api/wallets/ledger/","title":"Interacting with Tanssi-powered EVM appchains Using Ledger","text":""},{"location":"builders/toolkit/ethereum-api/wallets/ledger/#introduction","title":"Introduction","text":"<p>Developers and users of Tanssi-powered EVM appchains, such as the Tanssi demo EVM appchain, have a variety of options when it comes to wallets. Regarding cold wallets, which store your private keys in a secure, offline environment, Ledger is one of the most popular options. Ledger provides full support for Substrate blockchains, such as the Tanssi network.</p> <p>Ledger devices are hardware wallets designed to store the private keys offline. They are used to verify and sign the transactions, but they still need a software layer to provide the UI that interacts with the networks, builds the transactions, and sends the signed transactions back to the network once the user has verified them.</p> <p>This guide takes you through all the necessary steps to use your Ledger device with Tanssi-powered EVM appchains.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/ledger/#setting-up-ledger-device","title":"Setting Up Your Ledger Device","text":"<p>If you have a brand new Ledger device, refer to the official website for a guide on getting it started with the initial setup.</p> <p>Now, with your Ledger already initiated, install the Ethereum app taking the following steps:</p> <ol> <li>Open the Ledger Live App on your computer.</li> <li>Go to My Ledger.</li> <li>Connect and unlock the device.</li> </ol> <p>Finally, search for the Ethereum (ETH) app in Ledger Live and install it on your device.</p> <p></p> <p>And that's it. Your device now has an Ethereum account and is able to sign transactions on any Tanssi-powered EVM appchain.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/ledger/#adding-Ledger-hot-wallet","title":"Adding the Ledger to a Hot Wallet","text":"<p>As presented in the introduction, a Ledger hardware wallet provides secure, offline storage for private keys, allowing users to verify and sign transactions. However, by design, it can't interact with blockchains or dApps by itself, nor does it offer a UI for managing assets. To complement the device, a hot wallet is required. The user can choose any Ethereum-compatible wallet.</p> <p>For demonstration purposes, we'll show how to configure Metamask to work with your hardware wallet, but these steps are generally applicable to any other wallet that supports Ledger. To follow along with the steps, make sure you have Metamask installed in your browser, then open the extension and click on the dropdown icon next to the account name.</p> <p></p> <p>Now click on the + Add account or hardware wallet button.</p> <p></p> <p>Select Hardware wallet from the available options.</p> <p></p> <p>On the following screen:</p> <ol> <li>Select the LEDGER box. You'll be prompted to connect your Ledger, unlock it, and open the Ethereum app.</li> <li>Click on Continue.</li> </ol> <p></p> <p>Finally, you will be presented with a list of derived accounts. Select the one you want to import, click Unlock, and that's all! Your Metamask wallet can now sign transactions using your Ledger device.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/wallets/metamask/","title":"Interacting with your Tanssi EVM Network Using MetaMask","text":""},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#introduction","title":"Introduction","text":"<p>Developers building dApps on top of Tanssi-powered EVM networks can leverage their Ethereum compatibility features by integrating known Ethereum wallets, such as MetaMask. By doing so, they can use the injected library MetaMask provides to interact with the Tanssi EVM network.</p> <p>This guide takes you through all the necessary steps: from installing Metamask, to setting up a wallet, and finally connecting it to your Tanssi EVM network.</p> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension","title":"Install the MetaMask Extension","text":"<p>First, you'll start with a fresh and default MetaMask installation from the Chrome store. After downloading, installing, and initializing the extension, follow the Get Started steps to setup the wallet. In there, you need to create a wallet, set a password, and store your secret backup phrase (this gives direct access to your funds, so make sure to store these in a secure place).</p> <p>Note</p> <p>The Metamask browser extension is compatible with Chrome, Chromium based browsers (such as Microsoft Edge and Opera), and Firefox. Metamask is also available as a mobile app for iOS and Android devices.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#setup-a-wallet","title":"Setup a Wallet","text":"<p>After installing MetaMask, the setup will automatically open a new task with a welcome screen. Here, you are offered two options:</p> <ul> <li>Create a new wallet - you'll go through some steps to get a new seed phrase. Ensure you store this phrase securely and you don't share it publicly</li> <li>Import an existing wallet - you already have a seed phrase stored, and you want to restore an account from that recovery phrase</li> </ul> <p></p> <p>Once you've clicked on the option that adapts to your needs, follow the steps, and you should be all setup.</p> <p>Note</p> <p>Multiple accounts can be derived from a seed phrase by changing what is known as the address index. By default, when creating or importing an account from the seed phrase, you get the account with the address index 0. You can get the other indexes by just adding new accounts in the main Metamask screen.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#import-accounts","title":"Import Accounts","text":"<p>Once you've created a wallet or imported an existing one, you can also import any account into MetaMask if you hold the private keys.</p> <p>For this example, you'll use private keys from the development account. Click the account switcher button to import an account using its private keys. That is where it says Account 1.</p> <p></p> <p>Next, click on Import Account.</p> <p></p> <p>Finally, enter the private keys of the account you are trying to import. Once you've entered the private key, click on Import.</p> <p></p> <p>You should end up with an imported Account 2 that looks like this:</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#connect-metamask-to-evm-network","title":"Connect MetaMask to your Tanssi EVM Network","text":"<p>Once you have MetaMask installed and have created or imported an account, you can connect it to your Tanssi EVM network. To do so, take the following steps:</p> <ol> <li>Click in the upper left network selector menu</li> <li>Select Add Network</li> </ol> <p></p> <p>Next, go to the bottom of the page and click on Add network manually:</p> <p></p> <p>Here, you can configure MetaMask for the following networks:</p> Variable Value Network Name <code>Tanssi demo EVM appchain</code> RPC URL <code>https://services.tanssi-testnet.network/dancelight-2001/</code> Chain ID <code>5678</code> Symbol (Optional) <code>TANGO</code> Block Explorer (Optional) <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code> <p>To do so, fill in the following information:</p> <ol> <li>Network name - name that represents the network you are connecting to</li> <li>RPC URL - RPC endpoint of the network</li> <li>Chain ID - chain ID of the Ethereum compatible network</li> <li>Symbol - (optional) symbol of the native token of the network</li> <li>Block Explorer - (optional) URL of the block explorer</li> <li>Once you've verified all the information, click on Save</li> </ol> <p></p> <p>Once you've added the network, you'll be redirected to a screen stating that you've successfully added a network. Furthermore, you'll be prompted to Switch to Tanssi demo EVM appchain, the network added in this example.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/wallets/metamask/#interact-with-network","title":"Interact with the Network","text":"<p>Once you've connected Metamask to your Tanssi EVM network, you can start using your wallet by:</p> <ul> <li>Requesting TANGO tokens from the demo EVM network faucet</li> <li>Sending a token transfer to another address</li> <li>Adding ERC-20s to Metamask and interacting with them</li> <li>Adding ERC-721s to Metamask and interacting with them</li> </ul>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/","title":"Interacting with Your Tanssi EVM Network Using SubWallet","text":""},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/#introduction","title":"Introduction","text":"<p>Developers and users of Tanssi-powered EVM networks have a variety of options when it comes to wallets. Thanks to their seamless Ethereum compatibility, Tanssi EVM networks support a great variety of popular wallets, including SubWallet.</p> <p>SubWallet is a comprehensive Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Ethereum API, but you can check out a similar tutorial for interacting with SubWallet using the Substrate API. The SubWallet wallet browser extension can be downloaded for all supported browsers, including Chrome, Brave, Firefox, and MS Edge. SubWallet also has a mobile app for both iOS and Android, but that is beyond the scope of this guide. A complete online asset dashboard is accessible at web.subwallet.app.</p> <p>This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to your Tanssi EVM network, and sending funds.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/#creating-your-first-ethereum-account","title":"Creating Your First Ethereum Account","text":"<p>First, download and install the SubWallet extension. Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. Click Create a new account to get started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet.</p> <p></p> <p>You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <p></p> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/#importing-an-existing-evm-account","title":"Importing an Existing EVM Account","text":"<p>Of course, you can import an existing EVM account into SubWallet. To get started, take the following steps:</p> <ol> <li>Press the All accounts button at the top</li> <li>Press the Import account icon</li> </ol> <p></p> <p>On the following screen, select the method by which you would like to import the existing account.</p> <p></p> <p>On the following screen, you'll be able to provide the relevant seed phrase, private key, JSON file, or QR code, and you can begin using your new account right away.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/#configuring-subwallet-for-your-evm-network","title":"Configuring SubWallet for Your EVM Network","text":"<p>To configure SubWallet for your Tanssi-powered EVM network, press the More Options icon in the upper left corner. Then click Manage networks. Press the + icon. On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, the demo EVM network is used here, but you can substitute these details for your own Tanssi network. To add your Tanssi network to SubWallet, take the following steps:</p> <ol> <li>Paste in the HTTPS RPC URL of your Tanssi network. The demo EVM network's RPC URL is <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Other parameters will be auto-populated</li> <li>Paste in the block explorer URL of your Tanssi network. The demo EVM network's block explorer URL is <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Press Save</li> </ol> <p></p> <p>By default, all balances are hidden in SubWallet, but if you press the eye icon, you can toggle balance visibility.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/subwallet/#sending-assets-on-your-evm-network","title":"Sending Assets on Your EVM Network","text":"<p>To transfer the native token of your Tanssi network, take the following steps:</p> <ol> <li>Specify the asset to send</li> <li>Specify the destination chain (in this case, the same chain that you're sending from)</li> <li>Enter the destination address</li> <li>Enter the number of tokens to send</li> <li>Look over the transaction details, then press Transfer and subsequently Approve</li> </ol> <p></p> <p>This guide focused specifically on configuring SubWallet to work with your Tanssi EVM network, but SubWallet is also a full-featured wallet for Substrate (Polkadot) accounts. Under the Substrate API section, you'll find a similar guide for configuring SubWallet for use with your Substrate network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/ethereum-api/wallets/talisman/","title":"Interacting with Your Tanssi EVM Network Using Talisman","text":""},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#introduction","title":"Introduction","text":"<p>Developers and users of Tanssi-powered EVM networks have a variety of options when it comes to wallets. Thanks to their seamless Ethereum compatibility, Tanssi EVM networks support a great variety of popular wallets, such as Talisman.</p> <p>Talisman is a Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Ethereum API, but you can check out a similar tutorial for interacting with Talisman using the Substrate API. The Talisman wallet browser extension is available on Google Chrome and Brave, and a corresponding asset dashboard is accessible at app.talisman.xyz</p> <p>This guide takes you through all the necessary steps, from installing Talisman to setting up a wallet, connecting it to your Tanssi EVM network, and sending funds.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#setting-up-talisman","title":"Setting Up Talisman","text":"<p>First, download and install the Talisman extension. This guide will first cover creating a new wallet and later address importing an existing one. Review the terms and conditions, then press Get Started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet.</p> <p></p>"},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#creating-an-ethereum-account","title":"Creating an Ethereum Account","text":"<p>To create your first Ethereum account, take the following steps:</p> <ol> <li>Select the Ethereum option</li> <li>Give your account a name</li> <li>Press Create</li> </ol> <p></p> <p>After creating your first account, you'll be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <p></p> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#importing-an-existing-evm-account","title":"Importing an Existing EVM Account","text":"<p>Of course, you can import an existing EVM account into Talisman. To do so, take the following steps:</p> <ol> <li>Press Add Account</li> <li>Press Import</li> <li>Select Import via Recovery Phrase (note, this works for both seeds and private keys)</li> </ol> <p></p> <p>On the following screen, take the following steps:</p> <ol> <li>Select the Ethereum account type</li> <li>Provide a name for your account</li> <li>Paste in your seed or private key</li> <li>If you imported a mnenomic seed phrase in the prior step, select which accounts you'd like to import</li> <li>Press Import</li> </ol> <p></p>"},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#configuring-talisman-for-your-evm-network","title":"Configuring Talisman for Your EVM Network","text":"<p>To configure Talisman for your Tanssi EVM network, open the Talisman extension and click on the More Options tab. Then, take the following steps:</p> <ol> <li>Select Settings</li> <li>Check the Enable testnets box</li> <li>Press Add Network</li> </ol> <p></p> <p>On the following page, you'll then be prompted to enter the network details for your Tanssi-powered network. For demonstration purposes, the demo EVM network is used here, but you can substitute these details for your own network. To add your network to Talisman, take the following steps:</p> <ol> <li>Paste in the RPC URL of your Tanssi-powered network. The demo EVM network's RPC URL is <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Other parameters will be autopopulated</li> <li>Paste in the block explorer URL of your Tanssi-powered network. The demo EVM network's block explorer URL is <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Check the This is a testnet box if applicable</li> <li>Press Add Network</li> </ol> <p></p> <p>If you hold a balance of tokens in your newly created account for your network, you'll see the balance in the Talisman dashboard.</p>"},{"location":"builders/toolkit/ethereum-api/wallets/talisman/#sending-assets-on-your-evm-network","title":"Sending Assets on Your EVM Network","text":"<p>To transfer the native token of your Tanssi network, take the following steps:</p> <ol> <li>Click on the Send icon</li> <li>Click the desired Send from account</li> <li>Enter the destination address</li> <li>Enter the amount of tokens to send</li> <li>Look over the transaction details, then press Review and subsequently Confirm</li> </ol> <p></p> <p>This guide focused specifically on configuring Talisman to work with your Tanssi-powered EVM network, but Talisman is also a full-featured wallet for Substrate (Polkadot) accounts. Under the Substrate API section, you'll find a similar tutorial for configuring Talisman to work with Substrate-based chains.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/","title":"Integrations","text":"<p>Discover integrations that enable you to extend the functionality of your Tanssi-powered dApps. These integrations enable seamless interaction with external data sources, enhance user experience, and enable advanced features such as on-chain data feeds, analytics, and wallet support.</p> <p>Ready to start building? Check out the following integrations:</p> <ul> <li>Oracles - Acurast, Band, and Phala</li> <li>Indexers - SQD</li> <li>Wallets - RainbowKit</li> </ul>"},{"location":"builders/toolkit/integrations/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/integrations/indexers/","title":"Indexers","text":"<p>Indexers enable efficient ingestion, processing, and querying of blockchain data, providing developers with powerful tools to create responsive and data-rich applications on Tanssi-powered networks.</p> <p>Main features of indexers include:</p> <ul> <li>Improved data access speed - faster querying of on-chain data by organizing and indexing it, enabling quicker retrieval times</li> <li>Data aggregation - ingest and transform data that is easier to query and work with large amounts of data</li> <li>Enhanced querying capabilities - use sophisticatd querying methods, such as filtering, sorting, and pagination</li> <li>Real-time data updates - synchronization with the blockchain enables applications to access the latest information as soon as its available</li> </ul>"},{"location":"builders/toolkit/integrations/indexers/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/","title":"SQD","text":"<p>SQD is a blockchain indexing and query service designed to make it easier for developers to build data-rich applications on Substrate-based chains, such as Tanssi-powered networks. It provides an efficient and scalable solution for processing, indexing, and querying on-chain data, allowing developers to easily interact with the blockchain data they need without dealing with the complexities of raw blockchain data directly.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/","title":"Indexing ERC-20 Transfers on a Tanssi EVM Network","text":""},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#introduction","title":"Introduction","text":"<p>SQD is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD\u2019s decentralized data lake and open-source SDK. In very simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities.</p> <p>SQD has native and full support for both EVM and Substrate data. SQD offers a Substrate Archive and Processor and an EVM Archive and Processor. The Substrate Archive and Processor can be used to index both Substrate and EVM data. This allows developers to extract on-chain data from any Tanssi-powered network and process EVM logs as well as Substrate entities (events, extrinsics, and storage items) in one single project and serve the resulting data with one single GraphQL endpoint. If you exclusively want to index EVM data, it is recommended to use the EVM Archive and Processor.</p> <p>This tutorial is a step-by-step guide to building a Squid to index EVM data from start to finish. It's recommended that you follow along, taking each step described on your own, but you can also find a complete version of the Squid built in this tutorial in the tanssiSquid GitHub repository.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#check-prerequisites","title":"Check Prerequisites","text":"<p>To follow along with this tutorial, you'll need to have:</p> <ul> <li>Docker installed</li> <li>Docker Compose installed</li> <li>An empty Hardhat project. For step-by-step instructions, please refer to the Creating a Hardhat Project section of our Hardhat documentation page</li> </ul> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#deploy-an-erc20-with-hardhat","title":"Deploy an ERC-20 with Hardhat","text":"<p>Before we can index anything with SQD we need to make sure we have something to index! This section will walk through deploying an ERC-20 token to your Tanssi-powered network so you can get started indexing it. However, you can feel free to skip to Create a Squid Project if either of the two scenarios apply:</p> <ul> <li>You have already deployed an ERC-20 token to your network (and made several transfers)</li> <li>You would prefer to use an existing ERC-20 token deployed to the demo EVM network (of which there are already several transfer events)</li> </ul> <p>If you'd like to use an existing ERC-20 token on the demo EVM network, you can use the below <code>MyTok.sol</code> contract. The hashes of the token transfers are provided as well to assist with any debugging.</p> <p>In this section, we'll show you how to deploy an ERC-20 to your EVM network and we'll write a quick script to fire off a series of transfers that will be picked up by our SQD indexer. Ensure that you have initialized an empty Hardhat project via the instructions in the Creating a Hardhat Project section of our Hardhat documentation page.</p> <p>Before we dive into creating our project, let's install a couple of dependencies that we'll need: the Hardhat Ethers plugin and OpenZeppelin contracts. The Hardhat Ethers plugin provides a convenient way to use the Ethers library to interact with the network. We'll use OpenZeppelin's base ERC-20 implementation to create an ERC-20. To install both of these dependencies, you can run:</p> npmyarn <pre><code>npm install @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> <pre><code>yarn add @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> <p>Now we can edit <code>hardhat.config.js</code> to include the following network and account configurations for our network. You can replace the demo EVM network values with the respective parameters for your own Tanssi-powered EVM network which can be found at apps.tanssi.network.</p> hardhat.config.js <pre><code>// 1. Import the Ethers plugin required to interact with the contract\nrequire('@nomicfoundation/hardhat-ethers');\n\n// 2. Add your private key that is funded with tokens of your Tanssi-powered network\n// This is for example purposes only - **never store your private keys in a JavaScript file**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  // 3. Specify the Solidity version\n  solidity: '0.8.20',\n  networks: {\n    // 4. Add the network specification for your Tanssi EVM network\n    demo: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Fill in the EVM ChainID for your Tanssi-powered network\n      accounts: [privateKey],\n    },\n  },\n};\n</code></pre> <p>Remember</p> <p>You should never store your private keys in a JavaScript or Python file. It is done in this tutorial for ease of demonstration only. You should always manage your private keys with a designated secret manager or similar service.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#create-an-erc-20-contract","title":"Create an ERC-20 Contract","text":"<p>For the purposes of this tutorial, we'll be creating a simple ERC-20 contract. We'll rely on OpenZeppelin's ERC-20 base implementation. We'll start by creating a file for the contract and naming it <code>MyTok.sol</code>:</p> <pre><code>mkdir -p contracts &amp;&amp; touch contracts/MyTok.sol\n</code></pre> <p>Now we can edit the <code>MyTok.sol</code> file to include the following contract, which will mint an initial supply of MYTOKs and allow only the owner of the contract to mint additional tokens:</p> MyTok.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyTok is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") Ownable(msg.sender) {\n        _mint(msg.sender, 50000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n</code></pre>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#deploy-erc-20-contract","title":"Deploy an ERC-20 Contract","text":"<p>Now that we have our contract set up, we can compile and deploy our contract.</p> <p>To compile the contract, you can run:</p> <pre><code>npx hardhat compile\n</code></pre> <p></p> <p>This command will compile our contract and generate an <code>artifacts</code> directory containing the ABI of the contract.</p> <p>To deploy our contract, we'll need to create a deployment script that deploys our ERC-20 contract and mints an initial supply of MYTOKs. We'll use Alith's account to deploy the contract, and we'll specify the initial supply to be 1000 MYTOK. The initial supply will be minted and sent to the contract owner, which is Alith.</p> <p>Let's take the following steps to deploy our contract:</p> <ol> <li> <p>Create a directory and file for our script:</p> <pre><code>mkdir -p scripts &amp;&amp; touch scripts/deploy.js\n</code></pre> </li> <li> <p>In the <code>deploy.js</code> file, go ahead and add the following script:</p> deploy.js <pre><code>// scripts/deploy.js\nconst hre = require('hardhat');\nrequire('@nomicfoundation/hardhat-ethers');\n\nasync function main() {\n  // Get ERC-20 contract\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // This is a temporary stopgap solution to a bug\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Deploy the contract providing a gas price and gas limit\n  const myTok = await MyTok.deploy({\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // Wait for the deployment\n  await myTok.waitForDeployment();\n\n  console.log(`Contract deployed to ${myTok.target}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> </li> <li> <p>Run the script using the <code>dev</code> network configurations we set up in the <code>hardhat.config.js</code> file:</p> <pre><code>npx hardhat run scripts/deploy.js --network demo\n</code></pre> </li> </ol> <p>The address of the deployed contract should be printed to the terminal. Save the address, as we'll need it to interact with the contract in the following section.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#transfer-erc-20s","title":"Transfer ERC-20s","text":"<p>Since we'll be indexing <code>Transfer</code> events for our ERC-20, we'll need to send a few transactions that transfer some tokens from Alith's account to our other test accounts. We'll do this by creating a simple script that transfers 10 MYTOKs to Baltathar, Charleth, Dorothy, and Ethan. We'll take the following steps:</p> <p>Create a new file script to send transactions:</p> <pre><code>touch scripts/transactions.js\n</code></pre> <p>In the <code>transactions.js</code> file, add the following script and insert the contract address of your deployed MyTok contract (output in the console in the prior step):</p> transactions.js <pre><code>// We require the Hardhat Runtime Environment explicitly here. This is optional\n// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.\n//\n// You can also run a script with `npx hardhat run &lt;script&gt;`. If you do that, Hardhat\n// will compile your contracts, add the Hardhat Runtime Environment's members to the\n// global scope, and execute the script.\nconst hre = require('hardhat');\n\nasync function main() {\n  // Get Contract ABI\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // Gas price is typically specified in 'wei' and gas limit is just a number\n  // You can use Ethers.js utility functions to convert from gwei or ether if needed\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Plug ABI to address\n  const myTok = await MyTok.attach('INSERT_CONTRACT_ADDRESS');\n\n  const value = 100000000000000000n;\n\n  let tx;\n  // Transfer to Baltathar\n  tx = await myTok.transfer(\n    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);\n\n  // Transfer to Charleth\n  tx = await myTok.transfer(\n    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);\n\n  // Transfer to Dorothy\n  tx = await myTok.transfer(\n    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);\n\n  // Transfer to Ethan\n  tx = await myTok.transfer(\n    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);\n}\n\n// We recommend this pattern to be able to use async/await everywhere\n// and properly handle errors.\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>Run the script to send the transactions:</p> <pre><code>npx hardhat run scripts/transactions.js --network demo\n</code></pre> <p>As each transaction is sent, you'll see a log printed to the terminal.</p> <p></p> <p>Now we can move on to creating our Squid to index the data on our local development node.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#create-a-squid-project","title":"Create a Squid Project","text":"<p>Now we're going to create our Subquid project. First, we'll need to install the Squid CLI:</p> <pre><code>npm i -g @subsquid/cli@latest\n</code></pre> <p>To verify successful installation, you can run:</p> <pre><code>sqd --version\n</code></pre> <p>Now we'll be able to use the <code>sqd</code> command to interact with our Squid project. To create our project, we're going to use the <code>--template</code> (<code>-t</code>) flag, which will create a project from a template. We'll be using the EVM Squid template, which is a starter project for indexing EVM chains.</p> <p>You can run the following command to create an EVM Squid named <code>tanssi-squid</code>:</p> <pre><code>sqd init tanssi-squid --template evm\n</code></pre> <p>This will create a Squid with all of the necessary dependencies. You can go ahead and install the dependencies:</p> <pre><code>cd tanssi-squid &amp;&amp; npm ci\n</code></pre> <p>Now that we have a starting point for our project, we'll need to configure our project to index ERC-20 <code>Transfer</code> events taking place on our Tanssi network.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#set-up-the-indexer-for-erc-20-transfers","title":"Set Up the Indexer for ERC-20 Transfers","text":"<p>In order to index ERC-20 transfers, we'll need to take a series of actions:</p> <ol> <li>Define the database schema and generate the entity classes</li> <li>Use the <code>ERC20</code> contract's ABI to generate TypeScript interface classes</li> <li>Configure the processor by specifying exactly what data to ingest</li> <li>Transform the data and insert it into a TypeORM database in <code>main.ts</code></li> <li>Run the indexer and query the squid</li> </ol> <p>As mentioned, we'll first need to define the database schema for the transfer data. To do so, we'll edit the <code>schema.graphql</code> file, which is located in the root directory, and create a <code>Transfer</code> entity and <code>Account</code> entity. You can copy and paste the below schema, ensuring that any existing schema is first removed.</p> schema.graphql <pre><code>type Account @entity {\n  \"Account address\"\n  id: ID!\n  transfersFrom: [Transfer!] @derivedFrom(field: \"from\")\n  transfersTo: [Transfer!] @derivedFrom(field: \"to\")\n}\n\ntype Transfer @entity {\n  id: ID!\n  blockNumber: Int!\n  timestamp: DateTime!\n  txHash: String!\n  from: Account!\n  to: Account!\n  amount: BigInt!\n}\n</code></pre> <p>Now we can generate the entity classes from the schema, which we'll use when we process the transfer data. This will create new classes for each entity in the <code>src/model/generated</code> directory.</p> <pre><code>sqd codegen\n</code></pre> <p>In the next step, we'll use the ERC-20 ABI to automatically generate TypeScript interface classes. Below is a generic ERC-20 standard ABI. Copy and paste it into a file named <code>erc20.json</code> in the <code>abi</code> folder at the root level of the project.</p> ERC-20 ABI <pre><code>[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_from\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"payable\": true,\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }\n]\n</code></pre> <p>Next, we can use our contract's ABI to generate TypeScript interface classes. We can do this by running:</p> <pre><code>sqd typegen\n</code></pre> <p></p> <p>This will generate the related TypeScript interface classes in the <code>src/abi/erc20.ts</code> file. For this tutorial, we'll be accessing the <code>events</code> specifically.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#configure-the-processor","title":"Configure the Processor","text":"<p>The <code>processor.ts</code> file tells SQD exactly what data you'd like to ingest. Transforming that data into the exact desired format will take place at a later step. In <code>processor.ts</code>, we'll need to indicate a data source, a contract address, the event(s) to index, and a block range.</p> <p>Open up the <code>src</code> folder and head to the <code>processor.ts</code> file. First, we need to tell the SQD processor which contract we're interested in. Create a constant for the address in the following manner:</p> <pre><code>export const CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n</code></pre> <p>The <code>.toLowerCase()</code> is critical because the SQD processor is case-sensitive, and some block explorers format contract addresses with capitalization. Next, you'll see the line <code>export const processor = new EvmBatchProcessor()</code>, followed by <code>.setDataSource</code>. We'll need to make a few changes here. SQD has available archives for many chains that can speed up the data retrieval process, but it's unlikely your network has a hosted archive already. But not to worry, SQD can easily get the data it needs via your network's RPC URL. Go ahead and comment out or delete the archive line. Once done, your code should look similar to the below:</p> <pre><code>.setDataSource({\n  chain: {\n    url: assertNotNull(\n      'https://services.tanssi-testnet.network/dancelight-2001/'\n    ),\n    rateLimit: 300,\n  },\n})\n</code></pre> <p>The Squid template comes with a variable for your RPC URL defined in your <code>.env</code> file. You can replace that with the RPC URL for your network. For demonstration purposes, the RPC URL for the demo EVM network is hardcoded directly, as shown above. If you're setting the RPC URL in your <code>.env</code>, the respective line will look like this:</p> <pre><code>RPC_ENDPOINT=https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Now, let's define the event that we want to index by adding the following:</p> <pre><code>.addLog({\n  address: [contractAddress],\n  topic0: [erc20.events.Transfer.topic],\n  transaction: true,\n})\n</code></pre> <p>The <code>Transfer</code> event is defined in <code>erc20.ts</code>, which was auto-generated when <code>sqd typegen</code> was run. The import <code>import * as erc20 from './abi/erc20'</code> is already included as part of the Squid EVM template.</p> <p>Block range is an important value to modify to narrow the scope of the blocks you're indexing. For example, if you launched your ERC-20 at block <code>650000</code>, there is no need to query the chain before that block for transfer events. Setting an accurate block range will improve the performance of your indexer. You can set the earliest block to begin indexing in the following manner:</p> <pre><code>.setBlockRange({from: 632400,})\n</code></pre> <p>The chosen start block here corresponds to the relevant block to begin indexing on the demo EVM network, but you should change it to one relevant to your Tanssi-powered network and indexer project.</p> <p>Change the <code>setFields</code> section to specify the following data for our processor to ingest:</p> <pre><code>.setFields({\n  log: {\n    topics: true,\n    data: true,\n  },\n  transaction: {\n    hash: true,\n  },\n})\n</code></pre> <p>We also need to add the following imports to our <code>processor.ts</code> file:</p> <pre><code>import { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n</code></pre> <p>Once you've completed the prior steps, your <code>processor.ts</code> file should look similar to this:</p> processor.ts <pre><code>import { assertNotNull } from '@subsquid/util-internal';\nimport {\n  BlockHeader,\n  DataHandlerContext,\n  EvmBatchProcessor,\n  EvmBatchProcessorFields,\n  Log as _Log,\n  Transaction as _Transaction,\n} from '@subsquid/evm-processor';\nimport { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n\n// Here you'll need to import the contract\nexport const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n\nexport const processor = new EvmBatchProcessor()\n  .setDataSource({\n    chain: {\n      url: assertNotNull(\n        'https://services.tanssi-testnet.network/dancelight-2001'\n      ),\n      rateLimit: 300,\n    },\n  })\n  .setFinalityConfirmation(10)\n  .setFields({\n    log: {\n      topics: true,\n      data: true,\n    },\n    transaction: {\n      hash: true,\n    },\n  })\n  .addLog({\n    address: [contractAddress],\n    topic0: [erc20.events.Transfer.topic],\n    transaction: true,\n  })\n  .setBlockRange({\n    from: INSERT_START_BLOCK, // Note the lack of quotes here\n  });\n\nexport type Fields = EvmBatchProcessorFields&lt;typeof processor&gt;;\nexport type Block = BlockHeader&lt;Fields&gt;;\nexport type Log = _Log&lt;Fields&gt;;\nexport type Transaction = _Transaction&lt;Fields&gt;;\n</code></pre>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#transform-and-save-the-data","title":"Transform and Save the Data","text":"<p>While <code>processor.ts</code> determines the data being consumed, <code>main.ts</code> determines the bulk of actions related to processing and transforming that data. In the simplest terms, we are processing the data that was ingested via the SQD processor and inserting the desired pieces into a TypeORM database. For more detailed information on how SQD works, be sure to check out the SQD docs on Developing a Squid.</p> <p>Our <code>main.ts</code> file is going to scan through each processed block for the <code>Transfer</code> event and decode the transfer details, including the sender, receiver, and amount. The script also fetches account details for involved addresses and creates transfer objects with the extracted data. The script then inserts these records into a TypeORM database, enabling them to be easily queried. Let's break down the code that comprises <code>main.ts</code> in order:</p> <ol> <li>The job of <code>main.ts</code> is to run the processor and refine the collected data. In <code>processor.run</code>, the processor will iterate through all selected blocks and look for <code>Transfer</code> event logs. Whenever it finds a <code>Transfer</code> event, it's going to store it in an array of transfer events where it awaits further processing</li> <li>The <code>transferEvent</code> interface is the type of structure that stores the data extracted from the event logs</li> <li><code>getTransfer</code> is a helper function that extracts and decodes ERC-20 <code>Transfer</code> event data from a log entry. It constructs and returns a <code>TransferEvent</code> object, which includes details such as the transaction ID, block number, sender and receiver addresses, and the amount transferred. <code>getTransfer</code> is called at the time of storing the relevant transfer events into the array of transfers</li> <li><code>processTransfers</code> enriches the transfer data and then inserts these records into a TypeORM database using the <code>ctx.store</code> methods. The account model, while not strictly necessary, allows us to introduce another entity in the schema to demonstrate working with multiple entities in your Squid</li> <li><code>getAccount</code> is a helper function that manages the retrieval and creation of account objects. Given an account ID and a map of existing accounts, it returns the corresponding account object. If the account doesn't exist in the map, it creates a new one, adds it to the map, and then returns it</li> </ol> <p>We'll demo a sample query in a later section. You can copy and paste the below code into your <code>main.ts</code> file:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\n// 1. Iterate through all selected blocks and look for transfer events,\n// storing the relevant events in an array of transfer events\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  let transfers: TransferEvent[] = [];\n\n  for (let block of ctx.blocks) {\n    for (let log of block.logs) {\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  await processTransfers(ctx, transfers);\n});\n\n// 2. Define an interface to hold the data from the transfer events\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\n// 3. Extract and decode ERC-20 transfer event data from a log entry\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\n// 4. Enrich and insert data into typeorm database\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  await ctx.store.upsert(Array.from(accounts.values()));\n  await ctx.store.insert(transfers);\n}\n\n// 5. Helper function to get account object\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>Now we've taken all of the steps necessary and are ready to run our indexer!</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#run-the-indexer","title":"Run the Indexer","text":"<p>To run our indexer, we're going to run a series of <code>sqd</code> commands:</p> <p>Build our project:</p> <pre><code>sqd build\n</code></pre> <p>Launch the database:</p> <pre><code>sqd up\n</code></pre> <p>Remove the database migration file that comes with the EVM template and generate a new one for our new database schema:</p> <pre><code>sqd migration:generate\n</code></pre> <pre><code>sqd migration:apply\n</code></pre> <p>Launch the processor:</p> <pre><code>sqd process\n</code></pre> <p>In your terminal, you should see your indexer starting to process blocks!</p> <p></p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#query-your-squid","title":"Query Your Squid","text":"<p>To query your squid, open up a new terminal window within your project and run the following command:</p> <pre><code>sqd serve\n</code></pre> <p>And that's it! You can now run queries against your Squid on the GraphQL playground at <code>http://localhost:4350/graphql</code>. Try crafting your own GraphQL query, or use the below one:</p> Example query <pre><code>query {\n  accounts {\n    id\n    transfersFrom {\n      id\n      blockNumber\n      timestamp\n      txHash\n      to {\n        id\n      }\n      amount\n    }\n    transfersTo {\n      id\n      blockNumber\n      timestamp\n      txHash\n      from {\n        id\n      }\n      amount\n    }\n  }\n}\n</code></pre> <p></p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#debug-your-squid","title":"Debug Your Squid","text":"<p>It may seem tricky at first to debug errors when building your Squid, but fortunately, there are several techniques you can use to streamline this process. First and foremost, if you're facing errors with your Squid, you should enable debug mode in your <code>.env</code> file by uncommenting the debug mode line. This will trigger much more verbose logging and will help you locate the source of the error.</p> <pre><code># Uncommenting the below line enables debug mode\nSQD_DEBUG=*\n</code></pre> <p>You can also add logging statements directly to your <code>main.ts</code> file to indicate specific parameters like block height and more. For example, see this version of <code>main.ts</code>, which has been enhanced with detailed logging:</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  ctx.log.info('Processor started');\n  let transfers: TransferEvent[] = [];\n\n  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);\n  for (let block of ctx.blocks) {\n    ctx.log.debug(`Processing block number ${block.header.height}`);\n    for (let log of block.logs) {\n      ctx.log.debug(`Processing log with address ${log.address}`);\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        ctx.log.info(`Transfer event found in block ${block.header.height}`);\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  ctx.log.info(`Found ${transfers.length} transfers, processing...`);\n  await processTransfers(ctx, transfers);\n  ctx.log.info('Processor finished');\n});\n\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  ctx.log.debug(\n    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`\n  );\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  ctx.log.info('Starting to process transfer data');\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n  ctx.log.info(\n    `Accounts fetched, processing ${transfersData.length} transfers`\n  );\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  ctx.log.debug(`Upserting ${accounts.size} accounts`);\n  await ctx.store.upsert(Array.from(accounts.values()));\n  ctx.log.debug(`Inserting ${transfers.length} transfers`);\n  await ctx.store.insert(transfers);\n  ctx.log.info('Transfer data processing completed');\n}\n\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>See the SQD guide to logging for more information on debug mode.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/erc20-transfers/#common-errors","title":"Common Errors","text":"<p>Below are some common errors you may face when building a project and how you can solve them.</p> <pre><code>Error response from daemon: driver failed programming external connectivity on endpoint my-awesome-squid-db-1\n(49df671a7b0531abbb5dc5d2a4a3f5dc7e7505af89bf0ad1e5480bd1cdc61052):\nBind for 0.0.0.0:23798 failed: port is already allocated\n</code></pre> <p>This error indicates that you have another instance of SQD running somewhere else. You can stop that gracefully with the command <code>sqd down</code> or by pressing the Stop button next to the container in Docker Desktop.</p> <pre><code>Error: connect ECONNREFUSED 127.0.0.1:23798\n     at createConnectionError (node:net:1634:14)\n     at afterConnectMultiple (node:net:1664:40) {\n     errno: -61,code: 'ECONNREFUSED',syscall: 'connect',\n     address: '127.0.0.1',port: 23798}\n</code></pre> <p>To resolve this, run <code>sqd up</code> before you run <code>sqd migration:generate</code></p> <p>Is your Squid error-free, yet you aren't seeing any transfers detected? Make sure your log events are consistent and identical to the ones your processor is looking for. Your contract address also needs to be lowercase, which you can be assured of by defining it as follows:</p> <pre><code>export const contractAddress = '0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85'.toLowerCase();\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/indexers/sqd/quick-start/","title":"Indexing a Tanssi Network with SQD","text":""},{"location":"builders/toolkit/integrations/indexers/sqd/quick-start/#introduction","title":"Introduction","text":"<p>SQD is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD's decentralized data lake and open-source SDK. In simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities. SQD has native and full support for both EVM and Substrate data, even within the same project.</p> <p>This quick-start guide will show you how to create a Squid project and configure it to index data on a Tanssi-powered network. There is one section catered towards Substrate networks and another towards EVM networks. However, if you're building on an EVM network, you may also reference the Substrate section, if you also need to index Substrate data.</p> <p>For a more comprehensive end-to-end tutorial for EVM networks, be sure to check out the Indexing ERC-20 Transfers on a Tanssi EVM Network tutorial.</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/quick-start/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>For the examples in this guide, you will need to have the following:</p> <ul> <li>Node.js version 16 or newer</li> <li>Docker</li> <li>Squid CLI</li> </ul>"},{"location":"builders/toolkit/integrations/indexers/sqd/quick-start/#index-substrate-networks","title":"Index a Tanssi Substrate Network","text":"<p>To get started indexing Substrate data on your Tanssi-powered network, you'll need to create a Squid project and configure it for your network by taking the following steps:</p> <ol> <li> <p>Create a Squid project based on the Substrate template by running</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>For more information on getting started with this template, please check out the Getting started: Substrate chains guide on SQD's documentation site.</p> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file to set the data source to the RPC URL of your Tanssi network. Remove the <code>archive: lookupArchive</code> line as a Squid archive will not be used. Here, you'll need to specify the RPC URL of your Tanssi Substrate network, as the endpoint is used to ingest chain data</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> </li> <li> <p>Launch Postgres by running</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspect and run the processor</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Open a separate terminal window in the same directory, then start the GraphQL server</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>You can query your template Substrate Squid with the below sample query. If you've modified the template Substrate squid to index different data, you'll need to modify this query accordingly</p> <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> </li> </ol> <p>And that's all you have to do to configure your Squid project to index Substrate data on your Tanssi-powered Substrate network! Now you can update the <code>schema.graphql</code>, <code>src/main.ts</code>, <code>typegen.json</code>, and <code>src/processor.ts</code> files to index the data you need for your project!</p>"},{"location":"builders/toolkit/integrations/indexers/sqd/quick-start/#index-evm-networks","title":"Index a Tanssi EVM Network","text":"<p>To get started indexing EVM data on a Tanssi-powered EVM network, you'll need to create a Squid project and configure it for your network by taking the following steps:</p> <ol> <li> <p>You can create a Squid project for EVM data by using the generic EVM template or you can use the ABI template for indexing data related to a specific contract</p> EVMABI <pre><code>sqd init INSERT_SQUID_NAME --template evm\n</code></pre> <pre><code>sqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>For more information on getting started with both of these templates, please check out the following SQD docs:</p> <ul> <li>Getting started: EVM chains</li> <li>Quickstart: Squid generation tools</li> </ul> </li> <li> <p>Navigate into the root directory of your Squid project and install dependencies by running</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Modify the <code>src/processor.ts</code> file to set the data source to the RPC URL of your Tanssi network. Remove the <code>archive: lookupArchive('eth-mainnet')</code> line as a Squid archive will not be used. Here, the RPC URL of the demo EVM network is specified. The Squid project will use the RPC endpoint to ingest the relevant data</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> <p>Note</p> <p>To try this out on the demo EVM network, you can use the following RPC URL:</p> <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> </li> <li> <p>Launch Postgres by running</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspect and run the processor</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Open a separate terminal window in the same directory, then start the GraphQL server</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>You can now run queries, such as the sample query below, against your Squid on the GraphQL playground at <code>http://localhost:4350/graphql</code>. If you've modified the template Substrate squid to index different data, you'll need to modify this query accordingly</p> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>And that's all you have to do to configure your Squid project to index EVM data on your Tanssi-powered EVM network! Now you can update the <code>schema.graphql</code>, <code>src/main.ts</code>, and <code>src/processor.ts</code> files to index the data you need for your project!</p> <p>If you're interested in a more comprehensive step-by-step tutorial to get started indexing data for your Tanssi network, you can check out the Indexing ERC-20 Transfers on a Tanssi EVM Network tutorial!</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/oracles/","title":"Oracles","text":"<p>Blockchain oracles are services that enable blockchains to interact with external data sources, bridging the gap between smart contracts and real-world information. Oracles are essential for dynamic applications that rely on accurate and timely off-chain data.</p> <p>Main features of oracles include:</p> <ul> <li>External connectivity - allowing smart contracts to fetch and utilize real-world data</li> <li>Automation - trigger contract execution based on external conditions</li> <li>Flexibility - support various data types, such as price feeds, weather updates, and sports results</li> </ul>"},{"location":"builders/toolkit/integrations/oracles/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/","title":"Accessing Price Feeds with Acurast","text":""},{"location":"builders/toolkit/integrations/oracles/acurast/#introduction","title":"Introduction","text":"<p>Acurast gives developers complete permissionless access to compute that is trustless, affordable, and confidential for deploying their applications.</p> <p>One of Acurast's use cases is to enable developers to deploy their own push/pull oracles, interacting with off-chain APIs to bring price feeds on-chain. Pricing data is confidentially processed through Acurast Processors, pushing data to smart contracts of EVM-compatible chains like Tanssi-powered EVM networks via a standard Chainlink Aggregator Interface.</p> <p>This tutorial will walk through a demo of interacting with price feeds enabled by Acurast on the demo Tanssi EVM-compatible network. You can also deploy your own price feeds to your Tanssi EVM-compatible network. Please be advised that the steps shown in this tutorial are for demonstration purposes only - it's highly recommended that you contact the Acurast team directly as they can assist you with launching price feeds on your network to ensure the integrity of the deployment process.</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/#what-is-acurast","title":"What is Acurast?","text":"<p>Acurast is a decentralized, serverless cloud where everyone can become part of the cloud with their new, used, or even mobile phones with a smashed screen by providing compute power to the cloud and earning rewards. These so-called Processors are scattered across the globe, creating a distributed network of compute across the globe.</p> <p>Processors and developers can seamlessly interact through the Acurast Console.</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/#fetch-price-data","title":"Fetch Price Data","text":"<p>You can design your Acurast price feed exactly as you wish. The demo price feed built for this tutorial inherits the same interface as the Chainlink price feeds. The data lives in a series of smart contracts (one per price feed) and can be fetched with the aggregator interface:</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>As seen above in the interface, there are five functions for fetching data: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code>, and <code>latestRoundData</code>. For more information about the <code>AggregatorV3Interface.sol</code>, see the Chainlink API Reference.</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/#interacting-with-price-feeds-demo-evm-network","title":"Interacting with Price Feeds on the Tanssi Demo EVM Network","text":"<p>This tutorial will showcase interacting with a sample BTC/USDT price feed contract on the demo EVM network, but you can interact any of the price feeds listed in Supported Assets. The BTC/USDT price feed is deployed on the demo EVM network, so you can interact with it by accessing the aggregator contract at the below contract address:</p> <pre><code>0x02093b190D9462d964C11587f7DedD92718D7B56\n</code></pre> <p>For a refresher on setting up Remix to interface with the demo EVM network, see the Deploy Smart Contracts with Remix guide. Secondly, make sure you have connected MetaMask to the demo EVM network.</p> <p>Paste the aggregator contract into a new file in Remix and compile it.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Head to the Deploy and Run Transactions tab</li> <li>Set the ENVIRONMENT to Injected Provider -- MetaMask</li> <li>Select the AggregatorV3Interface contract from the CONTRACT dropdown</li> <li>Enter the sample price feed contract address for <code>BTC to USD</code>, which is <code>0x02093b190D9462d964C11587f7DedD92718D7B56</code> on the demo EVM network in the At Address field and click the At Address button</li> </ol> <p></p> <p>The aggregator contract should now be accessible. To interact with the aggregator contract, take the following steps:</p> <ol> <li>Expand the AggregatorV3Interface contract to reveal the available functions</li> <li>Click decimals to query how many digits after the decimal point are included in the returned price data</li> <li>Click description to verify the asset pair of the price feed</li> <li>Click latestRoundData to see the most recent price data for the asset pair. The price data for the pair is returned as the int256 answer</li> </ol> <p></p> <p>Note that to obtain a readable price from the price feed, it's essential to adjust for the feed's decimal places, which can be determined using the <code>decimals()</code> method. For instance, if the price feed returns a value of <code>51933620000</code>, you'll need to move the decimal point six places to accurately reflect the price. In this example, it corresponds to a Bitcoin price of <code>$51,933.62</code> at the time of writing.</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/#supported-assets","title":"Supported Assets","text":"<p>By its design, Acurast can support the price feed of any arbitrary asset that is accessible by an API. The API request that powers the demo price feed is as follows:</p> <pre><code>curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"\n</code></pre> <p>Upon running the above command in your terminal, you'll see a result that resembles the following:</p> curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"  {\"symbol\":\"BTCUSDT\",\"price\":\"51917.61000000\"} <p>Note</p> <p>This simple example of fetching a price feed relies on a single source of price feed data from one exchange. You can build a more complex job script that aggregates pricing data from multiple sources.</p> <p>The Acurast team has deployed the below price feeds on the Tanssi demo EVM network:</p> Asset &amp; Base Pair Aggregator Contract AAVE to USDT 0x6239Ff749De3a21DC219bcFeF9d27B0dfE171F42 BTC to USDT 0x02093b190D9462d964C11587f7DedD92718D7B56 CRV to USDT 0x01F143dfd745861902dA396ad7dfca962e5C83cA DAI to USDT 0x73aF6b14b73059686a9B93Cd28b2dEABF76AeC92 ETH to USDT 0x007c3F3cc99302c19792F73b7434E3eCbbC3db25 USDC to USDT 0xe4a46ef4cFbf87D026C3eB293b7672998d932F62 USDT to USD 0xf9c885E3A5846CEA887a0D69655BC08e52afe569"},{"location":"builders/toolkit/integrations/oracles/acurast/#designing-and-launching-your-own-price-feed","title":"Designing and Launching Your Own Price Feed","text":"<p>You can build and launch your own Acurast price feed on your Tanssi-powered EVM-compatible network. Please be advised that the steps shown in this tutorial are unaudited, unverified, and for demonstration purposes only - it's highly recommended that you contact the Acurast team directly as they can assist you with launching price feeds on your network to ensure the integrity of the deployment process.</p> <p>To launch an Acurast price feed, you need two key components: a smart contract and a script. In the prior example of Interacting with the BTC/USD price feed on the demo EVM network, the generic Chainlink interface is used because it is a more straightforward example for demonstration purposes. The underlying smart contract that powers that price feed conforms to the Chainlink Aggregator interface, but the demo contract has additional components worthy of discussion. You can find both the demo contract and script at the GitHub repo for the Acurast demo BTC/USD price feed.</p> <p>The demo contract, <code>InsecureDummyPriceFeed.sol</code>, emits an event when the price is updated and when a new round begins. The <code>setPrice</code> method is insecure, as shown in this demo smart contract, but it is provided to show you where you might add logic like aggregation consensus, access control checks, and other parameters.</p> InsecureDummyPriceFeed.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/**\nThis Dummy Oracle is compatible with Chainlink's AggregatorV2V3Interface, meaning projects currently using\nChainlink can seamlessly migrate. The updating of the price feed happens in the interval you specified on\nthe Acurast script.\n\nAt the moment no check on the signer/source is being performed, making this implementation INSECURE. However\nwith a minimal effort you can extend the \"setPrice\" entrypoint to reflext the kind of logic you are looking for\n(i.e. Aggregation Consensus, Check sources, thresholds, etc).\n**/\n\ncontract DummyChainlinkCompatibleOracle is AggregatorV2V3Interface {\n    int256 private latestPrice;\n    uint256 private latestPriceTimestamp;\n    uint256 private latestRoundId;\n\n    // Assuming price can be set without restriction for simplicity\n    // In a real-world scenario, there should be access control mechanisms\n    function setPrice(int256 _price) external {\n        latestPrice = _price;\n        latestPriceTimestamp = block.timestamp;\n        latestRoundId++;\n\n        emit AnswerUpdated(latestPrice, latestRoundId, latestPriceTimestamp);\n        emit NewRound(latestRoundId, msg.sender, latestPriceTimestamp);\n    }\n\n    // AggregatorInterface functions\n    function latestAnswer() external view override returns (int256) {\n        return latestPrice;\n    }\n\n    function latestTimestamp() external view override returns (uint256) {\n        return latestPriceTimestamp;\n    }\n\n    function latestRound() external view override returns (uint256) {\n        return latestRoundId;\n    }\n\n    function getAnswer(uint256 _roundId) external view override returns (int256) {\n        if(_roundId == latestRoundId) {\n            return latestPrice;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    function getTimestamp(uint256 _roundId) external view override returns (uint256) {\n        if(_roundId == latestRoundId) {\n            return latestPriceTimestamp;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    // AggregatorV3Interface functions\n    function decimals() external pure override returns (uint8) {\n        return 6; // Assume a common decimal value for simplicity\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"Sample Price Feed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId == latestRoundId, \"Only latest round data available\");\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n}\n</code></pre> <p>Warning</p> <p>This demo contract has some security vulnerabilities and lacks access control mechanisms, making it unsuitable for any real use. It was developed by the Acurast team for demonstration purposes only.</p> <p>Before proceeding to the next steps, you must first deploy your price feed's smart contract on your Tanssi EVM network. Or, you can deploy it to the demo EVM network, and you can obtain TestNet TANGO tokens from the Tanssi faucet. Once deployed, be sure to record the contract address, as you will need to enter this information into your Acurast price feed script.</p>"},{"location":"builders/toolkit/integrations/oracles/acurast/#building-the-acurast-script","title":"Building the Acurast Script","text":"<p>The Acurast oracle script plays a crucial role by updating your on-chain oracle with fresh data, acting as the vital connection between the Tanssi network's price feed and the Acurast network. Through the Acurast console, you will upload this script and specify all necessary parameters for your price feed's operation, including its frequency, schedule, and rewards for Acurast processors, among others. To facilitate this process, you will need cACU tokens, which are available from the faucet, and serve as the native currency of the Acurast Canary network.</p> <p>The Acurast script for the demo BTC/USD price feed can be used as a basis for creating your own script. Remember to update the contract address and RPC URL fields.</p> AcurastScript.js <pre><code>/**\n * This Oracle Script observes the BTC USDT Pair and posts the price on-chain.\n * Deploying the script is easy using console.acurast.com and simply copy/pasting\n * this script. Make sure to update `DESTINATION_CONTRACT` and `EVM_RPC_NODE` to\n * reflect your deployment. For RPC's with API keys like i.e. infura make sure\n * to work with the Acurast confidential environment variables. After having set\n * them for your job, you can access them easily with a `_STD_.env[\"MY_KEY\"]`. They\n * also come in handy for paid API KEYs, that you don't want to share publicly.\n */\n\nconst DESTINATION_CONTRACT = 'INSERT_CONTRACT_ADDRESS';\nconst EVM_RPC_NODE = 'INSERT_NETWORK_RPC_URL';\n\nhttpGET(\n  'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',\n  {},\n  (response, certificate) =&gt; {\n    if (\n      certificate ===\n      '4795062d13e1ed971c6b6e5699764681e4d090bad39a7ef367cc9cb705652384'\n    ) {\n      //const price = BigInt(JSON.parse(response)[\"price\"] * 10 ** 18); // if you need more precision, just keep in mind that JS stored bigger numbers in float format, rounding up/down your stuff.\n      const price = BigInt(JSON.parse(response)['price'] * 10 ** 6);\n      const int256AsBytes = '0x' + price.toString(16).padStart(64, '0');\n      const payload = '0x' + _STD_.chains.ethereum.abi.encode(int256AsBytes);\n      _STD_.chains.ethereum.fulfill(\n        EVM_RPC_NODE,\n        DESTINATION_CONTRACT,\n        payload,\n        {\n          methodSignature: 'setPrice(int256)',\n          gasLimit: '9000000',\n          maxFeePerGas: '2550000000',\n          maxPriorityFeePerGas: '2550000000',\n        },\n        (opHash) =&gt; {\n          console.log('Succeeded: ' + opHash);\n        },\n        (err) =&gt; {\n          console.log('Failed: ' + err);\n        }\n      );\n    }\n  },\n  (err) =&gt; {\n    console.log('Failed: ' + err);\n  }\n);\n</code></pre> <p>To configure your job, head to the Acurast console, then take the following steps:</p> <ol> <li>Click Create Jobs on the left-hand sidebar underneath the Consumer heading</li> <li>Select Moonbeam as the chain</li> <li>Select Moonbase as the environment. Remember that Tanssi's EVM-compatibility is derived from Moonbeam</li> <li>Select Price Feeds</li> <li>Paste in the code of your job script. You can copy and paste directly from the script of the sample BTC/USD price feed, just make sure to change the destination contract to one that you deployed on your network and the RPC node to your network's RPC URL, which can be found on the Tanssi dApp</li> <li>Optionally, you can test your code here. Any error messages will be readable in the browser's console</li> </ol> <p></p> <p>Continuing down the same setup page, take the following steps:</p> <ol> <li>Select Use Public Processors</li> <li>Select Interval</li> <li>Specify a Start time and End time</li> <li>Specify the Interval in minutes</li> <li>Specify a job duration and max start delay duration</li> <li>Select Number of processors to assign. The more processors you choose, the proportionally higher amount of cACU you'll need, which you can get from the faucet</li> <li>Select Max Reward paid to each processor for each job execution. You don't need to specify exactly <code>0.01</code> cACU - this amount was chosen as an example</li> <li>Review everything first, then Press Publish Job</li> </ol> <p></p> <p>On the following screen, you'll be able to monitor the status of your job. For more information about using Acurast to build and access price feeds on your Tanssi EVM-compatible network, be sure to check out the Acurast docs.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/oracles/band/","title":"Accessing Price Feeds with the Band Protocol","text":""},{"location":"builders/toolkit/integrations/oracles/band/#introduction","title":"Introduction","text":"<p>Band Protocol is a decentralized oracle network that provides reliable, secure, real-time data to smart contracts on various blockchain networks.</p> <p>The protocol is built on top of BandChain, a network designed to be compatible with most EVM-compatible chains, such as Tanssi-powered EVM networks, and blockchain development frameworks. The protocol aims to provide a solution that is:</p> <ul> <li>Decentralized, leveraging the computational power of a network of validators</li> <li>Flexible, supporting a wide range of data sources and formats, making integrations easy</li> <li>Scalable, designed to handle high volumes of data requests</li> <li>Affordable, allowing users to request data only when they need to and pay the associated fees</li> </ul> <p>Band protocol is currently deployed on many blockchains (Moonbeam, for example) across different ecosystems. To deploy the oracle onto your network, reach out to the Band Protocol team directly.</p> <p>This tutorial will walk through the steps to interact with price feeds using the Band protocol's oracle on the Tanssi demo EVM-compatible network. </p>"},{"location":"builders/toolkit/integrations/oracles/band/#setup-on-demo-evm-network","title":"Setup on the Tanssi Demo EVM Network","text":"<p>The Band Protocol oracle is already deployed on the Tanssi demo EVM network and configured to provide prices for the <code>ETH</code> and <code>DOT</code> tokens.</p> <p>The price feeds are pushed regularly to a smart contract that is accessible at the following address:</p> <pre><code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68\n</code></pre> <p>The smart can be interacted with using the interface:</p> IStdReference.sol <pre><code>// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.26;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    } \n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory);\n}\n</code></pre> <p>As seen above in the interface, there are two functions for fetching data:</p> getReferenceData(_base, _quote) \u2014 fetches the price for a given base/quote pair ParametersExample <ul> <li><code>_base</code> string memory - the token you want to get the price for</li> <li><code>_quote</code> string memory - the token (or <code>USD</code>) in which the price is expressed</li> </ul> <ul> <li><code>_base</code> - ETH</li> <li><code>_quote</code> - USD</li> </ul> getReferenceDataBulk(_bases, _quotes) \u2014 fetches prices for the given base/quote pairs simultaneously ParametersExample <ul> <li><code>_bases</code> string[] memory - the list of base tokens you want to get the prices for</li> <li><code>_quotes</code> string[] memory - the list of tokens (or <code>USD</code>) in which the prices are expressed</li> </ul> <ul> <li><code>_bases</code> - [\"ETH\", \"DOT\"]</li> <li><code>_quotes</code> - [\"USD\", \"USD\"]</li> </ul> <p>The response for both functions consists of the following data, grouped in one tuple in the case of <code>getReferenceData</code> and one list of tuples (one tuple per pair) in the case of <code>getReferenceDataBulk</code>:</p> <ul> <li><code>rate</code> uint256 - price for the given base/quote pair. Note that the result must be adjusted to consider eighteen decimal places</li> <li><code>lastUpdatedBase</code> uint256 - update timestamp for the <code>_base</code> parameter, expressed in UNIX epochs, which is the number of seconds that have passed since <code>01-01-1970 00:00:00 UT</code></li> <li><code>lastUpdatedQuote</code> uint256 - update timestamp for the <code>_quote</code> parameter, expressed in UNIX epochs, which is the number of seconds that have passed since <code>01-01-1970 00:00:00 UT</code></li> </ul>"},{"location":"builders/toolkit/integrations/oracles/band/#fetching-price-feeds-remix","title":"Fetching Price Feeds Using Remix","text":"<p>In this section, we'll use remix to fetch the price of the pair <code>ETH/USD</code>. </p> <p>First, make sure you have an EVM-compatible wallet connected to the demo EVM network. MetaMask is used as an example in this guide. Now, head to Remix, paste the <code>IStdReference</code> interface into a new file, and compile it.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Head to the Deploy &amp; Run Transactions tab</li> <li>Set the ENVIRONMENT to Injected Provider -- MetaMask</li> <li>Select the <code>IStdReference.sol</code> contract from the CONTRACT dropdown</li> <li>Enter the data feed contract address, which is <code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68</code> on the demo EVM network in the At Address field and click the At Address button</li> </ol> <p></p> <p>The contract should now be accessible. To interact with it, take the following steps:</p> <ol> <li>Expand the IStdReference contract to reveal the available functions</li> <li>Expand getReferenceData, and set the <code>_base</code> and <code>_quote</code> input parameters to <code>ETH</code> and <code>USD</code>, respectively</li> <li>Click Call</li> <li>The result will show three values: the price, update time for the <code>_base</code> parameter, and update time for the <code>_quote</code> parameter</li> </ol> <p></p> <p>Note that to obtain a readable price from the price feed, it's essential to adjust for the feed's decimal places, which are eighteen. For instance, the example above shows a value of <code>2361167929271984201806</code>, corresponding to an <code>ETH</code> price of <code>$2,361.167929271984201806</code> expressed in <code>USD</code>. Also, note that the update timestamp values are expressed in UNIX epoch time, expressed as the number of seconds that have passed since <code>01-01-1970 00:00:00 UT</code>. </p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/oracles/phala/","title":"Launching Price Feeds with Phala","text":""},{"location":"builders/toolkit/integrations/oracles/phala/#introduction","title":"Introduction","text":"<p>Phala Network is an off-chain compute network powered by Secure Enclaves that enables developers to build powerful smart contracts that connect to off-chain components called Phat Contracts. Phat Contracts are designed to enable functionality that surpasses the limitations of traditional smart contracts, such as storage, cost, and compute limitations while remaining trustless, verifiable, and permissionless. For more information about Phala's architecture, be sure to check out the Phala docs.</p> <p>Phala is not an oracle network itself; rather, Phala enables a variety of off-chain compute capabilities, such as a decentralized oracle network. Phala also provides a toolset called Phala Bricks that makes it easy to quickly launch these types of features without having to build them from scratch.</p> <p>This tutorial will walk through a demo of interacting with price feeds enabled by Phat contracts on the demo Tanssi-powered EVM-compatible network. Next, you'll learn how to deploy price feeds to your Tanssi EVM-compatible network. Please be advised that the steps shown in this tutorial are for demonstration purposes only - it's highly recommended that you contact the Phala team directly as they can assist you with launching price feeds on a network to ensure the integrity of the deployment process.</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#how-phala-enables-price-feeds","title":"How Phala Enables Price Feeds","text":"<p>Phala mirrors Chainlink Price Feeds from Ethereum MainNet. Chainlink Price Feeds have stood the test of time and have wide industry adoption. As a reminder, Chainlink Price Feeds don't rely on any single source of truth, rather, their pricing data is collected and aggregated from a variety of data sources gathered by a decentralized set of independent node operators. This helps to prevent manipulation and erratic pricing data.</p> <p>The core component of Phala's system design is the Secure Enclave, which processes the inputs it receives from the Phala blockchain, acting as an encrypted message queue, and guarantees secure and faithful execution, regardless of the presence of malicious workers. In this sense, the Phala blockchain requests a price feed update, which the Phala off-chain workers fetch from Ethereum MainNet, and return to the Phala blockchain.</p> <p>It's important to note that Phala isn't limited to replicating existing Oracles. You can create entirely new Oracles by sourcing off-chain data via Phat Contracts. In this Phat-EVM Oracle example, pricing data is sourced from the CoinGecko API. Price quote updates can then be constantly streamed from the Phat contract (push design), or the EVM smart contract can ask for a refreshed quote from the Phat contract (pull design).</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#fetch-price-data","title":"Fetch Price Data","text":"<p>There are several price feeds available on the demo EVM network that you can interact with. The price feeds enabled by Phat Contracts use the same interface as the Chainlink price feeds. The data lives in a series of smart contracts (one per price feed) and can be fetched with the aggregator interface:</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>As seen above in the interface, there are five functions for fetching data: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code>, and <code>latestRoundData</code>. For more information about the <code>AggregatorV3Interface.sol</code>, see the Chainlink API Reference.</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#supported-assets","title":"Supported Assets","text":"<p>Phala sources its price feed data by mirroring Chainlink's price feeds from Ethereum MainNet. Currently, there are data feed contracts for the demo EVM network for the following asset pairs:</p> Tanssi Demo EVM NetworkEthereum MainNet Asset &amp; Base Pair Aggregator Contract AAVE to USD 0x2E1640853bB2dD9f47831582665477865F9240DB BTC to USD 0x89BC5048d634859aef743fF2152363c0e83a6a49 CRV to USD 0xf38b25b79A72393Fca2Af88cf948D98c64726273 DAI to USD 0x1f56d8c7D72CE2210Ef340E00119CDac2b05449B ETH to USD 0x739d71fC66397a28B3A3b7d40eeB865CA05f0185 USDC to USD 0x4b8331Ce5Ae6cd33bE669c10Ded9AeBA774Bf252 USDT to USD 0x5018c16707500D2C89a0446C08f347A024f55AE3 Asset &amp; Base Pair Aggregator Contract AAVE to USD 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 BTC to USD 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c CRV to USD 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f DAI to USD 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 ETH to USD 0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419 USDC to USD 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6 USDT to USD 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D"},{"location":"builders/toolkit/integrations/oracles/phala/#interacting-with-price-feeds-demo-evm-network","title":"Interacting with Price Feeds on the Tanssi Demo EVM Network","text":"<p>Next, this tutorial will showcase interacting with the price feed contracts on the demo EVM network. These contracts are already deployed on the demo EVM network, so you can interact with them by accessing the aggregator contract corresponding to your desired asset.</p> <p>For a refresher on setting up Remix to interface with the demo EVM network, see the Deploy Smart Contracts with Remix guide. Secondly, make sure you have connected MetaMask to the demo EVM network.</p> <p>Paste the aggregator contract into a new file in Remix and compile it.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Head to the Deploy and Run Transactions tab</li> <li>Set the ENVIRONMENT to Injected Provider -- MetaMask</li> <li>Select the AggregatorV3Interface contract from the CONTRACT dropdown</li> <li>Enter the data feed contract address corresponding to <code>BTC to USD</code>, which is <code>0x89BC5048d634859aef743fF2152363c0e83a6a49</code> on the demo EVM network in the At Address field and click the At Address button</li> </ol> <p></p> <p>The aggregator contract should now be accessible. To interact with the aggregator contract, take the following steps:</p> <ol> <li>Expand the AggregatorV3Interface contract to reveal the available functions</li> <li>Click decimals to query how many digits after the decimal point are included in the returned price data</li> <li>Click description to verify the asset pair of the price feed</li> <li>Click latestRoundData to see the most recent price data for the asset pair. The price data for the pair is returned as the int256 answer</li> </ol> <p></p> <p>Note that to obtain a readable price, you must account for the decimals of the price feed, which is available with the <code>decimals()</code> method. So in this example, where the price feed returned a value of <code>5230364122303</code>, the decimal point will need to be moved eight places, which corresponds to a Bitcoin price of <code>$52,303.64</code> at the time of writing.</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#launching-price-feeds-on-an-evm-network","title":"Launching Price Feeds on an EVM Network","text":"<p>It's easy to launch price feeds on a Tanssi-powered EVM network! The following sections will walk through the process of launching a variety of price feeds. This process can be followed for quick Trial networks and dedicated networks on Dancelight. Please be advised that these instructions are for demonstration purposes only, and it's highly recommended that you contact the Phala Team for assistance in any production scenarios.</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#setup","title":"Setup","text":"<p>To get started, clone the Phala Mirrored Price Feed repo to a local directory. Then, run the following command:</p> <pre><code>cd mirrored-price-feed/ &amp;&amp; yarn install\n</code></pre> <p>Then, you'll need to configure your <code>.env</code> file. There's a convenient sample file in the repo that you can refer to. From the command line, run:  </p> <pre><code>cp env.example .env\n</code></pre> <p>Next, edit your <code>.env</code> to insert the private key of an account funded on your network, and the RPC URL of your network. If building on your own network, you can fund a dummy account from the Sudo account of your network. Your network's Sudo address and RPC URL are both accessible from your dashboard on the Tanssi DApp. You can leave the other fields in the <code>.env</code> blank. Your <code>.env</code> should resemble the below:</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=INSERT_YOUR_NETWORK_RPC_URL\nVERIFIER_URL=\nVERIFY_ADDRESS=\n</code></pre> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/integrations/oracles/phala/#configure-deployment-script","title":"Configure Deployment Script","text":"<p>Next, you'll need to edit the <code>OffchainAggregator.s.sol</code> file located in the scripts directory. <code>OffchainAggregator.sol</code> takes two parameters upon deployment, a <code>decimals</code> value, and a description of the price feed. The decimal value can remain unchanged at <code>8</code>, and the description should be changed to the price feed that you'd like to add to your network. In this case, <code>BTC / USD</code> is specified. Take care to copy the description exactly as shown, and remember that only specified assets shown in the Fetch Price Feed Data section are supported. If you specify an asset not supported by Phala, the price feed will not work correctly. Your <code>OffchainAggregator.s.sol</code> should resemble the following:</p> OffchainAggregator.s.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Script, console2} from \"forge-std/Script.sol\";\nimport {OffchainAggregator} from \"../src/OffchainAggregator.sol\";\n\ncontract OffchainAggregatorScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.startBroadcast();\n        OffchainAggregator aggregator = new OffchainAggregator(\n          8,\n          'BTC / USD'\n        );\n        console2.log(address(aggregator));\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>There are a few more changes that you need to make in <code>feeder.ts</code>, the file that maintains and updates your price feeds. You'll need to insert the details of your EVM network as follows:</p> <pre><code>const chain = defineChain({\n  id: INSERT_EVM_CHAIN_ID,\n  name: 'dancelight-evm-network',\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n});\n</code></pre> <p>You'll also see two arrays of contract addresses at the top of <code>feeder.ts</code>. The first array, named <code>mainnetFeedContracts</code> refers to Ethereum MainNet aggregator contract addresses, and you can leave that untouched. The second array, named <code>aggregatorContracts</code> still contains the addresses of the aggregator contracts on the demo EVM network. You should erase this array such that it is empty. Later in this guide, you'll return to it and add the contract addresses of your aggregator contracts specific to your Tanssi EVM network once they are deployed.</p> <p>Once you're finished editing, your <code>feeder.ts</code> file should resemble the below:</p> feeder.ts <pre><code>import {\n  createPublicClient,\n  http,\n  parseAbi,\n  createWalletClient,\n  defineChain,\n} from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst mainnetFeedContracts = {\n  'AAVE-USD': '0x547a514d5e3769680Ce22B2361c10Ea13619e8a9',\n  'CRV-USD': '0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f',\n  'ETH-USD': '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419',\n  'BTC-USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',\n  'DAI-USD': '0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9',\n  'USDT-USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D',\n  'USDC-USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',\n};\n\nconst aggregatorContracts = {};\n\nconst abi = parseAbi([\n  'function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n  'function transmit(uint80 _roundId, int192 _answer, uint64 _timestamp) external',\n  'function getRoundData(uint80 _roundId) public view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n]);\n\n// Insert your network details here\nconst chain = defineChain({\n  id: INSERT_EVM_CHAIN_ID,\n  name: 'dancelight-evm-network',\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n});\n\nconst publicClient = createPublicClient({\n  chain: mainnet,\n  transport: http(),\n});\n\nconst targetChainPublicClient = createPublicClient({\n  chain,\n  transport: http(),\n});\n\nasync function getLatestRoundData(pair: string) {\n  const address = mainnetFeedContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} mainnet feed contract did not exist.`);\n  }\n  const data = await publicClient.readContract({\n    address,\n    abi,\n    functionName: 'latestRoundData',\n  });\n  return data;\n}\n\nasync function getRoundDataFromAggregator(pair: string, roundId: number) {\n  const address = aggregatorContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const publicClient = createPublicClient({\n    chain,\n    transport: http(),\n  });\n  try {\n    const data = await publicClient.readContract({\n      address,\n      abi,\n      functionName: 'getRoundData',\n      args: [roundId],\n    });\n    return data;\n  } catch {}\n}\n\nasync function updateFeed(\n  walletClient: ReturnType&lt;createWalletClient&gt;,\n  pair: string\n) {\n  if (!aggregatorContracts[pair]) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const [roundId, answer, startedAt, updatedAt, answeredInRound] =\n    await getLatestRoundData(pair);\n  const aggregatorRoundId = Number(roundId &amp; BigInt('0xFFFFFFFFFFFFFFFF'));\n  const data = await getRoundDataFromAggregator(pair, aggregatorRoundId);\n  if (data[1] === answer) {\n    console.info(\n      `${pair} aggregatorRoundId ${aggregatorRoundId} data exists: ${data}`\n    );\n    return;\n  }\n\n  const hash = await walletClient.writeContract({\n    address: aggregatorContracts[pair],\n    abi,\n    functionName: 'transmit',\n    args: [roundId, answer, startedAt],\n  });\n  await targetChainPublicClient.waitForTransactionReceipt({ hash });\n  console.info(`${pair} updated, transmit tx hash: ${hash}`);\n}\n\nasync function main() {\n  if (!process.env.PRIVATE_KEY) {\n    throw new Error('missing process.env.PRIVATE_KEY');\n  }\n  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account,\n  });\n  for (const pair in aggregatorContracts) {\n    await updateFeed(walletClient, pair);\n  }\n}\n\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((err) =&gt; {\n    console.error(err);\n    process.exit(1);\n  });\n</code></pre>"},{"location":"builders/toolkit/integrations/oracles/phala/#build-and-test","title":"Build and Test","text":"<p>Run the following commands to build and test the project:</p> <pre><code>yarn build\n</code></pre> <pre><code>yarn test\n</code></pre> <p>If everything was successful, you'll see output like the following:</p> yarn build yarn run v1.22.10  forge build [.] compiling No files changed, compilation skipped \u2728 Done in 0.765. yarn test yarn run v1.22.10  forge test [.] compiling No files changed, compilation skipped Running 1 test for test/OffchainAggregator.t.sol:OffchainAggregatorTest [PASS] test_transmit() (gas: 60497) Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.96ms Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests) \u2728 Done in 0.765."},{"location":"builders/toolkit/integrations/oracles/phala/#deploy","title":"Deploy","text":"<p>To deploy your aggregator contract for the specified asset/base pair to your EVM network, use the following command:</p> <pre><code>yarn deploy\n</code></pre> <p>You'll get a transaction status as well as a contract address. Copy this contract address, as you'll need to refer to it in the following steps.</p> Waiting for receipts. [O0:00:18]\u3010######################################################\u3011 1/1 receipts CO.0s) #####7796 \u2705 [Success]Hash: Oxfb2f2dc6a35286c4595ce6e2bb64c93425b14c310a53f8224df0520666329fd \u2705 Contract Address: OxBc788db88C3344a24706754c1203a267790D626 Block: 4049 Paid: 0.002392252 ETH (598063 gas * 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json ========================== ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.002392252 ETH (598063 gas * avg 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/kevin/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json \u2728 Done in 30.765s."},{"location":"builders/toolkit/integrations/oracles/phala/#access-aggregator-contract","title":"Access Aggregator Contract","text":"<p>Next, this tutorial will demonstrate interacting with the newly deployed aggregator contract. Make sure that your MetaMask wallet is connected to your EVM network. You can add your network to your MetaMask by pressing Add to MetaMask on your dashboard on the Tanssi dApp.</p> <p>Paste the aggregator contract into a new file in Remix and compile it.</p> <p>Then, take the following steps:</p> <ol> <li>Head to the Deploy and Run Transactions tab</li> <li>Set the ENVIRONMENT to Injected Provider -- MetaMask and ensure that your MetaMask is on the network of your EVM network. You can verify the EVM chain ID in Remix if you are unsure</li> <li>Select the AggregatorV3Interface contract from the CONTRACT dropdown</li> <li>Enter the data feed contract address corresponding to your desired asset pair that was returned on the command line in the prior section in the At Address field and click the At Address button</li> </ol> <p></p> <p>Expand the AggregatorV3Interface contract to reveal the available functions and click latestRoundData to see the most recent price data for the asset pair. You should see <code>0</code> values for all. This is because your aggregator contract has been deployed, but it hasn't yet fetched price data. You can fix this with a quick price feed update.</p> <p></p>"},{"location":"builders/toolkit/integrations/oracles/phala/#Trigger","title":"Trigger Price Feed Update","text":"<p>In a prior section, you cleared out the array of aggregator contracts, but since you've now deployed an aggregator contract, you should specify it in the <code>feeder.ts</code> file so that you can manually trigger a refresh of the price data. Edit the <code>aggregatorContracts</code> array as follows:</p> <pre><code>const aggregatorContracts = {\n  'BTC-USD': 'INSERT_AGGREGATOR_CONTRACT_ADDRESS',\n}\n</code></pre> <p>Then, from the command line, run the following command:</p> <pre><code>npx tsx feeder.ts \n</code></pre> npx tsx feeder.ts BTC-USD updated, transmit tx hash: Oxf1797cfc5bd71e2d848b099cae197ff30dafb5f6947481a5ef6c69271e059a96 <p>Upon returning to Remix, click latestRoundData once more, and after waiting a moment, you should see an accurate value returned.</p> <p></p> <p>For more information about using Phala to access off-chain data, be sure to check out the Phala docs site.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/integrations/wallet-integrations/","title":"Wallets Integrations","text":"<p>Wallet integrations are essential for enabling user interactions with decentralized applications (dApps) by allowing users to securely manage their digital assets, sign transactions, and authenticate their identity. These integrations provide developers with the tools to build applications that can interact with users\u2019 wallets, facilitating blockchain transactions and interactions in a user-friendly manner.</p> <p>Main features of wallet integraions include:</p> <ul> <li>Multi-wallet support - out-of-the-box support for multiple wallet providers, reducing the need for custom integration</li> <li>Improved user experience - users can easily connect using their preferred wallet via an intuitive user interface</li> <li>Pre-built UI components - ready-to-use UI components for  wallet connection, account display, and balance management, streamlining development</li> <li>Customization - customize the wallet modal's appearance and behavior to match your branding and user interface design</li> </ul>"},{"location":"builders/toolkit/integrations/wallet-integrations/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/","title":"Integrate RainbowKit with a Tanssi Network","text":""},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#introduction","title":"Introduction","text":"<p>RainbowKit is a React library that adds wallet connection capabilities to a dApp. It supports numerous wallets and enables features such as switching connection chains, ENS address resolution, and balance display out-of-the-box. RainbowKit offers customization options for all EVM-compatible chains, making it possible to connect wallets to a network easily.</p> <p>RainbowKit bundles together multiple tools to simplify adding wallet connections to a dApp:</p> <ul> <li>Wagmi - a React Hooks library for interacting with Ethereum accounts, wallets, contracts, transactions, signing, ENS, and more</li> <li>viem - TypeScript interface which provides low-level stateless primitives for interacting with Ethereum</li> <li>WalletConnect - adds encrypted connections and enhanced UX experiences like connecting a mobile wallet by scanning a QR code</li> <li>TanStack Query - helps manage and update server state within the application</li> </ul> <p>This guide explains how to add RainbowKit to a dApp running on top of a Tanssi-powered network using the CLI, along with options for further customizing the integration.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#quick-start","title":"Quick Start","text":"<p>To start a new project, RainbowKit can scaffold a project using the CLI, combining RainbowKit and Wagmi in a Next.js application. Use your preferred package manager to run the CLI command and start the project:</p> npmpnpmyarn <pre><code>npm init @rainbow-me/rainbowkit@latest \n</code></pre> <pre><code>pnpm create @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>yarn create @rainbow-me/rainbowkit\n</code></pre> <p>The script will prompt for a project name, generate a new directory with the boilerplate starter code, and install all required dependencies. </p> npm init @rainbow-me/rainbowkit@latest   \ud83c\udf08 Welcome to RainbowKit!  rainbow-demo  \ud83d\ude80 Creating a new RainbowKit app in /Users/papermoon/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo  \ud83d\udce6 Installing dependencies with npm. This could take a while. \ud83d\udcda Initializing git repository  \ud83c\udf08 Done! Thanks for using RainbowKit \ud83d\ude4f  \ud83d\udc49 To get started, run cd rainbow-demo and then npm run dev <p>Navigate to the project directory, start the development server, and open <code>http://localhost:3000</code> to view the project locally:</p> npmpnpmyarn <pre><code>cd INSERT_PROJECT_NAME\nnpm run dev \n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\npnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\nyarn dev\n</code></pre> <p>The starting screen should look like this:</p> <p></p> <p>Open the project in a code editor and examine the directory and file structure, paying particular attention to the <code>wagmi.ts</code> file. This file allows configuration of the chains included in the list of networks that users can connect to via the dApp.</p> <p>Since the demo EVM network is a custom network on Tanssi, it cannot be imported directly from <code>wagmi/chains</code>. Instead, define the chain manually in the <code>wagmi.ts</code> file. For example, if the network uses the Tanssi demo network or another EVM-compatible chain, the necessary configurations must be added manually.</p> <p>Here is the configuration for the demo EVM network on Tanssi:</p> Demo EVM Network src/wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'TODO: get project id from...',\n  chains: [demoEVMChain], \n  ssr: true,\n});\n</code></pre> <p>To add support for the demo EVM network on Tanssi, update <code>wagmi.ts</code> as shown above. The following section explains how to generate the <code>projectId</code> value for WalletConnect.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#manual-setup","title":"Manual Setup","text":"<p>The following sections will walk you through the steps to integrate RainbowKit into an existing React application, such as installing and importing the necessary dependencies, configuring chain connections, and making the RainbowKit functionality available to users in the dApp. The setup will also include steps to specify which chain the Connect Wallet button should connect to by default and how to customize the RainbowKit theme to fit the project. This guide is based on the Tanssi demo EVM network, but can be adapted for your own Tanssi-powered EVM network by changing the RPC URL parameter.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before proceeding, ensure the following prerequisites are met:</p> <ul> <li> <p>A Tanssi EVM-compatible network</p> </li> <li> <p>An existing dApp built with React</p> </li> <li> <p>The RainbowKit examples repository includes templates for multiple React frameworks</p> </li> <li> <p>To follow this guide, visit Next.js and follow the Automatic Installation instructions, selecting Typescript and the App Router options during setup </p> </li> <li> <p>The wallet must support custom networks, as the Tanssi demo EVM network will be added manually</p> </li> <li> <p>A WalletConnect <code>projectId</code> - every dApp relying on WalletConnect is required to have an associated <code>projectId</code>. It is free to create an account,  and an ID can be generated instantly</p> <p>To obtain a WalletConnect <code>projectId</code>:</p> <ol> <li>Visit WalletConnect Cloud</li> <li>On the Projects page, select Create </li> <li>Add the project information (leaving the Homepage URL blank if the dApp is not deployed)</li> <li>Select the AppKit SDK</li> <li>Select a coding environment or platform (React is used in this guide)</li> <li>Locate the <code>projectId</code> in the left menu. or find it in the Get started code snippet of WalletConnect Quickstart</li> </ol> </li> </ul>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#getting-started","title":"Getting Started","text":"<p>Ensure that the project is in the root directory before proceeding, then install RainbowKit and its peer dependencies:</p> npmpnpmyarn <pre><code>npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <p>These packages provide the core functionality for wallet connections (RainbowKit), Ethereum interactions (wagmi and viem), and state management (TanStack Query).</p> <p>Next, start the development server to create a local dApp instance:</p> npmpnpmyarn <pre><code>npm run dev\n</code></pre> <pre><code>pnpm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <p>After starting the server, open <code>http://localhost:3000</code> to view the Next.js application in the browser.</p> <p>To test the RainbowKit connection, the MetaMask app can be used. Ensure that the Tanssi demo EVM network is connected in the MetaMask wallet.</p> <p>To add the Tanssi demo EVM network to MetaMask:</p> <ol> <li>Open MetaMask and go to Settings &gt; Networks &gt; Add Network.</li> <li>Input the following information:<ul> <li>Network Name: <code>Demo EVM Chain</code></li> <li>RPC URL: <code>https://services.tanssi-testnet.network/dancelight-2001/</code></li> <li>Chain ID: <code>5678</code></li> <li>Currency Symbol: <code>TANGO</code></li> <li>Block Explorer URL: <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> </ul> </li> </ol> <p>For detailed instructions on connecting MetaMask to the Tanssi demo EVM network, refer to the guide Connect MetaMask to your Tanssi EVM Network.</p> <p>After connecting, <code>the projectId</code> can be safely added to the application:</p> <ol> <li> <p>Create a <code>.env.local</code> file in the root directory of the project</p> <pre><code>touch .env.local\n</code></pre> </li> <li> <p>Add the <code>projectId</code> to this file</p> .env.local<pre><code>NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'\n</code></pre> </li> <li> <p>Locate the <code>.gitignore</code> file in this same directory and ensure <code>.env*.local</code> is included in the list of files to ignore. This will prevent committing the <code>projectId</code> to GitHub</p> </li> </ol> <p>The stored <code>projectId</code> will be required for configuring the <code>wagmi</code> settings in the upcoming section.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#connect-dapp-to-metamask","title":"Connect DApp to MetaMask","text":"<p>With the development environment set up and MetaMask configured for the Tanssi demo EVM network, the next step is to configure the dApp to connect with MetaMask's wallet using RainbowKit. This process involves the following key steps:</p> <ol> <li>Import RainbowKit, Wagmi, and TanStack Query</li> <li>Setup configuration for Wagmi</li> <li>Wrap the application with providers</li> <li>Add the connect button</li> </ol>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#import-rainbowkit-wagmi-and-tanstack-query","title":"Import RainbowKit, Wagmi, and TanStack Query","text":"<p>To proceed, ensure the project is in the root directory, and then create a new file called <code>wagmi.ts</code>. This file will contain the necessary imports and configurations to connect the dApp to wallets and interact with blockchains.</p> <p><pre><code>touch wagmi.ts\n</code></pre> In <code>wagmi.ts</code>, import the necessary libraries and define Demo EVM Chain as the supported chain:</p> wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',\n  chains: [demoEVMChain ], \n  ssr: true,\n});\n</code></pre>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#wrap-the-application-with-providers","title":"Wrap the Application with Providers","text":"<p>Next, create a file named <code>providers.tsx</code> to wrap the application with the necessary providers: <code>WagmiProvider</code>, and <code>QueryClientProvider</code>.</p> <pre><code>cd app &amp;&amp;\ntouch providers.tsx\n</code></pre> <p>Open <code>providers.tsx</code> add the following code to manage the providers</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { config } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider&gt;{children}&lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Now locate the <code>layout.tsx</code> file inside the <code>app</code> directory and modify the code to import <code>Providers</code> and wrap the application:</p> <p>layout.tsx<pre><code>import type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport '@rainbow-me/rainbowkit/styles.css';\nimport { Providers } from './providers';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'My Tanssi dApp',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &lt;html lang='en'&gt;\n      &lt;body&gt;\n        &lt;Providers&gt;{children}&lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre> This ensures that the app is wrapped with all necessary providers, including wagmi, and TanStack Query for state management.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#add-the-connect-button","title":"Add the Connect Button","text":"<p>RainbowKit offers a <code>ConnectButton</code> component, which renders the Connect and Disconnect buttons and UI elements for switching chains. This example imports the <code>ConnectButton</code> into the existing <code>page.tsx</code> file for simplicity, though it can also be added to an element like a Header or Navbar to appear at the top of every page. Update the code in <code>page.tsx</code> as follows:</p> page.tsx<pre><code>import { ConnectButton } from '@rainbow-me/rainbowkit';\n\nexport default function Home() {\n  return (\n    &lt;div className=\"flex h-screen items-center justify-center\"&gt;\n      &lt;ConnectButton /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Once the development server is running, the home page will display a Connect Wallet button. Clicking this button will open the RainbowKit modal, providing options to either connect an existing wallet or get a new one. Select MetaMask and follow the on-screen instructions to complete the connection process.</p> <p>The current configuration defaults to connecting to Demo EVM Chain and displays the current network, the native token balance, and the connected wallet address. If multiple networks are supported, selecting the arrow next to it will open the Switch Networks modal. This allows users to select another network and authorize the change.</p> <p>Once connected, users will see their TANGO token balance and wallet address.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#customize-rainbowkit","title":"Customize RainbowKit","text":"<p>RainbowKit simplifies the complexities of managing wallet connections while offering various options for customizing UI and functionality to fit the needs of a dApp. A full list of customization options can be found in the RainbowKit documentation. This section covers customizing the Connect Wallet button to connect initially to the Demo EVM Chain and render it in a custom color. </p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#set-custom-initial-chain","title":"Set Custom Initial Chain","text":"<p>By default, RainbowKit connects to the first chain supplied to Wagmi in the config. The order of chains listed in <code>wagmi.ts</code> will match the order displayed in the Switch Networks modal. To ensure that the Tanssi demo EVM network is always the default connection, simply move it to the top of the chain list. However, Relying solely on this default behavior might not be the best option.</p> <p>A better approach is to use the <code>initialChain</code> prop in the <code>RainbowKitProvider</code> component. This prop defines which chain the wallet will connect to initially when Connect Wallet is selected. To configure this, open the <code>providers.tsx</code> file and update the code by passing the <code>initialChain</code> prop with the custom Tanssi demo EVM network object defined earlier:</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider initialChain={demoEVMChain}&gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n\n}\n</code></pre> <p>By setting <code>initialChain={demoEVMChain}</code>, RainbowKit will attempt to connect to the Tanssi demo EVM network first whenever the Connect Wallet button is clicked.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#define-custom-theme-colors","title":"Define Custom Theme Colors","text":"<p>RainbowKit provides three built-in theme functions: <code>lightTheme</code>, <code>darkTheme</code>, and <code>midnightTheme</code>. These functions return a theme object that can be passed to the <code>RainbowKitProvider</code> prop <code>theme</code> to customize colors, border radius, font stack, and overlay blur. Update <code>providers.tsx</code> with the following code and ensure that <code>darkTheme</code> is added to the <code>@rainbow-me/rainbowkit</code> import statement for the changes to apply correctly. After customizing the initial chain and theme, the <code>providers.tsx</code> file will look like this:</p> <p>providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider\n          initialChain={demoEVMChain}\n          theme={darkTheme({\n            accentColor: '#189B9B', // Tanssi accent color\n            accentColorForeground: 'white',\n            borderRadius: 'medium',\n            fontStack: 'system',\n            overlayBlur: 'small'\n          })}\n        &gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> This configuration sets a dark theme with custom properties:</p> <ul> <li><code>accentColor</code> - the primary highlight color. In this example, Tanssi's accent color (#189B9B) is used, but it can be adjusted to match the branding of the dApp</li> <li><code>accentColorForeground</code> - the text color used on top of the accent color</li> <li><code>borderRadius</code> - controls the roundness of UI elements. Options are 'none', 'small', 'medium', or 'large'</li> <li><code>fontStack</code> - defines the fonts used. 'system' uses the default system fonts</li> <li><code>overlayBlur</code> - the blur effect applied to the background when modals are open</li> </ul> <p>Tip</p> <p>Experiment with different theme functions (<code>lightTheme</code>, <code>darkTheme</code>, <code>midnightTheme</code>) and color combinations to find the best match for the visual style of the dApp.</p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#handle-disconnections","title":"Handle Disconnections","text":"<p>To disconnect MetaMask from the dApp and reconnect for testing purposes, two methods can be used to complete this process.  </p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-dapp","title":"Disconnect from DApp","text":"<p>RainbowKit includes a Disconnect button out of the box. To open the modal, select the arrow next to the account number. Click the Disconnect button. At this point, the Connect Wallet option will reappear, and the account information will no longer be visible.</p> <p></p>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-metamask","title":"Disconnect from MetaMask","text":"<p>Some users prefer to disconnect from their wallet rather than use a button within a dApp. To use this method: </p> <ol> <li>Select the MetaMask extension in the browser to open the modal</li> <li>Select the three dots in the upper right corner of the MetaMask modal</li> <li>Select Connected sites</li> <li>Review the list of sites connected to the wallet</li> <li>Select Disconnect for each site that should be disconnected</li> </ol>"},{"location":"builders/toolkit/integrations/wallet-integrations/rainbowkit/#final-result","title":"Final Result","text":"<p>The Connect Wallet button on the home page should now render in the color specified for <code>accentColor</code> during theme customization. After selecting Connect Wallet, the same accent color will be displayed in the modal. MetaMask can be chosen, and signing the transaction will authorize the connection. The Tanssi demo EVM network will appear as the connected network, along with the TANGO token balance, without the need for manual network switching.</p> <p></p> <p>This guide includes only a few of the customization options available through RainbowKit. More information about the library's capabilities and options can be found in the RainbowKit Docs.</p> <p>The complete example code is available in the rainbow-manual-build-demo repository.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/","title":"Substrate Tools","text":"<p>When developing on Tanssi or any Tanssi-powered network, it's important to understand the underlying infrastructure that drives these chains. Built on top of the Substrate framework, these networks offer a robust and flexible foundation for building decentralized applications and services. Interacting with the Substrate API is key to engaging with the blockchain's core functionalities.</p> <p>Whether you're building decentralized applications (dApps), deploying smart contracts, or querying blockchain data, having the right tools and workflows to interact with this API will help you streamline development and ensure seamless integration with the network.</p> <p>Ready to dive in? Check out some of the following tools:</p> <ul> <li>Development environments - Chopsticks</li> <li>Libraries - Polkadot.js API and Sidecar REST API</li> <li>Wallets - SubWallet, and Talisman</li> </ul>"},{"location":"builders/toolkit/substrate-api/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/substrate-api/dev-env/","title":"Set Up Your Workspace","text":"<p>Building on Substrate involves working with a flexible, modular blockchain framework. Unlike traditional blockchains, Substrate\u2019s pallet-based architecture allows developers to create custom blockchains and integrate specialized features, which requires a development environment tailored to its complexities.</p> <p>In this section, you'll explore tools and techniques that can help you achieve the following with a Substrate development environment:</p> <ul> <li>Local environment setup - spin up a test environment without dealing with the complexity of configuring a Substrate node manually</li> <li>Network interaction - connect to and interact with Tanssi and Tanssi-powered networks</li> <li>Transaction simulation - test and simulate transactions on forked networks to evaluate changes before deploying</li> <li>Debugging - use debugging tools to troubleshoot and analyze transaction flow, state transitions, and more in a controlled environment</li> </ul>"},{"location":"builders/toolkit/substrate-api/dev-env/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/","title":"How to Use Chopsticks to Fork Your Network","text":""},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#introduction","title":"Introduction","text":"<p>Chopsticks provides a developer-friendly method of locally forking existing Substrate-based chains. It allows for the replaying of blocks to easily examine how transactions affect the state, the forking of multiple Tanssi networks for XCM testing, and more. This empowers developers to test and experiment with their custom blockchain configurations in a local development environment without deploying a live network.</p> <p>Overall, Chopsticks aims to simplify the process of building blockchain applications on Substrate and make it accessible to a wider range of developers.</p> <p>This article will cover using Chopsticks to fork and interact with the local copy of a Tanssi network.</p> <p>Note</p> <p>Chopsticks currently does not support calls done via the Ethereum JSON-RPC. Consequently, you can't fork your chain using Chopsticks and connect Metamask to it.</p>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#prerequisites","title":"Prerequisites","text":"<p>To follow along with this tutorial, you will need to clone the repository along with its submodules(Smoldot):</p> <pre><code>git clone --recurse-submodules https://github.com/AcalaNetwork/chopsticks.git\n</code></pre> <p>Then, get into the folder and install the dependencies using yarn:</p> <pre><code> cd chopsticks &amp;&amp; yarn\n</code></pre> <p>Finally, build the project:</p> <pre><code>yarn build-wasm\n</code></pre> <p>Now the development environment is ready to start testing and debugging Tanssi-deployed networks.</p>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#forking-demo-chain","title":"Forking a Demo EVM Network with Chopsticks","text":"<p>To fork a Tanssi network using Chopsticks, execute the command with only the RPC endpoint as a parameter:</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>This command will start a local clone of the chain as it was in the latest block.</p>      chopsticks % yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001         [01:59:42.628] INFO (xcm/59650): Frontier Container 2001 RPC listening on port 8000    <p>Typically, the configuration parameters are stored in a configuration file, as are the configurations in the repository's <code>configs</code> folder for the relay chains and parachains deployed in the Dotsama ecosystem. The following configuration file works for the demo EVM network, overriding the chain's sudo account with Alith's and additionally funding the account with tokens:</p> <pre><code>endpoint: wss://services.tanssi-testnet.network/dancelight-2001/\nmock-signature-host: true\nallow-unresolved-imports: true\ndb: ./tmp/db_ftrcon.sqlite\n\nimport-storage:\n  System:\n    Account:\n      - - - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\" # Alith\n        - providers: 1\n          sufficients: 1\n          consumers: 1\n          data:\n            free: \"100000000000000000000000\"\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n</code></pre> <p>The configuration file accepts all of the following parameters:</p> Option Description <code>genesis</code> The link to a parachain's raw genesis file to build the fork from, instead of an endpoint. <code>timestamp</code> Timestamp of the block to fork from. <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the Wasm to use as the parachain runtime instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>port</code> The port to expose an endpoint on. <code>build-block-mode</code> How blocks should be built in the fork: batch, manual, instant. <code>import-storage</code> A pre-defined JSON/YAML storage file path to override in the parachain's storage. <code>allow-unresolved-imports</code> Whether to allow Wasm unresolved imports when using a Wasm to build the parachain. <code>html</code> Include to generate storage diff preview between blocks. <code>mock-signature-host</code> Mock signature host so that any signature starts with <code>0xdeadbeef</code> and filled by <code>0xcd</code> is considered valid. <p>You can run the command <code>yarn start</code> to fork chains by specifying a local configuration file. Alternatively, the name or the GitHub URL can be used if the chain is listed in the repository's <code>configs</code> folder.</p> Local File PathChain NameGitHub URL <pre><code>yarn start --config=configs/polkadot.yml\n</code></pre> <pre><code>yarn start --config=polkadot\n</code></pre> <pre><code>yarn start \\\n--config=https://github.com/AcalaNetwork/chopsticks.git/master/configs/polkadot.yml\n</code></pre> <p>All settings (except <code>genesis</code> and <code>timestamp</code>) can also be passed as flags to configure the environment completely in the command line. For example, the following command forks the demo EVM network at block 100.</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/ --block 100\n</code></pre>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#interacting-with-a-fork","title":"Interacting with a Fork","text":"<p>When running a fork, by default, it will be accessible at:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>You can interact with the parachain via libraries such as Polkadot.js and its user interface, Polkadot.js Apps.</p> <p></p> <p>You should now be able to interact with the forked chain as you would with the real one.</p> <p>Note</p> <p>If your browser cannot connect to the WebSocket endpoint provided by Chopsticks, you might need to allow insecure connections for the Polkadot.js Apps URL. Another solution is to run the Docker version of Polkadot.js Apps.</p>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#replaying-blocks","title":"Replaying Blocks","text":"<p>If you would like to replay a block and retrieve its information to dissect the effects of an extrinsic, you can use the <code>yarn start run-block</code> command. Its following flags are:</p> Flag Description <code>endpoint</code> The endpoint of the parachain to fork. <code>block</code> Use to specify at which block hash or number to replay the fork. <code>wasm-override</code> Path of the Wasm to use as the parachain runtime instead of an endpoint's runtime. <code>db</code> Path to the name of the file that stores or will store the parachain's database. <code>config</code> Path or URL of the config file. <code>output-path=/[file_path]</code> Use to print out results to a JSON file instead of printing it out in the console. <code>html</code> Include to generate an HTML representation of the storage diff preview between blocks. <code>open</code> Whether to open the HTML representation. <p>For example, running the following command will re-run the demo EVM networks's block 1000 and write the storage diff and other data in a <code>chain-output.json</code> file:  </p> <pre><code>yarn start run-block  \\\n--endpoint wss://services.tanssi-testnet.network/dancelight-2001/  \\\n--output-path=./chain-output.json  \\\n--block 1000\n</code></pre>"},{"location":"builders/toolkit/substrate-api/dev-env/chopsticks/#websocket-commands","title":"WebSocket Commands","text":"<p>Chopstick's internal WebSocket server has special endpoints that allow the manipulation of the local Substrate chain.</p> <p>These are the methods that can be invoked and their parameters:</p> dev_newBlock (options) \u2014 Generates one or more new blocks ParametersExample <ul> <li>options - <code>{ \"to\": number, \"count\": number }</code> - a JSON object where <code>\"to\"</code> will create blocks up to a certain value, and <code>\"count\"</code> will increase by a certain number of blocks. Use only one entry at a time within the JSON object</li> </ul> <pre><code>import { WsProvider } from '@polkadot/api'\nconst ws = new WsProvider(`ws://localhost:8000`)\n// Creates five new blocks\nawait ws.send('dev_newBlock', [{ count: 5 }])\n</code></pre> dev_setStorage (values, blockHash) \u2014 Creates or overwrites the value of any storage ParametersExample <ul> <li>values - Object - a JSON object resembling the path to a storage value, similar to what you would retrieve via Polkadot.js  </li> <li>blockHash - String - optional, the block hash at which the storage value is changed  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Overwrites the sudo key\nawait ws.send('dev_setStorage', \n    [{\"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" }}]\n);\n</code></pre> dev_timeTravel (date) \u2014 Sets the timestamp of the block to the date value ParametersExample <ul> <li>date - Date - a string compatible with the JavaScript Date library that will change the timestamp at which the next blocks being created will be. All future blocks will be sequentially created after that point in time  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Sets the timestamp of the block to 15th August 2030\nawait ws.send('dev_timeTravel', [\"2030-08-15T00:00:00\"]);\n</code></pre> dev_setHead (hashOrNumber) \u2014 Sets the head of the blockchain to a specific hash or number ParametersExample <ul> <li>hashOrNumber - number | string - if found, the chain head will be set to the block with the block number or block hash of this value</li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Sets the head to block number 500\nawait ws.send('dev_setHead', [500]);\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/libraries/","title":"Libraries","text":"<p>As Tanssi and Tanssi-powered networks are built on Substrate, developers can utilize libraries tailored to the Substrate API to tap into the network\u2019s distinctive features.</p> <p>These libraries streamline the interaction with Substrate\u2019s modular architecture, helping you navigate the complexities of custom modules with ease and accelerate your development process.</p> <p>Some key capabilities of working with libraries include:</p> <ul> <li>Transaction management - build and sign transactions for submitting extrinsics (state changes) to the blockchain</li> <li>Interaction with custom modules - invoke a module's exposed functions, to query chain data or trigger state changes</li> <li>Account management - create cryptographic key pairs for signing transactions and manage on-chain account information such as balances</li> </ul>"},{"location":"builders/toolkit/substrate-api/libraries/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/","title":"Polkadot.js API Library","text":""},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#introduction","title":"Introduction","text":"<p>Polkadot.js is a collection of tools that allow you to interact with Substrate-based blockchains, such as your Tanssi-powered network! The Polkadot.js API is one component of Polkadot.js and is a library that allows application developers to query a network and interact with the node's Substrate interfaces using JavaScript, enabling you to read and write data to the network.</p> <p>You can use the Polkadot.js API to query on-chain data and send transactions from the Substrate side of your Tanssi network. You can query runtime constants, chain state, events, transaction (extrinsic) data, and more.</p> <p>Here you will find an overview of the available functionalities and some commonly used TypeScript code examples to get you started on interacting with your Tanssi network using the Polkadot.js API library.</p> <p>Editor\u2019s Note (2025 Update)</p> <p>Polkadot.js is the name of a developer toolset created for interacting with Substrate-based blockchains. While the name references Polkadot, the library itself is chain-agnostic and works with any Substrate-based network, including Tanssi.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#installing-polkadot.js-api-library","title":"Install Polkadot.js API","text":"<p>First, you need to install the Polkadot.js API library and the RLP library through a package manager such as <code>yarn</code>. Both dependencies are required to run the examples in this guide successfully.</p> <p>Install them in your project directory with the following command:</p> npmyarn <pre><code>npm i @polkadot/api\nnpm i @polkadot/util-rlp\n</code></pre> <pre><code>yarn add @polkadot/api\nyarn add @polkadot/util-rlp\n</code></pre> <p>The library also includes other core components, like Keyring for account management or some utilities that are used throughout this guide.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-an-API-provider-instance","title":"Create an API Provider Instance","text":"<p>To start interacting with your Tanssi network using the Polkadot.js API, you first need to create an instance of the Polkadot.js API. Create the <code>WsProvider</code> using the WebSocket endpoint of your Tanssi network.</p> <pre><code>// Import\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Code goes here\n\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration","title":"Metadata and Dynamic API Decoration","text":"<p>Before diving into the details of performing different tasks via the Polkadot.js API library, it's useful to understand some of the basic workings of the library.</p> <p>When the Polkadot.js API connects to a node, one of the first things it does is retrieve the metadata and decorate the API based on the metadata information. The metadata effectively provides data in the form of:</p> <pre><code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;\n</code></pre> <p>Where <code>&lt;type&gt;</code> can be either:</p> <ul> <li><code>query</code> - for endpoints to read all the state queries</li> <li><code>tx</code> - for endpoints related to transactions</li> <li><code>rpc</code> - for endpoints specific to RPC calls</li> <li><code>consts</code> - for endpoints specific to runtime constants</li> </ul> <p>And therefore, none of the information contained in the <code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> endpoints are hard-coded in the API. This allows the Polkadot.js API library to be modular and adapt to any Substrate-based chains with different modules, like your Tanssi network!</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#querying-for-information","title":"Query On-Chain Data","text":"<p>In this section, you will learn how to query for on-chain information using the Polkadot.js API library.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#state-queries","title":"Chain State Queries","text":"<p>This category of queries retrieves information related to the current state of the chain. These endpoints are generally of the form <code>api.query.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. You can see a list of all available endpoints by examining the <code>api.query</code> object, for example via:</p> <pre><code>console.log(api.query);\n</code></pre> <p>For example, assuming you've initialized the API, you can retrieve basic account information with the following snippet:</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Retrieve the last timestamp\nconst now = await api.query.timestamp.now();\n\n// Retrieve the account balance &amp; current nonce via the system module\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> View the complete script <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Retrieve the last timestamp via the timestamp module\n  const now = await api.query.timestamp.now();\n\n  // Retrieve the account balance &amp; current nonce via the system module\n  const { nonce, data: balance } = await api.query.system.account(addr);\n\n  console.log(\n    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#rpc-queries","title":"RPC Queries","text":"<p>The RPC calls provide the backbone for the transmission of data to and from the node. This means that all API endpoints such as <code>api.query</code>, <code>api.tx</code> or <code>api.derive</code> just wrap RPC calls, providing information in the encoded format as expected by the node. You can see a list of all available endpoints by examining the <code>api.rpc</code> object, for example, via:</p> <pre><code>console.log(api.rpc);\n</code></pre> <p>The <code>api.rpc</code> interface follows the a similar format to <code>api.query</code>. For instance, assuming you've initialized the API, you can get chain data and latest header with the following snippet:</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Retrieve the latest header\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// Log the information\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#query-subscriptions","title":"Query Subscriptions","text":"<p>The <code>rpc</code> API also provides endpoints for subscriptions. Assuming you've initialized the API, you can adapt the previous example to start using subscriptions to listen to new blocks.</p> <pre><code>// Retrieve the chain name\nconst chain = await api.rpc.system.chain();\n\n// Subscribe to the new headers\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n</code></pre> <p>The general pattern for <code>api.rpc.subscribe*</code> functions is to pass a callback into the subscription function, and this will be triggered on each new entry as they are imported.</p> <p>Other calls under <code>api.query.*</code> can be modified in a similar fashion to use subscription by providing a callback function, including calls that have parameters. Here is an example of how to subscribe to balance changes in an account:</p> <pre><code>// Define wallet address\nconst addr = 'INSERT_ADDRESS';\n\n// Subscribe to balance changes for a specified account\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n</code></pre> View the complete script <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#keyrings","title":"Create a Keyring for an Account","text":"<p>The Keyring object is used for maintaining key pairs, and the signing of any data, whether it's a transfer, a message, or a contract interaction.  </p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-a-keyring-instance","title":"Create a Keyring Instance","text":"<p>You can create an instance by just creating an instance of the Keyring class and specifying the default type of wallet address used. The default wallet type is <code>SR25519</code>, but for Tanssi EVM-compatible networks, the wallet type should be <code>ethereum</code>.</p> <pre><code>// Import the keyring as required\nimport Keyring from '@polkadot/keyring';\n\n// Create a keyring instance (ECDSA)\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\n\n// Create a keyring instance (SR25519)\nconst keyring = new Keyring({ type: 'sr25519' });\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#adding-accounts","title":"Add an Account to a Keyring","text":"<p>There are a number of ways to add an account to the keyring instance, including from the mnemonic phrase and the short-form private key. The following sample code will provide some examples:</p> From Mnemonic (ECDSA)From Private Key (ECDSA)From Mnemonic (SR25519) <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';\n\n// Import Ethereum account from mnemonic\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Define index of the derivation path and the derivation path\nconst index = 0;\nconst ethDerPath = \"m/44'/60'/0'/0/\" + index;\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst newPairEth = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${newPairEth.address}`);\n\n// Extract private key from mnemonic\nconst privateKey = u8aToHex(\n  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)\n    .secretKey\n);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from private key\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst otherPair = keyringECDSA.addFromUri(privateKeyInput);\nconsole.log(`Derived Address from provided Private Key: ${otherPair.address}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  await cryptoWaitReady();\n\n  // Import SR25519 account from mnemonic\n  const keyring = new Keyring({ type: 'sr25519' });\n  const mnemonic = 'INSERT_MNEMONIC';\n\n  // Extract SR25519 address from mnemonic\n  const newPair = keyring.addFromUri(`${mnemonic}`);\n  console.log(`Derived SR25519 Address from Mnemonic: ${newPair.address}`);\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#transactions","title":"Sending Transactions","text":"<p>Transaction endpoints are exposed on endpoints generally of the form <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>, where the module and method decorations are generated through metadata. These allow you to submit transactions for inclusion in blocks, be they transfers, interactions with pallets, or anything else Moonbeam supports. You can see a list of all available endpoints by examining the <code>api.tx</code> object, for example, via:</p> <pre><code>console.log(api.tx);\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#sending-basic-transactions","title":"Send a Basic Transaction","text":"<p>The Polkadot.js API library can be used to send transactions to the network. For example, assuming you've initialized the API and a keyring instance, you can use the following snippet to send a basic transaction (this code sample will also retrieve the encoded calldata of the transaction as well as the transaction hash after submitting):</p> <pre><code>// Initialize wallet key pairs\nconst alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n// Form the transaction\nconst tx = await api.tx.balances.transferAllowDeath(\n  'INSERT_BOBS_ADDRESS',\n  BigInt(INSERT_VALUE)\n);\n\n// Retrieve the encoded calldata of the transaction\nconst encodedCallData = tx.method.toHex()\nconsole.log(`Encoded calldata: ${encodedCallData}`);\n\n// Sign and send the transaction\nconst txHash = await tx.signAndSend(alice);\n\n// Show the transaction hash\nconsole.log(`Submitted with hash ${txHash}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Form the transaction\n  const tx = await api.tx.balances.transferAllowDeath(\n    'INSERT_BOBS_ADDRESS',\n    BigInt(INSERT_VALUE)\n  );\n\n  // Retrieve the encoded calldata of the transaction\n  const encodedCalldata = tx.method.toHex();\n  console.log(`Encoded calldata: ${encodedCalldata}`);\n\n  // Sign and send the transaction\n  const txHash = await tx.signAndSend(alice);\n\n  // Show the transaction hash\n  console.log(`Submitted with hash ${txHash}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre> <p>Note that the <code>signAndSend</code> function can also accept optional parameters, such as the <code>nonce</code>. For example, <code>signAndSend(alice, { nonce: aliceNonce })</code>. You can use the sample code from the State Queries section to retrieve the correct nonce, including transactions in the mempool.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#fees","title":"Fee Information","text":"<p>The transaction endpoint also offers a method to obtain weight information for a given <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>. To do so, you'll need to use the <code>paymentInfo</code> function after having built the entire transaction with the specific <code>module</code> and <code>method</code>.</p> <p>The <code>paymentInfo</code> function returns weight information in terms of <code>refTime</code> and <code>proofSize</code>, which can be used to determine the transaction fee. This is extremely helpful when crafting remote execution calls via XCM.</p> <p>For example, assuming you've initialized the API, the following snippet shows how you can get the weight info for a simple balance transfer between two accounts:</p> <pre><code>// Transaction to get weight information\nconst tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n// Get weight info\nconst { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\nconsole.log(`Transaction weight: ${weight}`);\nconsole.log(`Transaction fee: ${partialFee.toHuman()}`);\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Transaction to get weight information\n  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n  // Get weight info\n  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\n  console.log(`Transaction weight: ${weight}`);\n  console.log(`Transaction fee: ${partialFee.toHuman()}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#transaction-events","title":"Transaction Events","text":"<p>Any transaction will emit events; at a bare minimum, this will always be a <code>system.ExtrinsicSuccess</code> or <code>system.ExtrinsicFailed</code> event for the specific transaction. These provide the overall execution result for the transaction, that is, whether the execution has succeeded or failed.</p> <p>Depending on the transaction sent, some other events may be emitted; for instance, for a balance transfer event, this could include one or more <code>balance.Transfer</code> events.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#batching-transactions","title":"Batch Transactions","text":"<p>The Polkadot.js API allows transactions to be batch processed via the <code>api.tx.utility.batch</code> method. The batched transactions are processed sequentially from a single sender. The transaction fee can be estimated using the <code>paymentInfo</code> helper method.</p> <p>For example, assuming you've initialized the API, a keyring instance and added an account, the following example makes a couple of transfers in one transaction:</p> <pre><code>// Construct a list of transactions to batch\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n];\n\n// Estimate the fees as RuntimeDispatchInfo, using the signer (either\n// address or locked/unlocked keypair) \nconst info = await api.tx.utility\n  .batch(txs)\n  .paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construct the batch and send the transactions\nawait api.tx.utility\n  .batch(txs)\n  .signAndSend(alice, ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`included in ${status.asInBlock}`);\n\n      // Disconnect API here!\n    }\n  });\n</code></pre> View the complete script <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  await api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#sample-code-for-monitoring-native-token-transfers","title":"Sample Code for Monitoring Native Token Transfers","text":"<p>The following code samples will demonstrate how to listen to both types of native token transfers, sent via Substrate or Ethereum API, using either the Polkadot.js API library or Substrate API Sidecar. The following code snippets are for demo purposes only and should not be used without modification and further testing in a production environment.</p> <p>The following code snippet uses <code>subscribeFinalizedHeads</code> to subscribe to new finalized block headers, and loops through extrinsics fetched from the block, and retrieves the events of each extrinsic.</p> <p>Then, it checks if any event corresponds to a <code>balances.Transfer</code> event. If so, it will extract the <code>from</code>, <code>to</code>, <code>amount</code>, and the <code>tx hash</code> of the transfer and display it on the console. Note that the <code>amount</code> is shown in the smallest unit (Wei).  You can find all the available information about Polkadot.js and the Substrate JSON RPC in their official documentation site.</p> <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all Native token transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for any Tanssi-powered network\n\nconst main = async () =&gt; {\n  // Define the provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  // Create the provider\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        (await polkadotApi.at(lastFinalizedHeader.hash)).query.system.events(),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>In addition, you can find more sample code snippets related to more specific cases around balance transfers at this GitHub page.</p>"},{"location":"builders/toolkit/substrate-api/libraries/polkadot-js-api/#utilities","title":"Utility Functions","text":"<p>The Polkadot.js API also includes a number of utility libraries for computing commonly used cryptographic primitives and hash functions.</p> <p>The following example computes the deterministic transaction hash of a raw Ethereum legacy transaction by first computing its RLP (Recursive Length Prefix) encoding and then hashing the result with keccak256.</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Set the key type to string\ntype txType = {\n  [key: string]: any;\n};\n\n// Define the raw signed transaction\nconst txData: txType = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extract the values to an array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calculate the RLP encoded transaction\nvar encoded_tx = encode(txDataArray);\n\n// Hash the encoded transaction using keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>You can check the respective NPM repository page for a list of available methods in the <code>@polkadot/util-crypto</code> library and their descriptions.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/","title":"Using Substrate API Sidecar","text":""},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#introduction","title":"Introduction","text":"<p>Substrate API Sidecar allows applications to access blocks, account balance, and other information of Substrate-based blockchains through a REST API. This can be useful for exchanges, wallets or other types of applications that need to keep track of account balance and other state changes on a Tanssi-powered network. This page will describe how to install and run a Substrate API Sidecar for a Tanssi network, and the commonly used API endpoints.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#installing-and-running-substrate-api-sidecar","title":"Installing and Running Substrate API Sidecar","text":"<p>There are multiple ways of installing and running the Substrate API Sidecar. This guide will describe the steps for installing and running it locally through NPM. For running Substrate API Sidecar through Docker, or building and running it from source, please refer to the Substrate API Sidecar Github Repository.</p> <p>Note</p> <p>The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.</p> <p>Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their official documentation.</p> <p>Also, make sure you've initialized a <code>package.json</code> file for ES6 modules. You can initialize a default <code>package.json</code> file using npm by running the following command <code>npm init --yes</code>.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#installing-the-substrate-api-sidecar","title":"Installing the Substrate API Sidecar","text":"<p>To install the Substrate API Sidecar service locally in the current directory, run this from the command line:</p> <pre><code>npm install @substrate/api-sidecar@20.2.2\n</code></pre> <p>Note</p> <p>If the current folder does not already have a Node.js project structure, you need to manually created the <code>node_modules</code> directory by typing <code>mkdir node_modules</code>.</p> <p>Substrate API Sidecar v20.2.2 is the current stable version that has been tested to work with Tanssi networks. You can verify the installation was successful by typing from the installation directory root:</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#setting-up-the-substrate-api-sidecar","title":"Setting up the Substrate API Sidecar","text":"<p>In the terminal that Sidecar will run, export the environmental variable for the WS endpoint of the network you want to connect to. For example, the WSS endpoint of your Tanssi network. Some examples:</p> Tanssi MainNetDancelight TestNetDemo EVM NetworkYour Network <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=INSERT_NETWORK_WSS_ENDPOINT\n</code></pre> <p>After setting the environmental variable, you can use the <code>echo</code> command to check that the environmental variable has been set correctly, by typing:</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>And it should display the network endpoint you have just set.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#running-substrate-api-sidecar","title":"Running Substrate API Sidecar","text":"<p>With the network endpoint environmental variable set, and from the installation directory root, run:</p> <pre><code>node_modules/.bin/substrate-api-sidecar\n</code></pre> <p>If the installation and configuration are successful, you should see this output in the console:</p> <p></p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-sidecar-endpoints","title":"Substrate API Sidecar Endpoints","text":"<p>Some of the commonly used Substrate API Sidecar endpoints include:</p> <ul> <li>GET /blocks\u200b/head \u2014 Get the most recently finalized block. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block, which may not be finalized</li> <li>GET /blocks/head/header \u2014 Get the most recently finalized block header. The optional parameter <code>finalized</code> can be set to <code>false</code> to the get the newest known block header, which may not be finalized</li> <li>GET /blocks/{blockId} \u2014 Get a block by its height or hash</li> <li>GET /accounts/{accountId}/balance-info \u2014 Get balance information for an account</li> <li>GET /node/version \u2014 Get information about the Substrates node's implementation and versioning</li> <li>GET /runtime/metadata \u2014 Get the runtime metadata in decoded, JSON form</li> </ul> <p>For a full list of API endpoints available on Substrate API Sidecar, please refer to the official documentation.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#fields-mapping-in-block-json-object","title":"Field Mapping in Block JSON Object","text":"<p>Substrate API Sidecar returns blocks as a JSON object. Part of this JSON object is a nesting structure for individual extrinsics processed in a specific block. Each extrinsic calls a specific method of a given module. Generally speaking, for individual extrinsics, the nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"MODULE_NAME\"\n                |--method: \"METHOD_NAME\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"MODULE_NAME\"\n                        |--method: \"METHOD_EVENT_NAME\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Consequently, information from specific extrinsics (like balance transfers) can be extracted by knowing the module and method called by the extrinsic.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#evm-fields-mapping-in-block-json-object","title":"EVM Field Mapping in Block JSON Object","text":"<p>For Tanssi EVM networks, the information related to EVM execution of each Tanssi EVM network transaction can be identified by the <code>method</code> field under the current extrinsic object, where it is set to:</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre> <p>The nesting structure for EVM transactions is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>For example, for Substrate transactions, the \"Nonce\" and \"Signature\" fields are under:</p> <pre><code>extrinsics[extrinsic_number]\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-types-and-payload","title":"EVM Transaction Types and Payload","text":"<p>Tanssi EVM networks currently support three transaction standards: <code>legacy</code>, <code>eip1559</code>, and <code>eip2930</code>. These correspond to the <code>transaction type</code> field in the above JSON object diagram. For each transaction type, the transaction payload contains the following fields:</p> EIP1559LegacyEIP2930 <pre><code>    ...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <pre><code>    ...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n    ...\n</code></pre> <pre><code>    ...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <p>For more information on the new EIP1559 and EIP2930 transaction types and what each field means, please refer to the respective official Ethereum proposal specs.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-field-mappings","title":"Transaction Field Mappings","text":"<p>To obtain the EVM sender address, recipient address, and EVM hash of any EVM transaction type, check the <code>events</code> field under the current extrinsic object, and identify the event where the <code>method</code> field is set to:</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\"\n</code></pre> <p>The EVM field mappings are then summarized as the following:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> Max priority fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Max fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Nonce <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> Signature <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> EVM Field Block JSON Field Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> EVM hash <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> EVM execution status <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>For example, for EVM transactions, the \"Nonce\" and \"Signature\" fields are under:</p> <pre><code>extrinsics[extrinsic_number].args.transaction[transaction_type]\n</code></pre> <p>Consequently, this leaves the \"Nonce\" and \"Signature\" for the Substrate-level field <code>extrinsics[extrinsic_number]</code> to be <code>null</code>.</p> <p>A successfully executed EVM transaction will return either <code>succeed: \"Stopped\"</code> or <code>succeed: \"Returned\"</code> under the \"EVM Execution Status\" field.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#monitor-transfers","title":"Monitor Token Balance Transfers","text":"<p>The following code samples will demonstrate how to listen to both native token transfers, sent via Substrate or Ethereum API, and ERC-20 token transfers sent via the Ethereum API, using Substrate API Sidecar. Transfers via the Ethereum API are only applicable to Tanssi EVM networks.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#native-token-transfers","title":"Native Token Transfers","text":"<p>Both Tanssi non-EVM networks and EVM networks can perform Substrate-based native token balance transfers.</p> <p>The following code snippet uses the Axios HTTP client to query the Sidecar endpoint <code>/blocks/head</code> for the latest finalized block, and then decodes the block for the <code>from</code>, <code>to</code>, <code>value</code>, <code>tx hash</code> and <code>transaction status</code> of native token transfers at both the EVM and Substrate API level.</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum)\n// in a given Sidecar block, and extract the tx hash. It can be adapted for\n// any Tanssi-powered network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transfer')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#erc-20-token-transfers","title":"ERC-20 Token Transfers","text":"<p>Events emitted by smart contracts such as an ERC-20 token contract deployed on Tanssi EVM networks can be decoded from Sidecar block JSON objects. The nesting structure is as following:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce:\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |-- address\n                            |-- topics\n                                |--0\n                                |--1\n                                |--2\n                            |-- data\n            ...\n    ...\n</code></pre> <p>ERC-20 token transfers will emit the <code>Transfer</code> event which can be decoded as the following:</p> Tx Information Block JSON Field ERC-20 contract address <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> Event signature hash <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> Sender address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> Recipient address <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> Amount <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>Other events emitted by EVM smart contracts can be decoded in a similar fashion, but the content of the topics and data fields will change depending on the definition of the specific event.</p> <p>Note</p> <p>The amount transferred is given in accounting for decimals and in hexadecimal format.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-transaction-fees","title":"Substrate API Transaction Fees","text":"<p>For Tanssi non-EVM networks and EVM networks, all the information around fee data for transactions sent via the Substrate API can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The block endpoints will return data relevant to one or more blocks. You can read more about the block endpoints on the official Sidecar documentation.</p> <p>Read as a JSON object, for a given <code>pallet</code> (module) and <code>method</code>, the transaction fee is provided by an associated event with the following extructure:</p> <pre><code>{event_number}.method.pallet: \"transactionPayment\"\n{event_number}.method.method: \"TransactionFeePaid\"\n</code></pre> <p>The relevant nesting structure is as follows:</p> <pre><code>RESPONSE JSON Block Object:\n    ...\n    |--number\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n            |--signature\n            |--nonce\n            |--args\n            |--tip\n            |--hash\n            |--info\n            |--era\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"transactionPayment\"\n                        |--method: \"TransactionFeePaid\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n    ...\n</code></pre> <p>The object mappings are summarized as follows:</p> Tx Information Block JSON Field Fee paying account <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Total fees paid <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Tip <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>Then, the total transaction fee paid for this extrinsic is mapped to the following field of the block JSON object:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[1]\n</code></pre>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#ethereum-api-transaction-fees","title":"Ethereum API Transaction Fees","text":"<p>For Tanssi EVM networks, users could also send funds via the Ethereum API. To calculate the fee incurred on transactions sent via the Ethereum API, the following formula can be used:</p> EIP-1559LegacyEIP-2930 <pre><code>GasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ?\n            BaseFee + MaxPriorityFeePerGas : \n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>The following sections describe in more detail each of the components needed to calculate the transaction fee.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#base-fee","title":"Base Fee","text":"<p>The <code>BaseFee</code> is the minimum amount charged to send a transaction and is a value set by the network itself. It was introduced in EIP-1559. Tanssi EVM networks have a dynamic fee mechanism that aims to replicate the EIP-1559 fee market mechanism, where the base fee is adjusted based on block congestion.</p> <p>For example, for the Tanssi EVM network template the minimum gas price is <code>1 GWei</code>.</p> <p>The <code>BaseFee</code> can be directly retrieved from the <code>baseFeePerGas</code> storage found in the <code>baseFee</code> module (pallet), using the following endpoint:</p> <pre><code>GET /pallets/baseFee/storage/baseFeePerGas?at={blockId}\n</code></pre> <p>Read as a JSON object, the relevant nesting structure is as follows:</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>The relevant data will be stored in the <code>value</code> key of the JSON object. This value is a fixed point data type, hence the real value is found by dividing the <code>value</code> by the decimals.</p>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#gasprice-maxfeepergas-maxpriorityfeepergas","title":"GasPrice, MaxFeePerGas, and MaxPriorityFeePerGas","text":"<p>The <code>GasPrice</code> is used to specify the gas price of legacy transactions prior to EIP-1559. The <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> were both introduced in EIP-1559 alongside the <code>BaseFee</code>. The <code>MaxFeePerGas</code> defines the maximum fee permitted to be paid per unit of gas and is the sum of the <code>BaseFee</code> and the <code>MaxPriorityFeePerGas</code>. The <code>MaxPriorityFeePerGas</code> is the maximum priority fee configured by the sender of a transaction that is used to incentive the prioritization of a transaction in a block.</p> <p>Although Tanssi EVM networks are Ethereum-compatible, they are also Substrate-based chains at their core, and priorities work differently in Substrate than in Ethereum. In Substrate, transactions are not prioritized by gas price. To address this, Tanssi EVM networks uses a modified prioritization system that reprioritizes Substrate transactions using an Ethereum-first solution. A Substrate transaction still goes through the validity process, where it is assigned transaction tags, longevity, and a priority. The original priority is then overwritten with a new priority based on the transaction's fee per gas, which is derived from the transaction's tip and weight. If the transaction is an Ethereum transaction, the priority is set according to the priority fee.</p> <p>It's important to note that priority is not the sole component responsible for determining the order of transactions in a block. Other components, such as the longevity of a transaction, also play a role in the sorting process.</p> <p>The values of <code>GasPrice</code>, <code>MaxFeePerGas</code> and <code>MaxPriorityFeePerGas</code> for the applicable transaction types can be read from the block JSON object according to the structure described in the Sidecar API page.</p> <p>The data for an Ethereum transaction in a particular block can be extracted from the following block endpoint:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>The paths to the relevant values have also truncated and reproduced below:</p> EIP1559LegacyEIP2930 EVM Field Block JSON Field MaxFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> MaxPriorityFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> EVM Field Block JSON Field GasPrice <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code>"},{"location":"builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-weight","title":"Transaction Weight","text":"<p><code>TransactionWeight</code> is a Substrate mechanism used to measure the execution time a given transaction takes to be executed within a block. For all transactions types, <code>TransactionWeight</code> can be retrieved under the event of the relevant extrinsic where the <code>method</code> field is set to:</p> <pre><code>pallet: \"system\", method: \"ExtrinsicSuccess\"\n</code></pre> <p>And then <code>TransactionWeight</code> is mapped to the following field of the block JSON object:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight\n</code></pre>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/wallets/","title":"Wallets","text":"<p>Wallets are digital tools that allow users to securely store, manage, and transact with their digital assets. They store the cryptographic keys required to access digital assets and enable one to execute transactions on blockchain networks.</p> <p>The pages in this section provide an overview of getting started with various wallet providers. It covers how to create and import accounts, connect to your network, and begin interacting with it.</p>"},{"location":"builders/toolkit/substrate-api/wallets/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"builders/toolkit/substrate-api/wallets/ledger/","title":"Interacting with Substrate Tanssi Chains Using Ledger","text":""},{"location":"builders/toolkit/substrate-api/wallets/ledger/#introduction","title":"Introduction","text":"<p>Developers and users of Substrate networks, such as the Tanssi network or non-EVM Tanssi-powered appchains, have a variety of options when it comes to wallets. Regarding cold wallets, which store your private keys in a secure, offline environment, Ledger is one of the most popular options. Ledger provides full support for Substrate blockchains, such as the Tanssi network.</p> <p>Ledger devices are hardware wallets designed to store the private keys offline. They are used to verify and sign the transactions, but they still need a software layer to provide the UI that interacts with the networks, builds the transactions, and sends the signed transactions back to the network once the user has verified them.</p> <p>This guide takes you through all the necessary steps to use your Ledger device with Substrate Tanssi chains.</p>"},{"location":"builders/toolkit/substrate-api/wallets/ledger/#setting-up-ledger-device","title":"Setting Up Your Ledger Device","text":"<p>If you have a brand new Ledger device, refer to the official website for a guide on getting it started with the initial setup.</p> <p>Now, with your Ledger already initiated, install the Polkadot app taking the following steps:</p> <ol> <li>Open the Ledger Live App on your computer.</li> <li>Go to My Ledger.</li> <li>Connect and unlock the device.</li> </ol> <p>Finally, search for Polkadot (DOT) app in Ledger Live and install it on your device.</p> <p>Note</p> <p>Why Polkadot? Tanssi is built using Substrate, the same framework that powers Polkadot. As a result, even though Tanssi and Polkadot are separate networks, they share the same cryptographic signature schema. This means that the Ledger app named Polkadot (DOT) is fully compatible with Tanssi.</p> <p></p> <p>And that's it. Your device now has a Substrate account and is able to sign transactions on Tanssi and any non-EVM Tanssi-powered appchain.</p>"},{"location":"builders/toolkit/substrate-api/wallets/ledger/#adding-Ledger-hot-wallet","title":"Adding the Ledger to a Hot Wallet","text":"<p>As presented in the introduction, a Ledger hardware wallet provides secure, offline storage for private keys, allowing users to verify and sign transactions. However, by design, it can't interact with blockchains or dApps by itself, nor does it offer a UI for managing assets. To complement the device, a hot wallet is required. The user can choose any Substrate wallet, such as Talisman or SubWallet.</p> <p>For demonstration purposes, we'll show how to configure Talisman to work with your hardware wallet, but these steps are generally applicable to any other Substrate-enabled wallet that supports Ledger. To follow along with the steps, make sure you have Talisman installed in your browser, then open the extension and:</p> <ol> <li>Press the + icon (Add Account).</li> <li>Click on the Connect tab.</li> <li>Select Connect Ledger.</li> </ol> <p></p> <p>On the following screen, take the following steps:</p> <ol> <li>Select Polkadot. Other options will be presented below.</li> <li>Select Polkadot from the dropdown.</li> <li>Select Polkadot App from the box. You'll be prompted to connect your ledger and open the Polkadot app.</li> <li>Make sure that your ledger is successfully connected.</li> <li>Click on Continue.</li> </ol> <p></p> <p>In the next step, you will be presented with a list of derived accounts. Select the one you want to import, click Continue, and that's all! Your Talisman wallet can now sign transactions using your Ledger device.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/wallets/subwallet/","title":"Interacting with Your Tanssi Substrate Network Using SubWallet","text":""},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#introduction","title":"Introduction","text":"<p>Developers and users of Tanssi-powered Substrate networks have a variety of options when it comes to wallets. SubWallet is a comprehensive Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Substrate API, but you can check out a similar tutorial for interacting with SubWallet using the Ethereum API.</p> <p>The SubWallet wallet browser extension can be downloaded for all supported browsers, including Chrome, Brave, Firefox, and MS Edge. SubWallet also has a mobile app for both iOS and Android, but that is beyond the scope of this guide. A complete online asset dashboard is accessible at web.subwallet.app.</p> <p>This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to your Tanssi Substrate network, and sending funds.</p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#creating-your-first-substrate-account","title":"Creating Your First Substrate Account","text":"<p>First, download and install the SubWallet extension. Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. Click Create a new account to get started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet.</p> <p></p> <p>You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <p></p> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#importing-an-existing-substrate-account","title":"Importing an Existing Substrate Account","text":"<p>Of course, you can import an existing Substrate account into SubWallet. To get started, take the following steps:</p> <ol> <li>Press the All accounts button at the top</li> <li>Press the Import account icon</li> </ol> <p></p> <p>On the following screen, select the method by which you would like to import the existing account. If you're importing a Substrate account, you can choose from the seed phrase, Polkadot.js (JSON), or QR code options.</p> <p></p> <p>On the following screen, you'll be able to provide the relevant seed phrase, JSON file, or QR code, and you can begin using your new account right away.</p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-dancelight","title":"Connecting SubWallet to Dancelight","text":"<p>SubWallet comes pre-configured with support for Dancelight, the Tanssi TestNet, but it may not be enabled by default. You just need to head to the Manage networks page to toggle it on. Remember that Dancelight itself is the Substrate-based network that orchestrates and manages the launch of Tanssi-powered networks. To configure your SubWallet to work with Dancelight, press the More Options icon in the upper left corner. Then click Manage networks and take the following steps:</p> <ol> <li>Search for Dancelight</li> <li>Toggle the slider on to enable support for Dancelight</li> </ol> <p></p> <p>If you have a balance of Dancelight tokens, you'll see your account balance on the homepage of the SubWallet wallet. By default, all balances are hidden in SubWallet, but if you press the eye icon, you can toggle balance visibility.</p> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-your-substrate-network","title":"Connecting SubWallet to Your Substrate Network","text":"<p>To configure SubWallet for your Substrate network, press the More Options icon in the upper left corner. Then click Manage networks. Press the + icon. On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, Dancelight is used here; however, you can substitute these details with your own Tanssi network. To add your Tanssi network to SubWallet, take the following steps:</p> <ol> <li>Paste in the WSS URL of your Tanssi network. Other parameters like the parachain ID and token decimals may be auto-populated</li> <li>Provide a name for your Tanssi network</li> <li>Press Save</li> </ol> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#connecting-to-polkadotjs","title":"Connecting to Polkadot.js","text":"<p>To connect your Tanssi Substrate network to Polkadot.js Apps, first head to Polkadot.js Apps. In this example, Polkadot.js Apps is connected to Dancelight, but you can point Polkadot.js to your Tanssi network by clicking on the network dropdown and filling in the WSS endpoint of your Tanssi network in the custom endpoint field.</p> <p></p> <p>The SubWallet extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the SubWallet extension and click on the Connected icon next to your account at the top. To configure SubWallet to correctly interface with your Tanssi network on Polkadot.js Apps, you should take the following steps:</p> <ol> <li>Select the Substrate account(s) that you'd like to use with Polkadot.js Apps</li> <li>Press Connect</li> </ol> <p></p> <p>Your SubWallet wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your SubWallet account in the Accounts page of Polkadot.js Apps underneath the extension heading.</p>"},{"location":"builders/toolkit/substrate-api/wallets/subwallet/#sending-a-transaction","title":"Sending a Transaction","text":"<p>To send a transaction through the Substrate API, click Send next to your account on Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Input the send to address</li> <li>Enter the amount</li> <li>Press Make Transfer and confirm the transaction in the resulting Polkadot.js pop-up</li> <li>Press View Details if you'd like to inspect the contents of the transaction</li> <li>Press Approve to submit the transaction</li> </ol> <p></p> <p>You can also send a transaction through the Substrate API directly from the SubWallet extension without using Polkadot.js Apps. To do so, press the Send icon and take the following steps:</p> <ol> <li>Specify the asset to send</li> <li>Specify the destination chain (in this case, the same chain that you're sending from)</li> <li>Enter the destination address</li> <li>Enter the number of tokens to send</li> <li>Look over the transaction details, then press Transfer and subsequently Approve</li> </ol> <p></p> <p>This guide focused specifically on configuring SubWallet to work with your Tanssi Substrate network, but SubWallet is also a full-featured wallet for EVM accounts. Under the Ethereum API section, you'll find a similar guide for configuring SubWallet for use with your Tanssi EVM network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"builders/toolkit/substrate-api/wallets/talisman/","title":"Interacting with Tanssi or Your Substrate Appchain Using Talisman","text":""},{"location":"builders/toolkit/substrate-api/wallets/talisman/#introduction","title":"Introduction","text":"<p>Developers and users of Substrate networks, such as the Tanssi network or Tanssi-powered Substrate appchains, have a variety of options when it comes to wallets. Talisman is a great option, as it provides full native support for both Substrate and Ethereum accounts. This guide focuses on the Substrate API. You can also check out a similar guide for configuring Talisman for use with your Tanssi EVM network.</p> <p>Talisman is a Web3 wallet that natively supports Substrate and Ethereum accounts. The Talisman wallet browser extension is available on Google Chrome, Brave, and other Chromium-based browsers, as well as Firefox. An asset dashboard is accessible at app.talisman.xyz</p> <p>This guide takes you through all the necessary steps, from installing Talisman to setting up a wallet, connecting it to your Tanssi Substrate network, and sending funds.</p> <p>Editor\u2019s Note (2025 Update)</p> <p>This guide references options like Polkadot.js Apps or Polkadot account type because these are the labels used in common Substrate tools. Tanssi itself is independent \u2014 built with Substrate and aligned with Ethereum-backed security.</p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#setting-up-talisman","title":"Setting Up Talisman","text":"<p>First, download and install the Talisman extension. This guide will first cover creating a new wallet and later address importing an existing one. Review the terms and conditions, then press Get Started.</p> <p></p> <p>On the following screen, you'll be prompted to create a password to secure your new wallet.</p> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#create-a-substrate-account","title":"Create a Substrate Account","text":"<p>To create your first Substrate account in Talisman, take the following steps:</p> <ol> <li>Select the Polkadot option.</li> <li>Give your account a name.</li> <li>Press Create.</li> </ol> <p>Note</p> <p>Why Polkadot? Tanssi and Tanssi-powered appchains are built using Substrate, the same framework that powers Polkadot. As a result, even though Tanssi and Polkadot are separate networks, they share the same cryptographic signature schema.</p> <p></p> <p>After creating your first account, you'll be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.</p> <p></p> <p>Note</p> <p>You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.</p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#importing-an-existing-substrate-account","title":"Importing an Existing Substrate Account","text":"<p>Of course, you can import an existing Substrate account into Talisman. To do so, take the following steps:</p> <ol> <li>Press Add Account.</li> <li>Press Import.</li> <li>Select Import via Recovery Phrase.</li> </ol> <p></p> <p>On the following screen, take the following steps:</p> <ol> <li>Select the Polkadot account type.</li> <li>Provide a name for your account.</li> <li>Paste in your seed.</li> <li>Select which accounts you'd like to import.</li> <li>Press Import.</li> </ol> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-the-tanssi-network","title":"Connecting Talisman to the Tanssi Network","text":"<p>Talisman already comes pre-configured with support for Tanssi MainNet and Dancelight. To connect to Dancelight, you first need to make sure you have enabled support for TestNets on Talisman. To do so, take the following steps:</p> <ol> <li>Open the Talisman extension and click on the Talisman logo.</li> <li>Select Settings.</li> <li>Ensure that Enable testnets is checked.</li> </ol> <p></p> <p>If you have a balance of Tanssi MainNet or Dancelight tokens, you'll see your account balance on the homepage of the Talisman wallet. When you don't have a balance, the network is omitted from your list of assets.</p> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-your-substrate-network","title":"Connecting Talisman to Your Substrate Network","text":"<p>To configure Talisman for your Tanssi-powered Substrate network, open the Talisman extension and click on the More Options tab. Click on Settings &gt; Networks &amp; Tokens &gt; Manage Networks.</p> <ol> <li>Slide the network slider to Polkadot.</li> <li>Check the Enable testnets box.</li> <li>Press Add Network.</li> </ol> <p></p> <p>On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, Dancelight is used here, but you can substitute these details for your own Tanssi network. To add your Tanssi network to Talisman, take the following steps:</p> <ol> <li>Paste in the RPC URL of your Tanssi network. Other parameters will be auto-populated.</li> <li>Optionally, enter the block explorer URL of your Tanssi network, if applicable.</li> <li>Check the This is a testnet box if applicable.</li> <li>Press Add Network.</li> </ol> <p></p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs","title":"Connecting to Polkadot.js","text":"<p>To connect your Tanssi Substrate network to Polkadot.js Apps, first head to Polkadot.js Apps. In this example, Polkadot.js Apps is connected to Dancelight, but you can point Polkadot.js to your Tanssi network by clicking on the network dropdown and filling in the WSS endpoint of your Tanssi network in the custom endpoint field.</p> <p></p> <p>The Talisman extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the Talisman extension and click on the polkadot.js.org heading at the top. To configure Talisman to correctly interface with your Tanssi network on Polkadot.js Apps, you should take the following steps:</p> <ol> <li>Select the Substrate account(s) that you'd like to use with Polkadot.js Apps</li> <li>Press Connect 1. The value will change depending on the number of accounts you are connecting</li> </ol> <p></p> <p>Your Talisman wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your Talisman account in the Accounts page of Polkadot.js Apps underneath the extension heading.</p>"},{"location":"builders/toolkit/substrate-api/wallets/talisman/#sending-a-transaction","title":"Sending a Transaction","text":"<p>To send a transaction through the Substrate API, click Send next to your account on Polkadot.js Apps. Then, take the following steps:</p> <ol> <li>Input the send to address.</li> <li>Enter the amount.</li> <li>Press Make Transfer and confirm the transaction in the resulting Polkadot.js pop-up.</li> <li>Press View Details if you'd like to inspect the contents of the transaction.</li> <li>Press Approve to submit the transaction.</li> </ol> <p></p> <p>This guide focused specifically on configuring Talisman to work with your Tanssi Substrate network, but Talisman is also a full-featured wallet for EVM accounts. Under the Ethereum API section, you'll find a similar guide for configuring Talisman for use with your Tanssi EVM network.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"learn/","title":"Learn","text":"<p>Launching a decentralized network has traditionally been a challenging and time-consuming process, requiring expertise in infrastructure, security, and operational setup. Tanssi simplifies this journey by removing the complexities and making network deployment fast and accessible.</p> <p>This section explores the core elements that define Tanssi as a leading solution for network development. Whether you\u2019re starting your journey into decentralized networks or deepening your understanding of Tanssi\u2019s unique capabilities, these documents provide everything you need to understand how Tanssi sets a new standard for network infrastructure.</p>"},{"location":"learn/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/#jump-right-into-building","title":"Jump Right into BuildingBuild Your Network","text":"<p>Start your Tanssi journey here if you prefer to learn by doing.</p> <p>Learn how to design and customize your network with ready-to-use templates and tools tailored to your technical needs.</p>"},{"location":"learn/decentralized-networks/","title":"Tanssi-Powered Networks","text":"<p>Developing a blockchain that balances scalability, efficiency, and customization is a complex task. Tanssi-Powered Networks address these challenges through their integration into Tanssi's modular infrastructure. This section explains the networks' structure, functionality, and unique characteristics in the Tanssi ecosystem.</p> <p>Key features of Tanssi-powered networks:</p> <ul> <li>Runtime customization - adapt transaction types, execution logic, and state transitions to fit your network's specific requirements</li> <li>Transaction efficiency - optimize transaction fees for scalability and economic sustainability</li> <li>Scalability at its core - build networks that are prepared to grow alongside your ecosystem</li> </ul>"},{"location":"learn/decentralized-networks/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/decentralized-networks/included-templates/","title":"Network Templates Included in Tanssi","text":""},{"location":"learn/decentralized-networks/included-templates/#introduction","title":"Introduction","text":"<p>Building a new network from scratch can be a daunting prospect. Fortunately, thanks to the network development framework used by Tanssi and its modular-oriented architecture, developers can leverage some pre-bundled network templates that help them jumpstart the process and benefit in some aspects, such as:</p> <ul> <li> <p>Head Start - Tanssi network templates provide a starting point for your project, saving significant time and effort by providing a basic structure and a set of tested and ready-to-use functionalities. It allows developers to accelerate the construction of prototypes or minimum viable products (MVPs) and reduce the time to market</p> </li> <li> <p>Consistency - included Tanssi network templates follow established design patterns, coding standards, and best practices widely accepted among the developer community. They also provide a default set of architecture definitions to streamline blockchain development</p> </li> <li> <p>UX - Tanssi network templates cover the most demanded use cases, such as the EVM support for an Ethereum-compatible network</p> </li> <li> <p>Customizability - Tanssi network templates are a great starting point and are completely customizable. The functionalities and default configurations they include can be modified, replaced, or extended to meet the specific requirements of the use case</p> </li> <li> <p>Upgrades and Compatibility - Tanssi is built on top of an evolving framework, with new features, enhancements, and bug fixes being regularly introduced. The provided Tanssi network templates are kept up-to-date with these upgrades</p> </li> </ul>"},{"location":"learn/decentralized-networks/included-templates/#start-building","title":"Start Building a Network","text":"<p>To start building a decentralized network to deploy in Tanssi, some useful Tanssi network templates to kick-start the development process are provided in the official repository.</p> <p>The process is as simple as:</p> <ol> <li>Select one of the templates</li> <li>Add the specific logic to adapt the runtime to the requirements of the use case</li> <li>Deploy in Tanssi</li> </ol> <p></p> <p>The two included templates are the baseline network template and the baseline EVM template, which are presented in the following sections.</p>"},{"location":"learn/decentralized-networks/included-templates/#baseline-network-template","title":"Baseline Network Template","text":"<p>As presented in the Overview article, networks deployed through Tanssi are fully sovereign and customizable blockchains.</p> <p>As part of the Tanssi ecosystem, networks must include the essential components to implement the consensus mechanism and be able to interact and synchronize with the security provider of their choice (for example, Symbiotic on Ethereum). The baseline Tanssi network template includes all the necessary functionality for the sequencers logic, p2p, database, and synchronization layers between the network and the security provider, allowing developers to focus solely on customizing their product.</p> <p>This template also includes Tanssi's Author Noting module, which implements the logic for retrieving and validating the set of sequencers assigned to provide block production services to the network. It also includes logic that allows a sequencer to sign the block when the consensus mechanism determines that it is the sequencer's turn to produce the block (and thus be rewarded accordingly).</p> <p>The source code for this template is public and accessible on the Tanssi GitHub repository.</p>"},{"location":"learn/decentralized-networks/included-templates/#baseline-evm-template","title":"Baseline EVM (Ethereum Virtual Machine) Template","text":"<p>Extending the baseline Tanssi network template, this template provides not only Tanssi protocol support but also an EVM and full Ethereum compatibility.</p> <p>Leveraging a set EVM-specific modules, this template includes an Ethereum compatibility layer for networks to allow running unmodified Ethereum dApps.</p> <p>Using this template, networks support the deployment and running of any existing smart contract written in Solidity or Vyper with no changes. By emulating Ethereum block production and exposing the expected RPC interface, developers can also continue using the same tools like Metamask, Hardhat, Remix, Foundry, and many more out of the box, with no extra adapters.</p> <p>With this EVM template, developers can deploy a Moonbeam-like network in no time and add their custom logic and features specific to their use case.</p> <p>The source code for this template is public and accessible on the Tanssi GitHub repository.</p>"},{"location":"learn/decentralized-networks/overview/","title":"Tanssi Networks Overview","text":""},{"location":"learn/decentralized-networks/overview/#introduction","title":"Introduction","text":"<p>Networks deployed through Tanssi receive many benefits, like block production as a service, data retrievability as a service, and security through an external security providers such as Symbiotic on Ethereum.</p> <p>Also, because Tanssi-powered networks are based on a modular tech stack, they profit from unique advantages when customizations are required at a runtime level. This modularity allows developers to add functionality directly into the runtime or extend the capabilities of the EVM itself via precompiled contracts.</p> <p>For example, Tanssi provides a ready-to-use template that includes Frontier modules, enabling the effortless deployment of an EVM-compatible networks, similar to Moonbeam.</p> <p>This section covers the fundamentals of a Tanssi network, its architecture, its core modules and functionalities, and the transaction fee mechanism.</p>"},{"location":"learn/decentralized-networks/overview/#general-architecture","title":"General Architecture","text":"<p>As previously discussed, networks deployed through Tanssi are customizable blockchains that, among other features, receive block production as a service and inherit security with deterministic block finality within seconds from an external security provider. </p> <p>Tanssi-powered networks are fully decentralized networks. The decentralized nature of the networks considerably increases their resilience and fault tolerance since they don't rely on a single authority or entity to ensure their liveness, security, and performance but on trustless, decentralized protocols. For example, they receive block production services from a decentralized and incentivized set of sequencers managed by Tanssi.</p> <p>The Tanssi protocol runs with an external security provider, which has a set of operators (also called validators) with assets at stake, validating the transactions from the Tanssi network itself and all of the networks deployed through Tanssi. This way, all Tanssi-powered networks inherit the economic security derived from the Tanssi protocol and, indirectly, from the operators, which verify every transaction from every network. Tanssi networks don't need to run their own operator set nor bootstrap liquidity to secure their protocol.</p> <p>Tanssi networks also benefit from a set of Data-Preservers, with full archive nodes, ensuring the data availability layer availability. These data-preservers are incentivized through Tanssi's data retrieval services and also provide the RPC infrastructure for apps and users interacting with Tanssi networks.</p> <pre><code>flowchart TB\n    networks[\"Tanssi Networks&lt;br/&gt;(Decentralized Networks)\"]\n\n    subgraph tanssi[\"Tanssi Protocol\"]\n        direction TB\n        sequencers[\"Decentralized Sequencers Set\"]\n        node[\"Full Archive Nodes with&lt;br/&gt;RPC Services\"]\n    end\n\n    security[\"External Security Provider&lt;br/&gt;Operators\"]\n\n    networks&lt;--Block Production--&gt;tanssi\n    networks&lt;--Shared Security Model--&gt;tanssi\n    networks&lt;--Data Availability&lt;br/&gt;RPC endpoints--&gt;tanssi\n    tanssi&lt;--Transactions&lt;br/&gt;Validation and Finality--&gt;security</code></pre>"},{"location":"learn/decentralized-networks/overview/#network-transaction-flow","title":"Network Transaction Flow","text":"<p>A transaction submitted to a Tanssi-powered network follows a complex yet seamless path from submission to block inclusion and finalization. The network infrastructure, Tanssi, and the chosen security provider work together at different levels to ensure the process happens as quickly as possible, usually taking around 30 seconds. Remember that a transaction in a Tanssi network reaches deterministic finality. Consequently, once the transaction is final, it becomes irreversible and unchangeable, and the state transition resulting from executing that transaction is final.</p> <p>For example, a user initiates a transaction when interacting via an application deployed to a Tanssi-powered network. The RPC provider will share the transaction, which sits in the chain's transaction pool, with all network participants. A sequencer assigned by Tanssi to that network will eventually pick up the transaction and include it in the next network block.</p> <p>Then, the sequencer will share with the security provider's operators:</p> <ul> <li>The block itself with the state transitions</li> <li>The storage components in the Tanssi network database that the block is modifying</li> <li>The necessary hashes of the unaffected points in the Merkle tree of the storage</li> </ul> <p>These components constitute the proof of validity (PoV).</p> <p>Next, the PoV is verified by the security provider's operators. Note that the operators do not check that the Tanssi network storage is valid but that the state transitions that affect it are. A summary of that verification is then gossiped to other operators so they can verify it and include it in the next Tanssi block. Lastly, that Tanssi block with all the networks' verifications is finalized.</p> <p>The transaction flow process is summarized in the following diagram:</p> <p></p>"},{"location":"learn/decentralized-networks/runtime-features/","title":"Core Runtime Features","text":""},{"location":"learn/decentralized-networks/runtime-features/#introduction","title":"Introduction","text":"<p>Networks deployed through Tanssi have many benefits due to its unique architecture.</p> <p>Nevertheless, Tanssi-powered networks are also unique due to the framework (Substrate) they are built on top of, which provides some unique characteristics that developers can leverage to fine-tune specific behaviors in their runtime.</p> <p>This section covers some of these Tanssi network core runtime-specific features, including the different origins a transaction might have, the different types of transactions and how they are executed and included in a block, the special account known as SUDO, and the quite unique feature of Tanssi networks: the forkless runtime upgrades.</p>"},{"location":"learn/decentralized-networks/runtime-features/#origins","title":"Origins","text":"<p>Generally speaking, all calls in a Tanssi network have an origin. But what is an origin? Developers from the EVM realm might be familiar with the concept of msg.sender in EVM transactions. Origins are to Tanssi networks what msg.sender is to an EVM transaction, but supercharged with many extra functionalities.</p> <p>An origin defines where the call is coming from. In contrast to Ethereum-compatible chains, there can be many origins in Tanssi networks. For example, the msg.sender of an EVM transaction is known as a signed origin, which means that the call is a transaction that was signed by some on-chain account's private key. This allows the runtime to authenticate the source of the call and, for example, charge transaction fees to the associated account.</p> <p>However, origins can do much more than represent a private key/public key pair. Origins also have different privilege levels. For example, a signed origin can send a transaction that is dispatched by the private key/public key pair but should not be able to authorize a runtime upgrade.</p> <p>Some of the most common types of origins are:</p> <ul> <li>Root - a system-level origin with the highest privilege level. It can be thought of as a superuser of the chain, which can execute any call</li> <li>Signed - as mentioned before, the origin of a transaction signed by an on-chain account's private key, which includes the account identifier (address) as the signer</li> <li>None - a lack of origin. Used in specific actions that must be agreed upon at a runtime level. For example, you can program your runtime so that a transaction with none  origin can enact a pre-authorized runtime upgrade, which means that the transaction has no fee associated with it</li> <li>Custom - developers can also create custom origins for specific use cases. For example, Moonbeam's on-chain governance has specific origins for each type of governance vote, called tracks. Consequently, each track can be configured to only execute calls with specific privilege levels. One track is Root, whose origin is the Root origin mentioned before, and has a very restrictive configuration for votes to go through. But other tracks have much lower privilege levels to do some less critical network operations</li> </ul>"},{"location":"learn/decentralized-networks/runtime-features/#transaction-types","title":"Transaction Types","text":"<p>Tanssi networks have three main types of transactions:</p> <ul> <li>Signed Transactions - include a signed payload requesting to execute some runtime call. Generally, the signature is associated with a private key/public key pair. Depending on the runtime logic, the account associated with the signature pays a transaction fee</li> <li>Unsigned Transactions - include an unsigned payload requesting to execute some runtime call. Because these transactions are unsigned, there is no account associated with them. Consequently, runtimes need to define specific conditions that prevent network spam or replay attacks because there is no fee mechanism to prevent such malicious behaviors. One example of an unsigned transaction is executing pre-approved actions, like a runtime upgrade</li> <li>Inherent Transactions - an unsigned transaction that a sequencer inserts into a block when initializing its construction. These transactions are part of the block and are not stored in the transaction pool or shared among network participants. In addition, the data inserted through inherent transactions can skip runtime validation, and it might be up to operators to accept it. One example is the block timestamp. This is injected into the block by an inherent transaction, and operators can accept or reject the block based on whether the timestamp is within some acceptable range</li> </ul>"},{"location":"learn/decentralized-networks/runtime-features/#transaction-execution","title":"Transaction Execution","text":"<p>When a user or application submits a signed transaction to a Tanssi network, the transaction is validated at a full-node level using rules defined in the runtime, and then it is queued in a transaction pool. This ensures that only transactions that comply with certain chain-specific conditions are considered to be included in a block.</p> <p>Note</p> <p>The most common type of transaction is a signed transaction. Nevertheless, unsigned transactions are also validated before they are queued in the transaction pool.</p> <p>The valid transaction queue comprises two pools: ready and future. The ready queue contains all transactions that can be included in a new pending block. The future queue is for transactions that don't meet all the criteria to be included now but might become valid. For example, transactions with a future nonce. Invalid transactions are directly rejected.</p> <p>During the block-building process, a sequencer uses a priority system through a transaction orchestration module to order transactions for the next block, until the block reaches its maximum capacity. The block building and execution order has the following operations:</p> <ul> <li>Initializing a Block - known as <code>on_initialize</code>,  enables you to define runtime logic executed before any other transaction is accounted for. For example, inherent transactions, like the timestamp in the previous example, are commonly executed when initializing a block. Once the initialization logic is completed, the transaction orchestration module verifies the parent hash in the block header and the trie root to ensure the information is correct</li> <li>Transaction Execution - with the block already initialized, the transaction orchestration module executes each valid transaction according to its priority. The initial state is not cached before the execution, meaning that if one of the transactions fails mid-execution, any state changes committed up to that moment cannot be reverted, and the subsequent block will be invalid. Consequently, runtime logic should perform all necessary checks to ensure all valid transactions will succeed</li> <li>Finalizing a Block - after all queued valid transactions are executed or the block limit is reached, the orchestration module calls into each runtime module the <code>on_idle</code> and <code>on_finalize</code> functions. These two functions allow the definition of extra business logic that is automatically executed in the block finalization process. After the last <code>on_finalize</code> function is called, the orchestration module ensures that the block digest and storage root match what was calculated when the block was initialized</li> </ul>"},{"location":"learn/decentralized-networks/runtime-features/#forkless-upgrades","title":"Forkless Upgrades","text":"<p>Networks deployed through Tanssi have a thrilling feature: forkless upgrades. Forkless upgrades allow developers to change the state transition function that governs the chain without creating a network fork, as seen on Ethereum multiple times. Furthermore, if the Tanssi network is set up with an on-chain governance system, upgrades to the network can happen in a truly decentralized and trustless way.</p> <p>Forkless upgrades are made possible by storing the state transition function as a WebAssembly (Wasm) blob in both the Tanssi network itself and the Tanssi-powered network. When a new runtime is scheduled through a function call in the Tanssi-powered network, the Tanssi network validates this block, so it is notified and readies itself to validate incoming blocks using the most recent state transition function. Following a specified runtime upgrade delay period, a Tanssi sequencer on the Tanssi-powered network constructs a block that references a Tanssi network block, signaling to the Tanssi network that it can now apply the new runtime. Consequently, this new state transition function is utilized for that specific block. As all infrastructure participants at the network level employ the on-chain Wasm blob, every Tanssi network node operator can validate new blocks using the latest state transition function.</p> <p>A high-level summary of the runtime upgrade process is shown in the following diagram:</p> <p></p>"},{"location":"learn/decentralized-networks/runtime-features/#sudo-account","title":"SUDO Account","text":"<p>Tanssi networks may use a specific module called SUDO. This module introduces a new type of account, also named SUDO, that can execute transactions with the Root origin.</p> <p>Consequently, the SUDO account can perform any action that the runtime allows the Root origin to execute. This can include:</p> <ul> <li>Mint new native Tanssi network tokens</li> <li>Perform forkless runtime upgrades</li> <li>Send transactions impersonating other origin types. Therefore, SUDO can send transactions on behalf of other users without accessing their private key</li> </ul> <p>SUDO is recommended for TestNets as it allows them to swiftly make changes without the need to go through a lengthy on-chain governance process. It is good practice to have SUDO keys stored safely and grant access to SUDO calls via proxy accounts. Nevertheless, having SUDO enabled in a production environment can lead to undesired consequences.</p> <p>Understanding the centralization risks of having SUDO in a production environment is key.</p>"},{"location":"learn/decentralized-networks/tx-fees/","title":"Transaction Fees","text":""},{"location":"learn/decentralized-networks/tx-fees/#introduction","title":"Introduction","text":"<p>Tanssi-powered networks are built with a modular framework called Substrate. With this framework, you can build unique ways to handle transaction fees. For example, most transactions use a specific module called Transaction Payment. However, transaction fees on Tanssi-powered EVM-compatible networks can be charged at an EVM execution level, bypassing other fee-related modules.</p> <p>Under the hood, for execution time, instead of working with a gas-based mechanism, all Tanssi networks work with a weight-based mechanism. Weight refers to the time (in picoseconds) it takes to validate a block. Generally speaking, for both EVM and non-EVM Tanssi networks, all function calls have a weight associated with them, which sets limits on storage input/output and computation. For Tanssi EVM networks, there is a gas-to-weight mapping that fully complies with the expected gas requirements for Ethereum API-based tools.</p> <p>A transaction fee scheme is applied on top of the weight-based mechanism to ensure economic incentives are in line to limit the execution time, computation, and number of calls (database read/writes) to perform operations. Transaction fees are fundamental to preventing network spam, as they represent the cost of using the Tanssi network service. Consequently, a user interacting with the network through a specific function call will pay a transaction fee determined by a baseline fee algorithm.</p> <p>This page covers the fundamentals of transaction fees for Tanssi networks. It first covers the underlying transaction fee architecture and how it is adapted to a fully EIP-1559-compliant model for Tanssi EVM networks.</p>"},{"location":"learn/decentralized-networks/tx-fees/#baseline-fees","title":"Baseline Fees Calculation","text":"<p>Every action that alters the state of a Tanssi network incurs a transaction fee. This fee is essential for the network's operation, covering the computational resources required to process transactions, similar to the gas and gas price parameters in EVM-compatible chains like Ethereum.</p> <p>Tanssi networks modular framework use a weight-based fee calculation mechanism to determine transaction fees. This approach considers various factors, including computational resources and storage operations (inputs/outputs), to reflect the true cost of transactions accurately. By accounting for these elements, the network ensures fair and efficient resource allocation.</p> <p>Furthermore, Tanssi networks modularity ensures that EVM-compatible networks support legacy and EIP-1559 compatible transaction pricing mechanisms, ensuring full compatibility with development environments commonly used in Ethereum.</p> <p>This section outlines all the different concepts associated with transaction fees for Tanssi networks.</p>"},{"location":"learn/decentralized-networks/tx-fees/#baseline-weight","title":"Weight","text":"<p>Broadly speaking, weight refers to the execution time it takes to validate a block, measured in picoseconds. Weight is divided into two separate variables:</p> <ul> <li><code>refTime</code> - corresponds to the weight associated with computation time and database reads/writes</li> <li><code>proofSize</code> - corresponds to the weight associated with the size of the Proof-Of-Validity (or PoV for short). The PoV is associated with the relevant state of a transaction, and it is what the Tanssi network sequencer shares with the security provider operators to get a block validated and finalized as part of the network transaction flow</li> </ul> <p>To find the weights for all function calls, they are benchmarked in a system with reference hardware, and the approximate values of <code>refTime</code> and <code>proofSize</code> are set. This process is repeated for all function calls that consume blockspace and affect the PoV.</p> <p>For transactions in which the fees are handled by the transaction payment module, all weight-based parameters are then passed through a weight to fee algorithm that converts all to a final value, deducted from the sender's account when executing the function call. The algorithm can be customized, but Tanssi networks have a constant value set.</p> <p>For EVM transactions, gas is converted to weight through a gas-to-weight algorithm so that all EVM calls can be mapped to block execution time. Nevertheless, fees are handled at an EVM execution level.</p>"},{"location":"learn/decentralized-networks/tx-fees/#baseline-transaction-fees","title":"Baseline Transaction Fees","text":"<p>With all function calls benchmarked, the transaction fee for each specific call can be obtained. Transaction fees are typically comprised of the following elements:</p> <ul> <li><code>BaseFee</code> - baseline cost for a transaction to be included. It accounts for the transaction inclusion overhead, like signature verification. The fee is defined by two separate parameters:<ul> <li><code>ExtrinsicBaseWeight</code> - a constant value that represents the weight of the transaction inclusion overhead</li> <li><code>WeightToFee</code> - a polynomial function that converts weight to fee</li> </ul> </li> <li><code>WeightFee</code> - fee defined by two separate parameters:<ul> <li><code>BenchmarkedWeight</code> - weight that accounts for the complexity (execution time) of a specific call</li> <li><code>CongestionMultiplier</code> - a function that converts weight to fee and can be adjusted to account for the congestion of the network (weight consumed in the previous block). The default strategy for Tanssi networks is <code>SlowAdjustingFeeUpdate</code>, which adjusts this multiplier slowly over time following the network load</li> </ul> </li> <li><code>LengthFee</code> - a fee correlated to the length in bytes of the function call. The fee is defined by two separate parameters:<ul> <li><code>ByteLengthFunctionCall</code> - length in bytes of the call being executed</li> <li><code>LengthToFee</code> - a function that defines the per-byte fee algorithm. For Tanssi networks, this is a constant value</li> </ul> </li> <li><code>Tip</code> - an optional value that increases the overall fee, increasing the priority of the transaction by incentivizing sequencers to include it in the next block</li> </ul> <p>Therefore, in general terms, the transaction fee can be calculated with the following equation:</p> <pre><code>BaseFee = ExtrinsicBaseWeight * WeightToFee\nWeightFee = BenchmarkedWeight  * CongestionMultiplier\nLengthFee = ByteLengthFunctionCall * LengthToFee\n\nInclusionFee = BaseFee + WeightFee + LengthFee\nFinalFee = InclusionFee + Tip\n</code></pre> <p>All non-EVM function calls available to developers use these baseline calculations for transaction fees. Tanssi EVM networks have an extra layer to translate this fee scheme into an Ethereum-like scheme from an Ethereum JSON-RPC and EVM perspective. </p>"},{"location":"learn/decentralized-networks/tx-fees/#evm-transaction-fees","title":"EVM Transaction Fees","text":"<p>Tanssi offers templates for full Tanssi EVM-compatible networks. Such networks provide an Ethereum-like environment for developers, where they can use Eth-specific libraries like Ethers.js, Hardhat, and Foundry.</p> <p>In addition, all Tanssi EVM-compatible networks have an EIP-1559 compatible transaction pricing mechanism for EVM transactions. But they support both commonly used EVM transaction types:</p> <ul> <li>Type 0 (Legacy) - the transaction fee is calculated through a single gas price value that is included in the signed transaction blob. Because Tanssi EVM-compatible networks have a dynamic pricing mechanism, gas price must be greater than the current block's <code>baseFee</code> for a transaction to be considered valid</li> <li>Type 2 (EIP-1559) - the transaction fee is calculated with a combination of the <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code> from the signed transaction blob, and the network's <code>baseFee</code> dynamically changes based on block congestion</li> </ul> <p>Independently of the transaction type, the outcome of all EVM transactions is that there is an associated cost in native tokens that the network must charge. </p> <p>By default, Tanssi EVM-compatible networks are configured with the following parameters:</p> <ul> <li>Minimum BaseFee - the minimum gas price of the network in case there are no transactions for long periods. The default value is set to 1 GWei</li> <li>Block Fulness Target (Elasticity) - the target gas used in a block so that the <code>baseFee</code> remains the same. EIP-1559 defines this value as a constant set to 2, meaning that the target usage is 50% of the block gas limit. All Tanssi EVM-compatible networks are set with the same target</li> <li>Maximum BaseFee Increase - the maximum amount the <code>baseFee</code> can increase or decrease, in percent points, based on the previous block target usage. EIP-1559 defines this value as a constant set to 12.5%. Consequently, if the block is full/empty, the <code>baseFee</code> will increase/decrease by 12.5%, and any intermediate values are linearly adjusted. Developers can configure this value for Tanssi EVM-compatible networks, but the default value is 12.5%</li> </ul> <p>Note</p> <p>One key difference in Tanssi EVM-compatible networks EIP-1559 implementation is that the transaction fees are calculated using the previous block <code>baseFee</code>.</p> <p>The EVM transaction fee cost associated with all Tanssi EVM-compatible networks is captured at an EVM execution level. Nevertheless, EVM transactions do take block execution time. Therefore a gas-to-weight algorithm is required to account for the weight consumed by a specific call relative to the gas it is consuming.</p> <p>Ultimately, the transaction fee and weight associated to an EVM call in a Tanssi EVM-compatible network can be calculated with the following formula:</p> EIP-1559Legacy <pre><code>Gas Price = baseFee + maxPriorityFeePerGas &lt; maxFeePerGas ? \n           baseFee + maxPriorityFeePerGas : \n           maxFeePerGas;\nTransaction Fee = Gas Price * Gas Used\nTransaction Weight = Gas Used * GasToWeight\n</code></pre> <pre><code>Transaction Fee = GasPrice * GasUsed\nTransaction Weight = GasUsed * GasToWeight\n</code></pre> <p><code>GasToWeight</code> is a constant value set to <code>25000</code>.</p>"},{"location":"learn/framework/","title":"Network Development Framework","text":"<p>Building a blockchain from scratch is an intricate process that demands deep knowledge of consensus algorithms, cryptography, data structures, governance, and more. Tanssi simplifies this process by leveraging Substrate, a powerful blockchain development framework that provides all the essential components for creating customized blockchains.</p> <p>With Substrate\u2019s modular architecture, you can modify runtime characteristics, integrate pre-built modules, or develop new ones based on your network\u2019s specific needs. Tanssi provides the foundation you need to bring your blockchain vision to life.</p> <p>Key features of the framework:</p> <ul> <li>Substrate core architecture - divided into the core client, which manages external communications and internal responsibilities like storage, and the runtime, which executes transactions and manages state transitions with customizable logic</li> <li>End-user simplicity - the internal workings of the framework are abstracted for end-users, ensuring seamless interaction through dApps or via RPC endpoints, such as those used by wallets</li> <li>Modular system design - incorporate pre-built modules or create custom ones to meet specific needs</li> <li>Developer-centric flexibility - focus on runtime characteristics and use case specifics, allowing you to create a blockchain tailored to your vision without unnecessary complexity</li> </ul>"},{"location":"learn/framework/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/framework/architecture/","title":"Framework Architecture","text":""},{"location":"learn/framework/architecture/#introduction","title":"Introduction","text":"<p>Substrate is a software development kit (SDK) for building blockchains. This framework is the foundation and engine powering many projects across the Web3 ecosystem, including the Tanssi network itself and the networks deployed through Tanssi.</p> <p>Written in the Rust language and designed with a modular architecture, Substrate is extremely performant, flexible, and highly customizable, making it the best choice for developing blockchains.</p> <p>In this article, the architecture of a Substrate node is covered.</p>"},{"location":"learn/framework/architecture/#architecture","title":"Architecture","text":"<p>The Substrate framework is designed for maximum customizability, providing a fully functional implementation for every important internal aspect of a blockchain. It allows developers to focus on the specifics of the use case and the runtime characteristics, and it provides the ability to change any of the default features (should the need arise).</p> <p>The architecture of a Substrate node contains two main components:</p> <ul> <li>Core Client - handles the communication with the outer world (other nodes, dApps, end users, among others), and many other internal responsibilities, such as storage and communication</li> <li>Runtime - implements the custom logic of the Tanssi network, executes transactions, and manages the state transitions</li> </ul> <p>From the end-user perspective, all the interaction with the Tanssi network is usually made through dApps or directly via the node RPC endpoints, for example, using a wallet. When a user triggers a request to fetch data or sends transactions to a node, the core client is responsible for responding or queuing the transactions until execution in the runtime. Still, all these internal aspects of the node design are kept transparent to the user.</p> <p></p>"},{"location":"learn/framework/architecture/#core-client","title":"The Core Client","text":"<p>The core client comprises components responsible for everything in the operation of a node in the network except for what happens in the runtime.</p> <p>Some of the main components are:</p> <ul> <li>Networking - this component handles the communication with the peers in the network (synchronizing blocks, propagating transactions, and so on) and exposes the endpoints that allow dApps to integrate and interact with the Tanssi network</li> <li>Storage - this component manages the state storage of the Tanssi network in a highly efficient key-value database</li> <li>Consensus - this component ensures that all the participants in the network agree on the state of the blockchain, validating transactions, state transitions, and the resulting blocks</li> </ul> <p>The default configuration of a Substrate node and the built-in implementations of the components are usually the best choice for most use cases. Still, teams are welcome to innovate and change or replace any piece of the node or even write a completely different implementation of the core client, such as Kagome (C++ implementation) and Gossamer (Golang implementation).</p>"},{"location":"learn/framework/architecture/#runtime","title":"The Runtime","text":"<p>The runtime plays a crucial role in the operation of the Tanssi network. It contains the core logic and rules to meet the requirements of the use case the developers are building, and, therefore, it is responsible for validating the transactions and executing the state transitions.</p> <p>Being the core element in a Tanssi network, designing the Substrate architecture an important decision has been made regarding the format for the runtime: it is compiled to WebAssembly (Wasm) byte code.</p> <p>The Wasm format offers many advantages to a deployed Tanssi network, including:</p> <ul> <li>Portability - the Wasm format is platform-independent, meaning that the same binary can be distributed and run on different nodes using different hardware architectures and operating systems</li> <li>Deterministic Execution - the Wasm format ensures deterministic execution of code, which means that the same input will always produce the same output. Determinacy is a critical aspect in blockchains to obtain the same state transitions across every node in the network and reach a consensus</li> <li>Forkless Upgradeability - Substrate stores the runtime Wasm blob on-chain, meaning that the runtime itself becomes part of the state. This design allows upgrading the runtime logic in a forkless way using a transaction</li> </ul> <p>Besides the format, internally, a Substrate runtime is built by composing different modules, either provided and ready-to-use by Substrate or custom-made. Each one of these modules define, among other things, the transactions they expose, the logic behind them, what needs to be stored in the chain state, the best format to do it, and how they cooperate with other modules composing functionality. More details about building a runtime will be covered in the modules section.</p>"},{"location":"learn/framework/architecture/#client-runtime-communication","title":"Client-Runtime Communication","text":"<p>As previously described, the two main components of a Substrate node (the core client and the runtime) have a clear separation of concerns. Beyond the functional responsibilities, at a lower level, their binary representation and execution environments are different. While the node is compiled to be installed and run on a specific platform (be it Linux x64 or any other), the Tanssi network runtime is compiled to a Wasm format that is platform-agnostic and runs in an isolated execution environment.</p> <p>Bearing in mind the separated execution environments, all the communication between the node client and the runtime occurs through a limited and well-defined interface, allowing the necessary operations such as:</p> <ul> <li>Executing Transactions - when a user submits a transaction to the client node, the node passes this transaction to the runtime through the defined API for its execution</li> <li>State Queries - the client node can query the current state of the blockchain to retrieve information such as account balances and any other domain-specific data</li> <li>Consensus and Finality - the client node coordinates consensus and finalization of the blocks, but it is the runtime's responsibility to determine the validity of new blocks, validate transactions, and ensure that the consensus rules are followed</li> <li>Event Notifications - the runtime emits events while executing transactions that the client node can use to keep external users updated about specific actions or changes in the state</li> </ul>"},{"location":"learn/framework/modules/","title":"Network Framework Modules","text":""},{"location":"learn/framework/modules/#introduction","title":"Introduction","text":"<p>The Substrate framework provides complete and ready-to-use implementations of the main functions a Tanssi network needs to work properly, including cryptography, consensus, governance, and so on. These implementations are fully customizable and could be replaced with custom logic if needed.</p> <p>When building the Runtime, which defines the state transition rules between two blocks applied to a set of transactions, the intended behavior and features of the blockchain need to be set by determining the rules of the state transition.</p> <p>To build the Runtime, Substrate provides many built-in modules (also known as pallets) that can be freely used as building blocks to compose and interact with any other custom-made modules, allowing teams to create unique behaviors according to the specific requirements of their Tanssi network.</p> <p></p>"},{"location":"learn/framework/modules/#built-in-modules","title":"Built-in Modules","text":"<p>When designing and writing the rules of a Tanssi network, the available set of functional modules brings a solution to many of the coding requirements that would otherwise need to be built from scratch.</p> <p>Here is a list of some of the most popular modules:</p> <ul> <li>Balances - it provides functions for handling accounts and balances for the Tanssi network native currency</li> <li>Assets - it provides functions for handling any type of fungible tokens</li> <li>NFTs - it provides functions for dealing with non-fungible tokens</li> <li>Democracy - it provides functions to manage and administer general stakeholder voting</li> <li>Multisig - it provides functions for multi-signature dispatch</li> <li>Recovery - it provides functions to allow users to regain access to their accounts when the private key is lost. This works by granting other accounts the right to sign transactions on behalf of the lost account (note that it is necessary to have previously chosen the authorized accounts)</li> <li>Staking - it provides functions to administer staked tokens, support rewarding, slashing, depositing, withdrawing, and so on</li> </ul> <p>In addition to those previously listed, other modules like identity, smart contracts, vesting, and many others that are freely available can speed up the development of the Tanssi network and, consequently, the time to market.</p> <p>Note</p> <p>The framework also includes other modules that provide core protocol functionality, such as consensus and low-level data encoding.</p>"},{"location":"learn/framework/modules/#custom-modules","title":"Custom-Made Modules","text":"<p>Developers creating new modules enjoy complete freedom to express any desired behavior in the core logic of the blockchain, like exposing new transactions, storing sensible information, and validating and enforcing business logic.</p> <p>As explained in the Architecture article, a module needs to be able to communicate with the core client by exposing and integrating with a very specific API that allows the runtime to expose transactions, access storage, and code and decode information stored on-chain. It also needs to include many other required wiring codes that make the module work in the node.</p> <p>To improve developer experience when writing modules, Substrate relies heavily on Rust macros. Macros are special instructions that automatically expand to Rust code just before compile-time, allowing modules to keep up to seven times the amount of code out of sight of the developers. This allows developers to focus on the specific functional requirements when writing modules instead of dealing with technicalities and the necessary scaffolding code.</p> <p>All modules in Substrate, including custom-made ones, implement these attribute macros, of which the first three are mandatory:</p> <ul> <li><code>#[frame_support::pallet]</code> - this attribute is the entry point that marks the module as usable in the runtime</li> <li><code>#[pallet::pallet]</code> - applied to a structure that is used to retrieve module information easily</li> <li><code>#[pallet::config]</code> - is a required attribute to define the configuration for the data types of the module</li> <li><code>#[pallet::call]</code> -  this macro is used to define functions that will be exposed as transactions, allowing them to be dispatched to the runtime. It is here that the developers add their custom transactions and logic</li> <li><code>#[pallet::error]</code> - as transactions may not be successful (insufficient funds, as an error example), and for security reasons, a custom module can never end up throwing an exception, all the possible errors are to be identified and listed in an enum to be returned upon an unsuccessful execution</li> <li><code>#[pallet::event]</code> - events can be defined and used as a means to provide more information to the user</li> <li><code>#[pallet::storage]</code> - this macro is used to define elements that will be persisted in storage. As resources are scarce in a blockchain, it should be used wisely to store only sensible information</li> </ul> <p>All these macros act as attributes that must be applied to the code just above Rust modules, functions, structures, enums, types, etc., allowing the module to be built and added to the runtime, which, in time, will expose the custom logic to the outer world, as exposed in the following section.</p>"},{"location":"learn/framework/modules/#custom-module-example","title":"Custom Module Example","text":"<p>As an example of a custom module, the following code (not intended for production use) showcases the use of the previously mentioned macros by presenting a simple lottery with minimal functionality, exposing two transactions:</p> <ul> <li> <p>buy_ticket - this transaction verifies that the user signing the request has not already bought a ticket and has enough funds to pay for it. If everything is fine, the module transfers the ticket price to a special account and registers the user as a participant for the prize</p> </li> <li> <p>award_prize - this transaction generates a random number to pick the winner from the list of participants. The winner gets the total amount of the funds transferred to the module's special account</p> </li> </ul> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre> <p>For more information about the step-by-step process of creating a custom-made module to the runtime, please refer to the Adding a Custom-Made Module in the Builder's section.</p>"},{"location":"learn/framework/overview/","title":"Network Development Framework Overview","text":""},{"location":"learn/framework/overview/#introduction","title":"Introduction","text":"<p>Building a network from scratch is a very complex task that requires deep knowledge in a wide range of areas, including (but not limited to):</p> <ul> <li> <p>Consensus Algorithms - consensus ensures that all participants in the blockchain network agree on the validity of transactions. Some popular consensus mechanisms include Proof of Work (PoW) and Proof of Stake (PoS)</p> </li> <li> <p>Cryptography - cryptography plays a crucial role in securing the blockchain. You'll need cryptographic algorithms for tasks like creating digital signatures, verifying transactions, and encrypting data</p> </li> <li> <p>Distributed Network - a network architecture to enable nodes to communicate, validate transactions, and synchronize the blockchain data is key to maintaining a shared ledger in a decentralized network</p> </li> <li> <p>Data Structures - besides the list of blocks, where each block contains a set of transactions along with a reference to the previous block, an optimized and performant strategy to store the state of the network is needed</p> </li> <li> <p>Governance - if the network is designed to be permissionless, a voting mechanism is important in order to keep it evolving and reflecting the community will</p> </li> <li> <p>Upgradeability - it is necessary to clearly define how to upgrade, how modifications are implemented, and how conflicts are resolved within the network</p> </li> </ul> <p>Fortunately, there\u2019s no need to build these blockchain components from scratch, thanks to an excellent open-source framework called Substrate. Tanssi itself is built with this framework, leveraging its comprehensive base implementations, modularity, and flexibility to achieve a high level of customization.</p>"},{"location":"learn/framework/overview/#substrate-framework","title":"Substrate Framework","text":"<p>Substrate is an extremely performant, flexible, modular, and highly customizable framework for building blockchains. This framework is the foundation and engine powering many projects across the Web3 ecosystem, including the Tanssi network itself and the networks deployed through Tanssi.</p> <p>Many of its great features, such as performance, ease of use, and modularity, result from the programming language chosen for its development. This is where the Rust Programming Language shines: It is fast, portable, and provides a wonderful model to handle memory, among other reasons detailed in the next section.</p> <p>When developing a network, Substrate represents a great head start by providing a ready-to-use set of implementations of the main building blocks a project needs:</p> <ul> <li> <p>Consensus Algorithms - there are multiple built-in consensus engines, such as Aura (Proof of Authority), Babe (Proof of Stake), and Grandpa (block finality), but due to the high degree of customization Substrate offers, teams can always choose to develop their specific consensus to adapt to the use case needs, as the Moonbeam team did with the Nimbus Parachain Consensus Framework</p> </li> <li> <p>Runtime Modules - many built-in modules (explained in detail in the modules section) can be selected and configured into your network, such as accounts, balances, staking, governance, identity, and more</p> </li> <li> <p>Networking - built-in protocols and libraries for establishing connections, propagating transactions and blocks, synchronizing the blockchain state, and managing network interactions</p> </li> <li> <p>Storage - built-in storage mechanisms for efficient data storage and retrieval</p> </li> <li> <p>Transaction Queue - built-in transaction queue system that manages transaction validation, prioritization, and inclusion in blocks, ensuring the consistency and integrity of the network's state</p> </li> <li> <p>RPC APIs - Substrate provides Remote Procedure Call (RPC) APIs that enable external applications to interact with the network by querying blockchain data, submitting transactions, and accessing various functionalities exposed by the runtime</p> </li> </ul> <p>Every feature Substrate offers can be used as-is, extended, customized, or replaced to meet the specific requirements of the use case of the network.</p> <p>Substrate streamlines and speeds up the process of developing new networks. When used in conjunction with Tanssi, which helps in handling the infrastructure and overseeing the deployment, the task of launching a new network becomes significantly simpler!</p>"},{"location":"learn/framework/overview/#rust-programming-language","title":"Rust Programming Language","text":"<p>Rust is a programming language with features developers consistently rank highly in surveys like Stack Overflow's annual developer survey.</p> <p>In addition to providing a great experience for developers, Rust excels in many areas:</p> <ul> <li> <p>Memory safety - Rust compiler enforces strict compile-time checks to prevent common programming errors such as null pointer dereferences, buffer overflows, and data races. Additionally, memory is managed through a novel system of ownership (checked by the compiler), which eliminates the necessity for a garbage collector</p> </li> <li> <p>Performance - Rust achieves performance comparable to that of C and C++ by providing low-level control over system resources and minimizing runtime overhead. It has a zero-cost abstraction principle, similar to \"what you don't use, you don't pay for\" from C++, meaning that abstractions have no extra overhead</p> </li> <li> <p>Concurrency - Rust has built-in features that make it easy to write concurrent and parallel code without introducing data races. It provides lightweight threads (tasks) and a powerful ownership model that ensures the safe sharing of data between threads</p> </li> <li> <p>Expressive and safe abstractions - Rust offers a rich set of modern language features, such as pattern matching, algebraic data types, closures, and type inference, allowing developers to write and read expressive and concise code. The Rust compiler enforces the strong type system, preventing many runtime errors at compile-time</p> </li> <li> <p>Cross-platform compatibility - Rust is designed to work well on a variety of platforms and architectures. It supports major operating systems like Windows, macOS, and Linux, as well as embedded systems and WebAssembly. This versatility allows developers to write code that can be deployed across different environments</p> </li> <li> <p>Growing ecosystem - Rust has a rapidly growing ecosystem with a vibrant community and a rich collection of libraries and tools. The official package manager, Cargo, simplifies dependency management, building, and testing</p> </li> <li> <p>Interoperability - Rust provides seamless interoperability with existing codebases written in C and C++. It has a Foreign Function Interface (FFI) that allows Rust code to interface with code written in other languages, enabling developers to gradually introduce Rust into existing projects, like the Linux kernel</p> </li> </ul>"},{"location":"learn/framework/xcm/","title":"Native Cross-Chain Communication","text":""},{"location":"learn/framework/xcm/#introduction","title":"Introduction","text":"<p>All Tanssi-powered networks have an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication feature is possible thanks to the unique infrastructure the networks are built on top of, leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.</p> <p>XCM is a messaging language designed to be generic. It doesn't make any assumptions about the destination chain and can communicate different intentions between sovereign consensus systems.</p> <p>An XCM message is a program holding one or more instructions that will be relayed for execution to the destination chain. By itself, each XCM instruction is meaningless, but the combination of a specific set of instructions can result in a desired action when the XCM message is executed in the destination chain.</p> <p>In this article, we cover the basic concepts of the native cross-chain communication mechanism that allows fast and secure bridging within the ecosystem.</p>"},{"location":"learn/framework/xcm/#design-principles","title":"Design Principles","text":"<p>Conceived with an abstract mindset, XCM is not designed to comply with a specific use case or specific destination network setup, thus minimizing the coupling effect. Its core design principles are:</p> <ul> <li>Asynchronous - similar to sending a postcard -but way faster- the sender will keep performing its duties as usual, without blocking itself or awaiting a response from the destination</li> <li>Absolute -  messages are guaranteed to be delivered to the intended destination, in order and in a timely fashion</li> <li>Asymmetric -  messages sent have no response counterpart. Any return values, if required, must be sent back from the destination to the sender with another message</li> <li>Agnostic -  there are no assumptions whatsoever about the configuration or properties of two communicating networks. Networks might differ in every aspect, except the ability to understand XCM. E.g., one chain could be EVM-compatible and not the other, one chain could be a DeFi network and the other a gaming network, and so on</li> </ul>"},{"location":"learn/framework/xcm/#fees","title":"Fees","text":"<p>A user executing a transaction on a network must pay the fees derived from computational effort associated with the task, and cross-chain execution is no exception to this rule. In cross-chain communication, a message requires execution on at least two different chains, and the user needs to pay for the fees associated with the computational effort made by every chain involved. Besides the execution-related costs, Tanssi networks include a default delivery fee to prevent XCM spamming.</p> <p>For example, if a user on network A wants to call a smart contract on network B, the user must have enough funds to pay for the message delivery and include instructions in the XCM message to provide an asset that network B accepts as payment for its services to cover the associated fees. Once such an asset is provided, the execution can now be bought on the destination chain.</p> <p>Note</p> <p>Since networks are sovereign, they get to decide which tokens are valid for paying their XCM execution fees. E.g., if network B accepts network A tokens for fee payments, any user on network A can pay for an XCM message destined for network B using only network A tokens.</p>"},{"location":"learn/framework/xcm/#common-use-cases","title":"Common Use Cases","text":"<p>Many use cases can be addressed by benefiting from the common ground and versatility XCM provides. Two of the most recurrent ones are asset transfers and remote execution.</p>"},{"location":"learn/framework/xcm/#asset-transfer","title":"Asset Transfers","text":"<p>Moving digital assets from one network to another is essential for creating a more dynamic, efficient, and interconnected blockchain ecosystem. The native cross-chain capability allows two main strategies to transfer assets from one chain to another:</p> <ul> <li>Teleport - teleporting an asset is a simple and efficient mechanism, but it has a major caveat: it requires trust between the parties. In essence, when network A wants to send X amount of assets to network B, it burns X amount of assets and sends a message to network B instructing them to mint exactly X amount of assets, preserving the overall asset balance and concluding the teleport action. In this process, network A trusts network B not to mint more tokens than what was transferred, and network B trusts network A to burn the tokens that were transferred</li> <li>Reserve transfer - A reserve transfer involves the reserve chain of an asset, which is the chain where the asset is native (e.g., Moonbeam is the reserve chain for the GLMR token). Also, non-reserve networks hold a sovereign account on the reserve chain, a keyless account managed by the respective network governor. Thus, when reserve network A wants to send X amount of an asset to non-reserve network B, it locally transfers the assets to network's B sovereign account and, in the same atomic action, it sends an XCM message to network B with instructions to mint X amount of a derivative form of the transferred asset. On the other way around, if non-reserve network B wants to send X amount of an asset to reserve network A, then the steps are: network B burns the derived form of the asset locally and sends an XCM message to network A, with instructions to transfer the assets from network B's sovereign account to network's A destination account. Even if the non-reserve network mints derived tokens in excess (or doesn't burn tokens when transferring), these tokens will have no real value because they are not backed one-to-one in the reserve chain</li> </ul> <p>The associated fees for executing transfers are typically deducted from the transferred amount, so the recipient receives the intended amount minus the fees.</p>"},{"location":"learn/framework/xcm/#remote-execution","title":"Remote Execution","text":"<p>The native interoperability XCM provides allows a network to send a message to another triggering some action. For example, If the destination chain is EVM-compatible, network A can call a smart contract deployed on network B.</p> <p>As mentioned in the fees section, to get any on-chain request executed it is necessary to cover its associated fees. On XCM, remote execution can be bought with two steps:</p> <ol> <li>Reserve some assets using the <code>WithdrawAsset</code> XCM instruction, which takes funds from the call origin and puts them in a holding register</li> <li>Pay for the on-chain execution, using the <code>BuyExecution</code> XCM instruction, which uses the previously withdrawn assets</li> </ol> <p>Note</p> <p>When a network sends an XCM message, its default source on the receiving end is the origin network's Sovereign account. The sender network can add an XCM instruction called <code>DescendOrigin</code> to the message, changing the origin account to match the signing user's account, ensuring execution occurs on behalf of the same entity initiating the XCM message on the source chain, and avoiding a potentially unsafe scenario.</p> <p>Finally, the execution takes place on the destination chain, calling a smart contract or any other transaction using the XCM instruction called <code>Transact</code>.</p> <p>The general flow for remote execution is represented in the following diagram:</p> <p></p>"},{"location":"learn/framework/xcm/#channel-registration","title":"Establishing Cross-Chain Communication","text":"<p>Before two chains can communicate, a messaging channel must be established. Channels are unidirectional, which means that separate channels are needed to send messages from chain A to chain B and B to A.</p> <p>For chain A to communicate with chain B, chain A must send an open channel transaction to the relay chain requesting a channel be opened with chain B. Chain B must then accept the request by sending a corresponding XCM message to the relay chain. Only when both chains agree is the channel opened in the next epoch. The same process is required to establish a channel from chain B to chain A.</p> <p>It is important to note that a channel between a network and the relay chain is automatically opened upon network registration and onboarding.</p> <p></p> <p>Once the channel is established, cross-chain messages can be sent between networks. For asset transfers, assets will also need to be registered before being transferred.</p> <p>Note</p> <p>XCM is a versioned, ever-evolving language. When two communicating networks use different XCM versions, they must use the latest version supported by the less upgraded side. To find out the latest XCM version a network can work with, other networks can query it and subscribe for updates whenever this changes.</p>"},{"location":"learn/framework/xcm/#message-destinations","title":"Message Destinations","text":"<p>To compose meaningful messages in a multichain environment it is necessary to have a precise yet abstract way of referencing resources located in different consensus systems. A concept called multilocation is used to serve this purpose and target a specific chain or any of its inner elements, such as an account, an asset, or a smart contract.</p> <p>XCM's destination elements are organized in a hierarchical architecture, where elements are contained within other components. For example, a smart contract is an element contained within a network, and the same can be said for an account or an ERC20 asset. Networks are contained by the relay chain, which plays a crucial role in the cross-chain messaging process, relaying messages from one network to another.</p> <p>Multilocations are not a universal resource locator. They refer to elements from the sender's perspective and are composed of two components: <code>parents</code> and <code>interior</code>. Parents is a property that indicates if the route must \"move up\" in the hierarchy, i.e., from a network to the relay chain. Interior is a list of junctions that define how to locate the destination. Here are some examples of multilocations:</p> <ul> <li>Network A references a smart contract in network B - from the point of view of network A, to reach a smart contract in network B it is necessary to move up in the hierarchy (to the relay chain) and then descend to network B to, once there, reference the smart contract's address. The multilocation is therefore defined with a <code>parents</code> value set to <code>1</code>, which moves up, and two junctions, one defining which network should receive the message, and the other defining the H160 address of the smart contract that will be called</li> </ul> <p></p> <ul> <li>Network A references an account in the relay chain - from the point of view of network A, to reference an account in the relay chain, it is necessary to move up and then reference the account. The multilocation is defined with a <code>parents</code> value set to <code>1</code>, which moves up to the relay chain, and one junction that references the substrate type destination address</li> </ul> <p></p>"},{"location":"learn/tanssi/","title":"Learn About Tanssi","text":"<p>With Tanssi, developers can rely on seamless block production, integration with essential tools, and the flexibility to choose security providers that best fit their blockchain environment, empowering them to focus on innovation rather than technical hurdles.</p> <p>Tanssi's modular framework, runtime customization, transaction management, and interoperability transform network development into an accessible and efficient process, drastically reducing time to market while ensuring high performance and scalability.</p> <p>This section includes an overview of Tanssi\u2019s core capabilities that support network development, covering everything from infrastructure and security to essential integrations.</p>"},{"location":"learn/tanssi/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/tanssi/account-types/","title":"Accounts in the Tanssi Protocol","text":""},{"location":"learn/tanssi/account-types/#introduction","title":"Introduction","text":"<p>Blockchain technology relies on public-private key cryptography for secure asset ownership and transaction verification. Private keys authorize transactions, while public keys serve as addresses for verification. Due to the Tanssi protocol's hybrid Substrate and Ethereum nature, understanding the different account types is crucial for users and operators.</p>"},{"location":"learn/tanssi/account-types/#key-types-in-tanssi-protocol","title":"Account Types in the Tanssi Protocol","text":"Account Type Underlying Algorithm Primary Use in Tanssi Sr25519 Schnorr signatures on the Ristretto group Default signature scheme for Substrate-based transactions and operator identity. Ed25519 EdDSA using Curve25519 Used for specific consensus roles (e.g., block production, finality) within the Substrate framework. ECDSA Elliptic Curve Digital Signature Algorithm Receiving rewards through the Ethereum-based Symbiotic protocol for operators."},{"location":"learn/tanssi/account-types/#identity-and-operations","title":"Identity and Operations","text":"<p>Tanssi, built with the Substrate framework, utilizes distinct cryptographic schemes for different functions, primarily Sr25519 and Ed25519. These account types are crucial for interacting with the protocol's Substrate components by signing transactions.</p> <p>Sr25519 (Schnorrkel/Ristretto x25519) - is the primary account type used for most user-facing operations within Tanssi. Its strengths lie in security and efficiency. Sr25519 accounts serve as your on-chain identity, used for holding tokens, participating in governance, paying transaction fees, and other general interactions with the network. When you create a wallet to interact with Tanssi as a regular user, you will create and use an Sr25519 account.</p> <p>Ed25519 (Edwards-curve Digital Signature Algorithm) - while Sr25519 handles general identity and transactions, Ed25519 is specifically leveraged for its high performance in cryptographic signing, making it ideal for consensus-related operations. Within Tanssi, Ed25519 accounts are used by node operators for critical consensus mechanisms, such as block production and finality. Regular users will typically not create or directly use an Ed25519 account. However, these accounts are fundamental for the security and operation of the network, managed by those running nodes.</p> <p>Node operators on Tanssi require a Substrate account to record their activities, including operators who secure the network and sequencers who produce blocks. This account also tracks rewards, with session keys mapped to it for enhanced security.</p>"},{"location":"learn/tanssi/account-types/#security-and-rewards-on-ethereum","title":"Security and Rewards on Ethereum","text":"<p>The Elliptic Curve Digital Signature Algorithm (ECDSA) is fundamental to Ethereum and is used by Tanssi to integrate with the Ethereum network via Symbiotic. This partnership leverages Ethereum's security for Tanssi-powered networks.</p> <p>Tanssi operators need an ECDSA account to receive rewards distributed on Ethereum, likely through the Symbiotic protocol. The necessity of both Substrate and ECDSA accounts highlights Tanssi's hybrid design, where operations are Substrate-based, and security and rewards are linked to Ethereum.</p>"},{"location":"learn/tanssi/account-types/#account-mappings-in-tanssi","title":"Account Mappings in Tanssi","text":""},{"location":"learn/tanssi/account-types/#internal-key-binding-sr25519-and-ed25519","title":"Internal Key Binding (Sr25519 and Ed25519)","text":"<p>Within Tanssi's Substrate-based protocol, an operator\u2019s primary Sr25519 identity links to specific Ed25519 keys used for consensus tasks (like block production). Operators create this binding with an on-chain transaction. This transaction maps their internal public keys (\"session keys\") with the stash account. This on-chain registration ensures the network correctly attributes all actions from the session keys to the operator's primary identity.</p>"},{"location":"learn/tanssi/account-types/#cross-ecosystem-reward-mapping-sr25519-and-ecdsa","title":"Cross-Ecosystem Reward Mapping (Sr25519 and ECDSA)","text":"<p>For rewards on Ethereum (e.g., via Symbiotic), an operator's Tanssi Sr25519 identity maps to an Ethereum ECDSA address. Operators inform both accounts, which are then linked through the Tanssi middleware. This trusted link ensures that rewards from the operator's node work on the Tanssi network are routed to the operator's designated Ethereum account.</p>"},{"location":"learn/tanssi/glossary/","title":"Glossary","text":""},{"location":"learn/tanssi/glossary/#introduction","title":"Introduction","text":"<p>The Tanssi protocol offers a wide range of features and layered architecture, making it both rich and complex. There's a great deal of terminology specific to Tanssi, Appchains, Symbiotic, and the web3 space in general. We've compiled a list of terms you'll want to know as you review the Tanssi documentation.</p>"},{"location":"learn/tanssi/glossary/#appchain","title":"Appchain","text":"<p>A customizable application-specific blockchain deployed through Tanssi that goes live in minutes, benefiting from shared security, block production services, built-in bridging, and other services.</p>"},{"location":"learn/tanssi/glossary/#beefy","title":"BEEFY","text":"<p>BEEFY stands for Bridge Efficiency Enabling Finality Yielder. It is a consensus protocol that Tanssi utilizes for efficient, trustless bridging to Ethereum.</p>"},{"location":"learn/tanssi/glossary/#bridge","title":"Bridge","text":"<p>A bridge in the web3 context connects two different sovereign blockchains. Tanssi offers a built-in bridge based on Snowbridge connecting the Tanssi network to Ethereum in a decentralized and trustless way.</p>"},{"location":"learn/tanssi/glossary/#dancelight","title":"Dancelight","text":"<p>Tanssi's official TestNet for rapid network deployment and experimentation.</p>"},{"location":"learn/tanssi/glossary/#data-preservers","title":"Data Preservers","text":"<p>Full archive nodes that ensure data availability and provide RPC infrastructure for Tanssi and Tanssi-powered networks.</p>"},{"location":"learn/tanssi/glossary/#ecdsa","title":"ECDSA","text":"<p>ECDSA stands for Elliptic Curve Digital Signature Algorithm, which is the cryptographic scheme used for Ethereum accounts.</p>"},{"location":"learn/tanssi/glossary/#ed25519","title":"Ed25519","text":"<p>It is the cryptographic scheme for producing digital signatures used by node operators for consensus mechanisms like block production.</p>"},{"location":"learn/tanssi/glossary/#gateway","title":"Gateway Contract","text":"<p>One of the components of the Tanssi-Ethereum bridge. It serves as Ethereum's central messaging point that receives and validates messages from Tanssi.</p>"},{"location":"learn/tanssi/glossary/#light-client","title":"Light Client","text":"<p>One of the components of the Tanssi-Ethereum bridge. It serves as an on-chain verifier for data legitimacy in a network.</p> <p>A light client is a software that allows you to interact with a blockchain without having to download the entire data. It relies on a subset of information (such as block headers) and uses tools like Merkle proofs to verify transaction and data authenticity. This makes light clients more resource-efficient than full nodes.</p>"},{"location":"learn/tanssi/glossary/#merkle-root","title":"Merkle Root","text":"<p>A single cryptographic hash that allows the verification of an entire set of data, such as all the transactions in a block.</p>"},{"location":"learn/tanssi/glossary/#operator","title":"Operator","text":"<p>A node that validates transactions, providing security through a restaking protocol to Tanssi and all Tanssi-powered appchains.</p>"},{"location":"learn/tanssi/glossary/#relayer","title":"Relayer","text":"<p>A stateless component that transports messages and proofs between different blockchain networks, such as Tanssi and Ethereum.</p>"},{"location":"learn/tanssi/glossary/#restaking","title":"Restaking","text":"<p>The practice of using already-staked tokens to secure additional protocols or services.</p>"},{"location":"learn/tanssi/glossary/#sequencer","title":"Sequencer","text":"<p>A node responsible for executing transactions and producing blocks for Tanssi-powered appchains.</p>"},{"location":"learn/tanssi/glossary/#session","title":"Session","text":"<p>A period of time during which the same set of authorities (sequencers or validators) are active.</p>"},{"location":"learn/tanssi/glossary/#sr25519","title":"Sr25519","text":"<p>The primary signature scheme that is used for most user-facing operations within the Tanssi network.</p>"},{"location":"learn/tanssi/glossary/#substrate","title":"Substrate","text":"<p>A modular and performant blockchain development framework used to build Tanssi and Tanssi appchains.</p>"},{"location":"learn/tanssi/glossary/#symbiotic","title":"Symbiotic","text":"<p>A restaking protocol based on Ethereum, providing restaking services and economic security to Tanssi and Tanssi-powered appchains.</p>"},{"location":"learn/tanssi/glossary/#tanssi-substrate","title":"$TANSSI(Substrate)","text":"<p>The native utility token of the Tanssi protocol. It is used for staking, governance, network operations, and more.</p>"},{"location":"learn/tanssi/glossary/#tanssi-erc20","title":"$TANSSI(ERC20)","text":"<p>The ERC20 Ethereum representation of the Tanssi token. It is used for paying rewards to operators and more.</p>"},{"location":"learn/tanssi/glossary/#trustless","title":"Trustless","text":"<p>As with a trustless bridge, it enables operation without requiring trust in centralized intermediaries, relying instead on cryptographic proofs.</p>"},{"location":"learn/tanssi/glossary/#vault","title":"Vault","text":"<p>A Symbiotic component that receives and manages restaked collateral, delegating to operators and providing economic security to networks.</p>"},{"location":"learn/tanssi/glossary/#verifier","title":"Verifier","text":"<p>The component that validates cryptographic proofs.</p>"},{"location":"learn/tanssi/overview/","title":"What is Tanssi?","text":"<p>Tanssi is a decentralized appchain infrastructure protocol that allows developers to launch their appchain in minutes. In other words, Tanssi reduces the six-to-twelve-month setup process typically required for any team to go live with a new chain to minutes.</p> <p>You can think of Tanssi as AWS for appchains. Instead of dealing with all the networking infrastructure yourself, Tanssi handles all the hurdles, allowing you to focus on building your application logic, growing your community, and other tasks essential to your product's success.</p> <p>Security is another significant obstacle that developers must deal with, taking on the responsibility of attracting staked assets to ensure consensus security and bootstrapping a validator set, which can be particularly challenging for projects in their early stages. All Tanssi-powered appchains benefit from Ethereum-grade security right from the start, and by leveraging Tanssi's decentralized design, appchains aren't exposed to single points of failure. </p> <p>Tanssi-powered appchains also benefit from a modular tech stack, providing ultimate control over the logic that powers the blockchain's runtime, offering an excellent way for projects to scale and build optimized solutions for their products. This complete control over the appchain's logic and governance mechanism suits perfectly a wide range of use cases, including DeFi Protocols, Real World Assets (RWA), Gaming Platforms, and others.</p>"},{"location":"learn/tanssi/overview/#the-problem-with-appchains","title":"The Problem with Appchains","text":"<p>Developers looking to build decentralized appchains typically have to deal with the following problems:</p> <ul> <li> <p>Complex Infrastructure Management: Appchain deployments typically require handling numerous infrastructural components, including bootstrapping sequencers, operators (also known as validators), wallets, block explorers, oracles, indexers, RPC endpoints, and more. Properly managing these components are both time-consuming and resource-intensive.</p> </li> <li> <p>Weak &amp; Inefficient Security: Appchains commonly suffer from having a small set of operators or weak economic security. Early-stage projects often lack sufficient economic backing to support a robust consensus mechanism. Moreover, developers often have to pay for full blockchain capacity validation even when they might not have achieved product-market fit, and blocks might be close to empty. This essentially means that operators are being overpaid, and there is a significant opportunity cost, as those resources could be used elsewhere to develop the protocol.</p> </li> <li> <p>Cross-Chain and Interoperability:  Appchains inherently lack cross-chain capabilities, which prevents them from connecting to other blockchain ecosystems. Furthermore, developing interoperability solutions requires specialized expertise and meticulous implementation.</p> </li> <li> <p>Slow Time to Market: The complexities of appchain infrastructure divert developers' focus from application logic, which is the key driver for intuitive interfaces and a seamless user experience, critical for adoption.</p> </li> </ul>"},{"location":"learn/tanssi/overview/#what-tanssi-provides","title":"What Tanssi Provides","text":"<p>Tanssi addresses the most common appchain pain points by:</p> <ul> <li> <p>Sequencing as a Service: Appchains built with Tanssi have their blocks produced by Tanssi's incentivized workers. Tanssi guarantees the appchain's liveness by orchestrating a decentralized set of sequencers.</p> </li> <li> <p>Economic Security Through External Providers: Appchains deployed through Tanssi leverage security from a provider of choice (for example, Symbiotic for Ethereum). The protocol is designed to finalize transactions deterministically in seconds through a decentralized set of operators.</p> </li> <li> <p>Tanssi/Ethereum Bridge: Move liquidity to and from Ethereum using the built-in bridge based on Snowbridge.</p> </li> <li> <p>Key Integrations: Appchains built with Tanssi can access key infrastructural components alongside block production in a fully automated and standardized way. Tanssi-powered appchains come with built-in support for essential tools, including wallets, block explorers, indexers, RPC providers, and more, saving developers the effort of integrating these components. </p> </li> <li> <p>Modular Blockchain Framework: Appchains built with Tanssi can use a modular blockchain framework called Substrate, which enables developers to quickly and easily build optimized and customizable blockchains for any use case. Tanssi handles most infrastructural complexities, allowing developers to focus on their appchain's custom logic.</p> </li> </ul> <p>In summary, appchains deployed through Tanssi are sovereign Layer 1 solutions designed to be highly modular and interconnected, with a focus on simplifying the deployment process and enabling customization of the appchain itself. This empowers developers to bring their blockchain applications to market faster, securely, and with greater potential for integration and interaction within the broader blockchain ecosystems.</p>"},{"location":"learn/tanssi/overview/#tanssi-key-aspects","title":"Key Aspects of Tanssi","text":"<p>The following table summarizes the main benefits Tanssi brings to your project:</p> Aspect The Tanssi Solution Deployment Time - Minutes to deploy - Faster time to market Block production - Sequencing as a service- Decentralized set of sequencers by design Security - Ethereum-grade security from the start Finality/Settlement - Deterministic- Finality in seconds Cost - Registration bond + Pay-as-you-go model Customizability - Choose the governance mechanism that best suits your project - Modular framework- Full runtime customizability Integrations and tooling - Essential tools available from the start"},{"location":"learn/tanssi/overview/#tanssi-architecture","title":"General Architecture of Tanssi &amp; Tanssi-powered Appchains","text":"<p>As previously discussed, appchains deployed through Tanssi are sovereign and customizable blockchains that, among other features, leverage sequencing as a service and inherit block finality from an external security provider.</p> <p>A high-level overview of the architecture is presented below, featuring Symbiotic as the security provider.</p> <p></p> <p>The Tanssi protocol manages and orchestrates a decentralized set of sequencers assigned to provide block production services to Tanssi-powered appchains. The sequencers execute transactions and include them in blocks, which the security provider's operators then proceed to validate. Symbiotic's restaking protocol allows its operators to offer Ethereum-grade economic security. The mechanism of how this works is explained in two separate articles: Block Production Services and Ethereum with Symbiotic.</p> <p>While the sequencers providing block production services are rotated and reassigned to a different appchain upon every session change, each appchain will have its own set of Data Preservers running full archive nodes, ensuring data availability. These Data Preservers will provide the RPC infrastructure for apps and users interacting with Tanssi-powered appchains.</p> <p></p>"},{"location":"learn/tanssi/overview/#whats-next","title":"What's Next?","text":"<ul> <li>Head to the Tanssi dApp and launch your appchain.</li> <li>Interact with a live Tanssi-powered appchain: the Tanssi Demo EVM appchain.</li> </ul>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/","title":"Tanssi-Ethereum Bridge","text":""},{"location":"learn/tanssi/tanssi-ethereum-bridge/#introduction","title":"Introduction","text":"<p>Traditional blockchains often create silos, limiting asset and functional interoperability. The Tanssi-Ethereum bridge overcomes these limitations by enabling seamless cross-chain operations that benefit both ecosystems.</p> <p>The bridge is more than an asset exchange. It\u2019s a secure, standardized protocol for direct cross-chain interaction without centralized intermediaries. Its trustless design avoids the risks of central points of failure that many other bridges face.</p> <p>This article introduces the Tanssi-Ethereum bridge as a key interoperability layer between the two networks. You\u2019ll learn how it works, including its architecture, operator management, economic model, slashing mechanisms, and asset transfers.</p> <p>You'll also learn about the consensus layers that secure communication (BEEFY on Tanssi and the Ethereum Beacon Chain), and the roles of provers, verifiers, and relayers, giving you a clear view of how assets and messages move securely between Tanssi and Ethereum.</p>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#core-functions","title":"Core Functions","text":"<p>The bridge facilitates several critical operations between Tanssi and Ethereum:</p> <ul> <li>Operator Management - maintains operator stake information on Ethereum via the Symbiotic protocol, providing this data to Tanssi for selecting active, decentralized, and economically aligned operators each era</li> <li>Economic Operations - distributes rewards from Tanssi to Ethereum stakers and operators</li> <li>Slashing - processes slashing requests from Tanssi to Ethereum when operators violate protocol rules</li> <li>Asset Transfer - enables bilateral, trustless asset transfers between Tanssi and Ethereum, enhancing liquidity.</li> </ul> <p>This interoperability expands the potential of decentralized applications and significantly enhances the liquidity and usability of blockchain assets.</p>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#bridge-architecture","title":"The Bridge Architecture","text":"<p>Understanding the bridge's consensus functionality requires examining its core components: provers, verifiers, and relayers. Provers generate cryptographic proofs, verifiers validate them, and relayers move data between chains.</p> <p>Provers include Tanssi's BEEFY module and Ethereum's Beacon Chain consensus. They produce consensus data transmitted by specialized relayers.</p> <p>Each chain runs a light client of the other, acting as an on-chain verifier for data legitimacy. For instance, when Tanssi sends a message to Ethereum, it generates compact proofs of events or state changes based on its consensus. Ethereum's light client verifies these proofs before acting. This efficient method avoids processing the entire sending chain's state, relying instead on concise cryptographic proof verification.</p>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-consensus","title":"Tanssi to Ethereum Consensus","text":"<p>BEEFY (Bridge Efficiency Enabling Finality Yielder) is Tanssi's consensus protocol, which acts as a prover. It's designed for efficient, trustless bridging to chains like Ethereum that are not natively built for interoperability.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_Pallet as Tanssi &lt;br/&gt; BEEFY Pallet (prover)\n    participant Beefy_Relayer as Relayer &lt;br/&gt; (Beefy)\n    participant Eth_BeefyClient as Ethereum &lt;br/&gt; BEEFY Client (verifier)\n\n    Tanssi_Pallet-&gt;&gt;Beefy_Relayer: Generate BEEFY Commitment\n    activate Beefy_Relayer\n    Beefy_Relayer-&gt;&gt;Eth_BeefyClient: Submit commitment/proof\n    deactivate Beefy_Relayer\n\n    activate Eth_BeefyClient\n    Eth_BeefyClient-&gt;&gt;Eth_BeefyClient: Verify commitment\n    deactivate Eth_BeefyClient\n</code></pre>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-consensus","title":"Ethereum to Tanssi Consensus","text":"<p>For Ethereum-to-Tanssi bridging, Ethereum's Beacon Chain consensus is the prover. It provides Tanssi's on-chain light client with proof of Ethereum's finalized state, including events or messages for Tanssi.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_BeaconCons as Ethereum &lt;br/&gt; Beacon Chain Consensus(Prover)\n    participant Beacon_Relayer as Relayer &lt;br/&gt; (Beacon)\n    participant Tanssi_EthClient as Tanssi &lt;br/&gt; Ethereum Light Client (verifier)\n\n    Eth_BeaconCons-&gt;&gt;Beacon_Relayer: Beacon chain update (Header/Proof)\n    activate Beacon_Relayer\n    Beacon_Relayer-&gt;&gt;Tanssi_EthClient: Submit update/proof\n    deactivate Beacon_Relayer\n\n    activate Tanssi_EthClient\n    Tanssi_EthClient-&gt;&gt;Tanssi_EthClient: Verify update/proof\n    deactivate Tanssi_EthClient</code></pre> <p>From a messaging perspective, the bridge uses its consensus verification layer for secure cross-chain communication. Dedicated relayers transport messages: the Execution Relay for Ethereum to Tanssi, and the Tanssi Relay for Tanssi to Ethereum.</p> <p>Relayers are stateless and only submit proofs. They cannot forge messages or steal funds, as the consensus mechanism revalidates each proof on-chain. Multiple concurrent relayers improve responsiveness without centralizing power.</p> <p>Ethereum's <code>Gateway</code> contract is the central messaging point. It receives messages from Tanssi via relayers, validates them using consensus proofs, and executes operations like token minting/unlocking or smart contract calls.</p>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-messages","title":"Ethereum to Tanssi Inbound Messages","text":"<p>This section describes messages from Ethereum to Tanssi, using Ethereum's Beacon Chain consensus for proofs and an Execution Relay (or Beacon Relay).</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Gateway Contract\n    participant Exec_Relay as Relayer &lt;br/&gt; (Execution Relay)\n    participant Tanssi_InQueue as Tanssi &lt;br/&gt; Inbound Queue\n\n    Note over Eth_Gateway: Message Ready / Event Occurs\n    Eth_Gateway-&gt;&gt;Exec_Relay: Message + Proof\n    activate Exec_Relay\n    Exec_Relay-&gt;&gt;Tanssi_InQueue: Submit Message/Proof\n    deactivate Exec_Relay\n\n    activate Tanssi_InQueue\n    Tanssi_InQueue-&gt;&gt;Tanssi_InQueue: Process Inbound Message\n    deactivate Tanssi_InQueue</code></pre>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-messages","title":"Tanssi to Ethereum Outbound Messages","text":"<p>This section describes messages from Tanssi to Ethereum, using BEEFY consensus to prove Tanssi's state and a Tanssi Relay for transmission.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_OutQueue as Tanssi &lt;br/&gt; Outbound Queue\n    participant Para_Relay as Relayer &lt;br/&gt; (Tanssi Relay)\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Gateway Contract\n\n    Note over Tanssi_OutQueue: Message Ready / Proof Committed\n    Tanssi_OutQueue-&gt;&gt;Para_Relay: Message + Proof\n    activate Para_Relay\n    Para_Relay-&gt;&gt;Eth_Gateway: Submit Message/Proof\n    deactivate Para_Relay\n\n    activate Eth_Gateway\n    Eth_Gateway-&gt;&gt;Eth_Gateway: Process Outbound Message\n    deactivate Eth_Gateway</code></pre> <p>The <code>Gateway</code> manages Ethereum's outbound communications. For cross-chain transfers, it logs an event, locks tokens if necessary, and packages data for relay to Tanssi. Tanssi uses two queues for efficient message processing.</p> <p>The <code>Outbound Queue</code> handles messages to Ethereum. It bundles them and adds a Merkle root (cryptographic commitment) to each block header. This allows Ethereum's light client to verify message inclusion using consensus proofs efficiently.</p> <p>The <code>Inbound Queue</code> processes messages from Ethereum. It receives and verifies proofs of Ethereum events via Tanssi's on-chain Ethereum light client. Verified events become internal instructions in Tanssi. This layered, consensus-secured architecture ensures trustless cross-chain interactions.</p>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#token-transfers-flow","title":"Token Transfers Flow","text":"<p>This section explains how the bridge moves assets and messages. It involves locking/minting assets on one chain and a complementary action on the other, secured by verified proofs. The following describes the typical transfer sequences.</p> <ol> <li>Initiation (Source Chain) - user initiates asset transfer</li> <li>Relay Proof - off-chain relayers pick up the event and submit cryptographic proofs to the destination chain</li> <li>Verification (Destination Chain) - on-chain light clients independently verify submitted proofs</li> <li>Execution - upon successful verification, tokens are minted/unlocked on the destination chain</li> </ol>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#ethereum-to-tanssi-transfer","title":"Ethereum to Tanssi Transfer","text":"<p>This section outlines asset movement from Ethereum to Tanssi (as derivative assets).</p> <ol> <li>Lock on Ethereum - a user deposits assets into Ethereum's Bridge contract. The contract locks the tokens and emits a deposit event</li> <li>Relay Proof to Tanssi - an off-chain relayer detects the finalized event, creates a proof package (including Ethereum block header and Merkle proof of the deposit), and submits it to the Tanssi Bridge's <code>Inbound Queue</code></li> <li>Verify on Tanssi - Tanssi Bridge's <code>EthereumClient</code> module (an on-chain light client) receives the proof from the <code>Inbound Queue</code>. It verifies the Ethereum block header's finality/validity and the Merkle proof's authenticity</li> <li>Mint on Tanssi - upon successful verification by the <code>EthereumClient</code>, the <code>Inbound Queue</code> is notified and mints the corresponding asset on Tanssi</li> </ol> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant User\n    participant EBridge as Ethereum Bridge Contract\n    participant Relayer\n    participant TBP as Tanssi Bridge&lt;br/&gt; (Inbound Queue + ETH Client)\n    participant TAH as Tanssi\n\n    User-&gt;&gt;EBridge: 1. Deposit Asset\n    activate EBridge\n    Note over EBridge: Lock Tokens &amp; Emit Event\n    deactivate EBridge\n\n    Relayer-&gt;&gt;Relayer: Observe Ethereum Event\n    Relayer-&gt;&gt;TBP: 2. Submit Header + Merkle Proof\n    activate TBP\n    Note over TBP: Receive Proof (Inbound Queue)\n    TBP-&gt;&gt;TBP: 3. Verify Proof (EthereumClient Pallet)\n    TBP-&gt;&gt;TAH: Send Mint Request\n    deactivate TBP\n\n    activate TAH\n    TAH-&gt;&gt;TAH:  4. Mint Asset\n    TAH--&gt;&gt;User: (Asset appears in Recipient Account)\n    deactivate TAH</code></pre>"},{"location":"learn/tanssi/tanssi-ethereum-bridge/#tanssi-to-ethereum-transfer","title":"Tanssi to Ethereum Transfer","text":"<p>This flow describes the reverse process, moving assets from Tanssi to Ethereum.</p> <ol> <li>Initiate and Commit on Tanssi - user initiates a transfer on Tanssi. A message with transfer details goes to the Bridge's <code>Outbound Queue</code>. The queue processes it, bundles the payload, and commits its Merkle root to the Tanssi block header, representing all outgoing messages in that block</li> <li>Relay Proof to Ethereum - an off-chain relayer monitors Tanssi for finalized blocks with <code>Outbound Queue</code> Merkle roots. It retrieves proofs: a BEEFY commitment (signed statement of finalized Tanssi block headers) and a Merkle proof of the user's transfer payload under the committed root</li> <li>Submit Commitment in Ethereum - the relayer submits the BEEFY commitment and Merkle proof to Ethereum's <code>Gateway</code> contract</li> <li>Verify on Ethereum - Ethereum's Beefy Client contract (Tanssi's on-chain light client) receives the BEEFY commitment from the <code>Gateway</code> and verifies its validity (including signatures)</li> <li>Validate Payload - after commitment verification, the <code>Gateway</code> validates the Merkle proof for the user's payload</li> <li>Execute on Ethereum - with both proofs verified, the <code>Gateway</code> contract executes the action, usually releasing locked assets via the main Bridge contract to the recipient or executing a target contract call on Ethereum</li> </ol> <p>The following diagram illustrates the initiation and commitment phase of the asset transfer process on the Tanssi side.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant User\n    participant TAH as Tanssi\n    participant TBP as Tanssi Bridge&lt;br/&gt; (Outbound Queue)\n    participant Relayer\n\n    User-&gt;&gt;TAH: 1. Initiate Transfer &amp; Deposit Asset\n    activate TAH\n    TAH-&gt;&gt;TBP: Send message to Outbound Queue\n    deactivate TAH\n\n    activate TBP\n    Note over TBP: Process message, Bundle, and&lt;br/&gt;Commit Merkle Root to Tanssi Header\n    deactivate TBP\n\n    Relayer-&gt;&gt;Relayer: 2. Observe Tanssi Header /&lt;br/&gt;BEEFY Commitment &amp; Get Proof\n    Note over Relayer: Relayer is now ready to interact&lt;br/&gt;with Ethereum based on observed data.</code></pre> <p>The subsequent diagram details the relay, verification, and execution steps on the Ethereum side of the asset transfer.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Relayer\n    participant EGateway as Ethereum Gateway Contract\n    participant EBeefy as Ethereum Beefy Client Contract\n    participant EBridge as Ethereum Bridge Contract\n    participant User\n\n    Relayer-&gt;&gt;EGateway: 3. Submit BEEFY Commitment + Merkle Proof\n    activate EGateway\n    EGateway-&gt;&gt;EBeefy: 4. Verify BEEFY Commitment\n    activate EBeefy\n    EBeefy--&gt;&gt;EGateway: Verification OK\n    deactivate EBeefy\n\n    EGateway-&gt;&gt;EGateway: 5. Verify Merkle Proof for Payload\n    Note over EGateway: Proof Validated\n\n    EGateway-&gt;&gt;EBridge: 6. Execute: Unlock Tokens / Call Target Contract\n    activate EBridge\n    Note over EBridge: Assets Transferred or&lt;br/&gt;Target Call Executed\n    EBridge--&gt;&gt;User: (Tokens Received / Call Executed)\n    deactivate EBridge\n    deactivate EGateway</code></pre>"},{"location":"learn/tanssi/external-security-providers/","title":"External Security Providers","text":"<p>Tanssi integrates external security providers to strengthen the flexibility and resilience of its ecosystem. By adopting decentralized security models, these providers deliver customized solutions that address diverse operational needs, ensuring greater levels of security and trust across networks.</p> <p>This approach addresses common challenges developers face, such as securing significant economic resources or negotiating with operators to maintain nodes. Through Tanssi's collaborative security framework, developers can bypass these obstacles and focus on innovation, leveraging a secure and scalable infrastructure to streamline the deployment of networks.</p>"},{"location":"learn/tanssi/external-security-providers/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/","title":"Ethereum with Symbiotic","text":""},{"location":"learn/tanssi/external-security-providers/symbiotic/#introduction","title":"Introduction","text":"<p>The Tanssi protocol takes care of critical infrastructural components, making it easy for developers to launch their networks in a few minutes. In addition to block production, data retrievability, and integrations with essential tools such as wallets, RPC endpoints, block explorers, and others, another major task to tackle is providing security to the network.</p> <p>Tanssi is designed to offer developers a shared security model, alleviating them from having to source enough economic security or negotiating with operators to run nodes opting-in for their networks. By deploying networks through Tanssi, and by choosing Symbiotic as a security provider, developers benefit from Ethereum-grade security, tapping into billions of dollars in shared security from staked ETH.</p> <p>The following sections describe how the Symbiotic protocol works and how Tanssi networks can leverage it as their consensus mechanism.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#symbiotic","title":"Ethereum-Grade Security with Symbiotic","text":"<p>Symbiotic is a shared security protocol designed to be permissionless, multi-asset, and network-agnostic. It fosters capital efficiency by allowing users to extend the functionality of their staked assets to secure other networks while providing additional utility.</p> <p>The protocol provides a coordination layer for its main components and participants, aligning incentives among parties while minimizing execution layer risks by deploying non-upgradeable core contracts on Ethereum. The following diagram resumes all the components and actors participating in the protocol:</p> <pre><code>flowchart TD\n    %% Vaults subgraph\n    subgraph Ethereum[\"Ethereum/Symbiotic\"]\n        slash[/Slashing Events/]\n        Restakers -- Deposit Assets --&gt; Vaults\n        manager[\"Vault managers\"] -- Manage --&gt; Vaults\n        Resolvers -- Decide On --&gt; slash\n        slash -- Executes On --&gt; Vaults\n    end\n\n    %% Operators subgraph\n    subgraph Operators\n        direction BT\n        operators[\"Operators (Validators)\"]\n        node_operators[\"Node Operators\"]\n        node_operators -- Run --&gt; operators\n    end\n\n    %% Networks subgraph\n    subgraph Networks\n        direction BT\n        developers[\"Developers\"]\n        networks[\"Decentralized Networks\"]\n        developers -- Launch --&gt; networks\n    end\n\n    Vaults &lt;--&gt; Tanssi\n    Tanssi &lt;--&gt; Operators\n    Tanssi &lt;--&gt; Networks</code></pre> <p>Symbiotic's flexible design allows every party to decide on setups that best fit their use cases. For example, vaults can choose what forms of collateral they accept, operators can determine which networks they want to provide services to, and decentralized networks can customize their use case and define the level of security (which collaterals are accepted, for example) they need.</p> <p>The following sections describe the protocol's main components.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#vaults","title":"Vaults","text":"<p>Vaults are the Symbiotic protocol's economic backbone. They manage liquidity and deposits from restakers, connect operators and networks, and set up delegation strategies.</p> <p>Each vault is bound to a specific token that satisfies the ERC20 interface and is accepted as collateral. Internally, the funds within the vault are represented as shares, which provide a mechanism for tracking ownership and distributing rewards. However, the reward token may differ from the collateral token.</p> <p>A vault comprises three key modules, each serving a distinct function: the slasher, the delegator, and the accounting module. The implementation of these modules can vary depending on the vault manager's decisions.</p> <ul> <li>Slasher module - implements the slashing logic, which penalizes bad actors</li> <li>Delegator module - defines how funds are delegated across operators and networks. Several strategies are available, allowing the vault manager to select which operators and networks they want to work with</li> <li>Accounting module - handles the vault's financial operations, including processing user deposits, managing withdrawal requests, tracking active balances and total supply, and implementing epoch-based accounting for withdrawals and slashing events. The accounting module's standard implementation is ERC-4626, which provides a vault with a shares system included</li> </ul> <p>Since the operators get delegated stake from the vault and could potentially get slashed, they must be approved by the vault managers beforehand. On a similar note, vault managers analyze and authorize each network the vault will secure, considering, for example, the rewards the network offers.</p> <p>Vault managers also designate resolvers, responsible for approving or vetoing slashing events caused by operators on networks with veto-slashing support, like the Tanssi Network.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#operators","title":"Operators","text":"<p>Node operators are entities or individuals responsible for running the nodes (also known as operators or validators), which are the computational components validating the networks' transactions. They are responsible for the nodes' configuration, hardware setup, uptime, and performance.</p> <p>Node operators opt-in to provide services to networks, which must accept their request. Also, they opt-in to provide services in vaults, which must accept their request.</p> <p>Once an operator has been accepted by a vault and a network connected to that vault, the node can start providing validation services to that network, receiving rewards in exchange.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#networks","title":"Networks","text":"<p>Networks are the actively validated services or networks. These application-specific blockchains can be a use case from a wide range of industries, such as Gaming, Defi, RWAs, and others, and are the platforms that, through dApps, the end users interact with.</p> <p>Since operators opt-in to provide services to networks and the vault managers must accept the networks, the developers are responsible for defining, controlling, and adapting their methodology for onboarding, rewarding, and slashing operators.</p> <p>Note</p> <p>Networks deployed through Tanssi don't need to work on the relation with vaults and operators since the Tanssi protocol deals with those complexities.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#tanssi-symbiotic","title":"Tanssi with Symbiotic","text":"<p>Developers launching networks through Tanssi benefit from block production services, data retrievability as a service, and the shared security model derived from every vault opting-in to support the Tanssi protocol. This eliminates the hurdle of dealing with infrastructural and security components developers would need to take on otherwise.</p> <p>Vault managers running vaults can apply to offer the restaked collaterals as economic security for the Tanssi Network. Since Tanssi networks run in a sandbox-like environment, and the Tanssi protocol manages all the networks-related responsibilities, vault managers only need to analyze and opt-in to the Tanssi protocol, regardless of the quality and the quantity of networks that are running through the Tanssi protocol at any given moment.</p> <p>Operators opting-in to provide services to the Tanssi protocol (provided that they participate in a vault that supports the Tanssi protocol) have the benefit of running the same setup to provide block production and validation services to the Tanssi Network and, consequently, to every network deployed through Tanssi. This unique architecture facilitates all the tasks related to running and maintaining the operators since there are no changes in the setup when a new Tanssi network is launched or decommissioned.</p> <p>Note</p> <p>The Tanssi protocol effectively abstracts the details of the active set of networks away from vault managers and operators. Networks particularities don't require any additional setup from operators nor pose risks to vault assets.</p> <p>All things combined shape a functional and elegant ecosystem where developers can focus on creating and innovating. Tanssi handles the infrastructural components, guaranteeing liveness and performance, and Symbiotic provides the economic safeguards to ensure the validity of the operations.</p> <pre><code>flowchart LR\n    subgraph Symbiotic\n        direction LR\n        Operators\n        Vaults\n    end\n    Symbiotic  -- Validates/Secures --&gt; tanssi[\"Tanssi Network\"]\n    tanssi -- Block Production Services--&gt; Networks\n    tanssi -- Security--&gt; Networks\n    tanssi -- Data Retrievability--&gt; Networks\n\n    class Symbiotic custom-container</code></pre>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#tanssi-ethereum-communication","title":"Tanssi-Ethereum Communication","text":"<p>It is important to learn how Tanssi and Ethereum exchange data to understand the mechanics of the protocol. They connect through a two-way bridge that lets them communicate with each other. Each protocol has a specific job in making cross-chain operations possible.</p> <p>There are three key components between Symbiotic and Tanssi:</p> <pre><code>flowchart LR\n\nTanssi[\"Tanssi\"] &lt;--&gt; Relayer \nRelayer &lt;--&gt; Gateway \nGateway[\"Gateway\"] &lt;--&gt; Middleware\nMiddleware &lt;--&gt; Symbiotic[\"Symbiotic\"]\n\nclass Tanssi tanssiNode;\n\nclass Middleware middlewareNode;\n\nclass Gateway gatewayNode;\n\nclass Symbiotic symbioticNode;\n\nclass Relayer relayerNode;</code></pre> <ul> <li> <p><code>Relayer</code> - is the software that continuously monitors both blockchains and transmits messages. Enabling reliable bidirectional communication between Tanssi and Ethereum, serving as the connection layer that ensures messages are correctly delivered across networks</p> </li> <li> <p><code>Gateway</code> - operates on the Ethereum side of the bridge and serves three essential functions. It receives, verifies, and routes incoming messages from Tanssi to ensure they are correctly processed. The contract accepts outgoing messages destined for the Tanssi network, preparing them for relay. Finally, it handles higher-level application functionalities, most notably token transfers between the two networks, providing a secure interface for cross-chain asset movement</p> </li> <li> <p><code>Middleware</code> - is Tanssi's implementation for handling network events and operations. It is the critical link between the <code>Gateway</code> and Tanssi's core protocol</p> </li> </ul> <p>The <code>Middleware</code> plays a central role in network coordination between Tanssi and Symbiotic. It distributes rewards to operators and vaults based on their network security and performance contributions. The contract sorts operators by stake to create a merit-based ranking system for their selection and transmits the list of sorted operator keys to Tanssi for assignment. Additionally, it facilitates operator registration processes and handles the reward and slashing protocols that maintain network incentive alignment.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#from-ethereum-tanssi","title":"From Ethereum to Tanssi","text":"<p>The <code>Middleware</code> transmits operator set information to Tanssi for session assignment through the bridge. It sends details about active operators for each epoch, ordering them by their total stake aggregated across vaults. Tanssi then uses this information to assign operators for upcoming sessions, ensuring that the most economically aligned ones secure the network. This mechanism creates a stake-weighted operator selection process where economic security on Ethereum translates to operational security on Tanssi.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#from-tanssi-ethereum","title":"From Tanssi to Ethereum","text":"<p>Tanssi sends operational data back to Ethereum through the same communication channel. This message includes reward information that enables proper distribution to stakeholders based on network performance. The network also transmits slashing event data when operators fail to perform correctly or violate protocol rules, allowing the protocol to apply penalties. Tanssi can also request new tokens to be created on Ethereum and register tokens, making managing assets between both networks easy.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#rewards","title":"Rewards","text":"<p>Well-behaved operators and restakers are rewarded for their participation with TANSSI tokens. The reward process consists of two main phases: Reward Distribution Phase and Reward Claiming Phase.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#reward-distribution-phase","title":"Reward Distribution Phase","text":"<p>The reward distribution phase calculates and allocates rewards through five key steps involving operators, restakers, and smart contracts. The steps are:</p> <ol> <li>Reward Calculation - Tanssi calculates rewards based on the activity of operators and stakers and then creates a Merkle root. This Merkle root is a cryptographic fingerprint that summarizes the reward allocations, indicating who receives what. Stakers are rewarded according to their stake in each vault</li> <li>Reward Data Sent via XCM - reward allocation data is sent using XCM (Cross-Consensus Messaging), a standardized protocol for blockchain communication. Snowbridge acts as a trustless bridge between Tanssi and Ethereum</li> <li>Ethereum Message Reception - once the message is relayed to the <code>Gateway</code> contract, this contract serves as Tanssi's authorized entry point on Ethereum for the Snowbridge bridge</li> <li>Message Processing and Validation - the <code>Gateway</code> forwards the data to the <code>Middleware</code>, which is responsible for various tasks, including passing the information to the <code>OperatorReward</code> contract</li> <li>Reward Storage and Distribution - this is the final destination for the data. The <code>OperatorRewards</code> contract stores the Merkle tree of the reward allocations and handles the transfer of reward tokens when a claim is made</li> </ol> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n    participant Tanssi Network\n    participant Snowbridge (XCM)\n    participant Gateway\n    participant Middleware\n    participant OperatorRewards\n\n    Tanssi Network-&gt;&gt;Tanssi Network: 1. Calculate rewards and generate Merkle root\n    Tanssi Network-&gt;&gt;Snowbridge (XCM): 2. Reward data sent via XCM (Merkle root + data)\n    Snowbridge (XCM)-&gt;&gt;Gateway: 3. Relay message and sent to Ethereum \n    Gateway -&gt;&gt;Middleware: 4. Message processing and validation\n    Middleware-&gt;&gt;OperatorRewards: 5. Reward storage and distribution</code></pre>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#reward-claiming-phase","title":"Reward Claiming Phase","text":"<p>In the reward-claiming phase, operators and stakers can claim rewards based on their participation in the network. Tanssi determines the share distribution for operators and stakers, currently setting it at 20% for operators and 80% for stakers.</p> <ol> <li>Operator Reward Claim - operators can claim their share by calling the <code>OperatorRewards</code> contract by using a cryptographic receipt that verifies their entitlement</li> <li>Token Release - the operator call triggers the token release, and the <code>OperatorRewards</code> sends the established amount to the operator</li> <li>Token Distribution to Stakers - the remaining rewards are forwarded to the <code>StakerRewards</code> contract for further claiming of the staker</li> <li>Staker Allocation - the remaining 80% of the rewards are automatically directed to the <code>StakerRewards</code> contract, where stakers can claim rewards proportional to their stake in the vaults</li> </ol> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n participant Operator\n participant OperatorRewards\n participant StakerRewards\n participant Stakers\n\n Operator-&gt;&gt;OperatorRewards: 1. Operator reward claim\n OperatorRewards-&gt;&gt;Operator: 2. Release rewards to the operator\n OperatorRewards-&gt;&gt;StakerRewards: 3. Forward the remainder to StakerRewards\n Stakers-&gt;&gt;StakerRewards: 4. Stakers claim individual rewards</code></pre>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#slashing","title":"Slashing","text":"<p>The Tanssi protocol implements slashing to penalize operators for misbehavior. When a slashing event is triggered, the authorities designated as resolvers by the vault managers can either accept or revert this action.</p> <p>The following actions can trigger slashing events:</p> <ul> <li>Producing invalid blocks (e.g., blocks that include invalid transactions)</li> <li>Invalid validation (e.g., double-signing or breaking protocol rules)</li> <li>Downtime or unavailability</li> <li>Consensus violations</li> </ul> <p>Note</p> <p>Slashing events can only be triggered by operators' misbehavior within the Tanssi Network. Even if Tanssi networks are faulty or malicious, they operate in a sandboxed environment and cannot cause slashing.</p>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#slashing-process","title":"Slashing Process","text":"<p>The slashing process follows a path similar to that of rewards. When an operator misbehaves, the Tanssi Network sends a slashing request message to the trustless bridge (Snowbridge). The message passes through the <code>Gateway</code> and into the <code>Middleware</code> where the slashing method gets called.</p> <p>The slashing method receives a unique identifier for the operator's identity, the severity of the slash as a percentage of the operator's assigned stake in each vault, and the time context within which the offense occurred.</p> <p>The slashing process consists of the following steps:</p> <ol> <li>Slash Reported - Tanssi sends the slash request to the <code>Middleware</code> with the parameters <code>operatorKey</code>, <code>percentage</code>, and <code>epoch</code></li> <li>Operator Validation - the <code>Middleware</code> validates the operator's identity and checks if the operator is subject to slashing</li> <li>Retrieve Active Vaults - the <code>Middleware</code> iterates through all active vaults during the offense epoch, skipping any inactive vaults</li> <li>Retrieve Operator Stake - for each active vault, the <code>Middleware</code> retrieves the stake of the misbehaving operator</li> <li>Calculate Slash Amount - the <code>Middleware</code> calculates the slashing amount by applying the slashed percentage to the operator's stake in each vault</li> <li> <p>Slashing - depending on the vault's slashing implementation, there are two possible routes</p> <ul> <li> <p>Instant Slashing - if the vault uses instant slashing, the stake is immediately reduced</p> </li> <li> <p>Veto Slashing - if the vault uses veto slashing, the <code>Middleware</code> requests the slashing from a resolver. A time-limited veto window is created (e.g., 7 days)</p> </li> </ul> <p>The slashing is canceled if the resolver vetoes the request within the time window. Otherwise, the slashing penalty is executed if no veto occurs within the time window</p> </li> </ol> <p>This process ensures that each vault's slashing is handled independently, preventing cross-contamination, and offers both instant and time-delayed slashing with dispute resolution mechanisms.</p> <pre><code>%%{init: {'sequence': {'mirrorActors': false}}}%%\nsequenceDiagram\n    participant Network\n    participant Middleware\n    participant Vault\n    participant Slasher\n\n    Network-&gt;&gt;Middleware: 1. Slash reported\n    Middleware-&gt;&gt;Middleware: 2. Operator validation\n    loop Each Active Vault\n        Middleware-&gt;&gt;Vault: 3. Retrieve operator stake\n        Vault--&gt;&gt;Middleware: 4. Retrieve vault stake\n        Middleware-&gt;&gt;Middleware: 5. Calculate slash amount\n        alt Instant Slasher\n            Middleware-&gt;&gt;Slasher: 6.1 Slash\n        else Veto Slasher\n            Middleware-&gt;&gt;Slasher: 6.2 Request slash\n            opt If Not Vetoed\n                Slasher-&gt;&gt;Slasher: 6.2 Execute slash\n            end\n        end\n    end</code></pre>"},{"location":"learn/tanssi/external-security-providers/symbiotic/#burner","title":"Burner","text":"<p>The <code>Burner</code> contract is an extension responsible for handling actions that follow a slashing event, notably the burning of slashed collateral. Once a slash is executed, the <code>Slasher</code> contract calls the <code>Burner</code> to carry out these post-slashing tasks.</p> <p>Within the protocol, the <code>Burner</code> contract plays a crucial role in deciding what happens after slashing. While there are different ways to implement the burning process, the recommended approach is to burn the slashed assets. When a slash is executed, the <code>Burner</code> contract's <code>onSlash</code> function is activated. This function kicks off the process of burning the slashed assets.</p> <p>The vault manager chooses the specific implementation of the burning process during the vault's initialization phase, and once set, the vault manager cannot modify it. The exact design of the <code>Burner</code> contract may differ depending on the type of collateral asset involved. Below are some potential implementation options:</p> <ul> <li>Burning Tokens - if the slashed collateral is a regular ERC-20 token, the <code>Burner</code> destroys those tokens, permanently removing them from circulation</li> <li>Unwrapping and Burning - if the slashed tokens represent something like staked assets (e.g., liquid staking tokens) or liquidity provider (LP) tokens from a decentralized exchange (DEX), the <code>Burner</code> might convert them back into their original form before burning them</li> <li>Cross-Chain Operations - if the tokens are tied to assets on another blockchain, the <code>Burner</code> could unwrap them on Ethereum and trigger the burn process on the original network</li> <li>Alternative Handling - sometimes, burning isn't the best option. Instead, the <code>Burner</code> might redistribute the slashed assets to other operators, compensate affected users, or lock them in liquidity pools\u2014whatever the system is designed to do</li> </ul> <p>Burning slashed collateral is important because it penalizes misbehaving operators and reduces the total supply of tokens, which can have deflationary effects.</p>"},{"location":"learn/tanssi/network-features/","title":"Network Features","text":"<p>The network features in Tanssi are designed to provide the foundational mechanisms that support decentralization, security, and scalability. From securing networks through staking to future capabilities, this section outlines the core elements that empower Tanssi\u2019s network infrastructure.</p>"},{"location":"learn/tanssi/network-features/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/tanssi/network-features/staking/","title":"Tanssi Staking for Block Production","text":""},{"location":"learn/tanssi/network-features/staking/#introduction","title":"Introduction","text":"<p>One of Tanssi's core propositions is to simplify the infrastructure complexity for networks. A significant component is bootstrapping a decentralized set of sequencers, which Tanssi offers through its unique architecture and staking mechanics.</p> <p>Tanssi staking mechanics guarantee that the sequencers for Tanssi-powered networks are selected through a trustless and decentralized mechanism. They also incentivize the community to delegate to top-performing or engaged sequencers.</p> <p>This page covers the fundamental concepts of Tanssi's staking mechanics and how it secures a decentralized block production set that drives network liveness for Tanssi networks.</p> Learn How to Stake -&gt;"},{"location":"learn/tanssi/network-features/staking/#core-concepts","title":"Core Concepts","text":"<p>Tanssi's staking module mechanics were inspired by the concept of liquidity pool tokens (LP tokens) in traditional Automated-Market-Makers (AMMs) like Uniswap V2.</p> <p>Each sequencer has four liquidity pools through which delegators move as they perform different staking operations. In short, each liquidity pool represents a different state throughout the staking process: joining, staking through manual rewards, staking through auto-compound rewards, and leaving. Nevertheless, one core difference is that LP tokens in common AMMs are transferable while staking shares tokens are not.</p> <p>A delegator has four simple transactions to go through the different states (liquidity pools): delegate (for manual or auto-compound rewards), undelegate, swap, and execute pending operations. For example, users who want to stake through either rewards pool can use the delegate call and join the Joining Pool immediately. After a delay, users (or anyone else) can execute the pending operation and enter the initially set rewards pool. Once there, users can swap between reward pools as often as they like. Lastly, users in a rewards pool can use the undelegate call to go into the Leaving Pool and unstake their tokens (or anyone else's) executing the pending operation after a given delay.</p> <p>Liquidity pools have a set of shares that can be considered LP tokens in traditional AMMs. When users join a new liquidity pool, they are given several shares (LP tokens) that depend on the pool type, the number of tokens they staked, the total number of shares, and the total number of tokens staked in that pool.</p> <p>Rewards are assigned to a sequencer's Manual or Auto-Compound Reward Pools when Tanssi attests that the specific block production slot that sequencer was assigned to has been fulfilled, and the block was produced successfully.</p> <p>All rewards (for all pools) are stored in a protocol-owned account. Nevertheless, the protocol internally keeps track of the actual native tokens held by each pool. The core difference between staking through the Manual or Auto-Compound Rewards Pools is how rewards are distributed. In the Manual Rewards Pool, users have to claim any staking rewards they've accumulated manually. In contrast, in the Auto-Compound Rewards Pool, the rewards are automatically re-staked at each Tanssi block, where the protocol announces the sequencer for each block production assignment.</p> <p>The delegate and undelegate operations need to be sent by the delegator itself. They signal the intent of the action to be taken and ask the protocol to perform the necessary checks to allow the delegator to delegate or undelegate. Consequently, these actions can be executed only after a certain number of sessions, but anyone in the network can perform this second operation through the execute pending operation transaction.</p> <p>The following diagram summarizes the high-level flow of a delegator delegating and undelegating tokens to a sequencer. User actions are highlighted in cyan, while different pools are highlighted in coral.</p> <p></p>"},{"location":"learn/tanssi/network-features/staking/#staking-parameters","title":"Staking Parameters","text":"Tanssi MainNetDancelight TestNet Variable Value Joining Delay 7200 blocks (12 hours) Leaving Delay 7200 blocks (12 hours) Variable Value Joining Delay 7200 blocks (12 hours) Leaving Delay 7200 blocks (12 hours)"},{"location":"learn/tanssi/network-features/staking/#staking-pools","title":"Staking Pools","text":"<p>The following section goes through each of the liquidity pools that represent a step throughout the staking process.</p>"},{"location":"learn/tanssi/network-features/staking/#joining-pool","title":"Joining Pool","text":"<p>When a user first delegates to start the staking process, it must state what staking rewards mechanism it wants: manual or auto-compound rewards (each being a separate pool). Once the joining transaction is executed, the user automatically enters the Joining Pool and is given shares of that pool directly correlated to the number of tokens being staked. This pool offers stability to the current set of sequencers by providing a delay between a delegator staking and receiving rewards. The delay is set to at least one entire session.</p> <p>As a practical example, Alice starts the staking process targeting the Manual Rewards Pool and enters the Joining Pool halfway through a session; she must wait until the end of the next session to execute her pending operation to start receiving staking rewards.</p> <p>Joining Pools for each sequencer have a one-to-one ratio of shares per token staked. Therefore, if Alice is staking 100 tokens, she will receive 100 shares (LP tokens) of the Joining Pool she entered. When her delegate pending operation is executed, the protocol consumes her shares of the Joining Pool in favor of native protocol tokens, which are immediately swapped to shares in either the Manual Rewards or Auto-Compound Rewards Pools.</p> <p>The following diagrams assumes a user is staking into the Manual Rewards Pool.</p> <p></p>"},{"location":"learn/tanssi/network-features/staking/#manual-rewards-pool","title":"Manual Rewards Pool","text":"<p>When a user joins the Manual Rewards Pool, the protocol destroys all Joining Pool shares they own in favor of the native protocol token. Next, in the same block, the protocol computes the amount of Manual Pool shares that can be minted with this amount based on the share's price. The price is calculated based on current pool conditions, that is, the number of native tokens and shares that exist:</p> <pre><code>SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool \n</code></pre> <p>Shares don't have decimals. Consequently, any remaining native tokens when acquiring the pool's shares are refunded to the user. The share price is not impacted by users joining the pool, as the ratio is maintained. Once the user has Manual Rewards Pool shares, they earn staking rewards (that is, in the same session) that need to be claimed manually by the user delegating. </p> <p>In contrast to the Auto-Compound Rewards Pool, where reward distribution is done automatically to the specific pool, the distribution for the Manual Rewards Pools operates through a counter checkpoint rewards mechanism. This mechanism tracks the historical native token per share distribution rate assigned to you by the protocol for that particular Manual Reward Pool at a specific point in time. When Tanssi attests that a block was produced by a given sequencer, new rewards are assigned to that Manual Rewards Pool for users to claim, and the rewards counter increases. Therefore, rewards are reflected as the ratio of native tokens per share you receive as staking rewards, which is the difference between the current pool's rewards counter and your original rewards counter checkpoint.</p> <p>Consequently, the native tokens per share rewards counter plays a vital role in the protocol's calculation of the tokens the user is due when they claim their rewards. Once the rewards are calculated, the protocol sends them from the protocol-owned account to the user. Simultaneously, the user's rewards counter checkpoint is reset to the current one set by the pool current counter value. This reset is necessary to ensure the user's new rewards counter aligns and that the due rewards are zero.</p> <p>Similarly, when a user stakes or unstakes tokens, rewards are automatically claimed, and the user's checkpoint rewards counter is reset. Adding or removing a stake means that reward conditions for that specific amount differ from what the protocol has in storage. Consequently, the rewards counter checkpoint must be synced with the pool's rewards counter to ensure no imbalances.</p> <p></p>"},{"location":"learn/tanssi/network-features/staking/#autocompounded-rewards-pool","title":"Auto-Compound Rewards Pool","text":"<p>When a user joins the Auto-Compound Rewards Pool, the protocol destroys all Joining Pool shares they own in favor of the native protocol token. Next, in the same block, the protocol computes the amount of Auto-Compound shares that can be minted with this amount based on the share's price. The price is calculated based on current pool conditions, that is, the amount of native tokens and shares that exist:</p> <pre><code>SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool \n</code></pre> <p>Shares don't have decimals. Consequently, any remaining native tokens when acquiring the pool's shares are refunded to the user. The share price is not impacted by users joining the pool, as the ratio is maintained. Once the user has Auto-Compound Rewards Pool shares, they earn staking rewards (that is, in the same session).</p> <p>In contrast to the Manual Rewards Pool, native token rewards in the Auto-Compound Rewards Pool are automatically assigned to the pool at each Tanssi block where the protocol attests the sequencer for each block production assignment in any Tanssi-powered network. Consequently, as the number of native tokens held in the pool increases but the number of shares stays constant, the share price increases (according to the formula). Therefore, if the users redeem their shares for native tokens, they will receive more native tokens per share than when they joined the pool.</p> <p></p> <p>Native token rewards are automatically assigned as new stake into the Auto-Compound Rewards Pool, hence the auto-compounding nature of this specific staking pool mechanism.</p> <p>Nevertheless, when auto-compound staking rewards are assigned, they are not held in the user's reserved balance, as the protocol-owned account still has them. The increase in the delegator's stake is indirectly represented by the share price increase. However, in specific scenarios, a user might want to let the protocol know that they want that balance to be represented in their state as reserved balance, for example, for governance purposes. </p> <p>Consequently, the protocol offers a specific transaction any user can submit to update the reserve balance of any delegate. This call moves the auto-compound rewards for the specified user from the protocol-owned account to their reserve balance. This is also automatically executed by the protocol when a user removes liquidity from a Auto-Compound Rewards Pool.</p>"},{"location":"learn/tanssi/network-features/staking/#leaving-pool","title":"Leaving Pool","text":"<p>When a user decides to exit their staking positions from a Manual or Auto-Compound Reward Pool, they have the power to initiate an undelegation. This process, similar to when they initially entered the Joining Pool, is a two-step journey. The user signs an intent to remove a specific delegation and patiently waits for at least one entire session before the operation can be executed by anyone.</p> <p>Upon executing the leaving transaction intent, the protocol exchanges shares of the specified pool for native tokens at the current pool price. For the Manual Rewards Pool, any unclaimed rewards are assigned to the user. Simultaneously, the protocol purchases Leaving Pool shares in a one-to-one ratio for the native tokens the user just received. This ensures that the user joins the Leaving Pool, acquiring shares that correspond to the number of native tokens they desire to unstake.</p> <p>After an entire session passes, any user can execute the pending operation. Then, the protocol swaps Leaving Pool shares for native protocol tokens at a one-to-one ratio.</p> <p>The primary purpose of the Leaving Pool is to provide a buffer for users leaving the staking mechanics. This buffer allows the implementation of slashing mechanisms to deter bad behavior. Slashing has not been implemented in Tanssi but could be implemented in the future.</p> <p>The following diagrams assumes a user is unstaking from the Manual Rewards Pool.</p> <p></p>"},{"location":"learn/tanssi/network-features/staking/#swap-rewards-pool","title":"Swapping Between Rewards Pools","text":"<p>Tanssi's staking module allows users to swap their stake from one type of reward pool to another. Users can use this functionality to move partial or full amounts of the staked tokens in a specific pool. The main benefit is that users don't have to go through the Leaving Pool and the Joining Pool again to move their stake.</p> <p>First, all pending Manual Rewards Pool rewards are claimed at a protocol level, as liquidity is either added or removed. Therefore, the checkpoint rewards counter needs to be synced with the pool. Next, shares from the original pool are consumed and exchanged in favor of native protocol tokens at the current pool price. Then, shares of the new pool are attained at that pool's price. Lastly, any dust tokens remaining are automatically exchanged in favor of Leaving Pool shares. Note that all of the above is executed in the same block, and users don't have to wait for delays to earn rewards in the new pool. The dust in the Leaving Pool can be claimed after the required delays have passed.</p> <p></p>"},{"location":"learn/tanssi/network-services/","title":"Network Services","text":"<p>Tanssi's network services provide the essential infrastructure for secure and efficient blockchain operations. At the core of these services, the Tanssi protocol offers block production as a service, ensuring the continuous performance and scalability of decentralized networks.</p>"},{"location":"learn/tanssi/network-services/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/tanssi/network-services/block-production/","title":"Block Production Services","text":""},{"location":"learn/tanssi/network-services/block-production/#introduction","title":"Introduction","text":"<p>As presented in the Overview article, Tanssi is an infrastructure protocol that streamlines the deployment of decentralized networks with custom logic fitting a wide range of use cases, including DeFi, NFTs, Gaming, and any other use case development teams may want to address.</p> <p>Infrastructure poses a huge challenge for developers, requiring them to bootstrap sequencers, data preservers, and RPC endpoints, while also managing integrations, interoperability, and security. This demands valuable time and resources, diverting focus from what truly matters: delivering value to their users.</p> <p>Tanssi orchestrates resources, allowing developers to deploy decentralized networks (also known as actively validated services or AVSs) that are fully adaptable to any specific application or use case. In this analogy, the Tanssi network resembles Kubernetes in its role as an orchestrator, managing resources to guarantee the liveness and performance of the networks.</p> <p>The protocol also tackles the security front by allowing networks to select and connect to external security providers (like Symbiotic), ensuring Ethereum-grade security right from the start.</p> <p>This article covers the necessary aspects to consider when building and deploying your own modular blockchain, along with the most relevant technical aspects of the Tanssi protocol.</p>"},{"location":"learn/tanssi/network-services/block-production/#block-production-as-a-service","title":"Block Production as a Service","text":"<p>The Tanssi protocol provides block production as a service, orchestrating a decentralized and trustless set of sequencers, ensuring the networks' liveness. To do so, the protocol bridges both ends:</p> <ul> <li>Node operators: Who run sequencers, offering their block production services to get rewards.</li> <li>Developers: Who launch networks, which require sequencers.</li> </ul> <p>The protocol assigns a subset of sequencers to provide services to each network, rotating them after a period of time. The sequencers can serve any Tanssi-powered network, regardless of the custom logic they implement. On the other hand, networks deployed through Tanssi can customize their runtime as much as they need to fit their use case and upgrade the logic at any moment in a forkless fashion without worrying about the sequencer's setup.</p> <p>The following diagram illustrates how Tanssi assigns two sequencers to each active network, selecting them from a decentralized set of sequencers.</p> <pre><code>flowchart TB\n    subgraph network1 [Network 1]\n        s1bis[Sequencer 1]\n        s2bis[Sequencer 2]\n    end\n\n    subgraph network2 [Network 2]\n        s3bis[Sequencer 3]\n        s4bis[Sequencer 4]\n    end\n\n    Tanssi[Tanssi Network&lt;br/&gt;Orchestrator]\n\n    subgraph sequencers [Sequencers Pool]\n        direction LR\n        s1[Sequencer 1]\n        s2[Sequencer 2]\n        s3[Sequencer 3]\n        s4[Sequencer 4]\n        sn[Sequencer N]\n\n        s1 --- s2 --- s3 --- s4 --- sn\n    end\n\n    sequencers -- Managed by --&gt; Tanssi\n    Tanssi -- Assigns Sequencers --&gt; network1\n    Tanssi -- Assigns Sequencers --&gt; network2</code></pre>"},{"location":"learn/tanssi/network-services/block-production/#sequencer-selection-process","title":"Sequencer Selection Process","text":"<p>At any given time, all Tanssi networks require a certain number of sequencers, depending on the number of active networks and the current block production configuration set in Tanssi. The configuration sets the maximum number of total sequencers in the set and the number of sequencers each network has to have assigned.</p> Tanssi MainNetDancelight TestNet Variable Value Max. # of Sequencers 100 # of Sequencers (Networks) 5 Variable Value Max. # of Sequencers 100 # of Sequencers (Networks) 2 <p>Once the required number of sequencers for a given session is known, Tanssi uses two mechanisms to decide the set of sequencers distributed among all networks. </p> <p>The first mechanism is through the Invunerables module, which sets a list of fixed sequencers prioritized by the protocol and ensures block production stability in certain scenarios, such as TestNets. </p> <p>The second mechanism is through the Tanssi staking module. The module helps create a decentralized set of sequencers for all Tanssi networks by providing the protocol with a sorted list of sequencers by staked amount. Tanssi appends the sorted list by stake of sequencers to the invulnerable ones (if any), then takes from the list only the exact amount of sequencers needed, starting from the top, leaving out of the next session those sequencers that have less staked value, to finally begin the sequencer assignation process.</p>"},{"location":"learn/tanssi/network-services/block-production/#block_producers-assignment","title":"Sequencers Assignment","text":"<p>Once the sequencer set that will participate in the next session is known, Tanssi shuffles the list and assigns them to provide block production services to the active Tanssi networks.</p> <p>The assignment algorithm will start distributing the sequencers serving the networks by the registration date on a first-come, first-served basis. Once the assignment is made, it will be upheld for at least one session, representing a period measured in blocks with a constant set of sequencers. In Tanssi MainNet, the default session duration is set to 3600 blocks, which, with an average block time of six seconds, translates to (roughly) six hours.</p> <p>Every new assignment works intentionally with a one-session delay, so the sequencers know in advance which one of the networks they are assigned to. Sequencers will start syncing the new network they'll have to serve in the next session with a special syncing mechanism called warp sync. Warp sync allows the sequencers to swiftly sync the new network without acting as an archive node.</p> <p>When a new session starts, the Tanssi protocol will put the queued assignment into effect. Sequencers will automatically change and start producing blocks in the new Tanssi network they've been assigned to while discarding the chain state from the previous assignment. Tanssi will also calculate the new assignment, considering changes in Tanssi networks that might have been activated or deactivated and sequencers that might have been added or removed from the pool or changed the total staked value. This new assignment will be queued for the next session.</p> <p></p>"},{"location":"learn/tanssi/network-services/block-production/#tanssi-newtwork","title":"The Role of the Tanssi Network","text":"<p>As previously discussed, the Tanssi protocol assigns sequencers to the Tanssi networks, and the result of this assignment is stored within the chain state.  Besides running the network node, the sequencers also run the Tanssi one. Hence, by accessing the data stored in the finalized blocks of the Tanssi Network, they can learn their assignation for the session, and the Tanssi networks can confirm that a certain group of sequencers have been assigned to them. </p> <p>As the Tanssi networks produce blocks, those blocks need to be validated and finalized by an external security provider. Once an operator verifies a block, a small proof of validity is produced and stored in Tanssi, keeping track of the proofs for each block of each chain. This small representation of the proof of validity is called candidate receipt and is composed of a set of values, including the state root, which can be used to verify state proofs.</p> <p>Finally, Tanssi can verify that the author of a network block was the expected one and reward accordingly.</p> <p>The following diagram shows a simplified model of the data Tanssi stores in its internal state. For every active network (in this example, two), Tanssi stores the assigned sequencers, which are the only ones authorized to produce blocks on the network's behalf, proof of validity (candidate receipts) extended by the security provider's operators, the latest state root, and the latest sequencer. </p> <p></p>"},{"location":"learn/tanssi/network-services/block-production/#network","title":"The Role of the Tanssi-Powered Network","text":"<p>As a sequencer assigned to a Tanssi-powered network includes built-in Tanssi node functionality, it is technically feasible to read the state from the Tanssi Network.</p> <p>Leveraging this ability to access the states, the current sequencer with the authority to produce a block will read the state of the latest block produced in the Tanssi chain. It will proceed to include this state in the block of the network, the current set of sequencers assigned to the network, and its public signature, allowing Tanssi to know who produced the block and reward the node operator.</p> <p>Once the block is filled with network transactions, it will be proposed as a candidate and handed over to the Tanssi chain, where the security provider's operators will ensure that the included state proofs match the state proofs from the latest state of Tanssi (preventing unauthorized block production) and that the transactions produced valid state transitions. Having verified the work of the sequencer, the operators will finalize the proposed block, including its candidate receipt in a Tanssi Network block.</p> <p></p>"},{"location":"learn/tanssi/network-services/block-production/#block-production-fees","title":"Block Production Fees","text":"<p>As presented in the Introduction, Tanssi is an infrastructure protocol that addresses the complexities and high costs associated with setting up and maintaining blockchain infrastructure, streamlining the deployment of networks. This protocol brings benefits for both participants:</p> <ul> <li>Networks: Teams can focus on the core logic of their product, the UX, and the UI without dealing with the challenges of infrastructure bootstrapping and its management.</li> <li>Sequencers: Bearing with the responsibility of keeping their hardware and software configuration in optimal conditions, they are incentivized to execute transactions and produce blocks on behalf of the Tanssi networks.</li> </ul> <p>Block production as a service carries associated costs that must be covered by the networks that want to leverage Tanssi for such a purpose. The following sections cover the general aspects of those costs and associated service payments.</p>"},{"location":"learn/tanssi/network-services/block-production/#service-payments","title":"Service Payments","text":"<p>There are three main costs associated with block production as a service that any network must cover using Tanssi tokens to deploy successfully and get the block production services:</p> <ul> <li>Registration deposit: The initial deposit that is locked from the account that signs the network registration transaction.</li> <li>Registration storage deposit: The initial deposit that is locked from the account that signs the network registration transaction. It is a variable amount depending on the appchain's runtime size.</li> <li>Sequencers assignment: Every time the Tanssi protocol assigns sequencers, which happens once per session, a fixed fee is charged. This fee gives networks the right to be assigned sequencers and discourages networks whose runtime logic fails to produce valid transactions or blocks.</li> <li>Block production: Networks must pay for each block produced on their behalf. Since the protocol selects and assigns the sequencers on a per-session basis, networks must have enough funds to cover all the blocks to be produced in an entire session to be served.</li> </ul> <p>The current configuration is set as follows:</p> Tanssi MainNetDancelight TestNet Variable Value Registration deposit 1000 TANSSI Registration storage deposit 6.6666666 x 10<sup>-5</sup> TANSSI per appchain runtime byte Sequencers assignment 50 TANSSI per session Block production 0.03 TANSSI per block Variable Value Registration deposit 40 STAR Registration storage deposit 6.6666666 x 10<sup>-5</sup> STAR per appchain runtime byte Sequencers assignment 100 x 10<sup>-6</sup> STAR per session Block production 1 x 10<sup>-6</sup> STAR per block <p>To ensure block production in the next session, the total balance must be at least enough to cover the sequencers assignment cost plus the cost to produce the 3600 blocks that comprise an entire session.</p> <p>Note</p> <p>Although the sequencers assignment and block production costs are currently fixed, as protocol development progresses, they might become dynamic, varying in response to the network's workload.</p>"},{"location":"learn/tanssi/network-services/block-production/#tipping","title":"Tipping","text":"<p>On some occasions, Tanssi might experience a high demand for its block production services that can not be met with the available resources. For example, if there are ten active networks for the next session and Tanssi can only serve eight, two networks will stall for the entire session duration.</p> <p>To deal with these high-workload periods, the Tanssi protocol implements a tipping mechanism that allows networks to compete for a higher priority over the rest. Similar to Ethereum-compatible networks, where a priority fee can be set to outbid competing transactions and obtain preferential execution treatment, the Tanssi networks will be served according to the priority given by the tips they offer. Following the previous example, if there are ten active networks for the next session and Tanssi can only serve eight, then only the eight highest bidding networks will get sequencers assigned.</p>"},{"location":"node-operators/","title":"Node Operators","text":"<p>Operating nodes is a crucial part of maintaining a blockchain ecosystem, and Tanssi ensures that this process is as seamless as possible. From running network nodes and managing sequencers to onboarding operators, this section provides everything you need to get started and operate efficiently.</p> <p>Whether you're setting up for the first time, handling operational tasks, or retiring your node, these guides offer clear and concise instructions to help you maintain secure and reliable operations.</p>"},{"location":"node-operators/#node-types-in-the-tanssi-ecosystem","title":"Node Types in the Tanssi Ecosystem","text":"<p>Understanding the roles of different nodes in the Tanssi-powered network helps you choose the right one based on your desired level of participation in the Tanssi ecosystem:</p> <ul> <li>Network nodes - provide RPC endpoints and data availability services for smooth data flow and interaction between chains and users</li> <li>Sequencers - responsible for block production within the Tanssi ecosystem, sequencers collect transactions, execute them, and compile them in blocks, keeping liveness and operational continuity for all the Tanssi-powered networks</li> <li>Operators - also known as network validators, operators are responsible for securing the ecosystem. They verify every block produced by sequencers within Tanssi-powered networks, checking that the included transactions are valid. Operators must register and stake in the security provider (e.g., Symbiotic). They also produce blocks for the Tanssi network itself, keeping its liveness</li> </ul>"},{"location":"node-operators/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/network-node/","title":"Run a Node","text":"<p>Setting up a network node is essential for interacting with Tanssi or your Tanssi-powered network, providing a secure and dedicated RPC endpoint. This section offers step-by-step guides to help you configure and manage different types of nodes effectively.</p> <ul> <li>Tanssi Node - a Tanssi node connects directly to the Tanssi network, allowing you to interact via RPC endpoint</li> <li>Tanssi-powered Network Node - run a node for your Tanssi-powered network, enabling you to maintain your own RPC endpoint</li> </ul>"},{"location":"node-operators/network-node/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/network-node/tanssi/","title":"Run a Tanssi Node","text":"<p>Setting up a Tanssi Node is an important step in interacting with and querying the Tanssi network. You have two options for configuration: using Docker or Systemd. Whichever path you choose, we provide step-by-step tutorials to guide you through the process.</p>"},{"location":"node-operators/network-node/tanssi/#hardware-requirements","title":"Hardware Requirements","text":"<p>Appropriate hardware is essential for running a Tanssi node successfully. A performant setup ensures reliable service and quick response to queries.</p> <p>Recommended hardware:</p> <ul> <li>Recommended Configuration - bare metal hardware running Linux Debian or Ubuntu</li> <li>Recommended CPUs - Intel Ice Lake or newer (Xeon or Core series), AMD Zen3 or newer (EPYC or Ryzen). Eight Physical cores @ 3.4 GHz with hyperthreading disabled (SMT for AMD processors)</li> <li>Recommended NVMe - 500 GB NVMe SSD</li> <li>Recommended RAM - 32 GB ECC RAM</li> <li>Recommended Network - 1 Gbps connection</li> </ul> <p>Warning</p> <p>Maintaining your Tanssi Node's performance, keeping it updated, and ensuring its security are critical for reliable operation.</p>"},{"location":"node-operators/network-node/tanssi/#required-network-ports","title":"Required Network Ports","text":"<p>To ensure proper communication with the Tanssi network, make sure the following port is open for incoming connections:</p> Network Port Tanssi Chain 30333 (TCP)"},{"location":"node-operators/network-node/tanssi/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/","title":"Run a Tanssi Node Using Docker","text":""},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#introduction","title":"Introduction","text":"<p>In this guide, you'll learn how to spin up a Tanssi node using the official image release with Docker on Linux systems. Nodes are crucial for the Tanssi ecosystem as they provide stable API endpoints that applications and users can connect to for chain data and transaction submission.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#checking-prerequisites","title":"Checking Prerequisites","text":""},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#installing-docker","title":"Installing Docker","text":"<p>To get started, you'll need access to a computer running a Linux OS and install Docker.</p> <p>Run the following command to install Docker on a Linux Ubuntu platform:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>And the following command to check the installation:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>This is what a successful execution in the terminal looks like:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#pull-docker-image","title":"Pull the Docker Image","text":"<p>For every release, a Docker image is built and published. It contains all the necessary dependencies a Tanssi node requires and the binary file itself.</p> <p>A Docker image combines the binary corresponding to the latest stable release of the client node, along with the Tanssi orchestrator specification file.</p> <p>Run the following command to pull the Docker image:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>The command will download and extract the image and show the status upon execution:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#set-up-data-directory","title":"Set Up the Data Directory","text":"<p>Running a node requires syncing with the Tanssi chain and storing its state.</p> <p>Run the following command to create the directory where your node will store the databases containing blocks and chain states:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Or run the following command if you want to run the node with the current logged-in user:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#generate-node-key","title":"Generate the Node Key","text":"<p>To generate and store on disk the session keys that will be referenced in the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#start-your-node","title":"Start Your Node","text":"<p>To spin up your node, you must run the Docker image with the <code>docker run</code> command.</p> <p>Replace <code>INSERT_YOUR_TANSSI_NODE_NAME</code> with a human-readable name and set <code>INSERT_YOUR_IP_ADDRESS</code> with your public IP address.</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>docker run</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li>--state-pruning=archive - keeps all state data, which is necessary for historical state queries</li> <li>--blocks-pruning=archive - keeps all blocks, necessary for historical block data</li> <li>--database=paritydb - uses ParityDB as the database backend, which is optimized for RPC node performance</li> <li>--unsafe-rpc-external - allows external connections to the RPC server. This is required for the node to be accessible externally, but exposing RPC endpoints carries security risks. Ensure appropriate firewall and security measures are in place (see warning below)</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> flag opens your RPC node to external connections. In production environments, you should implement additional security measures like a reverse proxy with rate limiting and authentication.</p> <p>You can view all available flags by running:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>The first time your node spins up, the syncing process displays lots of log information from the node configuration and the chain blocks being synced. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>When the syncing process is finished, your node is ready to serve API requests.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-docker/#testing-your-rpc-node","title":"Testing Your Node","text":"<p>After your node is fully synced, you can verify that the RPC endpoint is working correctly by making a simple request. You can use curl to test the connection:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>If the RPC endpoint is working correctly, you should receive a JSON response containing the latest block header information.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/","title":"Run a Tanssi Node Using Systemd","text":""},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#introduction","title":"Introduction","text":"<p>In this guide, you'll learn how to spin up a Tanssi Node using the latest stable binary file release and manage the service using Systemd on Linux systems. Nodes provide essential API endpoints for applications and users to interact with the Tanssi network.</p> <p>The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need access to a computer running an Ubuntu Linux OS with Landlock enabled and root privileges. You will also need:</p> <ul> <li>Node binary files - a node requires three binary files: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code>, and <code>tanssi-relay-prepare-worker</code> ``</li> </ul> <p>The instructions in this guide execute the latest official stable release. However, you can build your own file by compiling the source code.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#check-landlock","title":"Check Landlock Support","text":"<p>Tanssi nodes use the Linux kernel's Landlock feature as a security measure to restrict access to system resources, limiting the damage if the application is compromised.</p> <p>Check the Landlock feature support in your system by running the following command:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>The output should look like:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>If Landlock is disabled in your system, upgrade the kernel to version 5.13 or above.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#download-latest-release","title":"Download the Latest Release","text":"<p>To get started, download the latest binary release and make it executable by running the following command:</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#set-up-systemd-service","title":"Set Up the Systemd Service","text":"<p>Systemd is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.</p> <p>The following commands configure a new account, create the directory, and move the previously downloaded files to the right location.</p> <ol> <li> <p>Create a new account to run the service:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Create a directory to store the required files and data:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Set the folder's ownership to the account that will run the service to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Move the binaries to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dacelight-data\n</code></pre> </li> </ol>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#generate-node-key","title":"Generate the Node Key","text":"<p>To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#create-systemd-configuration","title":"Create the Systemd Service Configuration File","text":"<p>The next step is to create the Systemd configuration file.</p> <p>You can create the file by running the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Now you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service, replacing the <code>INSERT_YOUR_TANSSI_NODE_NAME</code> tag with a human-readable name and <code>INSERT_YOUR_IP_ADDRESS</code> with your public IP address. The name will come in handy for connecting the log entries and metrics with the node that generates them.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Dancelight systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=dancelight_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/dancelight-data/tanssi-relay --chain=dancelight \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>ExecStart</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li>--state-pruning=archive - keeps all state data, which is necessary for historical state queries</li> <li>--blocks-pruning=archive - keeps all blocks, necessary for historical block data</li> <li>--database=paritydb - uses ParityDB as the database backend, which is optimized for RPC node performance</li> <li>--unsafe-rpc-external - allows external connections to the RPC server. This is required for the node to be accessible externally, but exposing RPC endpoints carries security risks. Ensure appropriate firewall and security measures are in place (see warning below)</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> flag opens your RPC node to external connections. In production environments, you should implement additional security measures like a reverse proxy with rate limiting and authentication.</p> <p>You can view all available flags by running:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#run-the-service","title":"Run the Service","text":"<p>Finally, enable the service and start it for the first time:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>You can verify that the service is up and running correctly by executing the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>Check the logs, if needed, with the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"node-operators/network-node/tanssi/tanssi-node-systemd/#testing-your-rpc-node","title":"Testing Your Node","text":"<p>After your node is fully synced, you can verify that the RPC endpoint is working correctly by making a simple request. You can use curl to test the connection:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>If the RPC endpoint is working correctly, you should receive a JSON response containing the latest block header information.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/","title":"Run a Node on a Tanssi-Powered Network","text":"<p>Setting up a network node is essential for interacting with your Tanssi-powered network and providing a secure and dedicated RPC endpoint. This section offers step-by-step guides to help you configure and manage your node effectively. Explore two different approaches for running your node:</p> <ul> <li>Using Docker - instructions to set up your node in a containerized environment for easy deployment and isolation</li> <li>Using Systemd - guidance for configuring your node as a service, enabling automated management and system integration</li> </ul>"},{"location":"node-operators/network-node/tanssi-powered-network/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/","title":"Run an Appchain Node Using Docker","text":""},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#introduction","title":"Introduction","text":"<p>Running a Tanssi-powered appchain node allows you to connect to and interact with the appchain using your infrastructure via either HTTP or WebSocket protocols.</p> <p>Nodes store block data and network state. However, developers can run different kinds of nodes:</p> <ul> <li> <p>Full Archive Node - a node storing the entire block data and network state at all block heights. Such nodes are helpful when querying historical data from old blocks. However, a full archive node takes up a lot of space</p> </li> <li> <p>Full Pruned Node - a node storing block data and network state up to some specific number of blocks before the current block height. Such nodes are helpful when querying recent data or submitting transactions through your infrastructure. They require much less space than an archival node but don't store the full network state</p> </li> </ul> <p>In this guide, you'll learn how to quickly spin up a Tanssi appchain node using Docker on a Linux computer. However, it can be adapted to other operating systems.</p> <p>Note</p> <p>It is not possible to run an RPC node for quick Trial appchains as they run on a private network, and their nodes are, therefore, unreachable for syncing.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#checking-prerequisites","title":"Checking Prerequisites","text":""},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#installing-docker","title":"Installing Docker","text":"<p>To get started, you'll need access to a computer running a Linux OS and install Docker.</p> <p>Run the following command to install Docker on a Linux Ubuntu platform:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>And the following command to check the installation:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>This is what a successful execution in the terminal looks like:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#getting-specifications-files","title":"Getting Specifications Files","text":"<p>An appchain node needs information about two different blockchains to run properly: the appchain and the Tanssi orchestration chain. </p> <p>That information is a file called chain specifications, and it holds, among other things, the genesis state of the blockchain, allowing the node to verify and sync properly the blocks and state it receives from other nodes.</p> <p>To get the Tanssi specifications file, execute the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>To get the appchain specification file, download it from the dashboard in the dApp by clicking the Network Data link</p> <p></p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#setup-data-directory","title":"Setup the Data Directory","text":"<p>Running a sequencer or an appchain node require syncing with two chains: the Tanssi orchestration chain and the appchain it is working for.</p> <p>Run the following command to create the directory where your node will store the databases containing blocks and chain states:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Or run the following command if you want to run the sequencer with the current logged-in user:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-docker-image","title":"Pulling the Docker Image","text":"<p>Two Docker images are built and published as part of the automated deployment process for every release: one for EVM-compatible appchains and the other for Substrate appchains.</p> <p>These Docker images include all the binary files required to run the latest stable release of the client node. </p> <p>Depending on the type of appchain you want to run the node for, pull the corresponding image.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-evm-docker-image","title":"EVM-Compatible Appchains","text":"<p>If the Tanssi-powered appchain was registered in the dApp choosing the EVM template or uploading a custom specification representing a Tanssi EVM-compatible appchain, then execute the following command to pull the Docker image:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <p>The command will download and extract the image and show the status upon execution:</p> docker pull moondancelabs/container-chain-evm-template  Using default tag: latest      latest: Pulling from moondancelabs/container-chain-evm-template      31ad3619f756: Already exists       8f3d9759dcde: Pull complete       de5eaba9b289: Pull complete       Digest: sha256:4930d631a8ac7f7852754d4cf77bb3317229d768f44092a00295ba50641b2a33      Status: Downloaded newer image for moondancelabs/container-chain-evm-template      docker.io/moondancelabs/container-chain-evm-template:latest"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-substrate-docker-image","title":"Simple Substrate Appchains","text":"<p>If the appchain was registered in the dApp choosing the basic Substrate template or uploading a custom specification file representing a Substrate appchain, then execute the following command to pull the Docker image:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <p>The command will download and extract the image and show the status upon execution, showing a similar output as the previous terminal image.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#start-up-command","title":"Start-Up Command","text":"<p>To spin up your node, you must run the Docker image with the <code>docker run</code> command. Note that you'll need to modify the following parameters:</p> <ul> <li><code>Appchain specs file</code> - replace <code>INSERT_YOUR_APPCHAIN_SPECS_FILE</code> with your appchain specs file name, downloaded in the Getting Specifications Files step.</li> <li><code>Bootnode</code> - a bootnode is a full archive node that is used to sync the network from scratch. You'll need to retrieve your Tanssi network bootnode and replace <code>INSERT_YOUR_NETWORK_BOOTNODES</code> with the actual bootnode information.</li> </ul> Tanssi MainNetDancelight TestNet EVM-compatible AppchainSimple Substrate Appchain <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> EVM-compatible AppchainSimple Substrate Appchain <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <p>Note</p> <p>Only the historical state of the last 256 finalized blocks are kept in the local database by default. To run a full archive node, you must set the <code>--state-pruning archive</code> flag. More information is in the flags section.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#fetching-bootnode-information","title":"Fetching Bootnode Information","text":"<p>Bootnode information can be read directly from Tanssi itself. For example, you can use the developer portal to get the bootnodes for a specific network in Dancelight.</p> <p>To do so, take the following steps:</p> <ol> <li>Select dataPreservers as the module to query</li> <li>Set the storage query to bootNodes</li> <li>Provide your Tanssi network ID</li> <li>Click on the + sign</li> </ol> <p></p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#example-demo-evm-appchain","title":"Full Node Example for Demo EVM Appchain","text":"<p>The following example spins up a full archive RPC node for the demo EVM network deployed on Dancelight with an ID of <code>2001</code>. This example assumes that the specs files were downloaded and are located in the data folder.</p> Demo EVM Appchain (Dancelight) <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=/data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=demoAppchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>docker run</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> EVM-compatible AppchainSimple Substrate Appchain <pre><code>docker run -ti moondancelabs/container-chain-evm-template --help\n</code></pre> <pre><code>docker run -ti moondancelabs/container-chain-simple-template --help\n</code></pre>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>Once your node spins up, the syncing process displays a lot of log information from both the node and the Tanssi appchain. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>Note</p> <p>The length of the syncing process is directly proportional to the size of the chain you are syncing to.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/","title":"Run an Appchain Node Using Systemd","text":""},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#introduction","title":"Introduction","text":"<p>Running a Tanssi-powered appchain node allows you to connect to and interact with the appchain using your infrastructure via either HTTP or WebSocket protocols.</p> <p>Nodes store block data and network state. However, developers can run different kinds of nodes:</p> <ul> <li> <p>Full Archive Node - a node storing the entire block data and network state at all block heights. Such nodes are helpful when querying historical data from old blocks. However, a full archive node takes up a lot of space</p> </li> <li> <p>Full Pruned Node - a node storing block data and network state up to some specific number of blocks before the current block height. Such nodes are helpful when querying recent data or submitting transactions through your infrastructure. They require much less space than an archival node but don't store the full network state</p> </li> </ul> <p>In this guide, you'll learn how to spin up a Tanssi appchain node using a binary executable file and manage the service with Systemd on Linux systems.</p> <p>The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.</p> <p>Note</p> <p>It is not possible to run an RPC node for quick Trial appchains as they run on a private network, and their nodes are, therefore, unreachable for syncing.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need access to a computer running an Ubuntu Linux OS and root privileges. You will also need:</p> <ul> <li> <p>Node binary file - the instructions in this guide execute the latest official stable node release. If you want to build and run your own file, make sure to follow the instructions for building your appchain node.</p> </li> <li> <p>Chain specifications files - the node needs information about two different blockchains to sync and run correctly. The following section will show you how to get those files.</p> </li> </ul>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#getting-specifications-files","title":"Getting Specifications Files","text":"<p>An appchain node needs information about two different blockchains to run properly: the appchain and the Tanssi orchestration chain. </p> <p>That information is a file called chain specifications, and it holds, among other things, the genesis state of the blockchain, allowing the node to verify and sync properly the blocks and state it receives from other nodes.</p> <p>To get the Tanssi specifications file, execute the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>To get the appchain specification file, download it from the dashboard in the dApp by clicking the Network Data link</p> <p></p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#download-latest-release","title":"Download the Latest Release","text":"<p>Every new release includes two node binaries, one for EVM-compatible networks and another for Substrate networks. To get started, run the following command to get the latest release binary that matches your network type and make it executable:</p> EVM-Compatible NetworkSubstrate Network <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-frontier-node &amp;&amp; \\\nchmod +x ./container-chain-frontier-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-simple-node &amp;&amp; \\\nchmod +x ./container-chain-simple-node\n</code></pre> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#setup-systemd-service","title":"Setup the Systemd Service","text":"<p>Systemd is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.</p> <p>The following commands configure a new account, the directory, and move the previously downloaded files to the right location.</p> <p>Create a new account to run the service:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Create a directory to store the required files and data:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the service to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Move the node binary as well: </p> Tanssi MainNetDancelight TestNet EVM-Compatible AppchainSubstrate Network <pre><code>mv ./container-chain-frontier-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/tanssi-data\n</code></pre> EVM-Compatible AppchainSubstrate Network <pre><code>mv ./container-chain-frontier-node /var/lib/dancelight-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/dancelight-data\n</code></pre> <p>Finally, move also your appchain's spec file to the same folder.</p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#create-systemd-configuration","title":"Create the Systemd Service Configuration File","text":"<p>The next step is to create the Systemd configuration file.</p> <p>You can create the file by running the following command:</p> <pre><code>sudo touch /etc/systemd/system/appchain.service\n</code></pre> <p>Now, you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service.</p> <p>Note that the <code>ExecStart</code> command  has some parameters that need to be changed to match your specific network:</p> <ul> <li><code>Specification file</code> - replace <code>INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME</code> with your appchain's file name. Your path will look like <code>/var/lib/tanssi-data/YOUR_FILENAME.json</code>, for a MainNet appchain.</li> <li><code>Bootnode</code> - a bootnode is a full archive node that is used to sync the network from scratch. You'll need to retrieve your Tanssi network bootnode and replace <code>INSERT_YOUR_NETWORK_BOOTNODES</code> with the actual bootnode information.</li> </ul> Tanssi MainNetDancelight TestNet EVM-Compatible AppchainSubstrate Network <pre><code>[Unit]\nDescription=\"Appchain systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-frontier-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Appchain systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-simple-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> EVM-Compatible NetworkSubstrate Network <pre><code>[Unit]\nDescription=\"Appchain systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Appchain systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-simple-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#fetching-bootnode-information","title":"Fetching Bootnode Information","text":"<p>Bootnode information can be read directly from Tanssi itself. For example, you can use the developer portal to get the bootnodes for a specific network in Dancelight.</p> <p>To do so, take the following steps:</p> <ol> <li>Select dataPreservers as the module to query</li> <li>Set the storage query to bootNodes</li> <li>Provide your Tanssi network ID</li> <li>Click on the + sign</li> </ol> <p></p>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#example-demo-evm-network","title":"Full Node Configuration Example for the Demo EVM Network","text":"<p>The following example deploys a fully functional full archive node for the demo EVM network deployed on Dancelight with an ID of <code>2001</code>.</p> <p>The raw chain specification file for the demo network is required to run the node, and can be downloaded from this public GitHub repository. Download the file and place it in the <code>/var/lib/dancelight-data/</code> directory.</p> Demo EVM Appchain (Dancelight) <pre><code>[Unit]\nDescription=\"Appchain systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=para \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--base-path=/var/lib/dancelight-data \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>ExecStart</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> EVM-compatible NetworkSimple Substrate Network <pre><code>/var/lib/dancelight-data/container-chain-frontier-node --help\n</code></pre> <pre><code>/var/lib/dancelight-data/container-chain-simple-node --help\n</code></pre>"},{"location":"node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-the-service","title":"Run the Service","text":"<p>Finally, enable the service and start it for the first time:</p> <pre><code>systemctl enable appchain.service &amp;&amp; \\\nsystemctl start appchain.service\n</code></pre> <p>You can verify that the service is up and running correctly running:</p> <pre><code>systemctl status appchain.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>And check the logs, if needed, with the following command:</p> <pre><code>journalctl -f -u appchain.service\n</code></pre> journalctl -f -u network.service  Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 Parachain Collator Template      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \u270c\ufe0f  version 0.1.0-3b1fbbfdfe7      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \u2764\ufe0f  by Moondance Labs,      2020-2024      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udccb Chain specification: Frontier Container 2001      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83c\udff7  Node name: para      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udc64 Role: FULL      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udcbe Database: RocksDb at /var/lib/network-data/chains/frontier_container_2001/db/full      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain id: Id(2001)      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain Account: 5Ec4AhPQLGvfWywVhJZwufTDvknLT3BVPQcbV977JmBDUsHP      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V0: 0x000000000000000000000000000000000000000000000000000000000000000000e1324cc53e66      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V1: 0x000000000000000000000000000000000000000000000000000000000000000000327cfde8482b"},{"location":"node-operators/operators/","title":"Tanssi Operators","text":"<p>Operators (also known as validators) are responsible for maintaining security within all the Tanssi-powered networks, verifying the integrity and validity of their transactions. They participate in a DPoS (Delegated Proof-of-Stake) consensus mechanism, which improves decentralization and fosters good behavior via economic incentives.</p> <p>This section provides everything you need to get started, from initial setup to operational best practices and account management.</p>"},{"location":"node-operators/operators/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/operators/offboarding/","title":"Offboarding an Operator from Tanssi","text":"<p>Stepping down as an operator requires following the proper procedures to ensure a smooth transition. This section provides clear instructions on offboarding your operator from the Tanssi network.</p> <p>Prerequisites</p> <p>Before starting to offboard your Tanssi node, check the prerequisites.</p> <p>Opt Out from Tanssi (Required)</p> <p>Opt out from the Tanssi network on Ethereum.</p> <p>Vault Opt Out (Optional)</p> <p>This step is optional and only necessary if you want to completely remove your association with the vault. Skipping this step won't affect your ability to rejoin the network in the future.</p> <p>Rejoining as an Operator</p> <p>If you decide to return as a Tanssi validator in the future, you can easily onboard again by following the steps outlined in the Onboarding guide.</p>"},{"location":"node-operators/operators/offboarding/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/","title":"Opt Out from Tanssi","text":""},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#introduction","title":"Introduction","text":"<p>The ability to manage node operators' participation within the Tanssi ecosystem is crucial. This guide addresses the initial step in the offboarding process: opting out of the Tanssi network. This action signals your intent to withdraw and allows the Tanssi protocol to verify your identity as the legitimate operator.</p> <p>During the onboarding process, one step was opting in to the Tanssi network to become an operator. This guide will walk you through the process of opting out. There are several ways to interact with the smart contracts involved. Refer to the prerequisites article to evaluate which alternative suits you best.</p> <p>Identity Validation</p> <p>When opting out, you sign the transaction using the private key or Ledger device associated with your operator account. This signature serves as cryptographic proof that you are the legitimate owner of the operator account, ensuring that only authorized operators can initiate the offboarding process.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#methods-for-opting-out","title":"Methods for Opting Out from a Tanssi Network","text":"<p>To opt out of the Tanssi network, you must interact with a smart contract. Below are the different methods available to perform this action. Choose the one that best fits your setup and security preferences.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-cli","title":"Using the Symbiotic CLI","text":"<p>The Symbiotic CLI provides a straightforward way to opt out of the network. Choose the appropriate command based on your network and signing method.</p> <p>Using a Ledger device:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3  --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>For signing with a private key:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Note that this method requires you to expose your private key; therefore, it is not recommended.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-etherscan","title":"Using Etherscan","text":"<p>You can interact directly with the smart contract through Etherscan using a browser wallet like MetaMask.</p> MainNetTestNet (Sepolia) <p>Contract address: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Contract address: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Make sure to select Contract and Write Contract, then click on Connect to Web3, and select your preferred wallet (e.g., MetaMask): </p> <ol> <li>Expand the optOut function</li> <li>Insert the <code>TANSSI_NETWORK_ADDRESS</code> in the where field. If you are opting out of Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. For TestNet use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Click Write and sign the transaction</li> </ol> <p></p> <p>Warning</p> <p>After submitting your opt out transaction, save the transaction hash. You'll need this hash later for verification in the operation offboarding form.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-safe","title":"Using Safe for Multisig Setups","text":"<p>For Safe accounts, use the Transaction Builder with these addresses:</p> MainNetTestNet (Sepolia) <p>0x7133415b33B438843D581013f98A08704316633c</p> <p>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Finally, pick the optOut function, insert the <code>TANSSI_NETWORK_ADDRESS</code> to which your node is currently registered (<code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code> for Tanssi MainNet and <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> for TestNet), and sign the transaction.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-status","title":"Verifying Your Opt-Out Status","text":"<p>After submitting the opt-out transaction, it's important to confirm that the action was successful and your operator is no longer opted into the network. You can verify this status using the methods outlined below.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-etherscan","title":"Using Etherscan to Verify","text":"<p>You can check your opt-out status on Etherscan by querying the smart contract:</p> MainNetTestNet (Sepolia) <p>Contract address: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Contract address: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>On the contract's page:</p> <ol> <li>Make sure to select the Read Contract tab</li> <li>Locate and expand the isOptedIn function</li> <li>Paste your operator's account address in the who field.</li> <li>Insert the <code>TANSSI_NETWORK_ADDRESS</code> in the where field. If you are opting out of Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. For TestNet use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Click on Query</li> </ol> <p></p> <p>You'll get a <code>false</code> result if your operator has successfully opted out, and <code>true</code> if they are still opted in.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-cli","title":"Using the Symbiotic CLI to Verify","text":"<p>You can also verify your opt-out status using the Symbiotic CLI:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4\n</code></pre> <p>The output will show <code>false</code> if you have successfully opted out and <code>true</code> if you are still opted in.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#contact-tanssi-team","title":"Contact Tanssi Team","text":"<p>Following the network opt-out, the next stage of offboarding your Tanssi operator involves formally notifying the Tanssi team. This page guides you through submitting the required offboarding form and explaining what to expect during the final removal process.</p> <p>After opting out from the network, notify the Tanssi team of your intention to stop running an operator. To do so, complete the operator offboarding form and wait for confirmation of request completion from the Tanssi team.</p> <p>Upon receiving your request, your operator's removal will be scheduled. This step is semi-automated and may take time to complete. You will be notified by email when it is safe to decommission the node. Please do not decommission your node until you receive this notification.</p> <p>Provide feedback</p> <p>Consider providing feedback in the offboarding form about your experience to help improve the Tanssi network.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#pause-operations","title":"Pause Operations (Optional)","text":"<p>Once you receive confirmation of your operator's removal from the Tanssi team, you can safely stop any running services related to your operator. If needed, back up important configuration files, logs, or any relevant data before deleting them. Afterward, you may repurpose, terminate, or shut down your infrastructure entirely.</p>"},{"location":"node-operators/operators/offboarding/opt-out-from-tanssi/#next-steps-vault-opt-out","title":"Next Steps (Optional)","text":"<p>After you have opted out of the network and informed the Tanssi team by submitting the offboarding form, you can take an additional optional step and opt out of any specific vaults your operator might be associated with.</p>"},{"location":"node-operators/operators/offboarding/prerequisites/","title":"Prerequisites for Offboarding","text":""},{"location":"node-operators/operators/offboarding/prerequisites/#introduction","title":"Introduction","text":"<p>Operator offboarding is the formal process by which node operators safely and transparently exit the Tanssi protocol. It ensures network integrity, security, and stability by providing clear steps for operators who wish to cease participation.</p> <p>Operators play a critical role in consensus and network operations. Abruptly shutting down a node without following the proper procedures can negatively impact operators, potentially resulting in slashing.</p> <p>This guide outlines the prerequisites for offboarding, and subsequent guides will walk you through the process.</p> <p>If you have questions during any part of the offboarding process, the Tanssi team can support you on Discord.</p>"},{"location":"node-operators/operators/offboarding/prerequisites/#prerequisites","title":"Prerequisites","text":"<p>Before starting the offboarding process, ensure you have the following:</p> <ul> <li>Access to the Ethereum (EVM) wallet that controls your operator account</li> <li>Sufficient ETH in your wallet to cover gas fees for transactions</li> </ul>"},{"location":"node-operators/operators/offboarding/prerequisites/#why-smart-contracts","title":"Why Smart Contract Interaction is Required","text":"<p>Like many decentralized systems, the Tanssi protocol utilizes smart contracts on the Ethereum blockchain to manage critical operations, including operator registration and staking. When an operator decides to offboard, they change their status and relationship with these core protocol contracts. Key offboarding steps, such as signaling your intent to exit or formally unregistering, involve transactions that update the state recorded in these smart contracts.</p>"},{"location":"node-operators/operators/offboarding/prerequisites/#interaction-methods","title":"Interaction Methods","text":"<p>There are several ways to interact with the smart contracts:</p> <ul> <li>Using the Symbiotic CLI</li> <li>Using Etherscan</li> <li>Using Safe for multisig setups</li> </ul> <p>In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:</p> <ul> <li>Using the account's private key directly (although this method is not recommended)</li> <li>Using a hot wallet, such as MetaMask</li> <li>Using a cold wallet, such as Ledger</li> </ul> <p>The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.</p>"},{"location":"node-operators/operators/offboarding/prerequisites/#set-up-the-cli","title":"Set Up the Symbiotic CLI","text":"<p>The Symbiotic CLI is a tool for interacting with Symbiotic's core smart contracts. It is written in Python, so you'll need to install the Python interpreter and pip, Python's package installer:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Now, with Python installed, download the Symbiotic CLI and its dependencies:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Run the following command to check if the installation was successful:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>The terminal should show a long list of the CLI available commands:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"node-operators/operators/offboarding/vault-opt-out/","title":"Vault Opt Out (Optional)","text":""},{"location":"node-operators/operators/offboarding/vault-opt-out/#introduction","title":"Introduction","text":"<p>This page details the optional final step in the Tanssi offboarding process: opting out of a specific vault. While not mandatory, this action allows operators to disassociate their accounts from individual vaults. Before you go ahead with this step, please make sure you have met all the conditions outlined in our prerequisites guide.</p> <p>This guide provides instructions for opting out using one of several available methods and for verifying the successful completion of this action.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#opting-out-of-a-vault","title":"Opting Out of a Vault","text":"<p>To proceed with opting out of a vault, you can utilize one of the methods detailed in the following sections.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-cli","title":"Using the Symbiotic CLI","text":"<p>Using a Ledger device:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>For signing with a private key:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Note that this method requires you to expose your private key; therefore, it is not recommended.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-etherscan","title":"Using Etherscan","text":"<p>Access the contract through Etherscan:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Contract address: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Make sure to select Contract and Write Contract, then click on Connect to Web3, and select your preferred wallet (e.g., MetaMask): </p> <ol> <li>Expand the optOut function</li> <li>Insert the <code>VAULT_ADDRESS</code> in the where field (e.g., <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> on Sepolia TestNet)</li> <li>Click Write and sign the transaction</li> </ol> <p></p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-safe","title":"Using Safe","text":"<p>For Safe accounts, use these contract addresses in the Transaction Builder:</p> MainNetTestNet (Sepolia) <p>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Finally, pick the optOut function, insert the <code>VAULT_ADDRESS</code> to which your node is currently registered (e.g., <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> on Sepolia TestNet), and sign the transaction.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#verify-vault-opt-out-status","title":"Verify Vault Opt Out Status","text":"<p>After submitting the vault opt out transaction, you can verify your opt out status using one of the methods in the following sections.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#using-etherscan","title":"Using Etherscan","text":"<p>You can check your vault opt out status on Etherscan:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Contract address: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>On the contract's page:</p> <p>Make sure to select Contract and Write Contract, then click on Connect to Web3, and select your preferred wallet (e.g., MetaMask):</p> <ol> <li>Select the isOptedIn function</li> <li>Paste your operator's account in the who field</li> <li>Insert the vault address in the where field</li> <li>Click on Query</li> </ol> <p>You'll get a <code>false</code> result if your operator has successfully opted out of the vault, and <code>true</code> if they are still opted in.</p> <p></p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#using-the-symbiotic-cli","title":"Using the Symbiotic CLI","text":"<p>You can also verify your vault opt out status using the Symbiotic CLI:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482\n</code></pre> <p>The output will show <code>false</code> if you have successfully opted out of the vault and <code>true</code> if you are still opted in.</p>"},{"location":"node-operators/operators/offboarding/vault-opt-out/#next-steps","title":"Next Steps","text":"<p>After completing the offboarding process, if you plan to return in the future, you can follow the onboarding process again.</p>"},{"location":"node-operators/operators/onboarding/","title":"Onboarding","text":"<p>One of Tanssi's core propositions for builders is that it provides Ethereum-grade economic security to every Tanssi-powered network, regardless of its TVL, userbase, or the specifics of the use case. Tanssi's design offers developers a shared security model, alleviating them from having to source enough economic security or negotiate with operators to run nodes opting in for their networks. </p> <p>The Tanssi protocol achieves this by integrating with external security providers, such as Symbiotic. In this model, different vaults associated with Tanssi provide economic security, and reliable operators provide validation services to the Tanssi network.</p> <p>Follow these steps to set up your node and prepare your account for active participation in the Tanssi protocol. </p> <p>Run an operator node</p> <p>Set up the actual node using Systemd or Docker.</p> <p>Register in Symbiotic</p> <p>Add your account to the Symbiotic operators registry. This registry is the central point for identifying operators within the Symbiotic ecosystem.</p> <p>Opt in to Tanssi Network</p> <p>Add your account to the Tanssi network operators registry. This registry is the central point for identifying operators participating in the Tanssi protocol.</p> <p>Opt in to a Tanssi-enabled vault</p> <p>Add your account to a Tanssi-enabled vault. Operators must opt in (and be admitted) to a Tanssi-enabled vault that manages and delegates staked assets to operators.</p> <p>Fill out the application form</p> <p>Fill out the form to apply as an operator. Since this step isn\u2019t fully automated, it may take up to a week for your application to be processed.</p> <p>Set up your account</p> <p>Map your account to your node to start validating in the Tanssi protocol.</p> <p>Set up an on-chain identity</p> <p>Set up an identity to improve the visibility and recognizability of your operator's Substrate account.</p> <p>Once you've fully onboarded, check out the operational tasks related to the maintenance of your node.</p>"},{"location":"node-operators/operators/onboarding/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/operators/onboarding/account-setup/","title":"Set Up Your Account to Secure the Tanssi Ecosystem","text":""},{"location":"node-operators/operators/onboarding/account-setup/#introduction","title":"Introduction","text":"<p>As presented in the onboarding section, once you've successfully opted into a Tanssi-enabled vault, opted into the Tanssi network, and filled out the application form, this is the sixth step of the process. After this step, your node will be able to participate in the Tanssi protocol.</p> <p>In this step, you'll map your Substrate stash account (the one keeping track of your rewards) to your node's session keys (the ones used for communication and consensus), allowing the protocol to include your node in the active set. </p> <p>This guide walks you through generating session keys for your node, mapping them to your account through the Tanssi developer portal, and verifying that the association has been established correctly. </p>"},{"location":"node-operators/operators/onboarding/account-setup/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before setting up your account, make sure that:</p> <ul> <li>You have a node correctly set up and running</li> <li>You have registered as an operator in the Symbiotic registry </li> <li>You have opted in to Tanssi Network and a Tanssi-enabled vault</li> </ul>"},{"location":"node-operators/operators/onboarding/account-setup/#map-account","title":"Map an Account to Your Node","text":"<p>The first step is a two-step process that generates and maps the session keys to your account. Session keys can be compared to the node's ID, and are used to perform network operations, such as signing validity proofs, whereas your account keeps track of your work and related rewards, and could have an on-chain identity. By mapping the session key to your account, you create an association between your account and your node.</p> <p>You will need to create session keys for your primary and backup servers. Each server should have its own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p>"},{"location":"node-operators/operators/onboarding/account-setup/#generate-session-keys","title":"Generate Session Keys","text":"<p>To generate session keys, send an RPC call using the <code>author_rotateKeys</code> method to your node's HTTP endpoint. For reference, if your node's HTTP endpoint is at port <code>9944</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9944 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Your hex-encoded session keys will be printed to the terminal in the <code>\"result\"</code> field.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":    \"0xca17757962a065eeebec2c6e0d2dc7fb24b56967fd9003e4d22bf4981da86fd4ac7cd701462730a76ab539d5a48f4fd2821acf07743335e56eef84d1544686480ada0ff0f38dfccee43515e619e03b0de95a08c74fcbb2da26af55ad144d5f54829a57d7d77bb9333cf9301eaa5d20c384f67388f36b402e33a03b949148325e80b812699fb22d9e4b4976e1d0e9964034489cb0b5b6b70c37d227fb54ffe50b444434b488361038b8b6949c36f0073c6bd52f2907c0991e32257d96bb946c590320539c343fc1f2e1dd1951a0ff38c6c9ea2f93a263e81ee95da1de0697e47e32\"} <p>Note</p> <p>Make sure you write down your session keys. In the next section, you'll need to map them to your account.</p>"},{"location":"node-operators/operators/onboarding/account-setup/#map-session-keys","title":"Map Session Keys","text":"<p>To perform the next step and map your session keys to your account, open the developer portal and head to the Developer tab, Extrinsics section. The following link will take you right there:</p> Tanssi MainNetDancelight TestNet <p>Mainnet developer portal</p> <p>TestNet developer portal</p> <p>Now, take the following steps:</p> <ol> <li>Select your account, which should be the same account that you previously registered with Tanssi</li> <li>Select the session module and the setKeys extrinsic</li> <li>For keys, enter your session keys</li> <li>For proof, enter <code>0x</code></li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p>"},{"location":"node-operators/operators/onboarding/account-setup/#verify-keys-mapping","title":"Verify the Keys Mapping","text":"<p>Using the <code>session.keyOwner</code> method allows you to verify that your session keys have been mapped to your account as expected. This method is accessible through the developer portal, in the Developer tab, Chain state section. The following link will take you right there:</p> Tanssi MainNetDancelight TestNet <p>Mainnet developer portal</p> <p>TestNet developer portal</p> <p>Now, take the following steps:</p> <ol> <li>Select the session module and the keyOwner query</li> <li>Enter <code>gran</code> in the SpCoreCryptoKeyTypeId field</li> <li>For Bytes, enter the first sixty six hex-encoded characters from your session keys (e.g., <code>0x00a12170e0925a9bf98f31bbdd7988550c1bf587766a2d2735e969aa5b4291dc</code>)</li> <li>Click the + button next to the extrinsic field</li> <li>The account associated with the session keys, which should be your account, will be displayed at the bottom of the page</li> </ol> <p></p> <p>And that's it! You've successfully mapped your account, and your node is now eligible to participate in the protocol.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/","title":"Opt In to Tanssi","text":""},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#introduction","title":"Introduction","text":"<p>After successfully registering your node in the Symbiotic protocol, the next steps are to opt in to both Tanssi-enabled vaults and the Tanssi network itself. As presented in the onboarding section, these are the third and fourth steps.</p> <p>This guide will walk through the steps to successfully opt into a Tanssi-enabled vault and the Tanssi network, allowing you to choose between multiple methods, including using the Symbiotic CLI, interacting directly with smart contracts through Etherscan, or utilizing Safe for multisig configurations. </p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before opting into a Tanssi-enabled vault and the Tanssi network, make sure that:</p> <ul> <li>You have a node correctly set up and running</li> <li>You have registered as an operator in the Symbiotic registry </li> </ul> <p>To follow this guide, you must interact with smart contracts, one from Symbiotic's core protocol and the other from Tanssi's integration with Symbiotic.</p> <p>There are several ways to interact with the smart contracts:</p> <ul> <li>Using the Symbiotic CLI</li> <li>Using Etherscan</li> <li>Using Safe for multisig setups</li> </ul> <p>In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:</p> <ul> <li>Using the account's private key directly (although this method is not recommended)</li> <li>Using a hot wallet, such as MetaMask</li> <li>Using a cold wallet, such as Ledger</li> </ul> <p>The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#set-up-the-cli","title":"Set Up the Symbiotic CLI","text":"<p>The Symbiotic CLI is a tool for interacting with Symbiotic's core smart contracts. It is written in Python, so you'll need to install the Python interpreter and pip, Python's package installer:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Now, with Python installed, download the Symbiotic CLI and its dependencies:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Run the following command to check if the installation was successful:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>The terminal should show a long list of the CLI available commands:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults","title":"Opt In to Tanssi-Enabled Vaults","text":"<p>Before enabling your operator to be active within the Tanssi network, you must opt in to at least one of the Tanssi-enabled vaults. The following sections describe several ways to opt into the vaults.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-cli","title":"Opt In Using the Symbiotic CLI","text":"<p>If you have correctly installed the Symbiotic CLI and you want to sign the transaction using a Ledger device, then run the following command, replacing <code>INSERT_VAULT_ADDRESS</code> with the specific one you want to join and <code>INSERT_OPERATOR_ADDRESS</code> with your account:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>If you want to sign the transaction directly using the operator's account private key, then run the following command, replacing the <code>INSERT_PRIVATE_KEY</code> parameter:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Note that this method requires you to expose your private key; therefore, it is not recommended.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-etherscan","title":"Opt In Using Etherscan","text":"<p>You can interact with Symbiotic's smart contracts using Etherscan, and sign the transaction using a browser wallet (MetaMask, for example). </p> <p>To open the contract's page, open the link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Contract address: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Click on Connect to Web3, and select your preferred wallet (e.g. MetaMask):</p> <p></p> <p>Note</p> <p>You can configure MetaMask to use a cold wallet.</p> <p>Once connected:</p> <ol> <li>Expand the <code>optin</code> function</li> <li>Insert the <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> on Sepolia TestNet)</li> <li>Click on Write, and sign the transaction</li> </ol> <p></p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-safe","title":"Opt In Using Safe for Multisig Setups","text":"<p>If you have a Safe account, then open the Transaction builder and insert the following contract address:</p> MainNetTestNet (Sepolia) <p>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>Finally, pick the <code>optin</code> function, insert the <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> on Sepolia TestNet), and sign the transaction.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#check-vault-registration","title":"Check the Registration Status","text":"<p>You can quickly check your registration status on Etherscan. Open the following link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</p> <p>Contract address: 0x95CC0a052ae33941877c9619835A233D21D57351</p> <p>In the contract's page:</p> <ol> <li>Select the <code>isOptedIn</code> function</li> <li>Paste your operator's account in the who field</li> <li>Insert the <code>VAULT_ADDRESS</code> in the where field</li> <li>Click on Query</li> </ol> <p>You'll get a <code>true</code> result if your operator was registered correctly and <code>false</code> otherwise.</p> <p></p> <p>You can also verify your registration status using the Symbiotic CLI running the following command, which prints <code>true</code> or <code>false</code> for any given operator address in a Tanssi-enabled vault:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482\n</code></pre> <p>And the output looks like:</p> python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS Connected to chain ID 1 True"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi","title":"Opt In to the Tanssi Network","text":"<p>Before enabling your operator to be a active within the Tanssi network, you must opt into the network and be approved by the Tanssi team. The following sections describe several ways to opt into the network.</p> <p>Note</p> <p>The MainNet Tanssi Network address will be disclosed upon launch.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-cli","title":"Opt In Using the Symbiotic CLI","text":"<p>If you have correctly installed the Symbiotic CLI and you want to sign the transaction using a Ledger device, then run the following command, replacing <code>INSERT_OPERATOR_ADDRESS</code>:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>If you want to sign the transaction directly using the operator's account private key, then run the following command, replacing the <code>INSERT_PRIVATE_KEY</code> parameter:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Note that this method requires you to expose your private key; therefore, it is not recommended.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-etherscan","title":"Opt In Using Etherscan","text":"<p>You can interact with Symbiotic's smart contracts using Etherscan and sign the transaction using a browser wallet (MetaMask, for example). </p> <p>Go to the contract's page by opening the link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Contract address: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Click on Connect to Web3, and select your preferred wallet (e.g. MetaMask):</p> <p></p> <p>Note</p> <p>You can configure MetaMask to use a cold wallet.</p> <p>Once connected:</p> <ol> <li>Expand the <code>optin</code> function</li> <li>Insert the <code>TANSSI_NETWORK_ADDRESS</code>. If you are opting in for Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. For TestNet use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Click on Write, and sign the transaction</li> </ol> <p></p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-safe","title":"Opt In Using Safe for Multisig Setups","text":"<p>If you have a Safe account, then open the Transaction builder and insert the following contract address:</p> MainNetTestNet (Sepolia) <p>0x7133415b33B438843D581013f98A08704316633c</p> <p>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>Finally, pick the <code>optin</code> function, insert Tanssi Network's address (<code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code> for Tanssi MainNet and <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> for TestNet), and sign the transaction.</p>"},{"location":"node-operators/operators/onboarding/opt-in-to-tanssi/#check-tanssi-registration","title":"Check the Registration Status","text":"<p>You can quickly check your registration status on Etherscan. Open the following link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0x7133415b33B438843D581013f98A08704316633c</p> <p>Contract address: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401</p> <p>On the contract's page:</p> <ol> <li>Select the <code>isOptedIn</code> function</li> <li>Paste your operator's account in the who field</li> <li>Insert the <code>TANSSI_NETWORK_ADDRESS</code> in the where field. If you are opting in for Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. For TestNet use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Click on Query</li> </ol> <p>You'll get a <code>true</code> result if your operator was registered correctly and <code>false</code> otherwise.</p> <p></p> <p>You can also verify your registration status using the Symbiotic CLI running the following command, which prints <code>true</code> or <code>false</code> for any given operator address in the Tanssi Network:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3\n</code></pre> <pre><code>python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 \n</code></pre> <p>And the output looks like:</p> python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 Connected to chain ID 1 True <p>Note</p> <p>Opting in to the Tanssi Networks requires approval by the Tanssi team. Requests to join could take up to one week.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/","title":"Register in Symbiotic","text":""},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#introduction","title":"Introduction","text":"<p>As presented in the onboarding section, registering in Symbiotic is the second step of the process. You should already have the node synced and running, whether using Docker or Systemd. </p> <p>The Tanssi protocol provides its appchains with Ethereum-grade security from the start by relying on external security providers, such as Symbiotic. To participate as an operator in the Tanssi ecosystem, you must first register your node in the Symbiotic protocol. The registration process establishes your node as a recognized operator.</p> <p>This guide will walk you through the steps to successfully register your node as a Symbiotic operator, allowing you to choose between multiple methods, including using the Symbiotic CLI, interacting directly with smart contracts through Etherscan, or utilizing Safe for multisig configurations.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Before registering as an operator, ensure you have already set up the node and it is running.</p> <p>To follow this guide, you must interact with smart contracts. There are several ways to interact with the smart contracts:</p> <ul> <li>Using the Symbiotic CLI</li> <li>Using Etherscan</li> <li>Using Safe for multisig setups</li> </ul> <p>In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:</p> <ul> <li>Using the account's private key directly (although this method is not recommended)</li> <li>Using a hot wallet, such as MetaMask</li> <li>Using a cold wallet, such as Ledger</li> </ul> <p>The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#set-up-the-cli","title":"Set Up the Symbiotic CLI","text":"<p>The Symbiotic CLI is a tool for interacting with Symbiotic's core smart contracts. It is written in Python, so you'll need to install the Python interpreter and pip, Python's package installer:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Now, with Python installed, download the Symbiotic CLI and its dependencies:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Run the following command to check if the installation was successful:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>The terminal should show a long list of the CLI available commands:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#registering-operator","title":"Register as an Operator","text":"<p>The Symbiotic protocol keeps a registry of all operators. Before being able to secure Tanssi-powered networks, node operators must register as operators in the Symbiotic protocol using one of the methods described in the following sections.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#register-with-cli","title":"Register Using the Symbiotic CLI","text":"<p>If you correctly installed the Symbiotic CLI and you want to sign the transaction using a Ledger device, then run the following command, replacing <code>INSERT_OPERATOR_ADDRESS</code> with your account:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS \n</code></pre> <p>If you want to sign the transaction directly using the account private key, then run the following command, replacing the <code>INSERT_PRIVATE_KEY</code> parameter:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Warning</p> <p>Note that this method requires you to expose your private key; therefore, it is not recommended.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#register-with-etherscan","title":"Register Using Etherscan","text":"<p>You can interact with Symbiotic's smart contracts using Etherscan and sign the transaction using a browser wallet (MetaMask, for example). </p> <p>Go to the contract's page by opening the link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Contract address: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Click on Connect to Web3, and select your preferred wallet (e.g. MetaMask):</p> <p></p> <p>Note</p> <p>You can configure MetaMask to use a cold wallet.</p> <p>Once connected:</p> <ol> <li>Expand the <code>registerOperator</code> function</li> <li>Click on Write, and sign the transaction</li> </ol> <p></p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#register-with-safe","title":"Register Using Safe for Multisig Setups","text":"<p>If you have a Safe account, then open the Transaction builder and insert the following contract address:</p> MainNetTestNet (Sepolia) <p>0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Finally, pick the <code>registerOperator</code> function and sign the transaction.</p>"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#check-registration","title":"Check the Registration Status","text":"<p>You can quickly check your registration status on Etherscan. Open the following link:</p> MainNetTestNet (Sepolia) <p>Contract address: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Contract address: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>On the contract's page:</p> <ol> <li>Select the <code>isEntity</code> function</li> <li>Paste your operator's account</li> <li>Click on Query</li> </ol> <p>If your operator was registered correctly, you'll get a <code>true</code> result, and otherwise, <code>false</code></p> <p></p> <p>You can also verify your registration status using the Symbiotic CLI running the following command, which prints <code>true</code> or <code>false</code> for any given operator address:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py isop INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia isop INSERT_OPERATOR_ADDRESS \n</code></pre> <p>And the output looks like:</p> python3 symb.py isop INSERT_OPERATOR_ADDRESS Connected to chain ID 1 True"},{"location":"node-operators/operators/onboarding/register-in-symbiotic/#submitting-metadata","title":"Submit Metadata","text":"<p>Once your operator is successfully registered, you can add metadata (e.g., logo) to improve its visibility on the Symbiotic website.</p> <p>To submit your operator's metadata, head to the Symbiotic metadata repository:</p> MainNet <p>MainNet repository</p> <p>Create a fork of this repo and, within the <code>operators</code> directory, create a new directory named after your operator's address. Within your operator's directory, add your <code>logo.png</code> and a file named <code>info.json</code> with the following fields, replacing the values with your own:</p> info.json<pre><code>{\n    \"name\": \"INSERT_YOUR_OPERATOR_NAME\",\n    \"description\": \"INSERT_YOUR_OPERATOR_DESCRIPTION\",\n    \"tags\": [\n        \"operator\"\n    ],\n    \"links\": [\n        {\n            \"type\": \"website\",\n            \"name\": \"Website\",\n            \"url\": \"https://INSERT_YOUR_WEBSITE_URL\"\n        },\n        {\n            \"type\": \"website\",\n            \"name\": \"X\",\n            \"url\": \"https://INSERT_YOUR_X_URL\"\n        }\n    ]\n}\n</code></pre> <p>Note</p> <p>The <code>links</code> parameter is an array. Add as many links as you need.</p> <p>Finally, open a pull request. The Symbiotic team will review it and merge it.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/","title":"Run an Operator Node","text":"<p>Setting up an operator node is an important step to participate in the Tanssi network. You have two options for configuration: using Docker or Systemd. Whichever path you choose, we provide step-by-step tutorials to guide you through the process and ensure your node meets the necessary requirements to validate the Tanssi-powered network's transactions and provide security to the ecosystem.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/#hardware-requirements","title":"Hardware Requirements","text":"<p>To run an operator node successfully, high-performance hardware is essential. Suboptimal configurations can lead to delays, unavailability, and ultimately, lost rewards and/or penalizations. Since the validation process relies heavily on single-threaded performance, prioritizing CPUs with strong single-thread capabilities over higher core counts is recommended.</p> <p>Recommended hardware:</p> <ul> <li>Recommended Configuration - Bare metal hardware running linux debian or ubuntu</li> <li>Recommended CPUs - Intel Ice Lake or newer (Xeon or Core series) or AMD Zen3 or newer (EPYC or Ryzen). Eight Physical cores @ 3.4 Ghz with hyperthreading disabled (SMT for AMD processors) </li> <li>Recommended NVMe - 500 GB NVMe SSD</li> <li>Recommended RAM - 32 GB ECC RAM</li> <li>Recommended Network - 1 Gbps connection </li> </ul> <p>Warning</p> <p>As an operator, you are responsible for both your own stake and that of your delegators. Maintaining your node's performance, keeping it updated, and ensuring its security are critical for maximizing rewards and building a strong reputation within the Tanssi network.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/#required-network-ports","title":"Required Network Ports","text":"<p>A successful operator must be able to synchronize and interact with one peer-to-peer (P2P) network. To ensure proper communication within the Tanssi ecosystem, make sure the following port is open for incoming:</p> Network Port Tanssi Chain 30333 (TCP)"},{"location":"node-operators/operators/onboarding/run-an-operator/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/","title":"Run an Operator Node Using Docker","text":""},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#introduction","title":"Introduction","text":"<p>Operators are a crucial component of the Tanssi ecosystem, providing security and validation services for Tanssi-powered networks. As an operator, you participate in the consensus mechanism that secures the network while earning rewards for your contribution.</p> <p>As presented in the onboarding section, running the actual node is the first step towards your active participation in the protocol.</p> <p>In this guide, you'll learn how to spin up a Tanssi operator using the official image release with Docker on Linux systems.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#checking-prerequisites","title":"Checking Prerequisites","text":""},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#installing-docker","title":"Installing Docker","text":"<p>To get started, you'll need access to a computer running a Linux OS and install Docker.</p> <p>Run the following command to install Docker on a Linux Ubuntu platform:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>And the following command to check the installation:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>This is what a successful execution in the terminal looks like:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#pull-docker-image","title":"Pull the Docker Image","text":"<p>A Docker image is built and published in every release, containing all the necessary dependencies a Tanssi operator requires and the binary file itself.</p> <p>A Docker image combines the binary corresponding to the latest stable release of the client node, along with the Tanssi orchestrator specification file.</p> <p>The following command to pull the Docker image:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>The command will download and extract the image and show the status upon execution:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#set-up-data-directory","title":"Set Up the Data Directory","text":"<p>Running a node requires syncing with the Tanssi chain and storing its state.</p> <p>Run the following command to create the directory where your node will store the databases containing blocks and chain states:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Or run the following command if you want to run the node with the current logged-in user:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#generate-node-key","title":"Generate the Node Key","text":"<p>To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#start-your-node","title":"Start Your Node","text":"<p>To spin up your node, you must run the Docker image with the <code>docker run</code> command. </p> <p>Replace <code>INSERT_YOUR_TANSSI_NODE_NAME</code> with a human-readable name and set <code>INSERT_YOUR_IP_ADDRESS</code> with your public IP address.</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>docker run</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>The first time your node spins up, the syncing process displays lots of log information from the node configuration and the chain blocks being synced. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>When the syncing process is finished, your node is ready for the next steps.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/","title":"Run an Operator Node Using Systemd","text":""},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#introduction","title":"Introduction","text":"<p>Operators are a crucial component of the Tanssi ecosystem, providing security and validation services for Tanssi-powered networks. As an operator, you participate in the consensus mechanism that secures the network while earning rewards for your contribution.</p> <p>As presented in the onboarding section, running the actual node is the first step towards your active participation in the protocol.</p> <p>In this guide, you'll learn how to spin up a Tanssi operator using the latest stable binary file release and manage the service using Systemd on Linux systems.</p> <p>The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need access to a computer running an Ubuntu Linux OS with Landlock enabled and root privileges. You will also need:</p> <ul> <li>Node binary files - an operator requires three binary files: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code>, and <code>tanssi-relay-prepare-worker</code>.</li> </ul> <p>The instructions in this guide execute the latest official stable release. However, you can build your own file compiling the source code.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#check-landlock","title":"Check Landlock Support","text":"<p>Tanssi operators use the Linux kernel's Landlock feature as a security measure to restrict its own access to system resources, limiting the damage if the application is compromised.</p> <p>Check the Landlock feature support in your system running the following command:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>The output should look like:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>If Landlock is disabled in your system, upgrade the kernel to version 5.13 or above.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#download-latest-release","title":"Download the Latest Release","text":"<p>To get started, download the latest binary release and make it executable by running the following command:</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#set-up-systemd-service","title":"Set Up the Systemd Service","text":"<p>Systemd is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.</p> <p>The following commands configure a new account, create the directory, and move the previously downloaded files to the right location.</p> <ol> <li> <p>Create a new account to run the service:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Create a directory to store the required files and data:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Set the folder's ownership to the account that will run the service to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Move the binaries to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dacelight-data\n</code></pre> </li> </ol>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#generate-node-key","title":"Generate the Node Key","text":"<p>To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#create-systemd-configuration","title":"Create the Systemd Service Configuration File","text":"<p>The next step is to create the Systemd configuration file.</p> <p>You can create the file by running the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Now you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service, replacing the <code>INSERT_YOUR_TANSSI_NODE_NAME</code> tag with a human-readable name and <code>INSERT_YOUR_IP_ADDRESS</code> with your public IP address. The name will come in handy for connecting the log entries and metrics with the node that generates them.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=dancelight \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>ExecStart</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"},{"location":"node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-the-service","title":"Run the Service","text":"<p>Finally, enable the service and start it for the first time:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>You can verify that the service is up and running correctly by executing the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>Check the logs, if needed, with the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"node-operators/operators/operational-tasks/","title":"Operational Tasks","text":"<p>Keeping your operator running requires regular maintenance to ensure consistent performance and secure account management. Regular updates are essential to keep your node compatible with the latest Tanssi protocol changes. At the same time, tools such as proxy accounts provide an extra layer of security by allowing you to delegate specific tasks without exposing your primary account credentials. This section provides the steps to keep your operations smooth, reliable, and secure.</p>"},{"location":"node-operators/operators/operational-tasks/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/","title":"Set Up an Operator Proxy Account","text":""},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and help keep the underlying accounts safe. As an operator on Tanssi, it's beneficial to use proxy accounts to interact with the network in place of your account.</p> <p>The <code>SessionKeyManagement</code> proxy type conveniently allows the account to rotate session keys on behalf of the primary account. It transforms it into a \"hot wallet\" that performs regular maintenance duties on behalf of your \"cold wallet\" operator account. For added safety, you can regularly rotate your proxy account.</p> <p>Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum access required to carry out their duties via a specific proxy account.</p> <p>This tutorial will walk you through configuring a <code>SessionKeyManagement</code> proxy account on Dancelight specifically for operator-related actions and demonstrate how to rotate your newly created keys using the proxy.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to:</p> <ul> <li> <p>Open the developer portal</p> Tanssi MainNetDancelight TestNet <p>Mainnet developer portal</p> <p>TestNet developer portal</p> </li> <li> <p>Create or have two accounts accessible in the developer portal</p> </li> <li>Both accounts will need to be funded with tokens</li> </ul> <p>If you need help importing your accounts into the developer portal, please check out the Connecting to the Developer Portal guide.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#create-a-proxy-account","title":"Create a Proxy Account","text":"<p>There are a couple of ways you can create proxy accounts in the developer portal, either from the Extrinsics page or the Accounts page. However, you must use the Extrinsics page to create a time-delayed proxy. The delay provides an additional layer of security for proxies by specifying a delay period based on the number of blocks. This setting prevents the proxy account from executing a transaction until the delay period ends, allowing the primary account that controls the proxy to review or cancel pending transactions.</p> <p>You can also create a proxy of type <code>Any</code>, which grants the proxy account full and unrestricted control over the primary account. The proxy account can transfer funds and perform any arbitrary action. The following demo will showcase how to configure a <code>SessionKeyManagement</code> proxy, which is more restrictive than an <code>Any</code> proxy, as it limits functionality to activities that pertain to mapping session keys.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-extrinsics","title":"Using the Extrinsics Section","text":"<p>To start creating your proxy account, head to the Developer tab and select Extrinsics from the dropdown. Next, you will need to take the following steps:</p> <ol> <li>Select the primary account</li> <li>From the submit the following extrinsic dropdown, select proxy</li> <li>Choose the addProxy extrinsic</li> <li>Choose Id from the AccountIdLookupOf dropdown</li> <li>Select the delegate account for the proxy</li> <li>From the proxyType dropdown, choose SessionKeyManagement</li> <li>Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to authorize and sign the transaction. Click Sign and Submit to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-accounts","title":"Using the Accounts Section","text":"<p>Another method for creating a proxy is by using the Accounts section of the developer portal. To do so, navigate to the Accounts page and take the following steps:</p> <ol> <li>Select the three vertical dots next to the primary account</li> <li>Select Add proxy</li> </ol> <p></p> <p>Note</p> <p>If the account already has a proxy, Manage proxies will be displayed as an option instead of Add proxy.</p> <p>A pop-up will appear where you can enter the required information, such as the proxied/primary account, the proxy account, and the type of proxy to create a proxy account. First, click Add proxy.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Select the account you would like to set as a proxy</li> <li>Select the proxy type</li> <li>Click Submit and sign the transaction</li> </ol> <p></p> <p>In the next section, you will learn how to verify if your proxy account was set up successfully.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#verify-your-proxy-account","title":"Verify Your Proxy Account","text":"<p>You can verify that your proxy account has been successfully set up in two ways: through the Accounts page or via the Chain state page.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-chain-state","title":"Using the Chain State Section","text":"<p>To check your proxy accounts from the Chain state section of the developer portal, you can take the following steps:</p> <ol> <li>From the selected state query dropdown, select proxy</li> <li>Choose the proxies entry from the list</li> <li>Select or paste your primary/proxied account</li> <li>Click on the + button to send the query</li> </ol> <p></p> <p>The result will appear on the page showing you information about your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies, expressed in Planck units.</p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-accounts-section","title":"Using the Accounts Section","text":"<p>You can also check your proxy accounts from the Accounts section of the developer portal. To do so, navigate to the Accounts page and take the following steps:</p> <ol> <li>Select the three vertical dots next to the primary account</li> <li>Select Manage proxy</li> </ol> <p>Note</p> <p>There should be a proxy symbol next to the primary account. To achieve the same effect, hover over the icon and click Manage proxies.</p> <p></p> <p>A pop-up will appear where you can see an overview of your proxy accounts.</p> <p></p>"},{"location":"node-operators/operators/operational-tasks/proxy-accounts/#execute-a-proxy-transaction","title":"Execute a Proxy Transaction","text":"<p>Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy on behalf of your primary account. The following example will set keys for a node. The proxy configuration shown is a realistic example of how you might have your own proxy configured for your developer portal primary account.</p> <p>To execute a transaction, you can navigate back to the Extrinsics page and take the following steps:</p> <ol> <li>Select the proxy account to submit the transaction from the using the select account dropdown</li> <li>From the submit the following extrinsic menu, select proxy</li> <li>Choose the proxy extrinsic</li> <li>Choose Id from the AccountIdLookupOf dropdown</li> <li>Select the primary account from the real dropdown</li> <li>Select the Session call</li> <li>Choose the setKeys entry</li> <li>Enter the node keys you want to map to your operator's account</li> <li>Enter <code>0x</code> in proof</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear asking you to authorize and sign the transaction; click on Sign and Submit.</p> <p>That's it! You've successfully executed a transaction using a proxy account on behalf of your primary operator account.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/","title":"Upgrade an Operator Node","text":"<p>Keeping your node updated is critical to maintaining compatibility with the latest Tanssi protocol changes and ensuring optimal performance. Outdated nodes can lead to desynchronization, reduced efficiency, or even an inability to participate in the protocol. By staying current with client releases, you can ensure your node operates securely and reliably within the network.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/#explore-what-this-section-covers","title":"Explore What This Section Covers","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/","title":"Upgrade Your Node Running via Docker","text":""},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#introduction","title":"Introduction","text":"<p>Keeping your node up-to-date is an important part of being a Tanssi operator. Not only does it help ensure that your node stays healthy, but it also contributes to keeping the entire Tanssi Network running smoothly.</p> <p>This tutorial covers upgrading your Tanssi operator node that was configured using Docker. It assumes you have already set up your account and launched an operator node using Systemd.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes","title":"Upgrade Docker Nodes","text":"<p>Upgrading your node is as simple as stopping the running container and restarting it with the new version tag.</p> <p>First, get the container ID of your Tanssi operator node with the following command:</p> <pre><code>docker ps -a\n</code></pre> <p>The container ID is the first column and if you're running multiple Docker containers, you can identify it by the image name of <code>moondancelabs/starlight</code>. You can run the stop command as follows:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>Your terminal interaction will resemble the following:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/dancelight-chain:2 \"/chain-network/tans\u2026\" 56 seconds ago  Up 56 seconds             determined_darwin      docker stop aa751703d6aa  aa751703d6aa    <p>To restart the node, you can use the same command you used when launching your node the first time. The command pulls the image and the node will resume syncing blocks from where it left off when the Docker process was stopped.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag","title":"Specify a Version Tag","text":"<p>To use a specific version tag, append it to the image name. For example, to fetch the version tagged <code>latest</code> (which is the default), append <code>:latest</code> to <code>moondancelabs/starlight</code>.</p> <p>And that's it! You've successfully upgraded your Tanssi node.</p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/","title":"Upgrade Your Node Running via Systemd","text":""},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction","title":"Introduction","text":"<p>Keeping your node up-to-date is an important part of being a Tanssi operator. Not only does it help ensure that your node stays healthy, but it also contributes to keeping the entire Tanssi Network running smoothly.</p> <p>This tutorial covers upgrading your Tanssi operator node that was configured using Systemd. It assumes you have already set up your account and launched a operator node using Systemd.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node","title":"Upgrading Your Systemd Node","text":"<p>If you're running your operator via the Systemd service, you must take steps to upgrade your node correctly. In short, you'll need to stop the service, replace the Tanssi binary with the updated version, and restart the service.</p> <p>You can stop your Tanssi Systemd service with the following command:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Then, navigate to the directory where your Tanssi binaries are stored and remove them.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>If you haven't changed your Tanssi binary file names, they will be named <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code>, and <code>tanssi-relay-prepare-worker</code>. Otherwise, you can replace <code>tanssi-relay*</code> in the command below with the correct names of your Tanssi binary files.</p> <pre><code>rm tanssi-relay*\n</code></pre> <p>To download the latest release and change permissions on it so the Tanssi service can use it, run the following command that corresponds to your environment:</p> GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <p>You can restart your Tanssi Systemd service with the following command:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>The node will resume syncing blocks from where it left off when the Systemd service was stopped. To verify that it is running correctly, you can use the following command to check the logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>And that's it! You've successfully upgraded your Tanssi node.</p>"},{"location":"node-operators/sequencers/","title":"Tanssi Sequencers","text":"<p>Sequencers play a critical role in maintaining the liveness and performance of the Tanssi ecosystem. They are responsible for producing blocks, executing transactions, and ensuring the network's smooth operation. This section provides everything you need to get started, from initial setup to operational best practices and account management.</p>"},{"location":"node-operators/sequencers/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/sequencers/offboarding/","title":"Offboarding","text":"<p>Stepping down as a sequencer requires following the proper procedures to ensure a smooth transition. This section provides clear instructions to unmap your session keys and undelegate your self-bonded stake, allowing you to safely reclaim your funds and disconnect your account from the network.</p> <p>What you\u2019ll learn:</p> <ul> <li>Removing your self-delegation - steps to remove your self-bonded stake and ensure your sequencer is no longer listed as an eligible participant</li> <li>Unmapping session keys - how to unmap your session keys, properly severing the connection between your node and your account</li> </ul> <p>Rejoining as a Sequencer</p> <p>If you decide to return as a Tanssi sequencer in the future, you can easily onboard again by following the steps outlined in the Onboarding guide.</p>"},{"location":"node-operators/sequencers/offboarding/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/sequencers/offboarding/account/","title":"Offboard as a Tanssi Sequencer","text":""},{"location":"node-operators/sequencers/offboarding/account/#introduction","title":"Introduction","text":"<p>As a sequencer, there may come a time when you need to gracefully exit the network. Decommissioning your account involves a two-step process to ensure that your node is properly disassociated from your account and that you receive your bond back.</p> <p>This guide will show you how to wind down your operations as a Tanssi sequencer properly. This includes undelegating your self-delegation to reclaim your bond and unmapping your session keys to sever the connection between your node and your account. Naturally, this guide assumes that you're an existing Tanssi sequencer with a sequencer node and mapped session keys.</p>"},{"location":"node-operators/sequencers/offboarding/account/#request-undelegation","title":"Request Undelegation","text":"<p>When you set up your Tanssi sequencer, you had to submit a delegation bond (at least <code>10000</code> TANSSI for Tanssi MainNet). To get that back and remove your sequencer from the list of eligible candidates, you'll need to take steps similar to those in the onboarding process.</p>"},{"location":"node-operators/sequencers/offboarding/account/#viewing-existing-stake","title":"View Existing Stake","text":"<p>Before undelegating, it is helpful first to see how much you have staked, as you'll need to provide this figure later. To do so, head to the developer portal, click on the Developer tab, select Chain State from the dropdown, and take the following steps:</p> <ol> <li>Select the pooledStaking module</li> <li>Select the pools query</li> <li>Enter your sequencer account</li> <li>Ensure that the include option slider is toggled on</li> <li>In the option field, you select JoiningShares</li> <li>Click the + button next to the extrinsic field</li> </ol> <p></p> <p>Note, JoiningShares returns only the initial amount you delegated when configuring your sequencer. To get your total amount staked, you'll need to repeat the above steps for either ManualRewardShares or ManualRewardSharesHeldStake if you didn't select Autocompounding, and either AutoCompoundingShares or AutoCompoundingSharesHeldStake if you configured Autocompounding. Then add your autocompounding or manual shares value to JoiningShares to get your total delegation outstanding.</p> <p>As an example, the total stake of an autocompounding sequencer can be calculated by adding JoiningShares to AutoCompoundingShares. Note this amount, as you'll need it in the next section.</p>"},{"location":"node-operators/sequencers/offboarding/account/#submit-undelegation-request","title":"Submit Undelegation Request","text":"<p>Head to the developer portal, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account from which you want to send the transaction. This account must be your existing sequencer account that you initially delegated from</li> <li>Select the pooledStaking module</li> <li>Select the requestUndelegate extrinsic</li> <li>Enter your account, which is, again, the same account you are sending the extrinsic from and the account you want to decommission as a sequencer</li> <li>Choose the target pool that you originally used when configuring your delegation (either Autocompounding or Manual)</li> <li>Select Stake or Shares from the dropdown</li> <li>Enter the amount to unstake. If you selected Shares, simply enter the number of Shares. If you selected Stake, you'll need to submit the value, including the twelve decimal places used by the Tanssi Network. As a reminder, the minimum stake amount is <code>10000</code> TANSSI. If you delegated the minimum amount and didn't accumulate additional rewards, you'll need to enter <code>10000000000000000</code></li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p>"},{"location":"node-operators/sequencers/offboarding/account/#execute-pending-request","title":"Execute the Pending Request","text":"<p>You'll need to wait before executing the pending request. In the case of Tanssi MainNet, the waiting period is configured to at least two sessions. Each session is comprised of <code>3600</code> blocks and translates to about 6 hour per session. So, two sessions correspond to approximately twelve hours.</p> <p>Before executing the pending request, you'll need to retrieve the session at which you submitted the request to delegate. To do so, head to the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the pooledStaking module</li> <li>Select the pendingOperations query</li> <li>Enter your sequencer account</li> <li>Toggle the include option slider off</li> <li>Click the + button next to the extrinsic field</li> <li>The pending request will be displayed at the bottom of the page</li> </ol> <p></p> <p>In the example in the above image, the undelegate request to leave the auto-compounding pool was submitted during session <code>5,037</code>. So, the request can be executed starting at session <code>5,039</code>. Take note of the operation and the session index at which you submitted the request, as you'll need both values to execute the pending request.</p> <p>You can run another query from the Chain state page to check the current session. To do so, you can:</p> <ol> <li>Select the session module</li> <li>Select the currentIndex query</li> <li>Click the + button next to the extrinsic field</li> <li>The current session will be displayed at the bottom of the page</li> </ol> <p></p> <p>If at least two sessions have passed from the session you submitted the extrinsic, the request is ready to be executed. To do so, select Extrinsics from the Developer dropdown and take the following steps:</p> <ol> <li>Select the account from which you want to send the extrinsic</li> <li>Select the pooledStaking module</li> <li>Select the executePendingOperations extrinsic</li> <li>For delegator, enter your account, which is the same account you sent the self-delegate request from</li> <li>For operation, select Leaving</li> <li>For candidate, enter the same account as you did in the delegator field</li> <li>For at, enter the session index at which you submitted the delegate request</li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p>"},{"location":"node-operators/sequencers/offboarding/account/#verify","title":"Verify That Your Account Is Not in the List of Eligible Candidates","text":"<p>If you'd like, you can verify that your sequencer is no longer in the list of eligible candidates. To do so, go to the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the pooledStaking module and the sortedEligibleCandidates query</li> <li>Click the + button next to the extrinsic field</li> <li>A list of the eligible candidates and their stakes will be displayed at the bottom of the page. You can search for your address to ensure that it does not exist in the list</li> </ol> <p></p>"},{"location":"node-operators/sequencers/offboarding/account/#unmap-session-keys","title":"Unmap Session Keys","text":"<p>Session keys are used to perform network operations, such as signing blocks, whereas your sequencer account holds the staked funds and has an on-chain identity. By unmapping the session key to your account, you sever the association between your sequencer account and your sequencer node.</p> <p>The unmapping step is taken only as part of the offboarding process. If you need to rotate/change your session keys, you'll need to follow the generating and mapping new session keys. You should not purge your keys during the session key rotation process.</p> <p>To unmap your session keys, head to the developer portal, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your Tanssi sequencer account</li> <li>Select the session module</li> <li>Select purgeKeys extrinsic</li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p> <p>Using the <code>session.keyOwner</code> method, you can verify that your session keys have been unmapped from your account as expected. To do this on the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the session module</li> <li>Select the keyOwner query</li> <li>Enter <code>nmbs</code> in the SpCoreCryptoKeyTypeId field</li> <li>For Bytes, enter your hex-encoded session keys</li> <li>Click the + button next to the extrinsic field</li> <li>The query should return none</li> </ol> <p></p> <p>And that's it! You have successfully offboarded a Tanssi sequencer. If you change your mind at any point and want to onboard back as a Tanssi sequencer, you can follow the steps in the onboarding guide.</p>"},{"location":"node-operators/sequencers/onboarding/","title":"Onboarding","text":"<p>Your journey as a sequencer begins here. Follow these steps to set up your node and prepare your account for active participation in the Tanssi network.</p> <p>Run a sequencer</p> <p>Set up the actual node using Systemd or Docker.</p> <p>Set up your account</p> <p>Map your account to your node's session keys.</p> <p>Self-delegate assets</p> <p>Delegate assets to your own account to become eligible for sequencing.</p> <p>Set up an on-chain identity</p> <p>Set up an identity to improve the visibility and recognizability of your sequencer.</p>"},{"location":"node-operators/sequencers/onboarding/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/","title":"Set Up Your Account to Produce Blocks on Tanssi","text":""},{"location":"node-operators/sequencers/onboarding/account-setup/#introduction","title":"Introduction","text":"<p>Before you can start producing blocks on Tanssi-powered networks, you'll need to set up your account and establish your eligibility.</p> <p>You must have spun up a Sequencer node to tackle the account setup steps in this guide.</p> <p>You'll need to set up your account by generating session keys and mapping those session keys to your account.  This account is the one to which delegators will choose to delegate and where your rewards will be distributed. You can optionally establish a proxy account for additional security. </p> <p>To establish eligibility, you must delegate yourself as a sequencer and meet the minimum bond requirements.</p> <p>By following the steps outlined in this guide, you'll learn everything you need to know to get started producing blocks within the Tanssi ecosystem.</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#important-variables","title":"Important Variables","text":"<p>When establishing eligibility to produce blocks, there are a couple of variables to be aware of:</p> <ul> <li>Minimum self-delegation - there is a minimum amount you must self-delegate to be considered eligible</li> <li>Session - a period that has a constant set of sequencers</li> <li>Network sequencers per session - the number of sequencers assigned to a Tanssi-powered network per session</li> </ul> Tanssi MainNetDancelight TestNet Variable Value Minimum self-delegation 10000 TANSSI Session 3600 blocks Network sequencers per session 5 sequencers Variable Value Minimum self-delegation 10000 STAR Session 3600 blocks Network sequencers per session 2 sequencers"},{"location":"node-operators/sequencers/onboarding/account-setup/#map-account","title":"Map an Account to Your Sequencer Node","text":"<p>The first step is a two-step process that generates session keys and maps the session keys to your account. Session keys are used to perform network operations, such as signing blocks, whereas your account holds the staked funds and has an on-chain identity. By mapping the session key to your account, you create an association between your account and your sequencer.</p> <p>You will need to create session keys for your primary and backup servers. Each of your servers, your primary and backup, should have its own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#generate-session-keys","title":"Generate Session Keys","text":"<p>Before generating session keys, you must be running a sequencer node.</p> <p>To generate session keys, you'll send an RPC call, using the <code>author_rotateKeys</code> method, to your node's HTTP endpoint. For reference, if your sequencer's HTTP endpoint is at port <code>9945</code>, the JSON-RPC call might look like this:</p> <pre><code>curl http://127.0.0.1:9945 -H \\\n\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Your hex-encoded session keys will be printed to the terminal in the <code>\"result\"</code> field.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"result\":    \"0x76afaf334bd33b82d0b8fbd6a2845cb3b9b785edf1dce4ccefd4973fa79fed2b\",\"id\":1} <p>Make sure you write down your session keys; you'll need to map your session keys to your account in the next section.</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#map-session-keys","title":"Map Session Keys","text":"<p>To perform the next step and map your session keys to your account, head to the developer portal, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select your account, which should be the same account that you previously self-delegated</li> <li>Select the session module and the setKeys extrinsic</li> <li>For keys, enter your session keys</li> <li>For proof, enter <code>0x</code></li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p> <p>Using the <code>session.keyOwner</code> method, you can verify that your session keys have been mapped to your account as expected. To do this on the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the session module and the keyOwner query</li> <li>Enter <code>nmbs</code> in the SpCoreCryptoKeyTypeId field</li> <li>For Bytes, enter your hex-encoded session keys</li> <li>Click the + button next to the extrinsic field</li> <li>The account associated with the session keys, which should be your account, will be displayed at the bottom of the page</li> </ol> <p></p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#submit-self-delegation","title":"Submit Self-Delegation","text":"<p>The next step towards becoming eligible to produce blocks on Tanssi-powered networks is to delegate to your own account. To do this, you'll be required to submit a minimum of tokens, as listed in the important variables section.</p> <p>After you've submitted the request to delegate, you'll need to wait for a minimum of sessions before you can execute the pending request. In the case of Tanssi MainNet, the number of sessions is configured to two. There are 3600 blocks in a session. So, two sessions are 7200 blocks, which can take around twelve hours.</p> <p>Sequencers are assigned upon each session. The sequencers participating in the session are picked from the list of candidates ordered by total stake until the total number of sequencers required is covered. So, you'll need to ensure that your total stake is enough to fill one of the slots, which may require more than the minimum self delegation.</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#request-delegate","title":"Request Delegate","text":"<p>Head to the developer portal, click on the Developer tab, select Extrinsics from the dropdown, and take the following steps:</p> <ol> <li>Select the account from which you want to send the transaction. This account must be the same account that you are delegating to and is the account that you want to become a sequencer</li> <li>Select the pooledStaking module and the requestDelegate extrinsic</li> <li>Enter your account, which is, again, the same account you are sending the transaction from and the account you want to become a sequencer</li> <li>Choose the target pool. The pool can either be the auto-compounding pool, which auto-compounds delegation rewards, or the manual rewards pool, in which all actions related to rewards are manual</li> <li>Enter the amount to stake. This amount must meet the minimum, which is 10000 TANSSI tokens for Tanssi MainNet. Tanssi Network uses twelve decimal places, so when submitting the value make sure you add the decimal places to the self delegation. For MainNet, the value would be <code>10000000000000000</code></li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#execute-pending-request","title":"Execute the Pending Request","text":"<p>Before executing the pending request, you'll need to retrieve the session at which you submitted the request to delegate. To do so, head to the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the pooledStaking module and the pendingOperations query</li> <li>Enter your account</li> <li>Toggle the include option slider off</li> <li>Click the + button next to the extrinsic field</li> <li>The pending request will be displayed at the bottom of the page</li> </ol> <p></p> <p>In the example in the above image, the delegate request to join the auto-compounding pool was submitted during session 4,829. So, the request can be executed starting at session 4,831.</p> <p>Take note of the operation and the session number at which you submitted the request, as you'll need both values to execute the pending request.</p> <p>You can run another query from the Chain state page to check the current session. To do so, you can:</p> <ol> <li>Select the session module and the currentIndex query</li> <li>Click the + button next to the extrinsic field</li> <li>The current session will be displayed at the bottom of the page</li> </ol> <p></p> <p>If the request can be executed, select Extrinsics from the Developer dropdown and take the following steps:</p> <ol> <li>Select the account from which you want to send the transaction</li> <li>Select the pooledStaking module and the executePendingOperations transaction</li> <li>For delegator, enter your account, which is the same account you sent the self-delegate request from</li> <li>For operation, select the type of operation to execute. This should be either JoiningAutoCompounding or JoiningManualRewards, depending on the target pool you selected at the time of submitting the self-delegation request</li> <li>For candidate, enter the same account as you did in the delegator field</li> <li>For at, enter the session id at which you submitted the delegate request</li> <li>Click Submit Transaction and sign and send the transaction from your wallet</li> </ol> <p></p> <p>Now, you have completed all of the necessary account setup to be eligible to produce blocks!</p>"},{"location":"node-operators/sequencers/onboarding/account-setup/#verify","title":"Verify That Your Account Is in the List of Eligible Candidates","text":"<p>If you've followed all of the steps in this guide and have fully synced your sequencer, you are now eligible to produce blocks. To verify that you are in the list of eligible candidates, you can go to the developer portal, click on the Developer tab, select Chain state from the dropdown, and take the following steps:</p> <ol> <li>Select the pooledStaking module and the sortedEligibleCandidates query</li> <li>Click the + button next to the extrinsic field</li> <li>A list of the eligible candidates and their stake will be displayed at the bottom of the page. You can search for your address to ensure you are eligible to produce blocks</li> </ol> <p></p> <p>Remember that you'll need to be in the top candidates by total stake to produce blocks, and this is based on the number of sequencers required for each network and Tanssi.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/","title":"Run a Sequencer Node","text":"<p>Setting up a sequencer node is an important step to participate in the Tanssi network. You have two options: Docker or Systemd. Whichever path you choose, we provide step-by-step tutorials to guide you through the process and ensure your node meets the necessary requirements to produce blocks and maintain a secure connection to the network.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/#hardware-requirements","title":"Hardware Requirements","text":"<p>To run a sequencer node successfully, using high-performance hardware is essential. Suboptimal configurations can lead to delays, missed authoring rounds, and lost rewards. Since the block production and import process relies heavily on single-threaded performance, prioritizing CPUs with strong single-thread capabilities over higher core counts is recommended.</p> <p>Recommended Hardware:</p> <ul> <li>Recommended CPUs - Intel Xeon E-2386/2388 or Ryzen 9 5950x/5900x</li> <li>Recommended NVMe - 1 TB NVMe</li> <li>Recommended RAM - 32 GB RAM</li> </ul> <p>Warning</p> <p>As a sequencer, you are responsible for both your own stake and that of your delegators. Maintaining your node's performance, keeping it updated, and ensuring its security are critical for maximizing rewards and building a strong reputation within the Tanssi network.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/#required-network-ports","title":"Required Network Ports","text":"<p>For successful block production, your node must synchronize and interact with two peer-to-peer (P2P) networks. To ensure proper communication within the Tanssi ecosystem, make sure the following ports are open for incoming:</p> Network Port Tanssi Chain 30334 (TCP) Assigned Network 30333 (TCP)"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/","title":"Run a Sequencer in Tanssi Using Docker","text":""},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#introduction","title":"Introduction","text":"<p>One of Tanssi's core propositions is that it provides decentralized and trustless block production for its networks. Tanssi's runtime handles sequencer assignments to all the active networks in the Tanssi ecosystem.</p> <p>Each time, the assignment algorithm distributes the available set of sequencers per session, assigning them to a random chain. Consequently, they would be producing blocks for the same network only for a relatively short period, increasing the overall security of the ecosystem.</p> <p>To this end, Tanssi's binary file (the software used to run nodes) already has an embedded mechanism to switch block production automatically to the assigned chain without requiring the node operator to make any changes. The binary includes the logic to sync the new chain and produce blocks when the session changes. Consequently, sequencers need to run the Tanssi binary file, and not that of the networks (like full nodes do).</p> <p>In this guide, you'll learn how to spin up a Tanssi sequencer to be part of the shared pool of sequencers using Docker on a Linux computer. However, it can be adapted to other operating systems.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#checking-prerequisites","title":"Checking Prerequisites","text":""},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#installing-docker","title":"Installing Docker","text":"<p>To get started, you'll need access to a computer running a Linux OS and install Docker.</p> <p>Run the following command to install Docker on a Linux Ubuntu platform:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>And the following command to check the installation:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>This is what a successful execution in the terminal looks like:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#pulling-docker-image","title":"Pulling the Docker Image","text":"<p>A Docker image is built and published in every release, containing all the necessary dependencies a Tanssi sequencer requires and the binary file itself.</p> <p>A Docker image combines the binary corresponding to the latest stable release of the client node, along with the Tanssi orchestrator specification file.</p> <p>The following command to pull the Docker image:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <p>The command will download and extract the image and show the status upon execution:</p> docker pull moondancelabs/tanssi  Using default tag: latest      latest: Pulling from moondancelabs/tanssi      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       d9dcf3cddfc5: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/tanssi      docker.io/moondancelabs/tanssi"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#download-tanssi-specs","title":"Download the Tanssi Chain Specs File","text":"<p>The node binary file also includes the necessary code to run a Tanssi orchestration chain node. When launching a sequencer, it will also be required to provide the Tanssi orchestration chain specification file as a parameter.</p> <p>Download the Tanssi orchestration chain specification file by executing the following:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#setup-data-directory","title":"Setup the Data Directory","text":"<p>Running a sequencer or an appchain node require syncing with two chains: the Tanssi orchestration chain and the appchain it is working for.</p> <p>Run the following command to create the directory where your node will store the databases containing blocks and chain states:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Or run the following command if you want to run the sequencer with the current logged-in user:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#generate-node-key","title":"Generate the Node Key","text":"<p>Starting from runtime 700 release, Tanssi sequencer nodes don't generate the session keys automatically on start-up. To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#start-up-command","title":"Start-Up Command","text":"<p>To spin up your node, you must run the Docker image with the <code>docker run</code> command. </p> <p>Note that the command contains two sections, divided by <code>-- \\</code>:</p> <ul> <li>Tanssi protocol section - it contains the flags to run the Tanssi node</li> <li>Sequencer section - it contains the flags to run the sequencer node. It is abstract enough to be dynamically adapted in runtime to the specific chain the node will serve</li> </ul> <p>Name each of the sections with a human-readable name by replacing the <code>INSERT_YOUR_TANSSI_NODE_NAME</code> and <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> tags in the <code>--name</code> flags. These names will come in handy for connecting the log entries and metrics with the node that generates them.</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#run-flags","title":"Run Flags","text":"<p>The flags used in the <code>docker run</code> command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run moondancelabs/tanssi --help\n</code></pre> <pre><code>docker run moondancelabs/tanssi --help\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#syncing-your-node","title":"Syncing Your Node","text":"<p>The first time your node spins up, the syncing process displays lots of log information from the node configuration and the node itself. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>When the syncing with the Tanssi orchestrator is finished, the node will still need to sync with the network it has been assigned to. The syncing with the chain served by the sequencer node will happen every time the sequencer is rotated.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/","title":"Run a Sequencer Node Using Systemd","text":""},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#introduction","title":"Introduction","text":"<p>One of Tanssi's core propositions is that it provides decentralized and trustless block production for its networks. Tanssi's runtime handles sequencer assignments to all the active networks in the Tanssi ecosystem.</p> <p>Each time, the assignment algorithm distributes the available set of sequencers per session, assigning them to a random chain. Consequently, they would be producing blocks for the same network only for a relatively short period, increasing the overall security of the ecosystem.</p> <p>To this end, Tanssi's binary file (the software used to run nodes) already has an embedded mechanism to switch block production automatically to the assigned chain without requiring the node operator to make any changes. The binary includes the logic to sync the new chain and produce blocks when the session changes. Consequently, sequencers need to run the Tanssi binary file, and not that of the networks (like full nodes do).</p> <p>In this guide, you'll learn how to spin up a Tanssi sequencer to be part of the shared pool of sequencers using the latest stable binary file release and managing the service with Systemd on Linux systems.</p> <p>The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To get started, you'll need access to a computer running an Ubuntu Linux OS and root privileges. You will also need:</p> <ul> <li>Node binary file - the instructions in this guide execute the latest official stable <code>tanssi-node</code> release. However, you can build your own file compiling the source code</li> <li>Tanssi chain specifications file - the Tanssi chain specification file can be downloaded from this public GitHub repository</li> </ul>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-latest-release","title":"Download the Latest Release","text":"<p>To get started, download and make executable the latest binary release by running the following command:</p> <p>Note</p> <p>It is recommended that you run the optimized binary versions for either Intel's Skylake or AMD's Zen3 architectures for better performance.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-tanssi-specs","title":"Download the Tanssi Chain Specs File","text":"<p>The node binary file also includes the necessary code to run a Tanssi orchestration chain node. When launching a sequencer, it will also be required to provide the Tanssi orchestration chain specification file as a parameter.</p> <p>Download the Tanssi orchestration chain specification file by executing the following:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#setup-systemd-service","title":"Setup the Systemd Service","text":"<p>Systemd is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.</p> <p>The following commands configure a new account, the directory, and move the previously downloaded files to the right location.</p> <p>Create a new account to run the service:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Create a directory to store the required files and data:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the service to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>And finally, move the binary to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-node /var/lib/dancelight-data\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#generate-node-key","title":"Generate the Node Key","text":"<p>Starting from runtime 700 release, Tanssi sequencer nodes don't generate the session keys automatically on start-up. To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>This step could be avoided using the <code>--unsafe-force-node-key-generation</code> parameter in the start-up command, although this is not the recommended practice.</p>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#create-systemd-configuration","title":"Create the Systemd Service Configuration File","text":"<p>The next step is to create the Systemd configuration file.</p> <p>You can create the file by running the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Now you can open the file using your favorite text editor (vim, emacs, nano, etc) and add the configuration for the service, replacing the <code>INSERT_YOUR_TANSSI_NODE_NAME</code> and <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> tags with a human-readable text in the <code>--name</code> flags. These names will come in handy for connecting the log entries and metrics with the node that generates them.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/tanssi-data/container \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/tanssi-data/relay \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--keystore-path=/var/lib/tanssi-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Dancelight systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/dancelight-data/container \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/dancelight-data/relay \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--keystore-path=/var/lib/dancelight-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-flags","title":"Run Flags","text":"<p>The flags used in the ExecStart command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:</p> <ul> <li><code>--name INSERT_NAME</code> - a human-readable name for this node</li> <li><code>--rpc-port INSERT_PORT</code> - specifies the JSON-RPC TCP port the node listens on</li> <li><code>--unsafe-rpc-external</code> - exposes the RPC service on all the interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the state), <code>archive-canonical</code> (which keeps only the state of finalized blocks), or any <code>number</code> (representing the number of blocks whose states are kept)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - specifies how many blocks should be kept in the database. The pruning type can be either <code>archive</code> (which makes the node behave as a full node keeping all the blocks), <code>archive-canonical</code> (which keeps only finalized blocks), or any <code>number</code> (representing the amount of finalized blocks to keep)</li> <li><code>--detailed-log-output</code> - enables detailed log output</li> </ul> <p>Warning</p> <p>The <code>--unsafe-rpc-external</code> enables external access to your node\u2019s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.</p> <p>For a complete list of available flags, their description, and possible values, run the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node  --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node  --help\n</code></pre>"},{"location":"node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-the-service","title":"Run the Service","text":"<p>Finally, enable the service and start it for the first time:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>You can verify that the service is up and running correctly running:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>And check the logs, if needed, with the following command:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"node-operators/sequencers/operational-tasks/","title":"Operational Task","text":"<p>Keeping your sequencer up and running is more than just setup - it requires regular maintenance to ensure consistent performance and secure management of your accounts. Regular updates are essential to keep your node compatible with the latest Tanssi protocol changes, while tools such as proxy accounts provide an extra layer of security by allowing you to delegate certain tasks without exposing your primary account credentials. This section provides the necessary steps to keep your operations smooth, reliable, and secure.</p>"},{"location":"node-operators/sequencers/operational-tasks/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/","title":"Set Up a Proxy Account","text":""},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/#introduction","title":"Introduction","text":"<p>Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and help keep the underlying accounts safe. As a sequencer on Tanssi, it's a good idea to take advantage of proxy accounts to interact with the network in place of your sequencer account.</p> <p>The staking proxy type conveniently allows the proxy account to manage staking activities, such as delegating and rotating session keys, on behalf of the primary sequencer account, effectively transforming it into a \"hot wallet\" for performing regular maintenance duties on behalf of your \"cold wallet\" sequencer account. For added safety, you can regularly rotate the proxy account.</p> <p>Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum access required to carry out their duties via a specific proxy account.</p> <p>This tutorial will walk you through configuring a staking proxy account on Dancelight specifically for operations as a sequencer. Then, it will demonstrate initiating a delegation using the newly created staking proxy.</p>"},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>To follow along with this tutorial, you will need to have:</p> <ul> <li>The developer portal open and connected to Dancelight</li> <li>Create or have two accounts accessible in the developer portal</li> <li>Both accounts will need to be funded, and the sequencer account will need at least the minimum self delegation required to become an active sequencer (10000 STAR for Dancelight)</li> </ul> <p>If you need help importing your accounts into the developer portal, please check out the Connecting to the Developer Portal guide.</p>"},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/#creating-a-staking-proxy-account","title":"Creating a Staking Proxy Account","text":"<p>There are a couple of ways you can create proxy accounts in the developer portal, either from the Extrinsics page or the Accounts page. However, to create a time-delayed proxy, you will need to use the Extrinsics page. A time delay provides an additional layer of security to proxies by specifying a delay period based on the number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions and provides a limited period of time to cancel any actions.</p> <p>You also have the option of creating a proxy of type Any which grants the proxy account full and unrestricted control over the primary account. This means that the proxy account can transfer funds, and perform any arbitrary action. The following demo will showcase configuring a Staking proxy, which is more restrictive than an Any proxy, as it limits functions to activities that pertain to staking, such as delegating, undelegating, and mapping session keys.</p> <p>To get started creating your proxy account, head to the Developer tab and select Extrinsics from the dropdown. Next, you will need to take the following steps:</p> <ol> <li>Select the primary account</li> <li>From the submit the following extrinsic dropdown, select proxy</li> <li>Choose the addProxy extrinsic</li> <li>Choose Id from the AccountIdLookupOf dropdown</li> <li>Select the delegate account for the proxy</li> <li>From the proxyType dropdown, choose Staking</li> <li>Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction</li> <li>Click Submit Transaction</li> </ol> <p></p> <p>You will then be prompted to authorize and sign the transaction. Click Sign and Submit to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.</p> <p>As previously mentioned, you can also create a proxy from the Accounts page. To do so, navigate to the Accounts page and take the following steps:</p> <ol> <li>Select the three vertical dots next to the primary account</li> <li>Select Add proxy</li> </ol> <p></p> <p>Note</p> <p>If the account already has a proxy, Manage proxies will be displayed as an option instead of Add proxy.</p> <p>A pop-up will appear and you can enter the required information, such as the proxied/primary account, the proxy account, and the type of proxy to create a proxy account. First, click Add proxy.</p> <p></p> <p>Then, take the following steps:</p> <ol> <li>Select the account you would like to set as a proxy</li> <li>Select the proxy type</li> <li>Click Submit and sign the transaction</li> </ol> <p></p> <p>In the next section, you will learn how to verify that your proxy account was set up successfully.</p>"},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/#verifying-your-proxy-account","title":"Verifying Your Proxy Account","text":"<p>You can verify that your proxy account has been successfully set up in a couple of ways: either through the Accounts page or via the Chain state page.</p> <p>To check your proxy accounts from the Chain state page, you can take the following steps:</p> <ol> <li>From the selected state query dropdown, select proxy</li> <li>Choose the proxies extrinsic</li> <li>Select your primary/proxied account</li> <li>Click on the + button to send the query</li> </ol> <p></p> <p>The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Planck.</p> <p>You can also check your proxy accounts from the Accounts page. To do so, navigate to the Accounts page, and there should be a Proxy symbol next to the primary account. Hover over the icon and click on Manage proxies to review your proxies.</p> <p></p> <p>A pop-up will appear where you can see an overview of all of your proxy accounts.</p> <p></p>"},{"location":"node-operators/sequencers/operational-tasks/proxy-accounts/#executing-a-proxy-transaction","title":"Executing a Proxy Transaction","text":"<p>Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the staking proxy account on behalf of your sequencer account, also known as the primary account or the account that is being proxied. The following example will demonstrate initiating a self-delegation. The proxy configuration shown is a realistic example of how you might have your own proxy configured for your developer portal primary account.</p> <p>To execute a transaction, you can navigate back to the Extrinsics page and take the following steps:</p> <ol> <li>Select the proxy account to submit the transaction from the using the select account dropdown</li> <li>From the submit the following extrinsic menu, select proxy</li> <li>Choose the proxy extrinsic</li> <li>Choose Id from the AccountIdLookupOf dropdown</li> <li>Select the primary account from the real dropdown</li> <li>Select the pooledStaking call</li> <li>Choose the requestDelegate extrinsic</li> <li>Enter the candidate address, which is the sequencer account</li> <li>Select AutoCompounding or ManualRewards for the pool field</li> <li>Enter the amount to stake. This amount must meet the minimum, which, for Dancelight, is 10000 STAR tokens. You'll need to submit the value including the twelve decimal places the Tanssi Network uses, so for a value of 10000, you'll need to enter <code>10000000000000000</code></li> <li>Click Submit Transaction</li> </ol> <p></p> <p>A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click Sign and Submit. To confirm the delegation request, you'll need to execute the pending request after two sessions have passed. Please refer to the instructions for executing pending requests for a step-by-step guide. You can also map your session keys to your sequencer account via proxy.</p> <p>After you've mapped your session keys and executed the pending delegation request, you can verify that your sequencer is in the list of eligible candidates.</p> <p>That's it! You've successfully executed a transaction using a proxy account on behalf of your primary sequencer account.</p>    The information presented herein has been provided by third parties and is made available solely for general information purposes. Tanssi does not endorse any project listed and described on the Tanssi Doc Website (https://docs.tanssi.network/). Tanssi Foundation does not warrant the accuracy, completeness or usefulness of this information. Any reliance you place on such information is strictly at your own risk. Tanssi Foundation disclaims all liability and responsibility arising from any reliance placed on this information by you or by anyone who may be informed of any of its contents. All statements and/or opinions expressed in these materials are solely the responsibility of the person or entity providing those materials and do not necessarily represent the opinion of Tanssi Foundation. The information should not be construed as professional or financial advice of any kind. Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. The information herein may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. Tanssi Foundation has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. These links are being provided to you only as a convenience and you release and hold Tanssi Foundation harmless from any and all liability arising from your use of this information or the information provided by any third-party website or service."},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/","title":"Upgrade Sequencers Node","text":"<p>Keeping your node updated is critical to maintaining compatibility with the latest Tanssi protocol changes and ensuring optimal performance. Outdated nodes can lead to desynchronization, reduced efficiency, or even an inability to participate in block production. By staying current with client releases, you can ensure your node operates securely and reliably within the network.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/#explore-what-this-section-covers","title":"Explore What This Section Covers","text":"<p>:::INSERT_GENERATED_CARDS::: </p>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/","title":"Upgrade Your Node Running via Docker","text":""},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#introduction","title":"Introduction","text":"<p>Keeping your node up-to-date is an important part of being a Tanssi sequencer. Not only does it help to ensure that your sequencer node stays healthy, it also contributes to keeping the entire Tanssi Network running smoothly.</p> <p>This tutorial covers upgrading your Tanssi sequencer that was configured using Docker. It assumes you have already set up your account and launched a sequencer using Docker.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes","title":"Upgrading Docker Nodes","text":"<p>If you're running your sequencer with Docker, updating your node is as simple as stopping the running container and restarting it with the new version tag.</p> <p>First, get the container ID of your Tanssi sequencer node with the following command:</p> <pre><code>docker ps -a\n</code></pre> <p>The container ID is the first column and if you're running multiple Docker containers, you can identify it by the image name of <code>moondancelabs/tanssi</code>. You can run the stop command as follows:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>Your terminal interaction will resemble the following:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/tanssi:v0.6.1 \"/tanssi/tanssi-node\u2026\" 56 seconds ago  Up 56 seconds             focused_chaum      docker stop aa751703d6aa  aa751703d6aa    <p>To restart the node, you can use the same command you used when launching your node the first time. The command pulls the image and the node will resume syncing blocks from where it left off when the Docker process was stopped.</p> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-skylake\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-znver3\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag","title":"Specifying a Version Tag","text":"<p>If you wanted to specify a particular version tag, you can do so by replacing the version tag appended to the image name. For example, if you wanted to fetch version <code>3</code>, you would replace the <code>2</code> in <code>moondancelabs/tanssi</code>.</p> <p>And that's it! You've successfully upgraded your Tanssi node.</p>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/","title":"Upgrade Your Node Running via Systemd","text":""},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction","title":"Introduction","text":"<p>Keeping your node up-to-date is an important part of being a Tanssi sequencer. Not only does it help to ensure that your sequencer node stays healthy, it also contributes to keeping the entire Tanssi Network running smoothly.</p> <p>This tutorial covers upgrading your Tanssi sequencer node that was configured using Systemd. It assumes you have already set up your account and launched a sequencer node using Systemd.</p> <p>Subscribe to Release Notifications</p> <p>Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  </p> <p>To subscribe, visit the Tanssi GitHub repository and click Watch. Select Custom notifications and ensure the box for Releases is checked.</p>"},{"location":"node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node","title":"Upgrading Your Systemd Node","text":"<p>If you're running your sequencer via the Systemd service, you'll need to take a few steps to properly upgrade your node. In short, you'll need to stop the service, replace the Tanssi binary with the updated version, and then start the service.</p> <p>You can stop your Tanssi Systemd service with the following command:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Then, navigate to the directory where your Tanssi binary is stored and remove it.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>Your Tanssi binary file will most likely be named <code>tanssi-node</code>. If not, you can replace <code>tanssi-node</code> below with the correct name of your Tanssi binary file.</p> <pre><code>rm tanssi-node\n</code></pre> <p>To download the latest release and change permissions on it so the Tanssi service can use it, run the following command that corresponds to your environment:</p> GenericIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <p>You can restart your Tanssi Systemd service with the following command:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>The node will resume syncing blocks from where it left off when the Systemd service was stopped. To verify that it is running correctly, you can use the following command to check the logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>And that's it! You've successfully upgraded your Tanssi node.</p>"},{"location":"pt/ai-resources/ai-resources/","title":"Recursos de IA","text":"<p>A Tanssi fornece arquivos <code>.txt</code> contendo o conte\u00fado da documenta\u00e7\u00e3o e a estrutura de navega\u00e7\u00e3o, otimizados para uso com modelos de linguagem (LLMs) e ferramentas de IA. Esses recursos ajudam a criar assistentes de IA, potencializam buscas em c\u00f3digo ou permitem ferramentas personalizadas treinadas na documenta\u00e7\u00e3o da Tanssi.</p> <p>Cada arquivo por categoria inclui o conte\u00fado b\u00e1sico das categorias Basics e Reference para garantir que os LLMs tenham o contexto necess\u00e1rio.</p>"},{"location":"pt/ai-resources/ai-resources/#baixar-arquivos-para-llm","title":"Baixar Arquivos para LLM","text":"Categoria Descri\u00e7\u00e3o Arquivo A\u00e7\u00f5es \u00cdndice \u00cdndice de navega\u00e7\u00e3o de todas as p\u00e1ginas da documenta\u00e7\u00e3o Tanssi <code>llms.txt</code> Documenta\u00e7\u00e3o Completa Conte\u00fado completo de todas as p\u00e1ginas da documenta\u00e7\u00e3o <code>llms-full.txt</code> Basics Framework, arquitetura e componentes centrais da Tanssi para formar a base de conhecimento geral <code>llms-basics.txt</code> Reference Material de refer\u00eancia, incluindo endpoints de rede, m\u00e9todos JSON RPC e endere\u00e7os de contratos ou tokens <code>llms-reference.txt</code> Appchain Como lan\u00e7ar e gerenciar uma appchain via dApp ou portal do desenvolvedor <code>llms-appchain.txt</code> Runtime Personalizado Como personalizar o runtime da sua appchain <code>llms-custom-runtime.txt</code> Template EVM Use o template EVM para lan\u00e7ar appchains compat\u00edveis com Ethereum e conhecer seu tooling associado (carteiras, integra\u00e7\u00f5es etc.) <code>llms-evm-template.txt</code> Template Substrate Use o template Substrate b\u00e1sico e o tooling associado (carteiras, integra\u00e7\u00f5es etc.) para lan\u00e7ar appchains <code>llms-substrate-template.txt</code> Operadores Como configurar e executar um n\u00f3 para proteger o ecossistema Tanssi <code>llms-operators.txt</code> Sequenciadores Como executar um sequencer para fornecer servi\u00e7os de produ\u00e7\u00e3o de blocos \u00e0s appchains <code>llms-sequencers.txt</code> <p>Nota</p> <p>O arquivo <code>llms-full.txt</code> pode exceder o limite de entrada de alguns modelos de linguagem devido ao seu tamanho. Se voc\u00ea encontrar limita\u00e7\u00f5es, considere usar os arquivos por categoria.</p>"},{"location":"pt/builders/","title":"Builders","text":"<p>Explore tudo o que precisa para construir, implementar e gerir redes dentro do ecossistema Tanssi. De ferramentas de desenvolvimento \u00e0 gest\u00e3o de contas e conectividade de rede, o conte\u00fado desta sec\u00e7\u00e3o permite que avance com confian\u00e7a do conceito \u00e0 implementa\u00e7\u00e3o.</p>"},{"location":"pt/builders/#construir-uma-rede-com-tanssi","title":"Construir uma Rede com TanssiPor Onde Come\u00e7ar?Personalizar a Sua Rede","text":"<ul> <li> <p>  Construir uma rede do zero usando um modelo</p> <p> Configurar um runtime existente baseado em Substrate para ser compat\u00edvel com Tanssi</p> </li> <li> <p>  Utilizar m\u00f3dulos pr\u00e9-existentes para adicionar funcionalidades</p> <p> Criar o seu pr\u00f3prio m\u00f3dulo personalizado</p> <p> Integrar m\u00f3dulos externos de outros fornecedores</p> </li> </ul>"},{"location":"pt/builders/#implementar-e-gerir-uma-rede-com-tanssi","title":"Implementar e Gerir uma Rede com TanssiPronto para Implementar?A\u00e7\u00f5es P\u00f3s-Implementa\u00e7\u00e3o","text":"<ul> <li> <p>  Implementar a sua rede com a Tanssi dApp</p> </li> <li> <p>  Pagar pelos servi\u00e7os de produ\u00e7\u00e3o de blocos</p> <p> Cunhar tokens para a economia da sua rede</p> <p> Gerir a conta Sudo para controlo administrativo</p> </li> </ul>"},{"location":"pt/builders/#interagir-com-uma-rede-com-tanssi","title":"Interagir com uma Rede com TanssiRefer\u00eancias de Rede TanssiFerramentas para Desenvolvimento de Rede Tanssi","text":"<ul> <li> <p>  Aceder aos endpoints da rede</p> </li> <li> <p>  Explorar ferramentas para integra\u00e7\u00e3o de API Ethereum</p> <p> Utilizar ferramentas Substrate para controlo avan\u00e7ado da rede</p> <p> Melhorar a funcionalidade da sua aplica\u00e7\u00e3o com integra\u00e7\u00f5es</p> </li> </ul>"},{"location":"pt/builders/#explore-esta-seccao","title":"Explore Esta Sec\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/account-management/","title":"Gerenciamento de Contas","text":"<p>O gerenciamento de contas on-chain oferece aos usu\u00e1rios e desenvolvedores maior flexibilidade e controle sobre como suas contas interagem com uma rede descentralizada. Voc\u00ea pode ajustar suas configura\u00e7\u00f5es de conta para uma integra\u00e7\u00e3o perfeita dentro do ecossistema, gerenciando fun\u00e7\u00f5es, permiss\u00f5es e identidades diretamente na blockchain.</p> <p>Esta se\u00e7\u00e3o descreve algumas das ferramentas e recursos relacionados ao gerenciamento de contas.</p>"},{"location":"pt/builders/account-management/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/account-management/identity/","title":"Configurar uma Identidade On-Chain","text":""},{"location":"pt/builders/account-management/identity/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O Substrate Identity module \u00e9 uma solu\u00e7\u00e3o pronta para uso para adicionar informa\u00e7\u00f5es pessoais \u00e0 sua conta on-chain. O estabelecimento de uma identidade torna mais f\u00e1cil para sua conta ser reconhecida por outros, pois seu nome de exibi\u00e7\u00e3o preencher\u00e1 automaticamente quando algu\u00e9m colar seu endere\u00e7o em um campo no portal do desenvolvedor.</p> <p>A identidade que voc\u00ea configura vai al\u00e9m de um simples nome de exibi\u00e7\u00e3o. As informa\u00e7\u00f5es pessoais podem incluir campos padr\u00e3o, como seu nome legal, nome de exibi\u00e7\u00e3o, site, identificador do Twitter, Discord e nome do Riot (agora conhecido como Element). Voc\u00ea tamb\u00e9m pode usar campos personalizados para incluir quaisquer outras informa\u00e7\u00f5es relevantes.</p> <p>Este guia demonstrar\u00e1 como configurar uma identidade com um nome de exibi\u00e7\u00e3o e par\u00e2metros adicionais, aprimorando sua visibilidade e reconhecimento.</p>"},{"location":"pt/builders/account-management/identity/#general-definitions","title":"Defini\u00e7\u00f5es Gerais","text":"<p>Para armazenar suas informa\u00e7\u00f5es on-chain, voc\u00ea deve vincular alguns fundos, que, eventualmente, ser\u00e3o devolvidos assim que a identidade for limpa. Existem duas categorias de campos: padr\u00e3o e personalizado. Uma quantia b\u00e1sica de dep\u00f3sito \u00e9 reservada ap\u00f3s a cria\u00e7\u00e3o da identidade e um dep\u00f3sito de armazenamento \u00e9 necess\u00e1rio para cada byte adicional de dados armazenados on-chain.</p> <ul> <li> <p>Campos padr\u00e3o incluem - seu nome legal, nome de exibi\u00e7\u00e3o, site, identificador do Twitter, Discord, nome do Riot (agora conhecido como Element)</p> </li> <li> <p>Campos personalizados incluem - quaisquer outras informa\u00e7\u00f5es relevantes</p> </li> <li> <p>Subcontas - Voc\u00ea pode vincular subcontas sob uma conta prim\u00e1ria. Por exemplo, um servi\u00e7o de sequenciador que est\u00e1 executando v\u00e1rios n\u00f3s de sequenciador diferentes pode estabelecer subcontas para demonstrar um link oficial entre os n\u00f3s</p> </li> </ul> Tanssi MainNetDancelight TestNet Vari\u00e1vel Defini\u00e7\u00e3o Valor Dep\u00f3sito b\u00e1sico O valor mantido em dep\u00f3sito para a defini\u00e7\u00e3o de uma identidade 0.33333333 TANSSI Dep\u00f3sito por byte O valor mantido em dep\u00f3sito por byte de armazenamento on-chain usado na defini\u00e7\u00e3o de uma identidade 0.0001 TANSSI Campos adicionais m\u00e1x. N\u00famero m\u00e1ximo de campos adicionais que podem ser armazenados em um ID 100 Subcontas m\u00e1x. N\u00famero m\u00e1ximo de subcontas que podem ser definidas sob uma identidade de conta 100 Vari\u00e1vel Defini\u00e7\u00e3o Valor Dep\u00f3sito b\u00e1sico O valor mantido em dep\u00f3sito para a defini\u00e7\u00e3o de uma identidade 0.33333333 STAR Dep\u00f3sito por byte O valor mantido em dep\u00f3sito por byte de armazenamento on-chain usado na defini\u00e7\u00e3o de uma identidade 0.0001 STAR Campos adicionais m\u00e1x. N\u00famero m\u00e1ximo de campos adicionais que podem ser armazenados em um ID 100 Subcontas m\u00e1x. N\u00famero m\u00e1ximo de subcontas que podem ser definidas sob uma identidade de conta 100"},{"location":"pt/builders/account-management/identity/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para acompanhar este guia, voc\u00ea precisar\u00e1 do seguinte:</p> Tanssi MainNetDancelight TestNet <ul> <li>O portal do desenvolvedor aberto e conectado ao Tanssi MainNet.</li> <li>Pelo menos uma conta financiada com tokens <code>TANSSI</code>.</li> </ul> <ul> <li>O portal do desenvolvedor aberto e conectado ao Dancelight.</li> <li>Pelo menos uma conta financiada com tokens <code>STAR</code>.</li> </ul> <p>Se precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia Conectando-se ao portal do desenvolvedor.</p>"},{"location":"pt/builders/account-management/identity/#get-started","title":"Comece","text":"<p>Dependendo das informa\u00e7\u00f5es a serem inclu\u00eddas, existem algumas maneiras diferentes de definir e limpar uma identidade usando o portal do desenvolvedor. Se voc\u00ea pretende registrar sua identidade usando apenas os campos padr\u00e3o, pode seguir as instru\u00e7\u00f5es da p\u00e1gina Gerenciando uma Identidade via Contas. Esta \u00e9 a maneira recomendada de definir e gerenciar sua identidade.</p> <p>Se voc\u00ea deseja adicionar campos personalizados al\u00e9m dos campos padr\u00e3o, siga as instru\u00e7\u00f5es para a p\u00e1gina Gerenciando uma Identidade via Extrinsics.</p> <p>Nota</p> <p>Observe que o uso da p\u00e1gina Contas no portal do desenvolvedor \u00e9 recomendado para gerenciar sua identidade, pois ela fornece uma interface f\u00e1cil de usar que imp\u00f5e limites de caracteres. Se voc\u00ea usar a p\u00e1gina Extrinsics, esteja ciente de que sua entrada para cada campo (ou seja, nome, e-mail, etc.) deve ter 32 caracteres ou menos; caso contr\u00e1rio, suas informa\u00e7\u00f5es ser\u00e3o cortadas.</p>"},{"location":"pt/builders/account-management/identity/#manage-via-accounts","title":"Gerenciar uma Identidade via Contas","text":""},{"location":"pt/builders/account-management/identity/#set-identity-via-accounts","title":"Definir uma Identidade","text":"<p>Para come\u00e7ar a definir uma identidade usando a p\u00e1gina Contas, v\u00e1 para a guia Contas do portal do desenvolvedor.</p> <p>Voc\u00ea j\u00e1 deve ter uma conta conectada, ent\u00e3o voc\u00ea pode clicar no nome da sua conta para verificar e observar seus saldos. Depois de enviar a transa\u00e7\u00e3o para definir uma identidade, os dep\u00f3sitos que voc\u00ea enviou ser\u00e3o movidos do seu saldo transfer\u00edvel para seu saldo reservado.</p> <p></p> <p>Para definir sua identidade, voc\u00ea precisar\u00e1:</p> <ol> <li>Clique nos tr\u00eas pontos verticais ao lado da conta para a qual deseja definir uma identidade</li> <li>Um menu aparecer\u00e1. Clique em Set on-chain identity</li> </ol> <p></p> <p>Em seguida, o menu para registrar e definir sua identidade aparecer\u00e1 e voc\u00ea poder\u00e1 come\u00e7ar a preencher suas informa\u00e7\u00f5es. Voc\u00ea n\u00e3o \u00e9 obrigado a inserir informa\u00e7\u00f5es para todos os campos; voc\u00ea pode escolher preencher apenas um campo ou todos eles; a escolha \u00e9 sua. Para este exemplo:</p> <ol> <li>Defina seu nome de exibi\u00e7\u00e3o</li> <li>Clique no bot\u00e3o include field para e-mail e depois insira seu e-mail</li> <li>Clique no bot\u00e3o include field para web e depois insira a URL do seu site</li> <li>Clique no bot\u00e3o include field para Twitter e depois insira seu identificador do Twitter</li> <li>Reveja os campos de dados anteriores e clique em Set Identity</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o. Se tudo estiver correto, assine-a.</p> <p>Voc\u00ea deve ver as notifica\u00e7\u00f5es de status aparecerem no canto superior direito. Depois que a transa\u00e7\u00e3o for confirmada, voc\u00ea pode clicar no nome da sua conta novamente, e o painel deslizar\u00e1 para fora no lado direito da p\u00e1gina. Seus saldos ter\u00e3o sido alterados e voc\u00ea tamb\u00e9m ver\u00e1 suas novas informa\u00e7\u00f5es de identidade.</p> <p></p> <p>Se as informa\u00e7\u00f5es de identidade corresponderem ao que voc\u00ea inseriu, voc\u00ea definiu com sucesso uma identidade!</p> <p>Depois de limpar sua identidade, o dep\u00f3sito em seu saldo reservado ser\u00e1 transferido de volta para seu saldo transfer\u00edvel. Se voc\u00ea precisar alterar sua identidade, pode passar pelo processo de configura\u00e7\u00e3o da sua identidade novamente. Observe que voc\u00ea deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles ser\u00e3o substitu\u00eddos. Voc\u00ea n\u00e3o precisar\u00e1 pagar outro dep\u00f3sito, a menos que campos personalizados sejam usados, mas precisar\u00e1 pagar taxas de g\u00e1s.</p>"},{"location":"pt/builders/account-management/identity/#manage-via-extrinsics","title":"Gerenciar uma Identidade via Extrinsics","text":""},{"location":"pt/builders/account-management/identity/#set-identity-extrinsics","title":"Definir uma Identidade","text":"<p>Para registrar uma identidade usando a p\u00e1gina de extr\u00ednsecos, navegue at\u00e9 a p\u00e1gina Extrinsics do portal do desenvolvedor. Certifique-se de que sua entrada n\u00e3o exceda 32 caracteres para cada campo de identidade. Para concluir sua identidade, siga as etapas a seguir:</p> <ol> <li>Selecione sua conta</li> <li>Selecione identidade no menu suspenso enviar o seguinte extr\u00ednseco</li> <li>Em seguida, selecione a fun\u00e7\u00e3o setIdentity(info)</li> <li>Selecione Raw como o formato de dados para inserir seu Nome de Exibi\u00e7\u00e3o</li> <li>Insira os dados para Exibi\u00e7\u00e3o no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu endere\u00e7o da web</li> <li>Insira a URL do seu site no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu e-mail</li> <li>Insira seu endere\u00e7o de e-mail no formato selecionado</li> <li>Selecione Raw como o formato de dados para inserir seu identificador do Twitter</li> <li>Insira seu Twitter no formato selecionado. Insira apenas o nome de usu\u00e1rio, come\u00e7ando com o s\u00edmbolo <code>@</code></li> <li>Reveja os campos preparados e pressione Enviar Transa\u00e7\u00e3o </li> </ol> <p>Opcionalmente, se voc\u00ea quiser inserir campos personalizados, siga as seguintes etapas:</p> <ol> <li>Role para o topo e clique em Add item</li> <li>Dois campos aparecer\u00e3o: o primeiro para o nome do campo e o segundo para o valor. Selecione Raw como o formato de dados para inserir o nome do campo</li> <li>Insira o nome do campo no formato especificado</li> <li>Selecione Raw como o formato de dados para inserir o valor personalizado</li> <li>Insira o valor personalizado no formato especificado</li> </ol> <p></p> <p>Finalmente, depois que todas as informa\u00e7\u00f5es de identidade forem adicionadas, voc\u00ea pode rolar para a parte inferior da p\u00e1gina e clicar em Submit Transaction.</p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o. Lembre-se, um dep\u00f3sito adicional \u00e9 necess\u00e1rio para cada campo personalizado adicional. Se tudo estiver correto, assine a transa\u00e7\u00e3o.</p> <p>Voc\u00ea deve ver as notifica\u00e7\u00f5es de status aparecerem no canto superior direito confirmando a transa\u00e7\u00e3o. Se bem-sucedido, voc\u00ea definiu uma identidade! Parab\u00e9ns! Para garantir que tudo tenha sido conclu\u00eddo e que suas informa\u00e7\u00f5es de identidade tenham uma boa apar\u00eancia, voc\u00ea pode verificar sua identidade.</p>"},{"location":"pt/builders/account-management/identity/#confirm-identity-extrinsics","title":"Confirmar uma Identidade","text":"<p>Para verificar a adi\u00e7\u00e3o de suas informa\u00e7\u00f5es de identidade, voc\u00ea pode clicar na guia Developer e, em seguida, navegar at\u00e9 o Chain state.</p> <p>Na p\u00e1gina Chain State, certifique-se de que Storage esteja selecionado. Em seguida, voc\u00ea pode come\u00e7ar a solicitar suas informa\u00e7\u00f5es de identidade:</p> <ol> <li>Defina a selected state query como identity</li> <li>Selecione a fun\u00e7\u00e3o identityOf(AccountId)</li> <li>Selecione sua conta</li> <li>Clique no bot\u00e3o + para obter suas informa\u00e7\u00f5es de identidade</li> </ol> <p></p> <p>Voc\u00ea pode ver agora que voc\u00ea definiu com sucesso uma identidade! Depois de limpar sua identidade, o dep\u00f3sito em seu saldo reservado ser\u00e1 transferido de volta para seu saldo transfer\u00edvel. Se voc\u00ea precisar alterar sua identidade, pode passar pelo processo de configura\u00e7\u00e3o da sua identidade novamente. Observe que voc\u00ea deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles ser\u00e3o substitu\u00eddos. Voc\u00ea n\u00e3o precisar\u00e1 pagar outro dep\u00f3sito, a menos que campos personalizados sejam usados, mas precisar\u00e1 pagar taxas de g\u00e1s.</p>"},{"location":"pt/builders/account-management/identity/#clear-identity-extrinsics","title":"Limpar uma Identidade","text":"<p>Para limpar sua identidade, siga as seguintes etapas na guia Extrinsics do portal do desenvolvedor:</p> <ol> <li>Selecione sua conta no menu suspenso usando a conta selecionada</li> <li>Selecione identity no menu suspenso enviar o seguinte extr\u00ednseco</li> <li>Em seguida, selecione a fun\u00e7\u00e3o clearIdentity()</li> <li>Clique em Enviar Transa\u00e7\u00e3o</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o. Se tudo estiver correto, assine-a. Voc\u00ea deve ver as notifica\u00e7\u00f5es de status no canto superior direito confirmando a transa\u00e7\u00e3o.</p> <p>Para confirmar se suas informa\u00e7\u00f5es de identidade foram removidas com sucesso, revise as etapas descritas na se\u00e7\u00e3o Confirmar uma Identidade. Desta vez, em vez de exibir seus detalhes de identidade, a resposta deve indicar none, confirmando que nenhuma informa\u00e7\u00e3o de identidade est\u00e1 atualmente vinculada \u00e0 sua conta. Al\u00e9m disso, ao verificar seus saldos, voc\u00ea descobrir\u00e1 que o dep\u00f3sito inicialmente feito para definir sua identidade foi creditado de volta ao seu saldo transfer\u00edvel. Isso conclui o processo de limpeza da sua identidade.</p> <p></p>"},{"location":"pt/builders/account-management/proxy-accounts/","title":"Contas Proxy","text":""},{"location":"pt/builders/account-management/proxy-accounts/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As contas proxy podem ser configuradas para executar um n\u00famero limitado de a\u00e7\u00f5es em nome das contas prim\u00e1rias e s\u00e3o \u00fateis para manter as contas subjacentes seguras. Sua conta proxy pode atuar como uma \"carteira quente\" para interagir com a rede em nome de sua conta de \"carteira fria\". Para maior seguran\u00e7a, voc\u00ea pode rotacionar regularmente a conta proxy.</p> <p>As contas proxy tamb\u00e9m podem ajud\u00e1-lo a implementar o princ\u00edpio do privil\u00e9gio m\u00ednimo para controle de acesso. Por exemplo, se voc\u00ea tiver v\u00e1rios membros da equipe, poder\u00e1 fornecer a eles o n\u00edvel m\u00ednimo de acesso necess\u00e1rio para realizar suas tarefas por meio de um tipo espec\u00edfico de conta proxy.</p> <p>Este tutorial o guiar\u00e1 pela configura\u00e7\u00e3o de uma conta proxy no Dancelight, o Tanssi TestNet, especificamente para transfer\u00eancias de saldo. Em seguida, demonstrar\u00e1 como realizar uma transfer\u00eancia de saldo usando o proxy rec\u00e9m-criado.</p>"},{"location":"pt/builders/account-management/proxy-accounts/#verifying-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para acompanhar este tutorial, voc\u00ea precisar\u00e1 ter:</p> <ul> <li>Polkadot.js Apps aberto e conectado ao Dancelight.</li> <li>Crie ou tenha duas contas acess\u00edveis no portal do desenvolvedor.</li> <li>Pelo menos uma das contas precisar\u00e1 ser financiada com tokens <code>STAR</code>.</li> </ul> <p>Se precisar de ajuda para importar suas contas para o Polkadot.js Apps, consulte o guia Conectando-se ao Polkadot.js.</p>"},{"location":"pt/builders/account-management/proxy-accounts/#general-definitions","title":"Defini\u00e7\u00f5es Gerais","text":"<p>Ao configurar uma conta proxy, uma garantia para o proxy \u00e9 retirada de seu saldo livre e movida para seu saldo reservado. A garantia \u00e9 necess\u00e1ria, pois a adi\u00e7\u00e3o de um proxy requer espa\u00e7o de armazenamento na cadeia e \u00e9 recalculada para cada proxy que voc\u00ea adiciona ou remove. A garantia \u00e9 devolvida ao seu saldo livre ap\u00f3s a remo\u00e7\u00e3o de todos os proxies da sua conta.</p> <p>O dep\u00f3sito \u00e9 calculado com base em uma base de dep\u00f3sito e um fator de dep\u00f3sito:</p> <ul> <li>Base do dep\u00f3sito - o valor a ser reservado para uma conta ter uma lista de proxies.</li> <li>Fator de dep\u00f3sito - o valor adicional a ser reservado para cada proxy que a conta prim\u00e1ria tiver.</li> </ul> <p>A equa\u00e7\u00e3o para calcular o dep\u00f3sito \u00e9:</p> <pre><code>base do dep\u00f3sito + fator de dep\u00f3sito * n\u00famero de proxies\n</code></pre> <p>Voc\u00ea pode encontrar cada uma das vari\u00e1veis relevantes abaixo.</p> Tanssi MainNetDancelight TestNet Vari\u00e1vel Valor Base do dep\u00f3sito 0.1008 TANSSI Fator de dep\u00f3sito 0.0033 TANSSI M\u00e1x. de proxies 32 proxies Vari\u00e1vel Valor Base do dep\u00f3sito 0.1008 STAR Fator de dep\u00f3sito 0.0033 STAR M\u00e1x. de proxies 32 proxies"},{"location":"pt/builders/account-management/proxy-accounts/#proxy-types","title":"Tipos de Proxy","text":"<p>Ao criar uma conta proxy, voc\u00ea deve escolher um tipo de proxy que definir\u00e1 como o proxy pode ser usado. As op\u00e7\u00f5es dispon\u00edveis s\u00e3o:</p> <ul> <li><code>Any</code> - permite que a conta proxy use qualquer fun\u00e7\u00e3o suportada pela palete proxy. N\u00e3o h\u00e1 filtragem de chamadas.</li> <li><code>NonTransfer</code> - este tipo de conta proxy \u00e9 permitido para enviar qualquer tipo de transa\u00e7\u00e3o, com exce\u00e7\u00e3o de transfer\u00eancias de saldo.</li> <li><code>Balances</code> - permite que a conta proxy fa\u00e7a apenas transa\u00e7\u00f5es relacionadas ao envio de fundos.</li> <li><code>Governance</code> - permite que a conta proxy fa\u00e7a apenas transa\u00e7\u00f5es relacionadas \u00e0 palete de governan\u00e7a, como vota\u00e7\u00e3o ou cria\u00e7\u00e3o de propostas de democracia. Observe que a governan\u00e7a ainda n\u00e3o est\u00e1 habilitada no Tanssi. Voc\u00ea pode criar contas proxy de governan\u00e7a, mas elas n\u00e3o poder\u00e3o tomar nenhuma a\u00e7\u00e3o at\u00e9 que a governan\u00e7a seja habilitada.</li> <li><code>Registrar</code> - permite que a conta proxy fa\u00e7a apenas transa\u00e7\u00f5es relacionadas \u00e0 palete do registrador.</li> <li><code>SudoRegistrar</code> - permite que a conta proxy fa\u00e7a apenas transa\u00e7\u00f5es relacionadas \u00e0 palete do registrador que precisam ser chamadas por Sudo.</li> <li><code>CancelProxy</code> - permite que a conta proxy rejeite e remova quaisquer chamadas proxy anunciadas.</li> <li><code>Staking</code> - permite que a conta proxy execute transa\u00e7\u00f5es relacionadas a staking, como fun\u00e7\u00f5es de sequenciador e <code>session()</code>.</li> <li><code>SessionKeyManagement</code> - permite que a conta proxy fa\u00e7a transa\u00e7\u00f5es relacionadas ao gerenciamento de chaves inclu\u00eddas na palete de sess\u00e3o.</li> </ul> <p>Para este guia, voc\u00ea configurar\u00e1 uma conta proxy usando o tipo de proxy de saldos. Como este tipo permite que o proxy gaste fundos em nome da conta prim\u00e1ria, voc\u00ea deve ter cuidado e fornecer acesso apenas a contas em que confia. O proxy ter\u00e1 acesso para transferir todos os fundos dentro da conta prim\u00e1ria e, se n\u00e3o for confi\u00e1vel, o proxy poder\u00e1 drenar a conta prim\u00e1ria. Certifique-se de manter a supervis\u00e3o de suas contas proxy e remover todos os proxies que n\u00e3o forem mais necess\u00e1rios.</p>"},{"location":"pt/builders/account-management/proxy-accounts/#creating-a-proxy-account","title":"Criando uma Conta Proxy","text":"<p>H\u00e1 algumas maneiras de criar contas proxy no Polkadot.js Apps, seja na p\u00e1gina Extrinsics ou na p\u00e1gina Accounts. No entanto, para criar um proxy com atraso de tempo, voc\u00ea precisar\u00e1 usar a p\u00e1gina Extrinsics. Um atraso de tempo fornece uma camada adicional de seguran\u00e7a para proxies, especificando um per\u00edodo de atraso com base no n\u00famero de blocos. Isso impedir\u00e1 que a conta proxy execute uma transa\u00e7\u00e3o at\u00e9 o final do per\u00edodo de atraso. O atraso permite tempo para a conta prim\u00e1ria que controla o proxy revisar as transa\u00e7\u00f5es pendentes, possivelmente para a\u00e7\u00f5es maliciosas, e cancelar, se necess\u00e1rio, antes da execu\u00e7\u00e3o.</p> <p>A seguinte demonstra\u00e7\u00e3o mostrar\u00e1 como configurar um proxy Balances, que permite a transfer\u00eancia de fundos, tornando-o perfeito para fins de demonstra\u00e7\u00e3o. Depois de configurar seu proxy de saldos, voc\u00ea pode tentar transferir fundos da conta prim\u00e1ria via proxy.</p> <p>Para come\u00e7ar a criar sua conta proxy, v\u00e1 para a aba Developer e selecione Extrinsics no menu suspenso. Em seguida, voc\u00ea precisar\u00e1 seguir as seguintes etapas:</p> <ol> <li>Selecione a conta prim\u00e1ria.</li> <li>No menu suspenso submit the following extrinsic, selecione proxy.</li> <li>Escolha a extr\u00ednseca addProxy.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Selecione a conta delegate para o proxy.</li> <li>No menu suspenso proxyType, escolha Balances.</li> <li>Opcionalmente, voc\u00ea pode adicionar um atraso de tempo usando um n\u00famero especificado de blocos para adicionar uma camada adicional de seguran\u00e7a para que a conta prim\u00e1ria revise a transa\u00e7\u00e3o pendente.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a autorizar e assinar a transa\u00e7\u00e3o. Clique em Sign and Submit para criar o relacionamento proxy. Depois que a transa\u00e7\u00e3o for enviada com sucesso, voc\u00ea receber\u00e1 algumas notifica\u00e7\u00f5es confirmando a transa\u00e7\u00e3o.</p> <p>Como mencionado anteriormente, voc\u00ea tamb\u00e9m pode criar um proxy na p\u00e1gina Accounts. Para fazer isso, navegue at\u00e9 a p\u00e1gina Accounts e siga as seguintes etapas:</p> <ol> <li>Selecione os tr\u00eas pontos verticais ao lado da conta prim\u00e1ria.</li> <li>Selecione Add proxy.</li> </ol> <p></p> <p>Nota</p> <p>Se a conta j\u00e1 tiver um proxy, Manage proxies ser\u00e1 exibido como uma op\u00e7\u00e3o em vez de Add proxy.</p> <p>Aparecer\u00e1 um pop-up e voc\u00ea poder\u00e1 inserir as informa\u00e7\u00f5es necess\u00e1rias, como a conta proxy/prim\u00e1ria, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em Add Proxy.</p> <p></p> <p>Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione a conta que deseja definir como proxy.</li> <li>Selecione o tipo de proxy.</li> <li>Clique em Submit e assine a transa\u00e7\u00e3o.</li> </ol> <p></p> <p>Na pr\u00f3xima se\u00e7\u00e3o, voc\u00ea aprender\u00e1 como verificar se sua conta proxy foi configurada com sucesso.</p>"},{"location":"pt/builders/account-management/proxy-accounts/#verifying-your-proxy-account","title":"Verificando sua Conta Proxy","text":"<p>Voc\u00ea pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: na p\u00e1gina Accounts ou na p\u00e1gina Chain state.</p> <p>Para verificar suas contas proxy na p\u00e1gina Chain state, voc\u00ea pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso selected state query, selecione proxy.</li> <li>Escolha a extr\u00ednseca proxies.</li> <li>Selecione sua conta prim\u00e1ria/proxy.</li> <li>Clique no bot\u00e3o + para enviar a consulta.</li> </ol> <p></p> <p>O resultado aparecer\u00e1 na p\u00e1gina, mostrando informa\u00e7\u00f5es sobre todos os seus proxies, incluindo o endere\u00e7o da conta delegate/proxy, o tipo de proxy, o per\u00edodo de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.</p> <p>Voc\u00ea tamb\u00e9m pode verificar suas contas proxy na p\u00e1gina Accounts. Para fazer isso, navegue at\u00e9 a p\u00e1gina Accounts e dever\u00e1 haver um s\u00edmbolo Proxy ao lado da conta prim\u00e1ria. Passe o mouse sobre o \u00edcone e clique em Manage proxies para revisar seus proxies.</p> <p></p> <p>Aparecer\u00e1 um pop-up onde voc\u00ea poder\u00e1 ver uma vis\u00e3o geral de todas as suas contas proxy.</p> <p></p>"},{"location":"pt/builders/account-management/proxy-accounts/#executando-uma-transa\u00e7\u00e3o-proxy","title":"Executando uma Transa\u00e7\u00e3o Proxy","text":"<p>Agora que voc\u00ea criou uma conta proxy e verificou se ela foi configurada com sucesso, voc\u00ea pode executar uma transa\u00e7\u00e3o usando a conta proxy em nome da conta prim\u00e1ria.</p> <p>Para executar uma transa\u00e7\u00e3o, voc\u00ea pode voltar para a p\u00e1gina Extrinsics e seguir as seguintes etapas:</p> <ol> <li>Selecione a conta proxy para enviar a transa\u00e7\u00e3o pelo menu suspenso using the select account.</li> <li>No menu submit the following extrinsic, selecione proxy.</li> <li>Escolha a extr\u00ednseca proxy.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Selecione a conta prim\u00e1ria no menu suspenso real.</li> <li>Selecione a chamada balances.</li> <li>Escolha a extr\u00ednseca transferKeepAlive.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>No campo dest, insira o endere\u00e7o para o qual voc\u00ea gostaria de enviar fundos.</li> <li>No campo value, insira a quantidade de tokens <code>STAR</code> para enviar. Para este exemplo, voc\u00ea pode enviar <code>2</code> tokens <code>STAR</code>.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Aparecer\u00e1 um pop-up para voc\u00ea autorizar e assinar a transa\u00e7\u00e3o. Insira sua senha para a conta proxy e clique em Sign and Submit.</p> <p>Se a transa\u00e7\u00e3o for bem-sucedida, voc\u00ea dever\u00e1 ver alguns pop-ups de notifica\u00e7\u00e3o. Se voc\u00ea for para a p\u00e1gina Accounts, ver\u00e1 que o saldo de sua conta prim\u00e1ria diminuiu. Se voc\u00ea verificar o saldo da conta para onde enviou os fundos, notar\u00e1 que o saldo aumentou.</p> <p></p> <p>\u00c9 isso! Voc\u00ea executou com sucesso uma transa\u00e7\u00e3o usando uma conta proxy em nome de sua conta prim\u00e1ria.</p>"},{"location":"pt/builders/account-management/proxy-accounts/#removing-a-proxy-account","title":"Removendo uma Conta Proxy","text":"<p>Semelhante \u00e0 adi\u00e7\u00e3o de uma conta proxy, h\u00e1 algumas maneiras de remover uma conta proxy, seja na p\u00e1gina Extrinsics ou na p\u00e1gina Accounts. Independentemente de qual p\u00e1gina voc\u00ea usar, voc\u00ea pode optar por remover uma \u00fanica conta proxy ou todos os proxies associados \u00e0 sua conta prim\u00e1ria.</p> <p>Para remover um proxy da p\u00e1gina Extrinsics, voc\u00ea pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso using the selected account, selecione sua conta prim\u00e1ria.</li> <li>Em seguida, selecione proxy.</li> <li>Escolha removeProxy para remover um \u00fanico proxy ou removeProxies para remover todos os proxies associados.</li> <li>Escolha Id no menu suspenso AccountIdLookupOf.</li> <li>Se estiver removendo um \u00fanico proxy, insira a conta proxy a ser removida no campo delegate.</li> <li>Selecione o proxyType a ser removido, neste caso, escolha Balances.</li> <li>Opcionalmente, selecione um per\u00edodo de atraso em n\u00famero de blocos.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Aparecer\u00e1 um pop-up pedindo que voc\u00ea autorize e assine a transa\u00e7\u00e3o. Voc\u00ea pode assinar e enviar a transa\u00e7\u00e3o da conta prim\u00e1ria ou proxy, mas a chamada para remover o proxy deve ser enviada da conta prim\u00e1ria. Insira sua senha e clique em Sign and Submit.</p> <p>Para verificar se o proxy ou as contas proxy foram removidos, siga as etapas na se\u00e7\u00e3o Verificando sua Conta Proxy.</p> <p>Como mencionado anteriormente, voc\u00ea tamb\u00e9m pode remover um proxy da p\u00e1gina Accounts. Para fazer isso, na p\u00e1gina Accounts, selecione os tr\u00eas pontos verticais ao lado da conta prim\u00e1ria e selecione Manage Proxies.</p> <p></p> <p>Aparecer\u00e1 um pop-up mostrando uma vis\u00e3o geral de suas contas proxy. Para remover todos os proxies, voc\u00ea pode clicar em Clear all, e ser\u00e1 automaticamente solicitado que voc\u00ea insira sua senha e envie a transa\u00e7\u00e3o. Para remover um \u00fanico proxy, siga as seguintes etapas:</p> <ol> <li>Clique no bot\u00e3o X ao lado do proxy para remover</li> <li>Pressione Submit</li> </ol> <p></p> <p>Na tela de confirma\u00e7\u00e3o da transa\u00e7\u00e3o, siga as seguintes etapas:</p> <ol> <li>Certifique-se de n\u00e3o usar um proxy para esta chamada (como este exemplo \u00e9 um proxy de saldos, a chamada para remover o proxy precisa vir da conta prim\u00e1ria, em vez da conta proxy).</li> <li>Insira sua senha para a conta respectiva.</li> <li>Pressione Sign and Submit.</li> </ol> <p></p> <p>Depois que a transa\u00e7\u00e3o for enviada com sucesso, voc\u00ea pode revisar seus proxies atuais ou, se removeu todos os proxies, notar\u00e1 que o \u00edcone do proxy n\u00e3o est\u00e1 mais sendo exibido ao lado da conta prim\u00e1ria. E \u00e9 isso! Voc\u00ea criou com sucesso um proxy, revisou todas as contas proxy associadas \u00e0 sua conta prim\u00e1ria, executou uma transa\u00e7\u00e3o proxy e removeu uma conta proxy!</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/build/","title":"Construa Sua Rede","text":"<p>Lan\u00e7ar sua rede com tecnologia Tanssi oferece a flexibilidade de escolher entre modelos pr\u00e9-configurados ou solu\u00e7\u00f5es totalmente personalizadas. Seja voc\u00ea buscando simplicidade ou controle preciso, a Tanssi fornece as ferramentas e orienta\u00e7\u00f5es para dar vida \u00e0 sua vis\u00e3o. Esta se\u00e7\u00e3o cobre tudo, desde a sele\u00e7\u00e3o de um modelo at\u00e9 a personaliza\u00e7\u00e3o de m\u00f3dulos, testes e implanta\u00e7\u00e3o de sua rede.</p>"},{"location":"pt/builders/build/#o-caminho-para-implantacao","title":"O Caminho para Implanta\u00e7\u00e3o","text":"<p>A implanta\u00e7\u00e3o de uma rede com Tanssi pode ser direta ou altamente personaliz\u00e1vel, dependendo de suas necessidades. O diagrama abaixo fornece uma clara divis\u00e3o dessas op\u00e7\u00f5es para orientar sua decis\u00e3o.</p> <pre><code>flowchart TD\n    Start[Escolha um modelo]\n    Start --&gt; Path1[O modelo \u00e9 suficiente]\n    Start --&gt; Path2[O modelo precisa de personaliza\u00e7\u00e3o]\n\n    Path1 --&gt; Deploy1[Implantar via Tanssi dApp]\n\n    Path2 --&gt; Fork[Fork o reposit\u00f3rio Tanssi]\n    Fork --&gt; Customize[Personalize sua rede]\n    Customize --&gt; Test[Executar testes]\n    Test --&gt; Deploy2[Implantar via Tanssi dApp]</code></pre> <p>Agora que voc\u00ea explorou os caminhos de implanta\u00e7\u00e3o, o pr\u00f3ximo passo \u00e9 aprender mais sobre cada modelo para que voc\u00ea possa escolher aquele que melhor se adapta \u00e0s suas necessidades.</p>"},{"location":"pt/builders/build/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/build/customize/","title":"Personalize Sua Rede com Tanssi","text":"<p>Adapte sua rede para atender aos requisitos exclusivos da sua aplica\u00e7\u00e3o. Esta se\u00e7\u00e3o fornece orienta\u00e7\u00f5es sobre como modificar e estender a funcionalidade da sua rede, oferecendo instru\u00e7\u00f5es e as melhores pr\u00e1ticas para ajud\u00e1-lo a alinh\u00e1-la com os objetivos do seu projeto.</p>"},{"location":"pt/builders/build/customize/#processo-para-personalizar-sua-rede","title":"Processo para Personalizar Sua Rede","text":"<p>O diagrama abaixo fornece um resumo simplificado das etapas essenciais para come\u00e7ar a construir e personalizar sua rede com Tanssi.</p> <pre><code>flowchart LR\n    A[Instale os pr\u00e9-requisitos de software] --&gt; B[Crie e adicione m\u00f3dulos]\n    B --&gt; C[Personalize e gere as especifica\u00e7\u00f5es da cadeia]</code></pre> <p>Para prosseguir, consulte a se\u00e7\u00e3o a seguir, onde voc\u00ea pode encontrar guias detalhados, passo a passo, para cada uma dessas etapas.</p>"},{"location":"pt/builders/build/customize/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/build/customize/adding-built-in-module/","title":"Adicionando um M\u00f3dulo Embutido","text":""},{"location":"pt/builders/build/customize/adding-built-in-module/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Substrate \u00e9 uma estrutura de desenvolvimento de software poderosa e modular inclu\u00edda nos SDKs Polkadot para construir blockchains. Ele fornece um conjunto abrangente de ferramentas e bibliotecas que abstraem funcionalidades complexas de blockchain, permitindo que os desenvolvedores se concentrem na constru\u00e7\u00e3o de recursos e aplica\u00e7\u00f5es inovadoras, focando no runtime, que cont\u00e9m a l\u00f3gica central e as regras da transi\u00e7\u00e3o de estado para o caso de uso.</p> <p>O que diferencia o Substrate \u00e9 sua arquitetura modular, que permite a integra\u00e7\u00e3o perfeita de m\u00f3dulos embutidos e a cria\u00e7\u00e3o de m\u00f3dulos personalizados, facilitando o desenvolvimento de protocolos de blockchain.</p> <p>Para casos que exigem apenas compatibilidade com EVM (Ethereum Virtual Machine), o template fornecido no reposit\u00f3rio Tanssi atende aos requisitos sem outras modifica\u00e7\u00f5es. No entanto, as equipes que desejam construir uma rede Substrate devem adicionar e configurar m\u00f3dulos embutidos e personalizados dentro do runtime. Isso envolve compilar, gerar a especifica\u00e7\u00e3o da cadeia e implantar por meio do protocolo Tanssi para transform\u00e1-lo em uma rede ao vivo com tecnologia Tanssi.</p> <p>Este artigo enfoca as etapas necess\u00e1rias para adicionar um m\u00f3dulo embutido ao template EVM.</p>"},{"location":"pt/builders/build/customize/adding-built-in-module/#verifying-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para seguir as etapas deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Um ambiente de desenvolvimento saud\u00e1vel com o compilador Rust e o gerenciador de pacotes Cargo</li> <li>O reposit\u00f3rio Tanssi, clonado do GitHub</li> </ul> <p>Voc\u00ea pode ler mais sobre como instalar os componentes necess\u00e1rios no artigo de pr\u00e9-requisitos.</p> <p>Como este artigo \u00e9 baseado no template EVM, certifique-se de que ele compile corretamente antes de continuar, executando o seguinte comando:</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre>"},{"location":"pt/builders/build/customize/adding-built-in-module/#adding-builtin-module-to-runtime","title":"Adicionando um M\u00f3dulo Embutido ao Runtime","text":"<p>Como introduzido no artigo de modularidade, o framework Substrate j\u00e1 inclui muitos m\u00f3dulos embutidos que abordam uma ampla gama de funcionalidades, prontos para serem usados em seu runtime.</p> <p>Os m\u00f3dulos s\u00e3o projetados para fornecer a funcionalidade necess\u00e1ria em casos de uso muito diferentes, como DeFi, NFTs ou qualquer outro, e, portanto, s\u00e3o blocos de constru\u00e7\u00e3o b\u00e1sicos que s\u00e3o inerentemente abstratos e podem ser configurados de acordo com as necessidades espec\u00edficas da rede com tecnologia Tanssi.</p> <p>Para adicionar um m\u00f3dulo, as seguintes etapas s\u00e3o necess\u00e1rias:</p> <ol> <li>Tornar a depend\u00eancia dispon\u00edvel dentro do projeto, declarando-a em Cargo, o gerenciador de pacotes da linguagem Rust</li> <li>Tornar os recursos padr\u00e3o (<code>std</code>) do m\u00f3dulo dispon\u00edveis para o compilador</li> <li>Configurar o m\u00f3dulo</li> <li>Adicionar o m\u00f3dulo ao runtime</li> <li>Adicionar a configura\u00e7\u00e3o padr\u00e3o \u00e0 especifica\u00e7\u00e3o da cadeia</li> </ol> <p>No exemplo a seguir, o popular m\u00f3dulo Substrate <code>pallet-assets</code> \u00e9 adicionado ao runtime do template EVM fornecido, encontrado no reposit\u00f3rio Tanssi, especificamente na pasta <code>container-chains/templates/frontier/</code>.</p>"},{"location":"pt/builders/build/customize/adding-built-in-module/#declare-dependency","title":"Declarar a Depend\u00eancia","text":"<p>Cada pacote cont\u00e9m um arquivo de manifesto chamado <code>Cargo.toml</code> que declara, entre outras coisas, todas as depend\u00eancias em que o pacote se baseia, e o runtime da rede com tecnologia Tanssi n\u00e3o \u00e9 exce\u00e7\u00e3o.</p> <p>Portanto, a primeira etapa \u00e9 declarar a depend\u00eancia e torn\u00e1-la dispon\u00edvel para o runtime. Abra o arquivo <code>Cargo.toml</code> localizado na pasta <code>container-chains/templates/frontier/runtime</code> com um editor de texto e adicione o m\u00f3dulo, referenciando o c\u00f3digo no Polkadot SDK:</p> <pre><code>[dependencies]\n...\npallet-assets = { \n   git = \"https://github.com/moondance-labs/polkadot-sdk\", \n   branch = \"tanssi-polkadot-stable2503\", \n   default-features = false \n}\n...\n</code></pre> <p>Nota</p> <p>Nossa equipe de engenharia contribui ativamente para o desenvolvimento do Substrate, corrigindo problemas e aprimorando funcionalidades. Como resultado, o reposit\u00f3rio fork Tanssi frequentemente fica \u00e0 frente do oficial. \u00c9 por isso que este exemplo faz refer\u00eancia a um m\u00f3dulo embutido de um reposit\u00f3rio Tanssi em vez do oficial.</p>"},{"location":"pt/builders/build/customize/adding-built-in-module/#standard-features","title":"Tornar os Recursos Padr\u00e3o Dispon\u00edveis para o Compilador","text":"<p>No Cargo, as flags de \u201crecursos\u201d fornecem um mecanismo para dizer ao compilador para incluir ou omitir determinadas partes do c\u00f3digo, o que \u00e9 um mecanismo \u00fatil para otimizar o tempo de compila\u00e7\u00e3o, minimizar os tamanhos dos arquivos bin\u00e1rios ou desabilitar determinado comportamento (por exemplo, n\u00e3o incluir testes unit\u00e1rios ou funcionalidade de benchmarking no runtime pretendido para produ\u00e7\u00e3o).</p> <p>Para compilar os recursos padr\u00e3o para o m\u00f3dulo Assets dentro do runtime, o mesmo arquivo <code>Cargo.toml</code> na pasta <code>runtime</code> deve ser editado, ativando a flag. Tudo o que est\u00e1 listado nesta se\u00e7\u00e3o garantir\u00e1 que esteja dispon\u00edvel para o compilador ao construir o bin\u00e1rio do runtime, que \u00e9, em \u00faltima an\u00e1lise, o arquivo que cont\u00e9m todas as informa\u00e7\u00f5es para executar sua rede com tecnologia Tanssi inicialmente.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-assets/std\",\n   ...\n]\n</code></pre>"},{"location":"pt/builders/build/customize/adding-built-in-module/#configure-the-module","title":"Configurar o M\u00f3dulo","text":"<p>Com a depend\u00eancia declarada no projeto, o m\u00f3dulo agora pode ser configurado e adicionado ao runtime. Para fazer isso, voc\u00ea precisa editar o arquivo <code>lib.rs</code> que est\u00e1 localizado em:</p> <pre><code>container-chains/templates/frontier/runtime/src/lib.rs\n</code></pre> <p>A configura\u00e7\u00e3o de novos m\u00f3dulos requer a implementa\u00e7\u00e3o de um <code>trait</code> de configura\u00e7\u00e3o para o m\u00f3dulo (neste exemplo, para Assets) no runtime, expresso em Rust da seguinte forma:</p> <pre><code>// Implementa o trait pallet_assets::Config no runtime\nimpl pallet_assets::Config for Runtime { ... }\n</code></pre> <p>Traits s\u00e3o uma forma de definir comportamento compartilhado em Rust e, neste caso, eles permitem que um novo runtime se beneficie da funcionalidade que o m\u00f3dulo Assets fornece apenas implementando seu trait de configura\u00e7\u00e3o e par\u00e2metros.</p> <p>Alguns dos par\u00e2metros que o trait precisa definir podem ser valores constantes; nesse caso, eles precisam ser definidos e inclu\u00eddos na macro <code>parameter_types!</code>, o que nos ajuda a reduzir o esfor\u00e7o de desenvolvimento, expandindo o c\u00f3digo e convertendo cada uma das constantes no tipo de struct correto com fun\u00e7\u00f5es que permitem que o runtime leia seu tipo e valores de forma padronizada.</p> <p>O seguinte trecho de c\u00f3digo mostra um exemplo das defini\u00e7\u00f5es de constantes a serem usadas na configura\u00e7\u00e3o do m\u00f3dulo:</p> <pre><code>parameter_types! {\n   // A quantidade de fundos que devem ser reservados para um ativo\n    pub const AssetDeposit: Balance = 100;\n   // A quantidade de fundos que deve ser reservada ao criar \n   // uma nova aprova\u00e7\u00e3o de transfer\u00eancia\n    pub const ApprovalDeposit: Balance = 1;\n   // A quantidade b\u00e1sica de fundos que deve ser reservada ao adicionar metadados \n   // ao seu ativo\n    pub const MetadataDepositBase: Balance = 10;\n   // Os fundos adicionais que devem ser reservados para o n\u00famero de bytes \n   // que voc\u00ea armazena em seus metadados\n    pub const MetadataDepositPerByte: Balance = 1;\n\n   // Comprimento m\u00e1ximo para o s\u00edmbolo do ativo e nome amig\u00e1vel\n   pub const StringLimit: u32 = 50;\n}\n</code></pre> <p>\u00c9 importante notar que cada m\u00f3dulo embutido tem um prop\u00f3sito diferente e, portanto, cada um deles tem necessidades diferentes em termos dos par\u00e2metros que devem ser configurados. O seguinte trecho de c\u00f3digo implementa o trait e configura o m\u00f3dulo Assets, usando tipos e as constantes definidas anteriormente na macro <code>parameter_types!</code>:</p> <pre><code>// Implementando o trait de configura\u00e7\u00e3o de Ativos para o runtime\nimpl pallet_assets::Config for Runtime {\n\n   // Armazena os saldos em um inteiro sem sinal de 128bits\n    type Balance = u128;\n   // O ID de um ativo pode ser definido como um inteiro sem sinal de 64 bits\n    type AssetId = u64;\n   // Usa o m\u00f3dulo Balances como mecanismo para opera\u00e7\u00f5es de moeda\n    type Currency = Balances;\n\n   // Configurar o m\u00f3dulo referenciando a anteriormente\n   // constantes definidas\n\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n   // Mais configura\u00e7\u00e3o\n   ...\n}\n</code></pre> Ver o script completo <pre><code>parameter_types! {\n    // The amount of funds that must be reserved for an asset\n    pub const AssetDeposit: Balance = 100;\n    // The amount of funds that must be reserved when creating \n    // a new transfer approval\n    pub const ApprovalDeposit: Balance = 1;\n    // The basic amount of funds that must be reserved when adding metadata \n    // to your asset\n    pub const MetadataDepositBase: Balance = 10;\n    // The additional funds that must be reserved for the number of bytes \n    // you store in your metadata\n    pub const MetadataDepositPerByte: Balance = 1;\n    // Maximum lenght for the asset symbol and friendly name\n    pub const StringLimit: u32 = 50;\n}\n\n// Implementing the Assets config trait for the runtime\nimpl pallet_assets::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n\n    // Stores the balances in an unsigned integer of 128bits\n    type Balance = u128;\n    // The id of an asset can be defined as an unsigned integer of 64 bits\n    type AssetId = u64;\n    // Uses module Balances as mechanism for currency operations\n    type Currency = Balances;\n\n    // Configure the module by referencing the previously\n    // defined constants\n    type AssetDeposit = AssetDeposit;\n    type MetadataDepositBase = MetadataDepositBase;\n    type MetadataDepositPerByte = MetadataDepositPerByte;\n    type ApprovalDeposit = ApprovalDeposit;\n    type StringLimit = StringLimit;\n\n    // More configuration\n    type AssetIdParameter = u64;\n    // Defines the allowed origins to create assets\n    type CreateOrigin = \n        frame_support::traits::AsEnsureOriginWithArg&lt;frame_system::EnsureSigned&lt;AccountId&gt;&gt;;\n    // Root can create assets\n    type ForceOrigin = EnsureRoot&lt;AccountId&gt;;\n    type AssetAccountDeposit = frame_support::traits::ConstU128&lt;1&gt;;\n    type Freezer = ();\n    type Extra = ();\n    type WeightInfo = pallet_assets::weights::SubstrateWeight&lt;Runtime&gt;;\n    type RemoveItemsLimit = frame_support::traits::ConstU32&lt;1000&gt;;\n    #[cfg(feature = \"runtime-benchmarks\")]\n    type BenchmarkHelper = ();\n    type CallbackHandle = ();\n}\n</code></pre> <p>A configura\u00e7\u00e3o completa do m\u00f3dulo cont\u00e9m mais par\u00e2metros; para ver uma descri\u00e7\u00e3o detalhada de cada um deles, consulte o trait de configura\u00e7\u00e3o oficial para a documenta\u00e7\u00e3o do m\u00f3dulo Assets.</p>"},{"location":"pt/builders/build/customize/adding-built-in-module/#add-module-to-runtime","title":"Adicionar o M\u00f3dulo ao Runtime","text":"<p>In the same <code>lib.rs</code> file referenced in the previous section, there is a segment enclosed in the macro <code>construct_runtime!()</code>. This is where the pallet must be added to be included in the runtime. Since the example is based on the EVM template, the runtime is already configured to include many modules, including the modules for system support, the modules to add the Ethereum compatibility layer, the modules to support the Tanssi protocol, balances, and now also Assets:</p> <pre><code>construct_runtime!(\n   pub enum Runtime where\n      Block = Block,\n      NodeBlock = opaque::Block,\n      UncheckedExtrinsic = UncheckedExtrinsic,\n   {\n      // Coisas de suporte do sistema.\n      System: frame_system = 0,\n      ParachainSystem: cumulus_pallet_parachain_system = 1,\n      Timestamp: pallet_timestamp = 2,\n      ParachainInfo: parachain_info = 3,\n      Sudo: pallet_sudo = 4,\n      Utility: pallet_utility = 5,\n      ...\n      Balances: pallet_balances = 10,\n      // M\u00f3dulo Assets \u00e9 adicionado aqui\n      Assets: pallet_assets = 11,\n      ...\n   }\n</code></pre>"},{"location":"pt/builders/build/customize/adding-built-in-module/#configure-chain-specs","title":"Configurar o M\u00f3dulo na Especifica\u00e7\u00e3o da Cadeia","text":"<p>Finally, add the configuration in the chain specification for the genesis state in the file <code>chain_spec.rs</code> located at:</p> <pre><code>container-chains/templates/frontier/node/src/`chain_spec.rs`\n</code></pre> <p>A fun\u00e7\u00e3o <code>testnet_genesis</code>, apresentada no seguinte trecho de c\u00f3digo, define o estado inicial para os m\u00f3dulos inclu\u00eddos no runtime (como contas financiadas inicialmente, por exemplo). Depois de adicionar o m\u00f3dulo Assets, \u00e9 necess\u00e1rio inicializ\u00e1-lo tamb\u00e9m e, no exemplo a seguir, seus valores padr\u00e3o s\u00e3o definidos.</p> <p>Mais detalhes sobre a especifica\u00e7\u00e3o da cadeia e como configur\u00e1-la ser\u00e3o abordados no artigo Personalizando Especifica\u00e7\u00f5es de Cadeia.</p> <pre><code>fn testnet_genesis(\n   endowed_accounts: Vec&lt;AccountId&gt;,\n   id: ParaId,\n   root_key: AccountId,\n) -&gt; container_chain_template_frontier_runtime::GenesisConfig {\n   container_chain_template_frontier_runtime::GenesisConfig {\n      system: container_chain_template_frontier_runtime::SystemConfig {\n         code: container_chain_template_frontier_runtime::WASM_BINARY\n               .expect(\"O bin\u00e1rio WASM n\u00e3o foi constru\u00eddo, por favor, construa-o!\")\n               .to_vec(),\n      },\n      ...\n      // Adicione o estado padr\u00e3o para este m\u00f3dulo no estado de g\u00eanese\n      assets: Default::default()\n      ...\n}\n</code></pre> <p>Com o m\u00f3dulo inclu\u00eddo, esta nova vers\u00e3o do runtime desbloqueou um novo conjunto de funcionalidades prontas para serem compostas com ainda mais dos m\u00f3dulos embutidos do Substrate ou personalizados.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/","title":"Adicionar um m\u00f3dulo personalizado","text":""},{"location":"pt/builders/build/customize/adding-custom-made-module/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Ao fornecer uma biblioteca abrangente de m\u00f3dulos pr\u00e9-constru\u00eddos que abordam muitos requisitos comuns, a estrutura simplifica enormemente o processo de constru\u00e7\u00e3o de um blockchain e acelera a implanta\u00e7\u00e3o e evolu\u00e7\u00e3o em uma rede com tecnologia Tanssi. No entanto, abordar um caso de uso inovador geralmente exige um esfor\u00e7o de desenvolvimento para atender totalmente aos requisitos e, no Substrate, adicionar l\u00f3gica personalizada se traduz em escrever e integrar m\u00f3dulos de tempo de execu\u00e7\u00e3o.</p> <p>O exemplo apresentado no artigo Modularidade mostra um m\u00f3dulo de loteria simples que exp\u00f5e duas transa\u00e7\u00f5es:</p> <ul> <li>Buy tickets - esta fun\u00e7\u00e3o gerencia a entrada de um usu\u00e1rio na loteria. Essencialmente, ela verifica se o participante tem saldo suficiente, n\u00e3o est\u00e1 participando e cuida da transfer\u00eancia de fundos para registrar o usu\u00e1rio na loteria</li> <li>Award prize - esta fun\u00e7\u00e3o que lida com um usu\u00e1rio que entra na loteria. Em alto n\u00edvel, ela busca um n\u00famero pseudo-aleat\u00f3rio para obter um vencedor e lida com a distribui\u00e7\u00e3o do pr\u00eamio</li> </ul> <p>A implementa\u00e7\u00e3o dessas transa\u00e7\u00f5es tamb\u00e9m usa armazenamento, emite eventos, define erros personalizados e depende de outros m\u00f3dulos para lidar com a moeda (para cobrar pelos bilhetes e transferir o valor total para o vencedor) e aleatorizar a sele\u00e7\u00e3o do vencedor.</p> <p>Neste artigo, as seguintes etapas, necess\u00e1rias para construir e adicionar o m\u00f3dulo de exemplo ao tempo de execu\u00e7\u00e3o, ser\u00e3o abordadas:</p> <ol> <li>Criar os arquivos do m\u00f3dulo de loteria (pacote).</li> <li>Configurar as depend\u00eancias do m\u00f3dulo.</li> <li>Adicionar l\u00f3gica personalizada.</li> <li>Configurar o tempo de execu\u00e7\u00e3o com o novo m\u00f3dulo.</li> </ol> <p>\u00c9 importante ressaltar que nenhum dos c\u00f3digos apresentados neste artigo se destina ao uso em produ\u00e7\u00e3o.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para seguir as etapas deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Clonar o reposit\u00f3rio Tanssi do Github</li> <li>Compilador Rust e gerenciador de pacotes Cargo</li> </ul> <p>Voc\u00ea pode ler mais sobre como instalar o Rust e o Cargo no artigo de pr\u00e9-requisitos.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#creating-lottery-module-files","title":"Criando os arquivos do m\u00f3dulo de loteria","text":"<p>Antes de iniciar seu processo de codifica\u00e7\u00e3o, \u00e9 essencial criar os arquivos que cont\u00eam sua l\u00f3gica. Os m\u00f3dulos Substrate s\u00e3o abstratos e destinados ao reaproveitamento em diferentes tempos de execu\u00e7\u00e3o com v\u00e1rias personaliza\u00e7\u00f5es. Para conseguir isso, voc\u00ea usar\u00e1 o Cargo, o gerenciador de pacotes do Rust, para criar o m\u00f3dulo como um novo pacote.</p> <p>Como mencionado na se\u00e7\u00e3o de pr\u00e9-requisitos, a primeira etapa \u00e9 clonar o reposit\u00f3rio Tanssi e, na pasta raiz, navegar at\u00e9 <code>pallets</code>, onde o m\u00f3dulo ser\u00e1 criado.</p> <pre><code>cd container-chains/pallets\n</code></pre> <p>Em seguida, crie o pacote do m\u00f3dulo com o Cargo:</p> <pre><code>cargo new lottery-example\n</code></pre> <p>Por padr\u00e3o, o Cargo cria o novo pacote em uma pasta com o nome fornecido (<code>lottery-example</code>, neste caso), contendo um arquivo de manifesto, <code>Cargo.toml</code> e uma pasta <code>src</code> com um arquivo <code>main.rs</code>. Para respeitar a conven\u00e7\u00e3o de nomenclatura usada no Substrate, o arquivo <code>main.rs</code> \u00e9 renomeado para <code>lib.rs</code>:</p> <pre><code>mv lottery-example/src/main.rs lottery-example/src/lib.rs\n</code></pre> <p>Depois de executar todos os comandos, o m\u00f3dulo \u00e9 criado e est\u00e1 pronto para conter a l\u00f3gica personalizada que voc\u00ea adicionar\u00e1 nas se\u00e7\u00f5es a seguir.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#configure-module-dependencies","title":"Configurar as depend\u00eancias do m\u00f3dulo","text":"<p>Como o m\u00f3dulo funciona como um pacote independente, ele tem seu pr\u00f3prio arquivo Cargo.toml, onde voc\u00ea deve especificar os atributos e depend\u00eancias do m\u00f3dulo.</p> <p>Por exemplo, voc\u00ea pode usar atributos para especificar detalhes como o nome do m\u00f3dulo, vers\u00e3o, autores e outras informa\u00e7\u00f5es relevantes. Por exemplo, no m\u00f3dulo <code>lottery-example</code>, o arquivo <code>Cargo.toml</code> pode ser configurado da seguinte forma:</p> <pre><code>#[pallet::storage]\n#[pallet::getter(fn get_participants)]\npub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n    _,\n    BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n    OptionQuery\n&gt;;\n</code></pre> <p>Este arquivo tamb\u00e9m define as depend\u00eancias do m\u00f3dulo, como a funcionalidade principal que permite a integra\u00e7\u00e3o perfeita com o tempo de execu\u00e7\u00e3o e outros m\u00f3dulos, acesso ao armazenamento, emiss\u00e3o de eventos e muito mais.</p> <p>O exemplo completo do arquivo <code>Cargo.toml</code> define, al\u00e9m dos atributos, as depend\u00eancias exigidas pelo Substrate:</p> Ver o arquivo Cargo.toml completo <pre><code>[package]\nname = \"module-lottery-example\"\nversion = \"4.0.0-dev\"\ndescription = \"Simple module example\"\nauthors = [\"\"]\nhomepage = \"\"\nedition = \"2021\"\npublish = false\n\n[package.metadata.docs.rs]\ntargets = [\"x86_64-unknown-linux-gnu\"]\n\n[dependencies]\ncodec = { package = \"parity-scale-codec\", version = \"3.6.1\", default-features = false, features = [\n    \"derive\",\n] }\nscale-info = { version = \"2.5.0\", default-features = false, features = [\"derive\"] }\nframe-benchmarking = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    optional = true, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-support = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\nframe-system = { \n    version = \"4.0.0-dev\", \n    default-features = false, \n    git = \"https://github.com/paritytech/substrate.git\", \n    branch = \"polkadot-v1.0.0\" \n}\n\n[dev-dependencies]\nsp-core = { version = \"21.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-io = { version = \"23.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\nsp-runtime = { version = \"24.0.0\", git = \"https://github.com/paritytech/substrate.git\", branch = \"polkadot-v1.0.0\" }\n\n[features]\ndefault = [\"std\"]\nstd = [\n    \"codec/std\",\n    \"frame-benchmarking?/std\",\n    \"frame-support/std\",\n    \"frame-system/std\",\n    \"scale-info/std\",\n]\nruntime-benchmarks = [\"frame-benchmarking/runtime-benchmarks\"]\ntry-runtime = [\"frame-support/try-runtime\"]\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#adding-custom-logic","title":"Adicionando l\u00f3gica personalizada","text":"<p>Conforme apresentado na se\u00e7\u00e3o m\u00f3dulo personalizado do artigo sobre modularidade, a cria\u00e7\u00e3o de um m\u00f3dulo envolve a implementa\u00e7\u00e3o das seguintes macros de atributo, das quais as tr\u00eas primeiras s\u00e3o obrigat\u00f3rias:</p> <ul> <li><code>#[frame_support::pallet]</code> - atributo de entrada que marca o m\u00f3dulo como utiliz\u00e1vel no runtime</li> <li><code>#[pallet::pallet]</code> - aplicado a uma estrutura usada para recuperar informa\u00e7\u00f5es do m\u00f3dulo com facilidade</li> <li><code>#[pallet::config]</code> - atributo obrigat\u00f3rio para definir a configura\u00e7\u00e3o dos tipos de dados do m\u00f3dulo</li> <li><code>#[pallet::call]</code> - macro usada para definir fun\u00e7\u00f5es expostas como transa\u00e7\u00f5es, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transa\u00e7\u00f5es e l\u00f3gica personalizadas</li> <li><code>#[pallet::error]</code> - como transa\u00e7\u00f5es podem falhar (por exemplo, fundos insuficientes) e, por seguran\u00e7a, um m\u00f3dulo n\u00e3o deve gerar exce\u00e7\u00f5es, todos os poss\u00edveis erros devem ser identificados e listados em um enum para serem retornados em uma execu\u00e7\u00e3o malsucedida</li> <li><code>#[pallet::event]</code> - eventos podem ser definidos e usados para fornecer mais informa\u00e7\u00f5es ao usu\u00e1rio</li> <li><code>#[pallet::storage]</code> - macro usada para definir elementos que ser\u00e3o persistidos em storage; como recursos s\u00e3o escassos em uma blockchain, deve ser usada com parcim\u00f4nia para armazenar apenas informa\u00e7\u00f5es essenciais</li> </ul>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-basic-structure","title":"Implementando a estrutura b\u00e1sica do m\u00f3dulo","text":"<p>As duas primeiras macros obrigat\u00f3rias, <code>#[frame_support::pallet]</code> e <code>#[pallet::pallet]</code>, fornecem a estrutura b\u00e1sica do m\u00f3dulo e s\u00e3o necess\u00e1rias para habilitar o m\u00f3dulo a ser usado em um tempo de execu\u00e7\u00e3o Substrate.</p> <p>A seguir, \u00e9 apresentada a estrutura geral de um m\u00f3dulo Substrate personalizado.</p> <pre><code>#[frame_support::pallet(dev_mode)]\npub mod pallet {\n    ...\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_); \n\n       // Toda a l\u00f3gica vai aqui\n}\n</code></pre> <p>A pr\u00f3xima etapa seria adicionar a terceira macro obrigat\u00f3ria (<code>#[pallet::config]</code>) e toda a l\u00f3gica personalizada, conforme mostrado nas se\u00e7\u00f5es a seguir.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-module-configuration","title":"Implementando a configura\u00e7\u00e3o do m\u00f3dulo","text":"<p>Para tornar os m\u00f3dulos altamente adapt\u00e1veis, sua configura\u00e7\u00e3o \u00e9 abstrata o suficiente para permitir que sejam adaptados aos requisitos espec\u00edficos do caso de uso que o tempo de execu\u00e7\u00e3o implementa.</p> <p>A implementa\u00e7\u00e3o da macro <code>#[pallet::config]</code> \u00e9 obrigat\u00f3ria e define a depend\u00eancia do m\u00f3dulo em outros m\u00f3dulos e os tipos e valores especificados pelas configura\u00e7\u00f5es espec\u00edficas do tempo de execu\u00e7\u00e3o.</p> <p>No m\u00f3dulo <code>lottery-example</code> personalizado que voc\u00ea est\u00e1 construindo, o m\u00f3dulo depende de outros m\u00f3dulos para gerenciar a moeda e a fun\u00e7\u00e3o aleat\u00f3ria para selecionar o vencedor. O m\u00f3dulo tamb\u00e9m l\u00ea e usa o pre\u00e7o do bilhete e o n\u00famero m\u00e1ximo de participantes diretamente das configura\u00e7\u00f5es do tempo de execu\u00e7\u00e3o. Consequentemente, a configura\u00e7\u00e3o precisa incluir essas depend\u00eancias:</p> <ul> <li>Events - o m\u00f3dulo depende da defini\u00e7\u00e3o de um evento do tempo de execu\u00e7\u00e3o para poder emiti-los</li> <li>Currency - o m\u00f3dulo <code>lottery-example</code> precisa poder transferir fundos, portanto, precisa da defini\u00e7\u00e3o do sistema monet\u00e1rio do tempo de execu\u00e7\u00e3o</li> <li>Randomness - este m\u00f3dulo \u00e9 usado para selecionar de forma justa o vencedor do pr\u00eamio da lista de participantes. Ele gera os n\u00fameros aleat\u00f3rios usando os hashes de bloco anteriores e o n\u00famero do bloco atual como semente</li> <li>Ticket coste - o pre\u00e7o a ser cobrado dos compradores que participam da loteria</li> <li>Maximum number of participants - o limite m\u00e1ximo de participantes permitido em cada rodada da loteria</li> <li>Module Id - o identificador exclusivo do m\u00f3dulo \u00e9 necess\u00e1rio para acessar a conta do m\u00f3dulo para manter os fundos dos participantes at\u00e9 serem transferidos para o vencedor</li> </ul> <p>A implementa\u00e7\u00e3o da configura\u00e7\u00e3o descrita para este exemplo \u00e9 mostrada no seguinte trecho de c\u00f3digo:</p> <pre><code>#[pallet::config]\npub trait Config: frame_system::Config {\n\n    // Defini\u00e7\u00e3o do evento\n    type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt;\n        + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n    // Moeda\n    type Currency: Currency&lt;Self::AccountId&gt;;\n\n    // Aleatoriedade\n    type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n    // Custo do bilhete\n    #[pallet::constant]\n    type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n    // N\u00famero m\u00e1ximo de participantes\n    #[pallet::constant]\n    type MaxParticipants: Get&lt;u32&gt;;\n\n    // ID do m\u00f3dulo\n    #[pallet::constant]\n    type PalletId: Get&lt;PalletId&gt;;\n}\n</code></pre> <p>Esta defini\u00e7\u00e3o abstrata de depend\u00eancias \u00e9 crucial para evitar o acoplamento a um caso de uso espec\u00edfico e para permitir que os m\u00f3dulos sirvam como blocos de constru\u00e7\u00e3o b\u00e1sicos para as redes Substrate.</p>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-transactions","title":"Implementando Transa\u00e7\u00f5es","text":"<p>Chamadas representam o comportamento que um tempo de execu\u00e7\u00e3o exp\u00f5e na forma de transa\u00e7\u00f5es que podem ser despachadas para processamento, expondo a l\u00f3gica personalizada adicionada ao m\u00f3dulo.</p> <p>Cada chamada est\u00e1 inclu\u00edda na macro <code>#[pallet::call]</code> e apresenta os seguintes elementos:</p> <ul> <li>Call Index - \u00e9 um identificador exclusivo obrigat\u00f3rio para cada chamada despach\u00e1vel</li> <li>Weight - \u00e9 uma medida do esfor\u00e7o computacional que uma extr\u00ednseca leva ao ser processada. Mais sobre pesos est\u00e1 na documenta\u00e7\u00e3o do Polkadot</li> <li>Origin - identifica a conta de assinatura que est\u00e1 fazendo a chamada</li> <li>Result - o valor de retorno da chamada, que pode ser um <code>Erro</code> se alguma coisa der errado</li> </ul> <p>A seguinte trecho apresenta a estrutura geral da implementa\u00e7\u00e3o da macro mencionada e os elementos de chamada:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn one_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn another_call(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult { }\n\n    // Outras chamadas\n}\n</code></pre> <p>Neste m\u00f3dulo <code>lottery-example</code>, definimos duas chamadas com a seguinte l\u00f3gica:</p> <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]    \n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Valida a assinatura de origem\n        // 2. Verifica se o usu\u00e1rio tem saldo suficiente para pagar o pre\u00e7o do bilhete\n        // 3. Verifica se o usu\u00e1rio j\u00e1 n\u00e3o est\u00e1 participando\n        // 4. Adiciona o usu\u00e1rio como um novo participante do pr\u00eamio\n        // 5. Transfere o custo do bilhete para a conta do m\u00f3dulo, para ser mantido at\u00e9 ser transferido para o vencedor\n        // 6. Notifica o evento\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n        // 1. Valida a assinatura de origem\n        // 2. Obt\u00e9m um n\u00famero aleat\u00f3rio do m\u00f3dulo de aleatoriedade\n        // 3. Seleciona o vencedor da lista de participantes\n        // 4. Transfere o pr\u00eamio total para a conta do vencedor\n        // 5. Redefine a lista de participantes e prepara-se para outra rodada da loteria\n    }\n}\n</code></pre> <p>Essas chamadas tamb\u00e9m emitem eventos para manter o usu\u00e1rio informado e podem retornar erros caso alguma das valida\u00e7\u00f5es d\u00ea errado.</p> <p>Aqui est\u00e1 a implementa\u00e7\u00e3o completa das chamadas com a l\u00f3gica da loteria personalizada:</p> Ver o c\u00f3digo de chamadas completo <pre><code>#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n    #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let buyer = ensure_signed(origin)?;\n\n        // 2. Checks that the user has enough balance to afford the ticket price\n        ensure!(\n            T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n            Error::&lt;T&gt;::NotEnoughCurrency\n        );\n\n        // 3. Checks that the user is not already participating\n        if let Some(participants) = Self::get_participants() {\n            ensure!(\n                !participants.contains(&amp;buyer),\n                Error::&lt;T&gt;::AccountAlreadyParticipating\n            );\n        }\n\n        // 4. Adds the user as a new participant for the prize\n        match Self::get_participants() {\n            Some(mut participants) =&gt; { \n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }, \n            None =&gt; {\n                let mut participants = BoundedVec::new();\n                ensure!(\n                    participants.try_push(buyer.clone()).is_ok(), \n                    Error::&lt;T&gt;::CanNotAddParticipant\n                );\n                Participants::&lt;T&gt;::set(Some(participants));\n            }\n        };\n\n        // 5. Transfers the ticket cost to the module's account\n        // to be hold until transferred to the winner\n        T::Currency::transfer(\n            &amp;buyer, \n            &amp;Self::get_pallet_account(), \n            T::TicketCost::get(), \n            ExistenceRequirement::KeepAlive)?;\n\n        // 6. Notify the event\n        Self::deposit_event(Event::TicketBought { who: buyer });\n        Ok(())\n    }\n\n    #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n        // 1. Validates the origin signature\n        let _who = ensure_root(origin)?;\n\n        match Self::get_participants() {\n            Some(participants) =&gt; { \n\n                // 2. Gets a random number from the randomness module\n                let nonce = Self::get_and_increment_nonce();\n                let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                    .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                // 3. Selects the winner from the participants lit\n                let winner_index = random_number as usize % participants.len();\n                let winner = participants.as_slice().get(winner_index).unwrap();\n\n                // 4. Transfers the total prize to the winner's account\n                let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                T::Currency::transfer(\n                    &amp;Self::get_pallet_account(), \n                    &amp;winner, \n                    prize, \n                    ExistenceRequirement::AllowDeath)?;\n\n                // 5. Resets the participants list, and gets ready for another lottery round\n                Participants::&lt;T&gt;::kill();\n\n                // 6. Notify the event\n                Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n            }, \n            None =&gt; {\n                // Notify the event (No participants)\n                Self::deposit_event(Event::ThereAreNoParticipants);\n            }\n        };\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-custom-errors","title":"Implementando erros personalizados","text":"<p>A macro <code>#[pallet::error]</code> \u00e9 usada para anotar uma enumera\u00e7\u00e3o de erros potenciais que poderiam ocorrer durante a execu\u00e7\u00e3o. \u00c9 crucial para a seguran\u00e7a garantir que todas as situa\u00e7\u00f5es de erro sejam tratadas com eleg\u00e2ncia, sem causar a falha do tempo de execu\u00e7\u00e3o.</p> <p>O exemplo a seguir desta implementa\u00e7\u00e3o de macro mostra os erros que podem ocorrer no m\u00f3dulo da loteria:</p> <pre><code>// Erros informam aos usu\u00e1rios que algo deu errado.\n#[pallet::error]\npub enum `Error`&lt;T&gt; {\n    NotEnoughCurrency,\n    AccountAlreadyParticipating,\n    CanNotAddParticipant,\n}\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-events","title":"Implementando eventos","text":"<p>A macro <code>#[pallet::event]</code> \u00e9 aplicada a uma enumera\u00e7\u00e3o de eventos para informar o usu\u00e1rio sobre quaisquer altera\u00e7\u00f5es no estado ou a\u00e7\u00f5es importantes que ocorreram durante a execu\u00e7\u00e3o no tempo de execu\u00e7\u00e3o.</p> <p>Como exemplo, para o m\u00f3dulo <code>lottery-example</code>, esta macro pode ser configurada com os seguintes eventos:</p> <pre><code>#[pallet::event]\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\npub enum Event&lt;T: Config&gt; {\n\n    // Evento emitido quando um bilhete \u00e9 comprado\n    TicketBought { who: T::AccountId },\n    // Evento emitido quando o pr\u00eamio \u00e9 concedido\n    PrizeAwarded { winner: T::AccountId },\n    // Evento emitido quando n\u00e3o h\u00e1 participantes  \n    ThereAreNoParticipants,\n    }\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#implementing-storage","title":"Implementando o armazenamento para persist\u00eancia de estado","text":"<p>A macro <code>#[pallet::storage]</code> inicializa uma estrutura de armazenamento de tempo de execu\u00e7\u00e3o. No ambiente altamente restrito de blockchains, decidir o que armazenar e qual estrutura usar pode ser fundamental em termos de desempenho. Mais sobre esse t\u00f3pico \u00e9 abordado na documenta\u00e7\u00e3o Substrate.</p> <p>Neste exemplo, o m\u00f3dulo <code>lottery-example</code> precisa de uma estrutura de armazenamento de valor b\u00e1sica para persistir a lista de participantes em um vetor de capacidade limitada (BoundedVec). Isso pode ser inicializado da seguinte forma:</p> <pre><code>#[pallet::storage]\n#[pallet::getter(fn get_participants)]\npub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n    _,\n    BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n    OptionQuery\n&gt;;\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#complete-module","title":"O m\u00f3dulo completo","text":"<p>Para juntar todas as pe\u00e7as, ap\u00f3s implementar todas as macros necess\u00e1rias e adicionar a l\u00f3gica personalizada, o m\u00f3dulo agora est\u00e1 completo e pronto para ser usado no tempo de execu\u00e7\u00e3o.</p> Ver o arquivo do m\u00f3dulo completo <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre>"},{"location":"pt/builders/build/customize/adding-custom-made-module/#configure-runtime","title":"Configurar o tempo de execu\u00e7\u00e3o","text":"<p>Finalmente, com o m\u00f3dulo finalizado, ele pode ser inclu\u00eddo no tempo de execu\u00e7\u00e3o. Ao fazer isso, as transa\u00e7\u00f5es <code>buy_tickets</code> e <code>award_prize</code> ser\u00e3o cham\u00e1veis pelos usu\u00e1rios. Isso tamb\u00e9m significa que a API Polkadot.js ser\u00e1 decorada com este m\u00f3dulo e todas as chamadas dispon\u00edveis que ele cont\u00e9m.\\n\\nPara configurar o tempo de execu\u00e7\u00e3o, abra o arquivo <code>lib.rs</code>, que cont\u00e9m a defini\u00e7\u00e3o para o tempo de execu\u00e7\u00e3o do modelo inclu\u00eddo e est\u00e1 localizado (no caso de usar o compat\u00edvel com EVM) na pasta:</p> <pre><code>*/container-chains/templates/frontier/runtime/src/\n</code></pre> <p>Para adicionar o m\u00f3dulo da loteria, configure os m\u00f3dulos da seguinte forma:</p> <p><pre><code>// Adicione a configura\u00e7\u00e3o para o m\u00f3dulo de aleatoriedade. Nenhum par\u00e2metro necess\u00e1rio.\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {\n}\n\n// // ID de m\u00f3dulo personalizado\n parameter_types! {\n    pub const PalletId: PalletId = PalletId(*b\"loex5678\");\n}\n\n// Adicione a configura\u00e7\u00e3o para o m\u00f3dulo da loteria\nimpl pallet_lottery_example::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type Currency = Balances;\n    type TicketCost = ConstU128&lt;1000000000000000&gt;;\n    type PalletId = PalletId;\n    type MaxParticipants = ConstU32&lt;500&gt;;\n    type MyRandomness = RandomCollectiveFlip;\n    }\n</code></pre> Com os m\u00f3dulos configurados, adicione a macro <code>construct_runtime!</code> (que define os m\u00f3dulos que ser\u00e3o inclu\u00eddos ao construir o tempo de execu\u00e7\u00e3o) e os m\u00f3dulos de aleatoriedade e loteria.</p> <pre><code>construct_runtime!(\n    pub struct Runtime {\n        ...\n        // Inclua a l\u00f3gica personalizada do pallet-template no tempo de execu\u00e7\u00e3o.\n        RandomCollectiveFlip: pallet_insecure_randomness_collective_flip,\n        Lottery: pallet_lottery_example,\n        ...\n}\n)\n</code></pre> <p>Com tudo definido, a rede agora tem suporte para uma implementa\u00e7\u00e3o b\u00e1sica de uma loteria.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/build/customize/adding-external-module/","title":"Adicionar um M\u00f3dulo Externo","text":""},{"location":"pt/builders/build/customize/adding-external-module/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores construindo sobre os Templates oferecidos pela Tanssi podem querer adicionar alguns m\u00f3dulos/depend\u00eancias externos em seu tempo de execu\u00e7\u00e3o para expandir certas funcionalidades.</p> <p>O reposit\u00f3rio Tanssi e os modelos pegam todas as depend\u00eancias de um fork do reposit\u00f3rio oficial do Polkadot SDK. Este fork \u00e9 mantido pela equipe de engenharia da Tanssi, que geralmente contribui ativamente para o desenvolvimento da Substrate, corrigindo problemas e aprimorando funcionalidades, e, como resultado, o reposit\u00f3rio do fork frequentemente fica temporariamente \u00e0 frente do oficial.</p> <p>Um problema de dupla refer\u00eancia pode surgir ao adicionar uma depend\u00eancia externa, como uma pallet de terceiros. Isso acontece se um m\u00f3dulo Tanssi faz refer\u00eancia a uma depend\u00eancia do reposit\u00f3rio fork do Polkadot SDK, e a terceiros faz refer\u00eancia \u00e0 mesma depend\u00eancia do reposit\u00f3rio oficial do Polkadot SDK. Para resolver esse problema, as refer\u00eancias \u00e0s depend\u00eancias devem ser unificadas.</p>"},{"location":"pt/builders/build/customize/adding-external-module/#solving-dependencies-conflicts-diener","title":"Resolvendo Conflitos de Depend\u00eancias com Diener","text":"<p>Para lidar de forma eficiente com as depend\u00eancias e suas origens, voc\u00ea pode conferir a ferramenta diener.</p> <p>Se o arquivo execut\u00e1vel <code>diener</code>, o reposit\u00f3rio do Polkadot SDK clonado e seu fork Tanssi estiverem localizados na mesma pasta, entre na pasta do fork Tanssi e execute o seguinte comando:</p> <pre><code>../diener patch --crates-to-patch ../polkadot-sdk \\\n    --target https://github.com/paritytech/polkadot-sdk \\\n    --point-to-git https://github.com/moondance-labs/polkadot-sdk \\\n    --point-to-git-branch tanssi-polkadot-stable2503\n</code></pre> <p>Este comando aplica as altera\u00e7\u00f5es ao arquivo <code>Cargo.toml</code>, corrigindo as depend\u00eancias e resolvendo os problemas de dupla refer\u00eancia.</p> <p>Voc\u00ea pode visitar a documenta\u00e7\u00e3o do diener para saber mais sobre a ferramenta e outras fun\u00e7\u00f5es extras que ela oferece.</p>"},{"location":"pt/builders/build/customize/adding-external-module/#double-reference-issue","title":"Exemplo do Problema de Dupla Refer\u00eancia","text":"<p>Para ilustrar a situa\u00e7\u00e3o, as seguintes etapas adicionam um m\u00f3dulo externo de demonstra\u00e7\u00e3o a um tempo de execu\u00e7\u00e3o personalizado com base no modelo de rede com tecnologia Tanssi de linha de base. Uma maneira de seguir este tutorial \u00e9 clonar o reposit\u00f3rio Tanssi Github, que atuar\u00e1 como o reposit\u00f3rio raiz do projeto.</p> <p>Este tutorial gerar\u00e1 um erro de tempo de compila\u00e7\u00e3o de refer\u00eancia m\u00faltipla. Finalmente, as etapas mostrar\u00e3o como corrigir o erro de compila\u00e7\u00e3o corrigindo as depend\u00eancias com a ferramenta <code>diener</code>, o tempo de execu\u00e7\u00e3o ser\u00e1 compilado com sucesso e funcionar\u00e1 conforme o esperado.</p>"},{"location":"pt/builders/build/customize/adding-external-module/#add-third-party-dependency","title":"Adicionar uma Depend\u00eancia de Terceiros","text":"<p>Semelhante ao que \u00e9 descrito no artigo m\u00f3dulo embutido, a adi\u00e7\u00e3o de um m\u00f3dulo de terceiros requer as seguintes etapas:</p> <ol> <li>Declare a depend\u00eancia no arquivo <code>Cargo.toml</code> raiz</li> <li>Torne as caracter\u00edsticas padr\u00e3o dispon\u00edveis para o compilador</li> <li>Configure e adicione o m\u00f3dulo ao tempo de execu\u00e7\u00e3o</li> </ol> <p>Se o m\u00f3dulo de terceiros fizer refer\u00eancia a alguma depend\u00eancia j\u00e1 referenciada de uma fonte ou vers\u00e3o distinta, a compila\u00e7\u00e3o falhar\u00e1.</p> <p>O diagrama a seguir mostra como duas refer\u00eancias diferentes para a mesma depend\u00eancia est\u00e3o sendo inclu\u00eddas no tempo de execu\u00e7\u00e3o, fazendo com que a compila\u00e7\u00e3o falhe:</p> <p></p> <p>Para resolver este problema, ser\u00e1 necess\u00e1rio aplicar um patch para que as refer\u00eancias para a depend\u00eancia sejam unificadas:</p> <p></p>"},{"location":"pt/builders/build/customize/adding-external-module/#declaring-dependency","title":"Declarando a Depend\u00eancia","text":"<p>A primeira etapa para reproduzir o problema de dupla refer\u00eancia \u00e9 declarar a depend\u00eancia no arquivo <code>Cargo.toml</code> localizado na pasta raiz do reposit\u00f3rio, na se\u00e7\u00e3o <code>[dependencies]</code>. Para este exemplo, um simples m\u00f3dulo de altern\u00e2ncia \u00e9 usado.</p> <p>Este m\u00f3dulo <code>toggle</code>, constru\u00eddo para fins de teste e educacionais, adiciona l\u00f3gica b\u00e1sica ao tempo de execu\u00e7\u00e3o, permitindo que os usu\u00e1rios alternem um estado entre verdadeiro e falso.</p> <pre><code>[dependencies]\n...\npallet-toggle = { \n    git = \"https://github.com/papermoonio/pallet-toggle\", \n    default-features = false \n}\n...\n</code></pre>"},{"location":"pt/builders/build/customize/adding-external-module/#add-standard-features","title":"Tornando os Recursos Padr\u00e3o Dispon\u00edveis para o Compilador","text":"<p>Tendo declarado o m\u00f3dulo no arquivo <code>Cargo.toml</code> do espa\u00e7o de trabalho, a depend\u00eancia pode agora ser adicionada ao arquivo <code>Cargo.toml</code> do modelo espec\u00edfico, que, para este exemplo que usa o reposit\u00f3rio Tanssi GitHub, est\u00e1 localizado na pasta <code>container-chains/templates/simple/runtime</code>.</p> <pre><code>[dependencies]\n...\npallet-toggle = { workspace = true }\n...\n</code></pre> <p>No mesmo arquivo <code>Cargo.toml</code>, adicione os seguintes recursos.</p> <pre><code>[features]\ndefault = [\n    \"std\",\n]\nstd = [\n    ...,\n    \"pallet-toggle/std\",\n   ...\n]\n...\nruntime-benchmarks = [\n    ...,\n    \"pallet-toggle/runtime-benchmarks\",\n]\n\ntry-runtime = [\n    ...,\n    \"pallet-toggle/try-runtime\",\n]\n</code></pre>"},{"location":"pt/builders/build/customize/adding-external-module/#configure-module-in-the-runtime","title":"Configurar e Adicionar o M\u00f3dulo ao Tempo de Execu\u00e7\u00e3o","text":"<p>Em seguida, adicione o seguinte snippet ao arquivo <code>lib.rs</code> dentro da pasta de tempo de execu\u00e7\u00e3o. Isso configura o m\u00f3dulo e adiciona o m\u00f3dulo dentro da macro <code>construct_runtime!</code>.</p> <pre><code>...\nimpl pallet_toggle::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = pallet_toggle::weights::SubstrateWeight&lt;Runtime&gt;;\n}\n\nconstruct_runtime!(\n    pub enum Runtime\n    {\n        ...\n        ...\n        Toggle: pallet_toggle,\n    }\n);\n</code></pre>"},{"location":"pt/builders/build/customize/adding-external-module/#compile-runtime","title":"Compilar o Tempo de Execu\u00e7\u00e3o","text":"<p>Ap\u00f3s concluir as etapas anteriores, o m\u00f3dulo \u00e9 declarado uma depend\u00eancia no projeto, configurado e adicionado ao tempo de execu\u00e7\u00e3o.</p> <p>Compile o modelo usando o seguinte comando:</p> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>A sa\u00edda do terminal exibir\u00e1 um erro, semelhante ao seguinte, causado por diferentes m\u00f3dulos referenciando diferentes vers\u00f5es da mesma depend\u00eancia:</p> <pre><code>error: failed to select a version for `syn`.\n</code></pre>"},{"location":"pt/builders/build/customize/adding-external-module/#patch-dependencies","title":"Depend\u00eancias de Patch","text":"<p>Finalmente, a execu\u00e7\u00e3o do comando <code>diener</code> adicionar\u00e1 uma se\u00e7\u00e3o <code>patch</code> ao seu arquivo <code>Cargo.toml</code> do espa\u00e7o de trabalho, substituindo as depend\u00eancias e unificando as origens e vers\u00f5es.</p> <p>\u00c9 assim que a execu\u00e7\u00e3o no terminal se parece:</p> ../diener patch --crates-to-patch ../polkadot-sdk \\      --target https://github.com/paritytech/polkadot-sdk \\      --point-to-git https://github.com/moondance-labs/polkadot-sdk \\      --point-to-git-branch tanssi-polkadot-v1.3.0       [2024-01-10T23:26:27Z INFO diener] Running diener v0.4.7       [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bridge-runtime-common.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-header-chain'      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-runtime'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core-hashing'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api-proc-macro' .      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-debug-derive'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-externalities'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-std'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-storage'.      [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-runtime-interface'.    <p>Como mostrado na sa\u00edda do terminal, <code>diener</code> adiciona um patch para as depend\u00eancias, criando uma se\u00e7\u00e3o <code>patch</code> em seu <code>toml</code> substituindo sua origem:</p> <pre><code>[patch.\"https://github.com/paritytech/polkadot-sdk\"]\nbridge-runtime-common = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-header-chain = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\nbp-runtime = { git = \"https://github.com/moondance-labs/polkadot-sdk\" , branch = \"tanssi-polkadot-v1.3.0\" }\n...\n</code></pre> <p>Finalmente, a compila\u00e7\u00e3o ter\u00e1 sucesso e o m\u00f3dulo ser\u00e1 integrado ao seu tempo de execu\u00e7\u00e3o.</p>"},{"location":"pt/builders/build/customize/customizing-chain-specs/","title":"Customizando as Especifica\u00e7\u00f5es da Cadeia","text":""},{"location":"pt/builders/build/customize/customizing-chain-specs/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A especifica\u00e7\u00e3o da cadeia refere-se a um conjunto de par\u00e2metros e configura\u00e7\u00f5es que definem as caracter\u00edsticas e o comportamento de uma nova rede com tecnologia Tanssi. Ela define as configura\u00e7\u00f5es e o estado iniciais sobre os quais todos os n\u00f3s participantes da rede devem concordar para alcan\u00e7ar o consenso e produzir blocos. Muitas configura\u00e7\u00f5es iniciais n\u00e3o podem ser alteradas ap\u00f3s o lan\u00e7amento da rede sem gerar uma cadeia completamente diferente.</p> <p>A especifica\u00e7\u00e3o cont\u00e9m duas se\u00e7\u00f5es principais:</p> <ul> <li>The client specification - inclui os par\u00e2metros de rede, por exemplo, os n\u00f3s de inicializa\u00e7\u00e3o com os quais o cliente se conecta ao ingressar na rede</li> <li>The client specification - representa o estado inicial em que todas as transa\u00e7\u00f5es e transi\u00e7\u00f5es de estado ocorrem. Inclui detalhes como as contas registradas iniciais e seus saldos, bem como a conta com privil\u00e9gios de administrador (sudo, se aplic\u00e1vel), entre outras informa\u00e7\u00f5es relevantes</li> </ul> <p>Essas informa\u00e7\u00f5es que a especifica\u00e7\u00e3o da cadeia cont\u00e9m podem ser armazenadas em um arquivo Rust (que pode ser encontrado nos templates inclu\u00eddos no reposit\u00f3rio Tanssi) ou em um arquivo JSON.</p> <p>Este artigo aborda as se\u00e7\u00f5es e atributos dentro de um arquivo de especifica\u00e7\u00e3o de cadeia e explica como obt\u00ea-lo, caso voc\u00ea queira lan\u00e7ar sua rede Tanssi carregando um arquivo de especifica\u00e7\u00f5es personalizadas.</p> <p>Nota do Editor (Atualiza\u00e7\u00e3o de 2025)</p> <p>Este guia explica como personalizar os arquivos de especifica\u00e7\u00e3o da cadeia em redes baseadas em Substrate. Alguns campos (por exemplo, cadeia de retransmiss\u00e3o, ID da parachain) v\u00eam do SDK do Substrate e s\u00e3o inclu\u00eddos para fins de compatibilidade ou modelo.</p> <p>Esses atributos n\u00e3o significam que uma rede com tecnologia Tanssi \u00e9 uma parachain Polkadot. Tanssi \u00e9 um protocolo de infraestrutura de appchain independente, constru\u00eddo com Substrate e alinhado com a seguran\u00e7a apoiada pelo Ethereum. Voc\u00ea pode encontrar termos relacionados ao Polkadot em arquivos de configura\u00e7\u00e3o por causa das origens compartilhadas do Substrate, mas as appchains com tecnologia Tanssi n\u00e3o exigem slots Polkadot ou mec\u00e2nica de cadeia de retransmiss\u00e3o.</p>"},{"location":"pt/builders/build/customize/customizing-chain-specs/#client-specification","title":"A Especifica\u00e7\u00e3o do Cliente","text":"<p>A especifica\u00e7\u00e3o do cliente cont\u00e9m a configura\u00e7\u00e3o da rede e outras configura\u00e7\u00f5es (excluindo as relacionadas ao estado do tempo de execu\u00e7\u00e3o):</p> <ul> <li>Name - nome para as especifica\u00e7\u00f5es</li> <li>Id - um ID simples exclusivo para a rede usado para definir o caminho de armazenamento no n\u00f3</li> <li>Fork ID - par\u00e2metro opcional para um identificador de fork de rede</li> <li>Chain type - um par\u00e2metro que pode ser definido para definir o tipo de cadeia e exibir informa\u00e7\u00f5es adicionais ou habilitar recursos adicionais (pode ser definido como Desenvolvimento, Local, Live ou um tipo personalizado)</li> <li>Boot Nodes - conjunto de n\u00f3s de inicializa\u00e7\u00e3o que ser\u00e3o usados \u200b\u200bquando o novo n\u00f3 entrar na rede e sincronizar</li> <li>Telemetry Endpoints - uma lista opcional de endpoints para enviar informa\u00e7\u00f5es e monitorar a opera\u00e7\u00e3o da rede</li> <li>Protocol ID - um nome exclusivo que define o protocolo de rede</li> <li>Relay Chain - define a ID da cadeia de orquestra\u00e7\u00e3o com a qual a rede Tanssi interage</li> <li>Parachain ID - define uma ID exclusiva que identifica a rede Tanssi</li> <li>Code Substitutes - um recurso de emerg\u00eancia para substituir o tempo de execu\u00e7\u00e3o quando uma rede Tanssi n\u00e3o consegue executar uma atualiza\u00e7\u00e3o de tempo de execu\u00e7\u00e3o</li> <li>Properties - propriedades chave-valor que podem ser personalizadas e s\u00e3o \u00fateis para melhorar a experi\u00eancia do usu\u00e1rio</li> </ul> <p>No atributo <code>properties</code>, as seguintes configura\u00e7\u00f5es s\u00e3o usadas por v\u00e1rias bibliotecas front-end, incluindo a API Polkadot.js:</p> <ul> <li>S\u00edmbolo do Token - um nome para o s\u00edmbolo do token da sua pr\u00f3pria rede Tanssi</li> <li>Formato SS58 - um inteiro que identifica exclusivamente as contas em sua rede. A codifica\u00e7\u00e3o SS58 transforma a conta subjacente de 32 bytes em uma representa\u00e7\u00e3o espec\u00edfica da rede. Este atributo n\u00e3o se aplica nem interfere nas contas Ethereum ECDSA em redes compat\u00edveis com EVM</li> <li>Decimais do Token - representam o qu\u00e3o divis\u00edvel um token pode ser e qual \u00e9 a menor representa\u00e7\u00e3o do token. Ele \u00e9 definido como <code>18</code> para redes compat\u00edveis com EVM</li> <li>\u00c9 Ethereum - um booleano que identifica a rede como compat\u00edvel com EVM ou n\u00e3o</li> </ul>"},{"location":"pt/builders/build/customize/customizing-chain-specs/#genesis-state","title":"O Estado da G\u00eanese","text":"<p>Todos os sequenciadores atribu\u00eddos \u00e0 rede Tanssi devem concordar com o estado inicial para que possam executar as extr\u00ednsecas de entrada, chegar aos mesmos resultados e, finalmente, chegar a um consenso sobre o novo estado v\u00e1lido.</p> <p>Este estado da g\u00eanese definir\u00e1 o ponto de partida da rede Tanssi. Ele inclui um valor inicial para os elementos que os m\u00f3dulos inclu\u00eddos no tempo de execu\u00e7\u00e3o precisam persistir e o c\u00f3digo Wasm inicial do tempo de execu\u00e7\u00e3o, que \u00e9 armazenado na cadeia.</p> <p>Por exemplo, nos modelos inclu\u00eddos, a especifica\u00e7\u00e3o da cadeia define as contas iniciais e os saldos de tokens no m\u00f3dulo <code>Balances</code>. Al\u00e9m disso, o template tamb\u00e9m tem uma conta sudo (que deve ser modificado) para o m\u00f3dulo <code>Sudo</code>, que fornece privil\u00e9gios exclusivos \u00e0 conta fornecida, e que pode ser removido assim que um m\u00f3dulo de democracia na cadeia for conectado.</p>"},{"location":"pt/builders/build/customize/customizing-chain-specs/#generating-json-chain-specs","title":"Gerando um Arquivo de Especifica\u00e7\u00e3o de Cadeia JSON","text":"<p>Os seguintes comandos construir\u00e3o e gerar\u00e3o a especifica\u00e7\u00e3o da cadeia para o modelo compat\u00edvel com EVM com base na configura\u00e7\u00e3o expressa em <code>chain_spec.rs</code>, localizado em <code>*/container-chains/templates/frontier/node/src/chain_spec.rs</code>. Este exemplo pode ser adaptado a qualquer outro modelo ou tempo de execu\u00e7\u00e3o personalizado.</p> <p>Para construir e gerar as especifica\u00e7\u00f5es da cadeia, siga estas etapas:</p> <ol> <li> <p>Clone o c\u00f3digo Tanssi hospedado no GitHub</p> <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre> </li> <li> <p>Entre na pasta do projeto</p> <pre><code>cd tanssi\n</code></pre> </li> <li> <p>Construa o modelo da rede compat\u00edvel com EVM Tanssi</p> <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> </li> </ol> <p>Esta etapa \u00e9 bastante detalhada e pode levar um tempo para ser conclu\u00edda. A captura de tela a seguir mostra o terminal ap\u00f3s concluir com sucesso o processo de constru\u00e7\u00e3o (observe que o tempo de conclus\u00e3o \u00e9 superior a 35 minutos):</p> <p></p> <ol> <li> <p>Gerar a especifica\u00e7\u00e3o da cadeia</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec &gt; chain_spec.json\n</code></pre> </li> </ol> <p>Ap\u00f3s executar a \u00faltima etapa, o terminal exibe apenas uma linha de log:</p> <p></p> <p>E agora o arquivo <code>chain_spec.json</code> contendo a especifica\u00e7\u00e3o do cliente e o estado da g\u00eanese \u00e9 criado na pasta atual.</p> <p>Nota</p> <p>As especifica\u00e7\u00f5es da cadeia JSON podem ser geradas em duas vers\u00f5es diferentes: a leg\u00edvel por humanos, que \u00e9 a gerada seguindo as etapas anteriores, e a vers\u00e3o bruta, que \u00e9 a necess\u00e1ria para implantar a rede por meio do Tanssi. Mais sobre como gerar a vers\u00e3o bruta posteriormente neste artigo.</p>"},{"location":"pt/builders/build/customize/customizing-chain-specs/#editing-json-chain-specs","title":"Editando o arquivo de especifica\u00e7\u00e3o da cadeia JSON","text":"<p>O arquivo <code>chain_spec.json</code> gerado reflete os par\u00e2metros definidos no arquivo de especifica\u00e7\u00f5es da cadeia Rust. Sendo um arquivo JSON, \u00e9 f\u00e1cil de ler e, caso algum par\u00e2metro precise ser alterado, f\u00e1cil de editar.</p> <p>Por exemplo, o seguinte trecho de c\u00f3digo mostra alguns dos atributos das especifica\u00e7\u00f5es do cliente:</p> <pre><code>{\n    // Define o nome da especifica\u00e7\u00e3o desta rede\n    \"name\": \"Rede Frontier 1000\",\n    // Defina um ID para as especifica\u00e7\u00f5es desta rede\n    \"id\": \"frontier_network_1000\",\n    // A rede estar\u00e1 ativa\n    \"chainType\": \"Live\",\n    \"bootNodes\": [\n        // n\u00f3s de inicializa\u00e7\u00e3o ser\u00e3o adicionados automaticamente durante a implanta\u00e7\u00e3o\n    ],\n    // Atributo opcional, o padr\u00e3o \u00e9 nulo\n    \"telemetryEndpoints\": null,\n    // Defina um identificador de protocolo para esta rede\n    \"protocolId\": \"network-chain-1000\",\n    // Defina propriedades para definir o token e a compatibilidade com ethereum\n    \"properties\": {\n        \"isEthereum\": true,\n        \"ss58Format\": 42,\n        \"tokenDecimals\": 18,\n        \"tokenSymbol\": \"UNIT\"\n    },\n    // Defina a cadeia de retransmiss\u00e3o stagenet\n    \"relay_chain\": \"westend_moonbase_relay_stagenet\",\n    // Defina o ID da parachain reservado na cadeia de retransmiss\u00e3o\n    \"para_id\": 3333,\n    // Sem necessidade\n    \"codeSubstitutes\": {},\n    \"genesis\": { \n        ... \n    }\n}\n</code></pre> <p>A outra se\u00e7\u00e3o importante do arquivo est\u00e1 dentro do atributo <code>genesis</code>, que cont\u00e9m o estado da g\u00eanese. No seguinte trecho JSON, os valores e a configura\u00e7\u00e3o padr\u00e3o para alguns m\u00f3dulos s\u00e3o apresentados como exemplo:</p> <pre><code>{\n    ...\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            // Define a conta que ter\u00e1 privil\u00e9gios sudo\n            \"sudo\": {\n                \"key\": \"0xf24ff3a9cf04c71dbc94d0b566cac\"\n            },\n            // Define os saldos iniciais para algumas contas\n            \"balances\": {\n                \"balances\": [\n                [\n                    \"0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x773539d4ac0e786233d90a233654ccee26a613d9\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0x798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc\",\n                    1208925819614629174706176\n                ],\n                [\n                    \"0xf24ff3a9cf04c71dbc94d0b566cac\",\n                    1208925819614629174706176\n                ]\n                ]\n            },\n            // Define os saldos para as contas EVM\n            \"evm\": {\n                \"accounts\": {\n                \"0x1000000000000000000000000000000000000001\": {\n                    \"nonce\": \"0x1\",\n                    \"balance\": \"0xd3c21bcecceda1000000\",\n                    \"storage\": {},\n                    \"code\": [\n                    0\n                    ]\n                },\n                \"0x6be02d1d3665660d22ff9624b7be0551ee1ac91b\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                },\n                \"0xd43593c715fdd31c61141abd04a99fd6822c8558\": {\n                    \"nonce\": \"0x0\",\n                    \"balance\": \"0xffffffffffffffffffffffffffffffff\",\n                    \"storage\": {},\n                    \"code\": []\n                }\n                }\n            },\n        }\n    }\n    ...\n}\n</code></pre> <p>Um exemplo de um atributo n\u00e3o edit\u00e1vel manualmente \u00e9 o tempo de execu\u00e7\u00e3o Wasm (na se\u00e7\u00e3o de estado da g\u00eanese), que \u00e9 uma representa\u00e7\u00e3o hexadecimal de um blob bin\u00e1rio gerado pelo compilador. Ainda assim, al\u00e9m disso, a maioria das propriedades s\u00e3o f\u00e1ceis de editar antes de iniciar a rede.</p>"},{"location":"pt/builders/build/customize/customizing-chain-specs/#generating-raw-specs-file","title":"Gerando um arquivo de especifica\u00e7\u00e3o de cadeia JSON bruto","text":"<p>Uma etapa final antes de implantar a rede Tanssi \u00e9 converter o arquivo de especifica\u00e7\u00e3o JSON em um formato bruto, que \u00e9 uma vers\u00e3o compacta e menos leg\u00edvel do mesmo arquivo, necess\u00e1ria para inicializar um n\u00f3.</p> <p>Depois de passar pelas etapas para gerar o arquivo de especifica\u00e7\u00e3o da cadeia JSON e editar seus valores, o seguinte comando converter\u00e1 o arquivo de especifica\u00e7\u00f5es da cadeia no formato bruto necess\u00e1rio:</p> <pre><code>./target/release/container-chain-frontier-node \\\n    build-spec --chain=chain_spec.json --raw &gt; raw_chain_spec.json\n</code></pre> <p>Agora que este arquivo foi configurado e personalizado e est\u00e1 no formato JSON bruto correto, ele pode ser carregado para inicializar uma nova rede no Tanssi.</p>"},{"location":"pt/builders/build/customize/prerequisites/","title":"Pr\u00e9-requisitos para a constru\u00e7\u00e3o de uma rede","text":""},{"location":"pt/builders/build/customize/prerequisites/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A implanta\u00e7\u00e3o de uma rede atrav\u00e9s da Tanssi \u00e9 um passo bastante simples, onde o \u00fanico requisito \u00e9 ter uma especifica\u00e7\u00e3o de cadeia v\u00e1lida para fazer upload.</p> <p>Embora a Tanssi forne\u00e7a especifica\u00e7\u00f5es de cadeia para os modelos dispon\u00edveis, pode ser necess\u00e1rio gerar uma nova para corresponder a quaisquer altera\u00e7\u00f5es que o caso de uso possa precisar ser implementado no tempo de execu\u00e7\u00e3o.</p> <p>As se\u00e7\u00f5es a seguir deste artigo cobrir\u00e3o o software m\u00ednimo necess\u00e1rio e seu processo de instala\u00e7\u00e3o para obter um ambiente de desenvolvimento adequado para compilar um n\u00f3 Substrate e gerar a especifica\u00e7\u00e3o da cadeia.</p>"},{"location":"pt/builders/build/customize/prerequisites/#installing-rust","title":"Instala\u00e7\u00e3o do Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o moderna, port\u00e1til e de alto desempenho que \u00e9 a base da estrutura de desenvolvimento de blockchain Substrate.</p> <p>Para compilar a rede Tanssi, o compilador rust, <code>rustc</code>, e o gerenciador de pacotes, <code>cargo</code>, devem ser instalados no sistema.</p> <p>De acordo com as instru\u00e7\u00f5es na documenta\u00e7\u00e3o oficial do Rust, para sistemas Linux ou macOS, execute o seguinte comando:</p> LinuxMacOS <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Quando o processo de instala\u00e7\u00e3o for conclu\u00eddo, executar o seguinte comando verifica se o compilador rec\u00e9m-instalado funciona corretamente, mostrando o n\u00famero da vers\u00e3o:</p> LinuxMacOS <pre><code>rustc --version\n</code></pre> <pre><code>rustc --version\n</code></pre> <p>H\u00e1 outros m\u00e9todos para instalar o Rust, como usar um gerenciador de pacotes. Outras op\u00e7\u00f5es podem ser encontradas no site oficial do Rust.</p>"},{"location":"pt/builders/build/customize/prerequisites/#installing-git","title":"Instala\u00e7\u00e3o do Git","text":"<p>Git \u00e9 recomendado para clonar o reposit\u00f3rio de c\u00f3digo da Tanssi, onde os modelos de n\u00f3 podem ser encontrados. O Git provavelmente \u00e9 fornecido na configura\u00e7\u00e3o de instala\u00e7\u00e3o padr\u00e3o do sistema operacional ou inclu\u00eddo em outras ferramentas, como o Xcode no MacOS.</p> <p>Se o Git n\u00e3o estiver presente no sistema, o seguinte comando o instalar\u00e1 usando um gerenciador de pacotes:</p> LinuxMacOS <pre><code>apt-get install git\n</code></pre> <pre><code>brew install git\n</code></pre> <p>Para verificar a instala\u00e7\u00e3o correta do Git, executar o seguinte comando em um terminal deve exibir a vers\u00e3o do Git:</p> LinuxMacOS <pre><code>git --version\n</code></pre> <pre><code>git --version\n</code></pre>"},{"location":"pt/builders/build/customize/prerequisites/#building-tanssi-template","title":"Construindo um modelo Tanssi","text":"<p>Para construir um n\u00f3 Substrate, como os modelos inclu\u00eddos no reposit\u00f3rio Tanssi, \u00e9 necess\u00e1rio instalar componentes de desenvolvimento adicionais no sistema:</p> LinuxMacOS <pre><code>apt-get install -y build-essential protobuf-compiler clang libssl-dev pkg-config\n</code></pre> <pre><code>brew install protobuf openssl\n</code></pre> <ol> <li> <p>Clone the Tanssi code hosted on GitHub <pre><code>git clone https://github.com/moondance-labs/tanssi\n</code></pre></p> </li> <li> <p>Entre na pasta do projeto <pre><code>cd tanssi\n</code></pre></p> </li> <li> <p>Construa o modelo de rede Tanssi</p> </li> </ol> Baseline EVMBaseline Substrate <pre><code>cargo build -p container-chain-frontier-node --release\n</code></pre> <pre><code>cargo build -p container-chain-simple-node --release\n</code></pre> <p>Ter um ambiente de desenvolvimento saud\u00e1vel ser\u00e1 necess\u00e1rio para construir um tempo de execu\u00e7\u00e3o personalizado e, finalmente, gerar o arquivo de especifica\u00e7\u00e3o da cadeia que ser\u00e1 usado para implantar sua rede Tanssi.</p>"},{"location":"pt/builders/build/templates/","title":"Modelos de Rede","text":"<p>Comece o desenvolvimento de sua rede com nossos modelos abrangentes. Projetados para implanta\u00e7\u00e3o r\u00e1pida, esses modelos fornecem uma base s\u00f3lida para solu\u00e7\u00f5es EVM e n\u00e3o-EVM, acelerando a sua jornada de produ\u00e7\u00e3o.</p>"},{"location":"pt/builders/build/templates/#escolha-um-modelo","title":"Escolha um Modelo","text":"<p>A Tanssi oferece dois modelos para dar in\u00edcio ao processo de desenvolvimento:</p> <ul> <li>Modelo de rede Tanssi b\u00e1sico - um modelo que fornece a plataforma b\u00e1sica para come\u00e7ar a adicionar l\u00f3gica personalizada   </li> </ul> <p> Saiba mais sobre o que este modelo fornece</p> <p> Comece a construir com este modelo</p> <ul> <li>Modelo de rede EVM (M\u00e1quina Virtual Ethereum) Tanssi b\u00e1sico - um modelo que fornece compatibilidade total com o Ethereum   </li> </ul> <p> Saiba mais sobre o que este modelo fornece</p> <p> Comece a construir com este modelo</p> <p>Para saber mais sobre os requisitos m\u00ednimos para que sua cadeia funcione na Tanssi e quais m\u00f3dulos s\u00e3o inclu\u00eddos automaticamente, consulte a p\u00e1gina Vis\u00e3o geral do modelo.</p>"},{"location":"pt/builders/build/templates/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/build/templates/custom-runtime/","title":"Runtime personalizado","text":""},{"location":"pt/builders/build/templates/custom-runtime/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Para as equipes que trabalham em um projeto de framework Substrate existente, ser\u00e1 necess\u00e1rio incluir alguns m\u00f3dulos e configura\u00e7\u00f5es obrigat\u00f3rias no runtime. Isso garantir\u00e1 que o runtime existente possa se tornar um runtime de rede Tanssi sem problemas, alinhando-se com as regras do protocolo.</p> <p>A falha em faz\u00ea-lo pode levar \u00e0 interoperabilidade reduzida e exposi\u00e7\u00e3o desnecess\u00e1ria a vulnerabilidades.</p>"},{"location":"pt/builders/build/templates/custom-runtime/#requisitos-minimos","title":"Requisitos M\u00ednimos","text":"<p>Runtimes Substrate j\u00e1 existentes precisam implementar pelo menos o framework para se comunicar dentro do ecossistema Tanssi, juntamente com os m\u00f3dulos espec\u00edficos do Tanssi.</p> <p>No entanto, as equipes podem j\u00e1 ter implementado certos m\u00f3dulos que podem colidir com algumas funcionalidades relacionadas ao Tanssi, por exemplo, produ\u00e7\u00e3o de blocos, atribui\u00e7\u00e3o de autoridade de bloco e consenso.</p> <p>Os seguintes m\u00f3dulos s\u00e3o inclu\u00eddos por padr\u00e3o em muitos modelos populares e devem ser removidos junto com sua configura\u00e7\u00e3o:</p> <pre><code>Authorship: pallet_authorship = 20,\nCollatorSelection: pallet_collator_selection = 21,\nSession: pallet_session = 22,\nAura: pallet_aura = 23,\nAuraExt: cumulus_pallet_aura_ext = 24,\n</code></pre> <p>Em qualquer caso, certifique-se de verificar seu runtime e remover todos os m\u00f3dulos que podem interferir na produ\u00e7\u00e3o de blocos como um recurso de servi\u00e7o antes de iniciar o processo de registro.</p>"},{"location":"pt/builders/build/templates/custom-runtime/#adding-cumulus-support","title":"Integrando Sua Cadeia Stand-Alone","text":"<p>Se seu runtime existente estiver configurado como uma cadeia stand-alone, voc\u00ea precisar\u00e1 adicionar um mecanismo de consenso para integrar no ecossistema Tanssi. Verifique qualquer um dos modelos dispon\u00edveis no reposit\u00f3rio Tanssi para uma configura\u00e7\u00e3o de refer\u00eancia ou a documenta\u00e7\u00e3o do framework.</p>"},{"location":"pt/builders/build/templates/custom-runtime/#adding-tanssi-support","title":"Adicionando Suporte ao Protocolo Tanssi","text":"<p>Para suportar o protocolo Tanssi, ser\u00e1 necess\u00e1rio adicionar dois m\u00f3dulos atrav\u00e9s das seguintes etapas:</p> <ol> <li> <p>Inclua as depend\u00eancias no manifesto <code>Cargo.toml</code> (geralmente localizado na pasta raiz). Abra o arquivo <code>Cargo.toml</code> e adicione os m\u00f3dulos na se\u00e7\u00e3o <code>dependencies</code></p> <pre><code>[dependencies]\n...\npallet-cc-authorities-noting = { \n    git = \"https://github.com/moondance-labs/tanssi\", \n    branch = \"master\", default-features = false \n}\npallet_authorities_noting = {\n    git = \"https://github.com/moondance-labs/moonkit\",\n    branch = \"tanssi-polkadot-v0.9.43\", default-features = false\n}\n...\n</code></pre> </li> <li> <p>Configure os m\u00f3dulos. Abra o arquivo <code>lib.rs</code> localizado na pasta <code>*/runtime/src</code> e adicione a configura\u00e7\u00e3o para ambos os m\u00f3dulos:</p> <pre><code>    impl pallet_author_inherent::Config for Runtime {\n        type AuthorId = NimbusId;\n        type AccountLookup = tp_consensus::NimbusLookUp;\n        type CanAuthor = pallet_cc_authorities_noting::CanAuthor&lt;Runtime&gt;;\n        type SlotBeacon = tp_consensus::AuraDigestSlotBeacon&lt;Runtime&gt;;\n        type WeightInfo = \n            pallet_author_inherent::weights::SubstrateWeight&lt;Runtime&gt;;\n    }\n\n    impl pallet_cc_authorities_noting::Config for Runtime {\n        type RuntimeEvent = RuntimeEvent;\n        type SelfParaId = parachain_info::Pallet&lt;Runtime&gt;;\n        type RelayChainStateProvider = \n            cumulus_pallet_parachain_system::RelaychainDataProvider&lt;Self&gt;;\n        type AuthorityId = NimbusId;\n        type WeightInfo = \n            pallet_cc_authorities_noting::weights::SubstrateWeight&lt;Runtime&gt;;\n    }\n</code></pre> <p>Observe que essa configura\u00e7\u00e3o \u00e9 agn\u00f3stica do caso de uso</p> </li> <li> <p>Declare os m\u00f3dulos como parte do runtime. No mesmo arquivo <code>lib.rs</code>, localizado na pasta <code>*/runtime/src</code>, adicione os m\u00f3dulos \u00e0 constru\u00e7\u00e3o do runtime:</p> <pre><code>        construct_runtime!(\n        pub enum Runtime where\n            Block = Block,\n            NodeBlock = opaque::Block,\n            UncheckedExtrinsic = UncheckedExtrinsic,\n        {\n            ...\n            // Tanssi network\n            AuthoritiesNoting: pallet_cc_authorities_noting = 50,\n            AuthorInherent: pallet_author_inherent = 51,\n            ...\n        }\n        );\n</code></pre> </li> <li> <p>Certifique-se de que seu cabe\u00e7alho est\u00e1 configurado da seguinte forma:</p> <pre><code>type Header = generic::Header&lt;BlockNumber, BlakeTwo256&gt;;\n/// An index to a block.\npub type BlockNumber = u32; \n</code></pre> </li> <li> <p>Adicione o executor do bloco, para permitir que os operadores na rede Tanssi validem que os autores s\u00e3o os sequenciadores atribu\u00eddos pelo Tanssi (e n\u00e3o um ator mal-intencionado)</p> </li> </ol> <p><code>rust     cumulus_pallet_parachain_system::register_validate_block! {         Runtime = Runtime,         BlockExecutor = pallet_author_inherent::BlockExecutor::&lt;Runtime, Executive&gt;         CheckInherents = CheckInherents,     }</code></p>"},{"location":"pt/builders/build/templates/evm/","title":"Modelo EVM Base","text":""},{"location":"pt/builders/build/templates/evm/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O modelo de rede EVM (Ethereum Virtual Machine) da Tanssi foi projetado para equipes que desenvolvem suas aplica\u00e7\u00f5es em cima de contratos inteligentes EVM. Ele inclui todos os componentes essenciais necess\u00e1rios para uma rede totalmente compat\u00edvel com o Ethereum:</p> <ul> <li>EVM - adiciona uma camada de execu\u00e7\u00e3o da Ethereum Virtual Machine para aplica\u00e7\u00f5es de contratos inteligentes baseados em EVM</li> <li>Suporte Etherum JSON RPC - as redes EVM da Tanssi s\u00e3o totalmente compat\u00edveis com Ethereum JSON RPC. Consequentemente, todas as ferramentas baseadas em Ethereum como MetaMask, Ethers.js, Viem, Hardhat, Foundry e muito mais, funcionam perfeitamente</li> <li>Contas Unificadas - permite que as redes EVM da Tanssi apresentem contas ECDSA no estilo Ethereum</li> </ul>"},{"location":"pt/builders/build/templates/evm/#evm-network-template","title":"EVM Network Template","text":"<p>O modelo j\u00e1 inclui a configura\u00e7\u00e3o necess\u00e1ria para integra\u00e7\u00e3o perfeita com o protocolo Tanssi e o provedor de seguran\u00e7a escolhido, por exemplo, Symbiotic no Ethereum. Portanto, este modelo n\u00e3o requer altera\u00e7\u00f5es adicionais no tempo de execu\u00e7\u00e3o se o aplicativo for constru\u00eddo em cima do EVM.</p> <p>Isso significa que este modelo est\u00e1 pronto para ser implantado como est\u00e1 atrav\u00e9s da Tanssi, desbloqueando muitos recursos, como:</p> <ul> <li>Utilizar a produ\u00e7\u00e3o de blocos como servi\u00e7o da Tanssi</li> <li>Obter finalidade de transa\u00e7\u00e3o determin\u00edstica em segundos</li> <li>Escolher o provedor de seguran\u00e7a que melhor se adapta \u00e0s suas necessidades. Por exemplo, aproveitar a seguran\u00e7a de n\u00edvel Ethereum do Symbiotic</li> <li>Construir dApps interagindo com sua rede atrav\u00e9s de uma API</li> <li>Conectar qualquer carteira Ethereum, como Metamask e Ledger</li> <li>Usar bibliotecas Ethereum bem conhecidas como Ethers.js, Web3.js, Web3.py, e mais</li> <li>Implantar contratos inteligentes EVM com ferramentas como Remix, Hardhat, Foundry, e mais</li> </ul>"},{"location":"pt/builders/build/templates/evm/#included-modules","title":"M\u00f3dulos Inclu\u00eddos","text":"<p>Alem dos m\u00f3dulos e configura\u00e7\u00f5es que tornam o modelo de rede Tanssi EVM compat\u00edvel com o protocolo Tanssi, ele tamb\u00e9m inclui muitos m\u00f3dulos para fornecer funcionalidades b\u00e1sicas.</p> <p>Para atingir a compatibilidade total com o Ethereum, esses m\u00f3dulos espec\u00edficos tamb\u00e9m est\u00e3o inclu\u00eddos:</p> <ul> <li>EVM - adiciona suporte para execu\u00e7\u00e3o de bytecode EVM n\u00e3o modificado em uma rede com tecnologia Tanssi. Ele usa o SputnikVM baseado em Rust como o mecanismo EVM subjacente</li> <li>Ethereum - funciona em conjunto com o m\u00f3dulo EVM para fornecer emula\u00e7\u00e3o completa para o processamento de blocos Ethereum. Entre muitas outras tarefas, \u00e9 respons\u00e1vel por criar blocos Ethereum emulados para componentes espec\u00edficos do Ethereum, como logs EVM</li> </ul> <p>Ambos os m\u00f3dulos fazem parte do projeto Frontier, que \u00e9 a espinha dorsal das redes com tecnologia Tanssi compat\u00edveis com Ethereum.</p>"},{"location":"pt/builders/build/templates/overview/","title":"Vis\u00e3o Geral dos Modelos","text":""},{"location":"pt/builders/build/templates/overview/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As redes implantadas atrav\u00e9s do Tanssi s\u00e3o blockchains totalmente personaliz\u00e1veis, beneficiando-se de um conjunto compartilhado de sequenciadores e da seguran\u00e7a de um provedor de sua escolha. Os modelos apresentados neste artigo implementam as funcionalidades e configura\u00e7\u00f5es necess\u00e1rias para suportar o protocolo Tanssi, tornando o desenvolvimento mais f\u00e1cil.</p>"},{"location":"pt/builders/build/templates/overview/#base-setup-supporting-tanssi","title":"Configura\u00e7\u00e3o Base para Suportar o Protocolo Tanssi","text":"<p>As redes Tanssi devem implementar os seguintes m\u00f3dulos para suportar o protocolo e se beneficiar com seguran\u00e7a da produ\u00e7\u00e3o de blocos do Tanssi como um servi\u00e7o:</p> <ul> <li>Author Noting - registra o conjunto de sequenciadores atribu\u00eddos \u00e0 rede pelo Tanssi</li> <li>Author Inherent - permite que o sequenciador que est\u00e1 criando o bloco inclua sua identidade para ser validado e recompensado</li> </ul> <p>Se voc\u00ea n\u00e3o incluir esses m\u00f3dulos no tempo de execu\u00e7\u00e3o da rede Tanssi, n\u00e3o haver\u00e1 um m\u00e9todo para confirmar que os blocos est\u00e3o sendo gerados por sequenciadores confi\u00e1veis designados pelo orquestrador Tanssi. Isso poderia criar uma vulnerabilidade para que atores mal-intencionados explorem e comprometam a rede. Para obter mais informa\u00e7\u00f5es sobre a produ\u00e7\u00e3o de blocos do Tanssi como um servi\u00e7o, consulte o artigo Servi\u00e7os de Produ\u00e7\u00e3o de Blocos.</p> <p>Al\u00e9m da produ\u00e7\u00e3o de blocos, h\u00e1 outros aspectos essenciais para qualquer rede coberta nos modelos, como:</p> <ul> <li>Consenso - as redes t\u00eam a funcionalidade necess\u00e1ria para permitir que os sequenciadores produzam blocos, fofoquem e validem-nos e coordenem com o provedor de seguran\u00e7a para serem notificados sobre a finalidade do bloco</li> <li>Interoperabilidade de Redes - lida com a ingest\u00e3o e envio de mensagens descendentes e laterais de entrada, permitindo que uma rede Tanssi se comunique e interaja com as outras cadeias dentro do ecossistema</li> <li>Atualiza\u00e7\u00f5es de tempo de execu\u00e7\u00e3o - uma atualiza\u00e7\u00e3o de tempo de execu\u00e7\u00e3o em uma rede Tanssi deve ser informada aos operadores do provedor de seguran\u00e7a para permitir que eles verifiquem os blocos produzidos pelos sequenciadores das redes Tanssi</li> </ul>"},{"location":"pt/builders/build/templates/overview/#included-modules","title":"M\u00f3dulos Inclu\u00eddos","text":"<p>Al\u00e9m dos m\u00f3dulos necess\u00e1rios para suportar a opera\u00e7\u00e3o de uma rede Tanssi, muitos outros m\u00f3dulos fornecem comportamento funcional com o qual os usu\u00e1rios podem interagir.</p> <p>Estes s\u00e3o alguns dos m\u00f3dulos funcionais que exp\u00f5em um comportamento aos usu\u00e1rios que est\u00e3o inclu\u00eddos nos modelos e prontos para uso:</p> <ul> <li>Balances - o m\u00f3dulo Balances fornece fun\u00e7\u00f5es para lidar com contas e saldos para a moeda nativa da rede Tanssi</li> <li>Utility - o m\u00f3dulo Utility fornece fun\u00e7\u00f5es para executar v\u00e1rias chamadas em um \u00fanico despacho. Al\u00e9m dos lotes de transa\u00e7\u00f5es, este m\u00f3dulo tamb\u00e9m permite a execu\u00e7\u00e3o de uma chamada de uma origem alternativa assinada</li> <li>Proxy - o m\u00f3dulo Proxy fornece fun\u00e7\u00f5es para delegar a outras contas (proxies) a permiss\u00e3o para despachar chamadas de uma origem proxy</li> <li>Modo de Manuten\u00e7\u00e3o - o m\u00f3dulo Modo de Manuten\u00e7\u00e3o permite que a rede Tanssi seja definida para um modo em que n\u00e3o executa transfer\u00eancias de saldo/ativos ou outras transa\u00e7\u00f5es. Isso pode ser \u00fatil ao atualizar o tempo de execu\u00e7\u00e3o em uma emerg\u00eancia, ao executar grandes migra\u00e7\u00f5es de armazenamento ou quando uma vulnerabilidade de seguran\u00e7a \u00e9 descoberta</li> <li>Tx Pause - o m\u00f3dulo Tx Pause permite que uma origem v\u00e1lida (normalmente Root) pause (e cancele a pausa) um m\u00f3dulo inteiro ou uma \u00fanica transa\u00e7\u00e3o. Uma transa\u00e7\u00e3o em pausa (ou todas as transa\u00e7\u00f5es inclu\u00eddas em um m\u00f3dulo em pausa) falhar\u00e1 quando chamada at\u00e9 que seja despausada. Este m\u00f3dulo fornece um grau maior de granularidade em compara\u00e7\u00e3o com o modo de manuten\u00e7\u00e3o, tornando-o particularmente \u00fatil quando uma transa\u00e7\u00e3o defeituosa ou vulner\u00e1vel \u00e9 identificada no tempo de execu\u00e7\u00e3o</li> <li>Multisig - o m\u00f3dulo Multisig permite despachos de transa\u00e7\u00f5es que exigem -tipicamente- mais de uma assinatura. Uma transa\u00e7\u00e3o multisig define um conjunto de contas autorizadas e um limite para sua aprova\u00e7\u00e3o, exigindo consenso entre v\u00e1rias partes</li> </ul>"},{"location":"pt/builders/build/templates/overview/#getting-started","title":"Comece a Construir","text":"<p>Para come\u00e7ar a construir sobre os modelos fornecidos, seja o modelo de rede Tanssi base ou o modelo EVM (Ethereum Virtual Machine) base, a abordagem recomendada \u00e9 bifurcar o reposit\u00f3rio Tanssi e come\u00e7ar a adicionar m\u00f3dulos integrados ou m\u00f3dulos personalizados sobre a tag vers\u00e3o mais recente.</p> <p>Esta abordagem tem algumas vantagens, como:</p> <ul> <li>Construir sobre a vers\u00e3o mais recente e est\u00e1vel</li> <li>Obter o protocolo Tanssi j\u00e1 configurado e inclu\u00eddo no tempo de execu\u00e7\u00e3o do modelo</li> <li>Mantenha sua bifurca\u00e7\u00e3o atualizada sincronizando com o reposit\u00f3rio upstream do Tanssi</li> <li>Execute os testes inclu\u00eddos, garantindo que a produ\u00e7\u00e3o de blocos em sua rede Tanssi funcione conforme o esperado</li> <li>Execute um ambiente local completo com a configura\u00e7\u00e3o Zombienet inclu\u00edda</li> </ul> <p>Se os modelos j\u00e1 cobrem as necessidades do seu caso de uso ou ap\u00f3s construir e testar sua cadeia, voc\u00ea pode continuar com o artigo Implantar sua rede via o Tanssi DApp para saber como usar o Tanssi dApp para registrar e colocar sua cadeia em funcionamento.</p>"},{"location":"pt/builders/build/templates/substrate/","title":"Modelo de Rede de Base","text":""},{"location":"pt/builders/build/templates/substrate/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O reposit\u00f3rio Tanssi inclui um modelo m\u00ednimo que fornece a configura\u00e7\u00e3o necess\u00e1ria para suportar o protocolo Tanssi e alguns m\u00f3dulos essenciais, como o que permite lidar com a moeda da rede Tanssi.</p> <p>Esta se\u00e7\u00e3o aborda este modelo b\u00e1sico, o que ele inclui e alguns aspectos a serem considerados ao adicionar depend\u00eancias externas.</p>"},{"location":"pt/builders/build/templates/substrate/#baseline-network-template","title":"Modelo de Rede de Base","text":"<p>Desenvolver um tempo de execu\u00e7\u00e3o de rede normalmente envolve duas etapas principais:</p> <ol> <li>Incorporar m\u00f3dulos internos pr\u00e9-existentes no tempo de execu\u00e7\u00e3o</li> <li>Criar m\u00f3dulos personalizados adaptados \u00e0s necessidades espec\u00edficas do seu aplicativo</li> </ol> <p>Como o modelo fornecido j\u00e1 inclui as configura\u00e7\u00f5es essenciais para uma integra\u00e7\u00e3o perfeita com o protocolo Tanssi e o provedor de seguran\u00e7a (por exemplo, Symbiotic no Ethereum), as equipes interessadas em construir uma rede inovadora com tecnologia Tanssi podem usar este modelo como ponto de partida para adicionar sua l\u00f3gica personalizada.</p> <p>Aqui est\u00e3o alguns dos recursos que v\u00eam com este modelo:</p> <ul> <li>Utilize da Tanssi produ\u00e7\u00e3o de blocos como servi\u00e7o</li> <li>Escolha o provedor de seguran\u00e7a que melhor se adapta \u00e0s suas necessidades. Por exemplo, aproveite a seguran\u00e7a de n\u00edvel Ethereum do Symbiotic</li> <li>Obtenha a finalidade determin\u00edstica da transa\u00e7\u00e3o em segundos</li> <li>Crie dApps que interagem com sua rede por meio de uma API</li> </ul> <p>Aproveitando esses recursos no modelo, voc\u00ea pode iniciar o desenvolvimento da sua rede Tanssi e personaliz\u00e1-la para atender aos seus requisitos e inova\u00e7\u00f5es espec\u00edficos.</p>"},{"location":"pt/builders/build/templates/substrate/#adding-extra-dependencies","title":"Adicionando Depend\u00eancias Extras","text":"<p>O modelo de rede Substrate inclui todos os m\u00f3dulos e configura\u00e7\u00f5es necess\u00e1rios que o tornam compat\u00edvel com o protocolo Tanssi e tamb\u00e9m muitos outros m\u00f3dulos que fornecem funcionalidades b\u00e1sicas.</p> <p>Este modelo foi projetado para servir como base para construir, pois a maioria dos casos de uso requer capacidades expandidas, adicionando m\u00f3dulos existentes ou personalizados. Para saber como adicionar novas funcionalidades ao seu tempo de execu\u00e7\u00e3o, consulte a se\u00e7\u00e3o personalizar tempo de execu\u00e7\u00e3o.</p>"},{"location":"pt/builders/deploy/","title":"Implante sua Appchain em Minutos","text":"<p>Com o Tanssi, lan\u00e7ar sua appchain \u00e9 simples e eficiente. A plataforma simplifica o processo, para que voc\u00ea possa se concentrar na constru\u00e7\u00e3o de seu aplicativo.</p>"},{"location":"pt/builders/deploy/#visao-geral-rapida-da-implantacao-via-tanssi-dapp","title":"Vis\u00e3o geral r\u00e1pida da implanta\u00e7\u00e3o via Tanssi DApp","text":"<p>A implanta\u00e7\u00e3o de uma appchain com tecnologia Tanssi via Tanssi dApp \u00e9 realizada como um fluxo \u00fanico e simplificado, consistindo em cinco etapas distintas:</p> <ol> <li>Selecione um template e configure-o</li> <li>Satisfa\u00e7a os saldos m\u00ednimos de token necess\u00e1rios</li> <li>Reserve seu Tanssi appchain ID</li> <li>Gere seus arquivos de appchain personalizados</li> <li>Registre sua appchain no Tanssi</li> </ol> <p></p> <p>Nota</p> <p>Para implanta\u00e7\u00f5es de Quick Trial appchains e Dedicated appchains no Tanssi TestNet, a equipe Tanssi concluir\u00e1 a verifica\u00e7\u00e3o manualmente. Ap\u00f3s a verifica\u00e7\u00e3o, geralmente leva cerca de dez minutos para sua quick trial appchain ficar pronta e cerca de duas horas para uma dedicada. Para o Tanssi MainNet, o processo ser\u00e1 totalmente descentralizado e sem permiss\u00e3o.</p> <p>Para come\u00e7ar, visite Usando o Tanssi DApp.</p>"},{"location":"pt/builders/deploy/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/deploy/dapp/","title":"Implemente sua appchain atrav\u00e9s do Tanssi DApp","text":""},{"location":"pt/builders/deploy/dapp/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A Tanssi tem como objetivo reduzir a barreira de entrada para a constru\u00e7\u00e3o de appchains descentralizadas, simplificando o processo de integra\u00e7\u00e3o e abstraindo os detalhes t\u00e9cnicos do lan\u00e7amento de uma appchain com tecnologia Tanssi. O Tanssi dApp permite que voc\u00ea inicie uma appchain em apenas alguns minutos. Este guia mostra as etapas necess\u00e1rias para lan\u00e7ar uma appchain na Dancelight, a Tanssi TestNet, usando o Tanssi dApp.</p>"},{"location":"pt/builders/deploy/dapp/#quick-trial-vs-dedicated-appchains","title":"Testes r\u00e1pidos vs. appchains dedicadas","text":"<p>O Tanssi dApp suporta a cria\u00e7\u00e3o de dois tipos de appchains:</p> <ul> <li>Teste r\u00e1pido: uma appchain tempor\u00e1ria que se autodestr\u00f3i ap\u00f3s 48 horas</li> <li>Dedicada: uma appchain de longa dura\u00e7\u00e3o para builders do ecossistema Tanssi</li> </ul> <p>Ambos os tipos se comportam de forma id\u00eantica; a diferen\u00e7a \u00e9 a natureza tempor\u00e1ria do teste r\u00e1pido. Em geral, o teste r\u00e1pido \u00e9 o melhor para quem quer experimentar uma appchain com tecnologia Tanssi. Se precisar de um ambiente de teste de longa dura\u00e7\u00e3o, a equipe Tanssi pode ajudar a configurar uma appchain dedicada.</p> <p>As capturas de tela e o conte\u00fado deste guia usam appchains de teste r\u00e1pido, mas o processo \u00e9 o mesmo para configurar uma appchain dedicada.</p> <p></p>"},{"location":"pt/builders/deploy/dapp/#prerequisites","title":"Pr\u00e9-requisitos","text":""},{"location":"pt/builders/deploy/dapp/#supported-wallets","title":"Carteiras suportadas","text":"<p>Como a Tanssi \u00e9 constru\u00edda com Substrate, voc\u00ea precisar\u00e1 de uma carteira compat\u00edvel com Substrate para implantar e gerenciar sua appchain Tanssi. Carteiras suportadas:</p> <ul> <li>Talisman</li> <li>SubWallet</li> <li>Enkrypt</li> <li>Extens\u00e3o Polkadot.js</li> </ul> <p>Se voc\u00ea implantar uma appchain EVM com tecnologia Tanssi, os usu\u00e1rios poder\u00e3o usar carteiras Ethereum, como MetaMask, sem precisar de carteira Substrate.</p> <p></p>"},{"location":"pt/builders/deploy/dapp/#connect-wallet","title":"Conecte sua carteira ao DApp","text":"<p>Para conectar sua carteira ao Tanssi dApp, clique em Connect Wallet no canto superior direito e escolha o tipo de carteira. Depois:</p> <ol> <li>Escolha sua conta no menu suspenso</li> <li>Assine a mensagem solicitada para fazer login no Tanssi dApp</li> </ol> <p></p> <p>Ap\u00f3s conectar, seu endere\u00e7o aparecer\u00e1 no canto superior direito. Se tiver v\u00e1rias contas conectadas, clique no endere\u00e7o para trocar.</p>"},{"location":"pt/builders/deploy/dapp/#configure-your-appchain","title":"Configure sua appchain","text":"<p>Na p\u00e1gina inicial do dApp, clique em Start Building no bloco Launch Network para configurar sua appchain imediatamente. Escolha entre Quick Trial ou Dedicated. Veja as diferen\u00e7as em Testes r\u00e1pidos vs. appchains dedicadas.</p> <p></p> <p>Em seguida, selecione o template que melhor atende ao seu caso de uso e configure as propriedades da appchain. Voc\u00ea pode escolher o template EVM ou Substrate ou enviar um arquivo de especifica\u00e7\u00e3o bruta. Consulte Templates para detalhes.</p>"},{"location":"pt/builders/deploy/dapp/#evm-template","title":"Template EVM","text":"<p>O template EVM adiciona a camada de compatibilidade Ethereum \u00e0 sua appchain Tanssi.</p> <p>Voc\u00ea precisar\u00e1 de um ID de cadeia EVM exclusivo (EIP-155). Verifique se o ID est\u00e1 livre em Chainlist. Ao lan\u00e7ar em produ\u00e7\u00e3o, abra um PR para reservar o ID no reposit\u00f3rio <code>ethereum-lists/chains</code> assim que o endpoint RPC estiver ativo.</p> <p>Nota</p> <p>Um ID de cadeia EVM registrado \u00e9 necess\u00e1rio apenas na MainNet. Para testes na TestNet, use qualquer ID dispon\u00edvel.</p> <p>Para configurar:</p> <ol> <li>Em Network Details, informe o nome do projeto, o ID de cadeia EVM e a categoria</li> <li>Em Gas Token, informe o s\u00edmbolo do token nativo (18 casas decimais fixas)</li> <li>Opcional: ajuste configura\u00e7\u00f5es EIP-1559 em Advanced (base fee e varia\u00e7\u00e3o m\u00e1xima)</li> <li>Em Accounts, forne\u00e7a o endere\u00e7o (estilo Ethereum) da conta sudo e o saldo inicial. S\u00f3 existe uma conta sudo por vez; ela pode ser trocada depois e a rede pode migrar para um modelo descentralizado</li> <li>Opcional: em Advanced, clique em Add para adicionar contas e saldos de g\u00eanese</li> <li>Opcional: em Genesis Smart Contracts, clique em Add para incluir contratos g\u00eanese (remova <code>0x</code> do bytecode)</li> <li>Ao finalizar o template, clique em Continue e siga para Checar saldos</li> </ol> <p></p>"},{"location":"pt/builders/deploy/dapp/#substrate-template","title":"Template Substrate","text":"<p>O template Substrate traz as configura\u00e7\u00f5es b\u00e1sicas para integrar com a Tanssi e pode servir como base para uma appchain personalizada.</p> <p>Para configurar:</p> <ol> <li>Em Network Details, informe o nome do projeto e a categoria</li> <li>Em Gas Token, informe decimais, s\u00edmbolo e formato SS58</li> <li>Em Accounts, informe o endere\u00e7o (estilo Substrate) da conta sudo e o saldo inicial. S\u00f3 existe uma conta sudo por vez; pode ser trocada depois e a rede pode migrar para governan\u00e7a descentralizada</li> <li>Opcional: em Advanced, clique em Add para adicionar contas e saldos de g\u00eanese</li> <li>Clique em Continue para seguir para Checar saldos</li> </ol> <p></p>"},{"location":"pt/builders/deploy/dapp/#custom","title":"Personalizado","text":"<p>Se voc\u00ea j\u00e1 possui um runtime Substrate e vai enviar um arquivo de especifica\u00e7\u00e3o personalizado, garanta que ele possa evoluir para uma appchain Tanssi.</p> <p>Seu runtime deve implementar o seguinte:</p> <ul> <li>Inclua o SDK Cumulus conforme Base Setup to Connect to Polkadot</li> <li>Inclua os m\u00f3dulos Tanssi de produ\u00e7\u00e3o de blocos conforme Base Setup to Support the Tanssi Protocol</li> </ul> <p>Outras exig\u00eancias no runtime:</p> <ul> <li> <p>No m\u00f3dulo <code>timestamp</code>, defina <code>OnTimestampSet</code> conforme o snippet:</p> <pre><code>type OnTimestampSet = tp_consensus::OnTimestampSet&lt;\n    &lt;Self as pallet_author_inherent::Config&gt;::SlotBeacon,\n    ConstU64&lt;{ SLOT_DURATION }&gt;,\n&gt;;\n</code></pre> </li> <li> <p>Remova m\u00f3dulos de produ\u00e7\u00e3o de blocos/consenso (Aura, Grandpa etc.), deixando a Tanssi assumir. Por exemplo, removendo:</p> <pre><code>// Suporte a collators. A ordem destes 4 \u00e9 importante e n\u00e3o deve mudar.\n#[runtime::pallet_index(20)]\npub type Authorship = pallet_authorship;\n#[runtime::pallet_index(21)]\npub type CollatorSelection = pallet_collator_selection;\n#[runtime::pallet_index(22)]\npub type Session = pallet_session;\n#[runtime::pallet_index(23)]\npub type Aura = pallet_aura;\n#[runtime::pallet_index(24)]\npub type AuraExt = cumulus_pallet_aura_ext;\n</code></pre> </li> </ul> <p>Por fim, gere e edite a especifica\u00e7\u00e3o da cadeia, prestando aten\u00e7\u00e3o especial a:</p> <ul> <li><code>para_id</code>: voc\u00ea precisa de um ID pr\u00e9-registrado; obtenha-o no passo Reserve your Network ID e retorne para prosseguir</li> <li><code>is_ethereum</code>: defina como <code>true</code> se precisar expor RPCs compat\u00edveis com Ethereum</li> </ul> <p>Ajuste tamb\u00e9m conforme o tipo de appchain:</p> Quick Trial AppchainDedicated Appchain <pre><code>{\n    ...\n    \"relay_chain\": \"rococo_flashbox_relay_testnet\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 1000\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <pre><code>{\n    ...\n    \"relay_chain\": \"rococo-local\",\n    \"chainType\": \"Live\",\n    \"genesis\": {\n        \"runtime\": {\n            ...\n            \"authoritiesNoting\": {\n                \"orchestratorParaId\": 0\n            },\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <p>Depois, selecione o template Custom e envie o arquivo JSON de especifica\u00e7\u00e3o bruta.</p> <p></p> <p>Nota</p> <p>O arquivo de especifica\u00e7\u00e3o bruta n\u00e3o deve exceder 2 MB.</p>"},{"location":"pt/builders/deploy/dapp/#check-balances","title":"Checar saldos","text":"<p>Verifique se voc\u00ea tem saldo suficiente. Caso n\u00e3o tenha, clique em Request Tokens e fa\u00e7a login com GitHub ou Google, responda \u00e0s perguntas r\u00e1pidas e solicite os tokens para a carteira conectada.</p> <p></p> <p>Para appchains dedicadas, preencha o formul\u00e1rio de inscri\u00e7\u00e3o; a equipe enviar\u00e1 os tokens em at\u00e9 um dia \u00fatil.</p> <p>Saldos m\u00ednimos para lan\u00e7ar:</p> Quick Trial AppchainDedicated Appchain Chain Balance Required Orchestration layer 70 UNIT Tanssi TestNet 100 SNAP Chain Balance Required Tanssi TestNet 100 STAR <p>Nota</p> <p>Appchains de teste r\u00e1pido usam uma camada adicional de orquestra\u00e7\u00e3o e, portanto, requerem SNAP e UNIT. Para appchains dedicadas, apenas STAR \u00e9 necess\u00e1rio.</p>"},{"location":"pt/builders/deploy/dapp/#reserve-appchain-id","title":"Reserve seu ID de appchain","text":"<p>Se ainda n\u00e3o fez isso, voc\u00ea precisa reservar o seu ID de appchain Tanssi, que identificar\u00e1 sua cadeia dentro do ecossistema Tanssi.</p> <p>Para reservar o seu ID de appchain Tanssi, ser\u00e1 necess\u00e1rio enviar uma transa\u00e7\u00e3o. Certifique-se de usar a conta com a qual pretende lan\u00e7ar sua appchain Tanssi ao enviar a transa\u00e7\u00e3o.</p> <ol> <li>Clique em Reserve Network ID</li> <li>Assine a transa\u00e7\u00e3o na sua carteira</li> </ol> <p></p> <p>Ap\u00f3s a transa\u00e7\u00e3o, o ID aparecer\u00e1 no dApp; clique em Continue. Parte dos tokens UNIT (ou STAR, para appchain dedicada) ficar\u00e1 reservada.</p> <p></p>"},{"location":"pt/builders/deploy/dapp/#generate-appchain-files","title":"Gere seus arquivos de appchain","text":"<p>Antes de implantar, gere tr\u00eas arquivos:</p> <ul> <li>A especifica\u00e7\u00e3o da cadeia bruta - uma vers\u00e3o compacta do arquivo de especifica\u00e7\u00e3o JSON, que define as configura\u00e7\u00f5es iniciais e o estado que todos os n\u00f3s participantes da rede devem concordar para alcan\u00e7ar consenso e produzir blocos</li> <li>O cabe\u00e7alho do estado g\u00eanese - define o estado inicial sobre o qual todas as transa\u00e7\u00f5es e transi\u00e7\u00f5es de estado s\u00e3o executadas</li> <li>O G\u00eanesis Wasm - um objeto WebAssembly (Wasm) que define a l\u00f3gica de tempo de execu\u00e7\u00e3o. Eles s\u00e3o gerados automaticamente com base no seu ID e configura\u00e7\u00f5es. Clique em Generate.</li> </ul> <p></p> <p>Quando prontos, clique em Continue para o passo final.</p>"},{"location":"pt/builders/deploy/dapp/#deploy-your-appchain","title":"Fa\u00e7a o deploy da sua appchain","text":"<p>No caso de teste r\u00e1pido, s\u00e3o duas transa\u00e7\u00f5es: registrar na camada de orquestra\u00e7\u00e3o e na Tanssi TestNet.</p> <p>Para registrar na camada de orquestra\u00e7\u00e3o:</p> <ol> <li>Clique em Register em Register Network in Relay</li> <li>Confirme a transa\u00e7\u00e3o na carteira</li> </ol> <p></p> <p>Quando a transa\u00e7\u00e3o for conclu\u00edda com sucesso, o dApp ser\u00e1 atualizado para mostrar que voc\u00ea registrou sua appchain Tanssi na se\u00e7\u00e3o Register Network in Relay.</p> <p>Por fim, para registrar sua appchain na Tanssi, siga estas etapas:</p> <ol> <li>Clique em Register em Register Network in Tanssi</li> <li>Confirme a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Quando a transa\u00e7\u00e3o for conclu\u00edda, o dApp exibir\u00e1 o registro da appchain. No painel, voc\u00ea poder\u00e1 acompanhar o status, blocos, endpoints RPC/WS e outras informa\u00e7\u00f5es.</p> <p></p> <p>E pronto! Voc\u00ea registrou sua appchain Tanssi. O processo de lan\u00e7amento iniciar\u00e1 automaticamente ap\u00f3s a verifica\u00e7\u00e3o da equipe Tanssi. Depois de ativa, volte ao Dashboard para ver o RPC e demais dados da rede.</p>"},{"location":"pt/builders/interoperability/","title":"Interoperabilidade","text":"<p>Explore as solu\u00e7\u00f5es cross-chain integradas dispon\u00edveis no ecossistema Tanssi, permitindo transfer\u00eancias de ativos e comunica\u00e7\u00e3o entre Tanssi e Ethereum.</p>"},{"location":"pt/builders/interoperability/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/interoperability/built-in-bridge/","title":"Usando a Ponte Tanssi Integrada","text":""},{"location":"pt/builders/interoperability/built-in-bridge/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O protocolo Tanssi orquestra componentes de infraestrutura, permitindo que os desenvolvedores lancem seus appchains personalizados em minutos e fornecendo a eles seguran\u00e7a econ\u00f4mica de n\u00edvel Ethereum pronta para uso. Para facilitar todo o processo para os desenvolvedores, uma arquitetura de primeira classe foi projetada e implementada.</p> <p>O token TANSSI \u00e9 o motor que permite a integra\u00e7\u00e3o de diferentes componentes de infraestrutura com provedores de seguran\u00e7a externos e alinha incentivos entre v\u00e1rios atores, incluindo detentores de tokens, operadores de n\u00f3s e construtores de appchain. Para atender a diferentes casos de uso, o token tem duas vers\u00f5es: a moeda nativa da rede Tanssi, TANSSI (Substrate), e sua vers\u00e3o ERC-20, no Ethereum.</p> <p>Os usu\u00e1rios podem converter de uma vers\u00e3o para outra do token usando uma ponte sem confian\u00e7a integrada do Tanssi.</p> <p>Neste guia, voc\u00ea aprender\u00e1 como mover seus ativos de Tanssi para Ethereum e vice-versa por meio de uma interface web segura e f\u00e1cil de usar dispon\u00edvel no Tanssi dApp, tornando as transfer\u00eancias entre cadeias acess\u00edveis a todos.</p>"},{"location":"pt/builders/interoperability/built-in-bridge/#prerequisites","title":"Pr\u00e9-requisitos","text":"<p>Antes de usar a ponte Tanssi, certifique-se de ter:</p> <p>Para fazer a ponte de Tanssi para Ethereum:</p> <ul> <li>Uma carteira compat\u00edvel com Substrate, como Talisman.</li> <li>Saldo TANSSI (Substrate) para transferir e pagar as taxas de ponte.</li> <li>A conta de destino do tipo Ethereum.</li> </ul> <p>Para fazer a ponte de Ethereum para Tanssi:</p> <ul> <li>Uma carteira compat\u00edvel com Ethereum, como MetaMask.</li> <li>Saldo TANSSI (ERC-20) para transferir.</li> <li>Saldo ETH para pagar as taxas de ponte.</li> <li>A conta de destino do tipo Substrate.</li> </ul>"},{"location":"pt/builders/interoperability/built-in-bridge/#bridge-to-ethereum","title":"Fazendo a ponte de tokens TANSSI para Ethereum","text":"<p>Se voc\u00ea deseja converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) no Ethereum, acesse o Tanssi dApp, abra a se\u00e7\u00e3o da ponte e siga estas etapas:</p> <ol> <li>Selecione Mainnet no menu suspenso From.</li> <li>Clique em Connect Wallet. Uma janela pop-up aparecer\u00e1, permitindo que voc\u00ea selecione sua carteira Substrate preferida e escolha a conta correspondente.</li> </ol> <p></p> <p>Agora, com sua carteira conectada:</p> <ol> <li>Selecione a conta de destino no menu suspenso Select recipient address ou escolha o item Enter a custom address e insira manualmente a conta para onde deseja receber os tokens ERC-20.</li> <li>Insira o valor a ser transferido no campo Balance. As taxas estimadas de ponte e transa\u00e7\u00e3o ser\u00e3o exibidas junto com o valor que a conta de destino receber\u00e1.</li> <li>Clique em Send e assine a transa\u00e7\u00e3o.</li> </ol> <p></p> <p>E \u00e9 isso! Seus tokens ser\u00e3o transferidos quando a pr\u00f3xima sess\u00e3o come\u00e7ar. Voc\u00ea pode ver quanto tempo resta na sess\u00e3o atual na barra de progresso.</p> <p>Nota</p> <ul> <li>Voc\u00ea pode adicionar facilmente o endere\u00e7o do contrato TANSSI ERC-20 \u00e0 sua carteira clicando no \u00edcone + mostrado ao lado do seu saldo.</li> <li>As taxas para converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) podem flutuar ao longo do tempo e devem ser pagas usando TANSSI.</li> </ul>"},{"location":"pt/builders/interoperability/built-in-bridge/#bridge-to-tanssi","title":"Fazendo a ponte de ERC-20 TANSSI para a Rede Tanssi","text":"<p>Se voc\u00ea deseja converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi, acesse o Tanssi dApp, abra a se\u00e7\u00e3o da ponte e siga estas etapas:</p> <ol> <li>Selecione Ethereum no menu suspenso From.</li> <li>Clique em Connect Wallet, selecione sua carteira Ethereum preferida e escolha a conta.</li> </ol> <p></p> <p>Agora, com sua carteira conectada:</p> <ol> <li>Insira a conta de destino Substrate no campo Recipient.</li> <li>Insira o valor a ser transferido no campo Balance. As taxas estimadas de ponte e transa\u00e7\u00e3o ser\u00e3o exibidas junto com o valor que a conta de destino receber\u00e1.</li> <li>Clique em Send e assine a transa\u00e7\u00e3o.</li> </ol> <p></p> <p>E \u00e9 isso! Seus tokens ser\u00e3o transferidos quando a pr\u00f3xima sess\u00e3o come\u00e7ar. Voc\u00ea pode ver quanto tempo resta na sess\u00e3o atual na barra de progresso.</p> <p>Nota</p> <p>As taxas para converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi podem flutuar ao longo do tempo e devem ser pagas usando ETH.</p>"},{"location":"pt/builders/manage/","title":"Gerenciando sua Rede com Tecnologia Tanssi","text":"<p>A Tanssi dApp e o portal do desenvolvedor servem a prop\u00f3sitos diferentes ao gerenciar sua rede, oferecendo benef\u00edcios exclusivos adaptados \u00e0s suas necessidades:</p> <ul> <li> <p>Tanssi dApp - simplifica todo o ciclo de vida da rede, desde a implanta\u00e7\u00e3o at\u00e9 o gerenciamento b\u00e1sico. Ao remover as complexidades t\u00e9cnicas, ela permite uma experi\u00eancia mais r\u00e1pida e simplificada para criar e gerenciar redes. Algumas a\u00e7\u00f5es que podem ser executadas via dApp incluem:</p> </li> <li> <p>Pagamento por servi\u00e7os de produ\u00e7\u00e3o de blocos</p> </li> <li> <p>Gerenciamento de tokens (ou seja, cunhagem e transfer\u00eancia de tokens, atualiza\u00e7\u00e3o de saldos e muito mais)</p> </li> <li> <p>Developer portal - constru\u00eddo sobre Polkadot.js Apps, o portal do desenvolvedor fornece ferramentas avan\u00e7adas para gerenciamento de rede, incluindo atualiza\u00e7\u00f5es de tempo de execu\u00e7\u00e3o, cunhagem de tokens e muito mais. \u00c9 ideal para tarefas que exigem controle e personaliza\u00e7\u00e3o precisos. Algumas a\u00e7\u00f5es que podem ser executadas atrav\u00e9s do portal do desenvolvedor incluem:</p> </li> <li> <p>Gerenciamento da conta Sudo</p> </li> <li>Despacho de atualiza\u00e7\u00f5es de tempo de execu\u00e7\u00e3o</li> <li>Cunhagem de tokens</li> <li>Pausar transa\u00e7\u00f5es ou habilitar modo de manuten\u00e7\u00e3o em emerg\u00eancias</li> </ul> <p>Passe para as se\u00e7\u00f5es abaixo para explorar como cada ferramenta ajuda voc\u00ea a gerenciar sua rede com tecnologia Tanssi de forma eficiente.</p>"},{"location":"pt/builders/manage/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/manage/dapp/","title":"Usando o DApp Tanssi para Gerenciar Sua Rede","text":"<p>O Tanssi dApp \u00e9 a sua plataforma de refer\u00eancia para lidar com os aspectos operacionais da sua rede dentro do ecossistema Tanssi. Projetado para facilitar o uso, o dApp permite que os desenvolvedores agilizem tarefas di\u00e1rias como gerenciar tokens, pagar por servi\u00e7os de produ\u00e7\u00e3o de blocos e supervisionar as opera\u00e7\u00f5es essenciais da rede sem precisar de conhecimento t\u00e9cnico profundo ou configura\u00e7\u00f5es avan\u00e7adas.</p>"},{"location":"pt/builders/manage/dapp/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/","title":"Gerenciar Tokens","text":""},{"location":"pt/builders/manage/dapp/manage-tokens/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Qualquer rede implantada atrav\u00e9s do Tanssi \u00e9 soberana e livre para definir o modelo de governan\u00e7a que melhor se adapta ao seu caso de uso. O governador da rede tem superpoderes sobre a administra\u00e7\u00e3o da cadeia. Consequentemente, eles podem chamar fun\u00e7\u00f5es privilegiadas, como atualizar o tempo de execu\u00e7\u00e3o e gerenciar opera\u00e7\u00f5es relacionadas a tokens nativos, entre outras a\u00e7\u00f5es.</p> <p>Existem algumas a\u00e7\u00f5es relacionadas ao gerenciamento de tokens nativos que est\u00e3o dispon\u00edveis para o governador da rede no Tanssi dApp:</p> <ul> <li>Mint tokens - cunha novos tokens, aumentando a oferta total</li> <li>Update balances - aumenta ou diminui o saldo de uma conta, afetando a oferta total</li> <li>Transfer tokens - executa uma transfer\u00eancia for\u00e7ada de tokens de uma conta para outra</li> <li>Configure gas dynamic - dispon\u00edvel apenas em redes compat\u00edveis com EVM, esta a\u00e7\u00e3o altera a configura\u00e7\u00e3o EIP-1559, afetando o mecanismo de precifica\u00e7\u00e3o da transa\u00e7\u00e3o</li> </ul> <p>Neste guia, voc\u00ea aprender\u00e1 como executar as a\u00e7\u00f5es listadas anteriormente usando o Tanssi dApp.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para os exemplos neste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Teste R\u00e1pido ou Dedicado)</li> <li>A conta que voc\u00ea usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, tamb\u00e9m importada em qualquer uma das carteiras suportadas</li> </ul> <p>Note</p> <p>A conta de registro da rede \u00e9 sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compat\u00edvel com EVM, a conta Sudo ser\u00e1 do tipo Ethereum; caso contr\u00e1rio, ser\u00e1 do tipo Substrate.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#retrieving-registration-account","title":"Recuperando a conta de registro","text":"<p>Se voc\u00ea n\u00e3o souber qual \u00e9 a sua conta de registro, pode consult\u00e1\u2011la diretamente na cadeia orquestradora do Tanssi, que mant\u00e9m os registros de todas as redes cadastradas. Para isso, acesse a se\u00e7\u00e3o Chain state no Polkadot.js Apps conectado \u00e0 cadeia orquestradora para redes de teste r\u00e1pidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o m\u00f3dulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no \u00edcone +</li> </ol> <p>A conta de registro aparecer\u00e1 na parte inferior.</p> <p></p> <p>Note</p> <p>O dApp exibir\u00e1 sua rede no painel somente se a conta de registro estiver configurada corretamente.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#retrieving-sudo-account","title":"Recuperando a conta Sudo","text":"<p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#accesing-token-management-panel","title":"Acessando o Painel de Gerenciamento de Tokens","text":"<p>O Tanssi dApp implementa uma interface suave, permitindo que o governador da rede acesse e execute fun\u00e7\u00f5es privilegiadas. Para fazer isso, v\u00e1 para o Tanssi dApp e, em seguida:</p> <ol> <li>Clique no bot\u00e3o Manage</li> <li>Clique no bot\u00e3o Token Management.</li> </ol> <p></p> <p>Agora voc\u00ea tem acesso direto \u00e0s a\u00e7\u00f5es apresentadas na introdu\u00e7\u00e3o:</p> <ol> <li>Mint Tokens</li> <li>Update Balances</li> <li>Transfer Tokens</li> <li>Configurar Gas Dynamics</li> </ol> <p></p> <p>Nota</p> <p>Se voc\u00ea n\u00e3o vir os detalhes da sua rede no painel, certifique-se de cumprir os pr\u00e9-requisitos.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#minting-tokens","title":"Minting Tokens","text":"<p>O governador da rede pode cunhar novos tokens, aumentando sua oferta total. Para fazer isso, no painel Token Management, clique no bot\u00e3o Mint tokens e, em seguida:</p> <ol> <li> <p>Insira o endere\u00e7o que conter\u00e1 os tokens rec\u00e9m-cunhados</p> <p>Nota</p> <p>O endere\u00e7o de destino deve ser do tipo Ethereum se a cadeia for compat\u00edvel com EVM e do tipo Substrate caso contr\u00e1rio.</p> </li> <li> <p>Insira a quantidade de tokens a serem cunhados</p> </li> <li>Clique em Mint</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o com a conta do governador da rede. Depois que a transa\u00e7\u00e3o for conclu\u00edda, o saldo da conta de destino ter\u00e1 sido aumentado pela quantia desejada.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#updating-balances","title":"Updating Balances","text":"<p>O governador da rede pode aumentar ou diminuir o saldo de qualquer conta, afetando, assim, a oferta total. Para fazer isso, no painel Token Management, clique no bot\u00e3o Update Balances e, em seguida:</p> <ol> <li> <p>Insira o endere\u00e7o que conter\u00e1 os tokens rec\u00e9m-cunhados. Depois de inserir o endere\u00e7o, seu saldo atual ser\u00e1 exibido</p> <p>Nota</p> <p>O endere\u00e7o de destino deve ser do tipo Ethereum se a cadeia for compat\u00edvel com EVM e do tipo Substrate caso contr\u00e1rio.</p> </li> <li> <p>Insira o novo saldo que o endere\u00e7o conter\u00e1</p> </li> <li>Clique em Update</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o com a conta do governador da rede. Depois que a transa\u00e7\u00e3o for conclu\u00edda, o saldo da conta de destino refletir\u00e1 exatamente a quantia desejada, independentemente das participa\u00e7\u00f5es anteriores.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#forced-transfers","title":"Executando Transfer\u00eancias For\u00e7adas","text":"<p>O governador da rede pode reatribuir saldos, for\u00e7ando uma transfer\u00eancia de tokens de uma conta para outra. Para fazer isso, no painel Token Management, clique no bot\u00e3o Transfer Tokens e, em seguida:</p> <ol> <li>Insira o endere\u00e7o de origem que transferir\u00e1 seus tokens</li> <li> <p>Insira o endere\u00e7o de destino que receber\u00e1 os tokens</p> <p>Nota</p> <p>Os endere\u00e7os de origem e destino devem ser do tipo Ethereum se a cadeia for compat\u00edvel com EVM e do tipo Substrate caso contr\u00e1rio.</p> </li> <li> <p>Insira a quantidade de tokens a serem transferidos</p> </li> <li>Clique em Transfer</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o com a conta do governador da rede. Depois que a transa\u00e7\u00e3o for conclu\u00edda, a conta de destino ter\u00e1 recebido o n\u00famero de tokens do endere\u00e7o de origem.</p>"},{"location":"pt/builders/manage/dapp/manage-tokens/#definindo-a-gas-dynamics-definindo-gas","title":"Definindo a Gas Dynamics{: #definindo-gas }","text":"<p>Nota</p> <p>Esta op\u00e7\u00e3o se aplica apenas a redes compat\u00edveis com EVM.</p> <p>O governador de uma rede compat\u00edvel com EVM com tecnologia Tanssi pode alterar sua configura\u00e7\u00e3o EIP-1559, afetando o mecanismo de precifica\u00e7\u00e3o da transa\u00e7\u00e3o. Para fazer isso, no painel Token Management, clique no bot\u00e3o Gas Dynamics e, em seguida:</p> <ol> <li>Insira a nova taxa base, expressa em unidades Wei (10<sup>-18</sup>)</li> <li>Insira o valor da elasticidade</li> <li>Clique em Update Dynamics</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o com a conta do governador da rede. Depois que a transa\u00e7\u00e3o for conclu\u00edda, o mecanismo de taxas da rede ser\u00e1 executado com os novos par\u00e2metros de precifica\u00e7\u00e3o da transa\u00e7\u00e3o.</p>"},{"location":"pt/builders/manage/dapp/register-external-assets/","title":"Registrar Ativos Externos","text":""},{"location":"pt/builders/manage/dapp/register-external-assets/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A transfer\u00eancia de ativos entre cadeias \u00e9 crucial porque permite a movimenta\u00e7\u00e3o cont\u00ednua de ativos digitais em diferentes redes, aprimorando a interoperabilidade, a liquidez e a experi\u00eancia do usu\u00e1rio. Para permitir transfer\u00eancias de ativos de e para duas redes, primeiro, um canal bidirecional deve ser aberto entre elas. Gra\u00e7as ao dApp Tanssi, abrir um canal \u00e9 uma tarefa f\u00e1cil e r\u00e1pida. Consulte o artigo Gerenciar Canais de Comunica\u00e7\u00e3o Cross-Chain para saber como fazer isso.</p> <p>Nota</p> <p>Abrir um canal de comunica\u00e7\u00e3o bidirecional requer aprova\u00e7\u00e3o dos governadores de ambas as redes.</p> <p>Depois que os canais de comunica\u00e7\u00e3o da sua rede forem estabelecidos, voc\u00ea pode registrar os ativos de outras cadeias (ativos externos) para come\u00e7ar a operar. Este guia ir\u00e1 gui\u00e1-lo pelo processo de registro de ativos externos usando o Tanssi dApp.</p>"},{"location":"pt/builders/manage/dapp/register-external-assets/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Dedicada) executando runtime 500 ou superior</li> <li>A conta que voc\u00ea usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, tamb\u00e9m importada em qualquer uma das carteiras suportadas</li> </ul> <p>!!! note       A conta de registro da rede \u00e9 sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compat\u00edvel com EVM, a conta Sudo ser\u00e1 do tipo Ethereum; caso contr\u00e1rio, ser\u00e1 do tipo Substrate.</p> <p>### Recuperando a conta de registro {: #retrieving-registration-account }</p> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a sua conta de registro, pode consult\u00e1\u2011la diretamente na cadeia orquestradora do Tanssi, que mant\u00e9m os registros de todas as redes cadastradas. Para isso, acesse a se\u00e7\u00e3o Chain state no Polkadot.js Apps conectado \u00e0 cadeia orquestradora para redes de teste r\u00e1pidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o m\u00f3dulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no \u00edcone +</li> </ol> <p>A conta de registro aparecer\u00e1 na parte inferior.</p> <p></p> <p>!!! note       O dApp exibir\u00e1 sua rede no painel somente se a conta de registro estiver configurada corretamente.</p> <p>### Recuperando a conta Sudo {: #retrieving-sudo-account }</p> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>!!! warning       \u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/dapp/register-external-assets/#accesing-external-assets-management-panel","title":"Acessando o Painel de Registro de Ativos Externos","text":"<p>O dApp do Tanssi facilita para o respons\u00e1vel pela rede gerenciar as configura\u00e7\u00f5es de comunica\u00e7\u00e3o entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gest\u00e3o de cross\u2011chain, acesse o Tanssi dApp e:</p> <ol> <li>Clique em Manage</li> <li>Clique em XCM</li> </ol> <p></p> <p>Note</p> <p>Se os detalhes da sua rede n\u00e3o aparecerem no dashboard, verifique se voc\u00ea cumpriu os pr\u00e9-requisitos.</p> <p>O painel mostrar\u00e1 a configura\u00e7\u00e3o cross-chain da sua rede, juntamente com v\u00e1rias a\u00e7\u00f5es dispon\u00edveis. Em rela\u00e7\u00e3o aos ativos externos, os elementos relevantes que s\u00e3o apresentados a voc\u00ea s\u00e3o:</p> <ol> <li>Registered Assets panel - esta se\u00e7\u00e3o ir\u00e1 agrupar e apresentar a voc\u00ea todos os ativos registrados que sua rede j\u00e1 tem dispon\u00edveis</li> <li>Registered Assets List - os ativos externos j\u00e1 registrados ser\u00e3o exibidos nesta se\u00e7\u00e3o, juntamente com suas informa\u00e7\u00f5es associadas, como nome do ativo, s\u00edmbolo, ID, oferta total e ID da rede onde \u00e9 nativo</li> <li>Asset Registration - esta op\u00e7\u00e3o permite que voc\u00ea selecione outros ativos externos dispon\u00edveis e registre-os. A se\u00e7\u00e3o a seguir explica como faz\u00ea-lo</li> </ol> <p></p>"},{"location":"pt/builders/manage/dapp/register-external-assets/#register-external-asset","title":"Registrar um Ativo Externo","text":"<p>Desde que sua rede j\u00e1 tenha estabelecido canais de comunica\u00e7\u00e3o bidirecionais com outra rede, o governador da rede pode registrar ativos externos.</p> <p>Para fazer isso, clique em Asset Registration e depois:</p> <ol> <li>Selecione pelo menos um dos ativos dispon\u00edveis na lista</li> <li>Clique em Register</li> </ol> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o e, assim que ela for conclu\u00edda, o ativo externo estar\u00e1 dispon\u00edvel localmente.</p> <p></p> <p>Nota</p> <p>O dApp apresenta apenas ativos conhecidos de redes conhecidas do ecossistema. Se o ativo que voc\u00ea precisa registrar n\u00e3o estiver listado, voc\u00ea ter\u00e1 que faz\u00ea-lo usando o portal do desenvolvedor.</p>"},{"location":"pt/builders/manage/dapp/services-payment/","title":"Pagamento dos Servi\u00e7os de Produ\u00e7\u00e3o de Blocos","text":""},{"location":"pt/builders/manage/dapp/services-payment/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Como apresentado no artigo Produ\u00e7\u00e3o de Blocos como Servi\u00e7o, existem dois custos principais associados que o governador da rede deve cobrir:</p> <ul> <li>Sequencers assignment - para a atribui\u00e7\u00e3o de sequenciadores pelo protocolo Tanssi, que acontece uma vez por sess\u00e3o</li> <li>Block production - para cada bloco que \u00e9 produzido em nome da rede</li> </ul> <p>Neste guia, voc\u00ea aprender\u00e1 como usar o Tanssi dApp para recarregar sua conta e manter a atividade da sua rede.</p>"},{"location":"pt/builders/manage/dapp/services-payment/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para os exemplos neste guia, voc\u00ea precisar\u00e1 do seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Teste R\u00e1pido ou Dedicado)</li> <li>A conta que voc\u00ea usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a sua conta de registro, pode consult\u00e1\u2011la diretamente na cadeia orquestradora do Tanssi, que mant\u00e9m os registros de todas as redes cadastradas. Para isso, acesse a se\u00e7\u00e3o Chain state no Polkadot.js Apps conectado \u00e0 cadeia orquestradora para redes de teste r\u00e1pidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o m\u00f3dulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no \u00edcone +</li> </ol> <p>A conta de registro aparecer\u00e1 na parte inferior.</p> <p></p> <p>Note</p> <p>O dApp exibir\u00e1 sua rede no painel somente se a conta de registro estiver configurada corretamente.</p>"},{"location":"pt/builders/manage/dapp/services-payment/#topping-up","title":"Topping-Up os Cr\u00e9ditos da Sua Rede","text":"<p>Seguindo um modelo de pagamento conforme o uso, as redes devem ter fundos alocados para pagar pelos servi\u00e7os, que, ao longo do tempo, ser\u00e3o deduzidos e queimados pelo protocolo Tanssi a cada mudan\u00e7a de sess\u00e3o para o custo da atribui\u00e7\u00e3o do sequenciador e para cada bloco pelo custo de produ\u00e7\u00e3o do bloco.</p> <p>Voc\u00ea pode verificar o saldo atual da sua rede e recarreg\u00e1-lo usando o Tanssi dApp. Para fazer isso, acesse o Tanssi dApp e conecte a conta de registro da rede ao dApp. O site exibir\u00e1 um cart\u00e3o mostrando o status da sua rede. Este cart\u00e3o inclui a previs\u00e3o de atividade projetada abaixo da se\u00e7\u00e3o Block Production e o bot\u00e3o Top Up.</p> <p></p> <p>Clicar no bot\u00e3o Top Up exibe uma barra lateral onde as seguintes informa\u00e7\u00f5es podem ser vistas:</p> <ul> <li>Current balance - o saldo atual alocado para o servi\u00e7o de produ\u00e7\u00e3o de blocos da rede</li> <li>Available balance - o saldo dispon\u00edvel na conta de registro da rede, que est\u00e1 conectada ao dApp</li> <li>Current cost - custo atual por atribui\u00e7\u00e3o de sequenciador e custo por bloco</li> <li>Projected forecast - o dia estimado em que a rede ficar\u00e1 sem fundos e deixar\u00e1 de ser atendida</li> </ul> <p>Para estender o horizonte projetado da rede, execute as seguintes a\u00e7\u00f5es:</p> <ol> <li>Insira a quantidade de tokens para comprar servi\u00e7os de produ\u00e7\u00e3o de blocos</li> <li>Clique em Top Up</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o e, depois que ela for conclu\u00edda, sua rede se beneficiar\u00e1 de um horizonte de atividade estendida.</p> <p>Aten\u00e7\u00e3o</p> <p>Se sua rede n\u00e3o tiver fundos suficientes para cobrir a atribui\u00e7\u00e3o do sequenciador e o valor de blocos de uma sess\u00e3o, ela travar\u00e1.</p>"},{"location":"pt/builders/manage/dapp/xcm-channels/","title":"Gerenciar Canais de Comunica\u00e7\u00e3o Cross-Chain","text":""},{"location":"pt/builders/manage/dapp/xcm-channels/#Introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Conforme apresentado no artigo Comunica\u00e7\u00e3o Cross-Chain Nativa da se\u00e7\u00e3o Aprenda, todas as redes Tanssi t\u00eam uma capacidade inerente de se comunicar e interoperar com qualquer outra rede no ecossistema. Esse recurso de comunica\u00e7\u00e3o cross-chain nativo \u00e9 poss\u00edvel gra\u00e7as \u00e0 infraestrutura \u00fanica em que as redes s\u00e3o constru\u00eddas, aproveitando o formato Cross-Consensus Message (XCM para abreviar), que facilita a comunica\u00e7\u00e3o entre diferentes sistemas de consenso.</p> <p>A primeira etapa para habilitar a comunica\u00e7\u00e3o entre as redes \u00e9 abrir um canal. O processo de abertura de um canal come\u00e7a enviando uma solicita\u00e7\u00e3o para a rede com a qual voc\u00ea deseja estabelecer comunica\u00e7\u00f5es. Depois que a solicita\u00e7\u00e3o for aceita pelo governador da cadeia de destino, um canal ser\u00e1 aberto.</p> <p>Neste guia, voc\u00ea aprender\u00e1 como usar o Tanssi dApp para gerenciar os canais de comunica\u00e7\u00e3o cross-chain da sua rede.</p>"},{"location":"pt/builders/manage/dapp/xcm-channels/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede Tanssi (Dedicada) executando o runtime 500 ou superior</li> <li>A conta que voc\u00ea usou ao registrar a rede, importada em qualquer uma das carteiras suportadas</li> <li>A conta Sudo da sua rede, tamb\u00e9m importada em qualquer uma das carteiras suportadas</li> </ul> <p>!!! note       A conta de registro da rede \u00e9 sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compat\u00edvel com EVM, a conta Sudo ser\u00e1 do tipo Ethereum; caso contr\u00e1rio, ser\u00e1 do tipo Substrate.</p> <p>### Recuperando a conta de registro {: #retrieving-registration-account }</p> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a sua conta de registro, pode consult\u00e1\u2011la diretamente na cadeia orquestradora do Tanssi, que mant\u00e9m os registros de todas as redes cadastradas. Para isso, acesse a se\u00e7\u00e3o Chain state no Polkadot.js Apps conectado \u00e0 cadeia orquestradora para redes de teste r\u00e1pidas ou redes dedicadas e siga estes passos:</p> <ol> <li>Selecione o m\u00f3dulo de armazenamento registrar</li> <li>Selecione registrarDeposit</li> <li>Insira o ID da sua rede</li> <li>Clique no \u00edcone +</li> </ol> <p>A conta de registro aparecer\u00e1 na parte inferior.</p> <p></p> <p>!!! note       O dApp exibir\u00e1 sua rede no painel somente se a conta de registro estiver configurada corretamente.</p> <p>### Recuperando a conta Sudo {: #retrieving-sudo-account }</p> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>!!! warning       \u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/dapp/xcm-channels/#accesing-channel-management-panel","title":"Acessando o Painel de Gerenciamento de Canais","text":"<p>O dApp do Tanssi facilita para o respons\u00e1vel pela rede gerenciar as configura\u00e7\u00f5es de comunica\u00e7\u00e3o entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gest\u00e3o de cross\u2011chain, acesse o Tanssi dApp e:</p> <ol> <li>Clique em Manage</li> <li>Clique em XCM</li> </ol> <p></p> <p>Note</p> <p>Se os detalhes da sua rede n\u00e3o aparecerem no dashboard, verifique se voc\u00ea cumpriu os pr\u00e9-requisitos.</p> <p>O painel mostrar\u00e1 o status dos canais de comunica\u00e7\u00e3o da sua rede, juntamente com v\u00e1rias a\u00e7\u00f5es dispon\u00edveis. Os elementos que voc\u00ea recebe s\u00e3o:</p> <ol> <li>Sovereign account - \u00e9 uma conta sem chave que pertence \u00e0 rede em um sistema de consenso diferente, a cadeia de retransmiss\u00e3o neste caso. Ela s\u00f3 pode ser usada pelo governador da rede.</li> </ol> <p>Antes de abrir um novo canal, a conta soberana da rede na cadeia de retransmiss\u00e3o deve ser financiada com tokens suficientes para serem bloqueados como um dep\u00f3sito de canal.</p> <p>Nesta se\u00e7\u00e3o, voc\u00ea pode ver o saldo da conta soberana da sua rede, copiar seu endere\u00e7o e depositar tokens</p> <ol> <li>Incoming/Outgoing channel requests - toda solicita\u00e7\u00e3o de canal precisa ser aceita pela contraparte antes que qualquer mensagem possa ser enviada.</li> </ol> <p>Nesta se\u00e7\u00e3o, voc\u00ea pode ver a lista de solicita\u00e7\u00f5es de sa\u00edda pendentes e cancel\u00e1-las. Voc\u00ea tamb\u00e9m pode ver quaisquer solicita\u00e7\u00f5es de canal de entrada que sua rede possa ter recebido e aceitar o canal</p> <ol> <li>Established channels - Depois que o governador da cadeia de destino aceitar a solicita\u00e7\u00e3o do canal, o canal se torna aberto e dispon\u00edvel para transmiss\u00e3o de mensagens.</li> </ol> <p>Nesta se\u00e7\u00e3o, voc\u00ea pode ver a lista de canais aceitos que sua rede possui, a dire\u00e7\u00e3o em que as mensagens fluem pelo canal e cancelar o canal</p> <ol> <li>Request to open new channels - esta op\u00e7\u00e3o permite que voc\u00ea selecione uma rede existente no ecossistema e solicite a abertura de um canal. A pr\u00f3xima se\u00e7\u00e3o explica como fazer isso</li> </ol> <p></p>"},{"location":"pt/builders/manage/dapp/xcm-channels/#request-new-channel","title":"Solicita\u00e7\u00e3o para Abrir Novo Canal","text":"<p>Desde que sua rede tenha fundos suficientes para o dep\u00f3sito na conta soberana da cadeia de retransmiss\u00e3o, o governador da rede pode solicitar a abertura de um novo canal com qualquer outra rede.</p> <p>Para fazer isso, clique em HRMP Channels e, em seguida:</p> <ol> <li>Selecione a rede com a qual voc\u00ea deseja estabelecer um canal</li> <li>Clique em Request Channel</li> </ol> <p>Voc\u00ea ser\u00e1 solicitado a assinar a transa\u00e7\u00e3o e, assim que ela for conclu\u00edda, a cadeia de destino receber\u00e1 a solicita\u00e7\u00e3o.</p> <p></p>"},{"location":"pt/builders/manage/developer-portal/","title":"Usando o Portal do Desenvolvedor","text":"<p>O portal do desenvolvedor permite que voc\u00ea gerencie com efici\u00eancia suas opera\u00e7\u00f5es de rede, seguran\u00e7a e personaliza\u00e7\u00e3o alimentadas pela Tanssi. Com ferramentas intuitivas \u00e0 sua disposi\u00e7\u00e3o, voc\u00ea pode garantir um gerenciamento tranquilo e adaptar sua rede para atender aos requisitos exclusivos do seu projeto.</p>"},{"location":"pt/builders/manage/developer-portal/#como-conectar-ao-portal-do-desenvolvedor","title":"Como Conectar ao Portal do Desenvolvedor","text":"<p>Antes de come\u00e7ar, voc\u00ea precisa recuperar a WS URL da sua rede. Esta informa\u00e7\u00e3o est\u00e1 dispon\u00edvel no Dashboard da sua rede no dApp Tanssi, na se\u00e7\u00e3o Properties.</p> <p></p> <p>Agora voc\u00ea est\u00e1 pronto para conectar sua rede alimentada pela Tanssi ao portal do desenvolvedor. Navegue at\u00e9 Polkadot.js Apps e clique nas informa\u00e7\u00f5es da chain no canto superior esquerdo para mudar para a sua rede.</p> <p></p> <p>Para configurar sua rede, siga estes passos:</p> <ol> <li>Role para baixo no menu do lado esquerdo at\u00e9 ver Development (Desenvolvimento). Clique nisso para expandir as op\u00e7\u00f5es</li> <li>Clique em Local Node (N\u00f3 Local)</li> <li>Insira sua URL RPC no campo de entrada do custom endpoint (ponto de extremidade personalizado)</li> <li>Clique no bot\u00e3o salvar. O portal ser\u00e1 recarregado e voc\u00ea dever\u00e1 estar conectado \u00e0 sua rede</li> </ol> <p></p> <p>Agora que voc\u00ea tem sua rede carregada no portal do desenvolvedor, voc\u00ea pode mergulhar nos seguintes guias para come\u00e7ar a gerenciar sua rede.</p>"},{"location":"pt/builders/manage/developer-portal/#explore-esta-secao","title":"Explore esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/manage/developer-portal/impersonate/","title":"Usando Sudo para personificar outras contas","text":""},{"location":"pt/builders/manage/developer-portal/impersonate/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Sudo \u00e9 um m\u00f3dulo que permite que chamadas de tempo de execu\u00e7\u00e3o privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo \u00e9, por vezes, referido coloquialmente como um superutilizador ou conta semelhante a um deus. Isto permite-lhe executar a\u00e7\u00f5es privilegiadas ao gerir a sua rede, como personificar outras contas.</p> <p>Neste guia, aprender\u00e1 como usar Sudo para personificar outras contas. Por exemplo, este guia usar\u00e1 a conta Sudo para se apresentar como uma conta arbitr\u00e1ria e transferir fundos dessa conta.</p> <p>Aten\u00e7\u00e3o</p> <p>A transfer\u00eancia de saldo demonstrada neste guia \u00e9 duvidosa e \u00e9 mostrada apenas como um exemplo de uso do Sudo.</p>"},{"location":"pt/builders/manage/developer-portal/impersonate/#checking-prerequisites","title":"Verifica\u00e7\u00e3o de Pr\u00e9-requisitos","text":"<p>Para os exemplos neste guia, precisar\u00e1 do seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada aos Polkadot.js Apps da sua rede. Pode consultar o Guia de Gerenciamento do Sudo para obter instru\u00e7\u00f5es sobre como injetar a sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/impersonate/#using-the-sudo-as-method","title":"Usando o M\u00e9todo Sudo As","text":"<p>Como sabe, a conta Sudo pode executar fun\u00e7\u00f5es privilegiadas, incluindo a personifica\u00e7\u00e3o de outras contas. Ao enviar uma chamada atrav\u00e9s de <code>sudoAs</code>, o tempo de execu\u00e7\u00e3o primeiro autenticar\u00e1 a chave Sudo e, em seguida, despachar\u00e1 a chamada de fun\u00e7\u00e3o desejada com a origem <code>Signed</code> de uma determinada conta. No exemplo a seguir, o m\u00e9todo <code>sudoAs</code> orquestrar\u00e1 o envio de alguns tokens para outra conta. Embora o resultado seja semelhante ao uso do Sudo com uma chamada <code>forceBalanceTransfer</code>, o exemplo a seguir usa uma chamada de transfer\u00eancia de saldo regular, onde a origem \u00e9 a conta do remetente e n\u00e3o a conta Sudo.</p> <p>Para fazer uma chamada <code>sudoAs</code> para personificar outra conta, navegue para o separador Developer (Desenvolvedor) dos Polkadot.js Apps para a sua rede com tecnologia Tanssi e clique em Sudo. Se n\u00e3o vir Sudo neste menu, n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua conta Sudo est\u00e1 injetada pela sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga os seguintes passos:</p> <ol> <li>Selecione a paleta Sudo</li> <li>Selecione o m\u00e9todo sudoAs</li> <li>Selecione ou cole a conta desejada para personificar</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, \u00e9 a paleta balances (saldos)</li> <li>Selecione o m\u00e9todo transferAllowDeath</li> <li>Especifique a conta de destino para a transfer\u00eancia de saldo</li> <li>Especifique o n\u00famero de tokens a enviar</li> <li>Pressione SubmitSudo e confirme o pop-up resultante</li> </ol> <p></p> <p>A outra conta tinha um saldo inicial de <code>1.000</code> tokens antes da chamada e, subsequentemente, caiu para <code>995</code>, como esperado.</p> <p></p>"},{"location":"pt/builders/manage/developer-portal/impersonate/#using-sudo-and-the-dispatch-as-utility","title":"Usando Sudo e a Utilidade Dispatch As","text":"<p>A sec\u00e7\u00e3o a seguir demonstrar\u00e1 o uso do Sudo para despachar chamadas de uma origem arbitr\u00e1ria. Ao enviar uma chamada desta forma, o tempo de execu\u00e7\u00e3o primeiro autenticar\u00e1 a chave Sudo e, em seguida, despachar\u00e1 a chamada usando a paleta <code>utility</code> e a fun\u00e7\u00e3o <code>dispatchAs</code>, permitindo que a origem da transa\u00e7\u00e3o seja exatamente o que deseja.</p> <p>Para fazer isso, navegue para o separador Developer (Desenvolvedor) dos Polkadot.js Apps para a sua rede com tecnologia Tanssi e clique em Sudo. Se n\u00e3o vir Sudo neste menu, n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua conta Sudo est\u00e1 injetada pela sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga os seguintes passos:</p> <ol> <li>Selecione a paleta Sudo</li> <li>Selecione o m\u00e9todo Sudo</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, \u00e9 a paleta utility (utilidade)</li> <li>Selecione o m\u00e9todo dispatchAs</li> <li>Selecione system (sistema) no menu pendente</li> <li>Selecione a origem signed (assinada), que define a origem da transa\u00e7\u00e3o para ser a conta especificada em vez de root (raiz)</li> <li>Selecione a paleta desejada para a chamada a enviar. Neste caso, \u00e9 a paleta balances (saldos)</li> <li>Selecione o m\u00e9todo transferAllowDeath</li> <li>Especifique a conta de destino para a transfer\u00eancia de saldo</li> <li>Especifique o n\u00famero de tokens a enviar</li> <li>Pressione SubmitSudo e confirme o pop-up resultante </li> </ol> <p>A outra conta tinha um saldo inicial de <code>995</code> tokens antes da chamada e caiu para <code>990</code>, como esperado.</p> <p></p> <p>E \u00e9 isso! A sec\u00e7\u00e3o Developer Portal tem muitos mais guias sobre como gerir a sua rede Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/manage/developer-portal/maintenance/","title":"Habilitando o Modo de Manuten\u00e7\u00e3o","text":""},{"location":"pt/builders/manage/developer-portal/maintenance/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A paleta de Manuten\u00e7\u00e3o \u00e9 um m\u00f3dulo projetado para uso apenas em emerg\u00eancias que representam amea\u00e7as existenciais \u00e0 rede. Habilitar o modo de manuten\u00e7\u00e3o em sua rede suspender\u00e1 o processamento de todas as transa\u00e7\u00f5es regulares, incluindo intera\u00e7\u00f5es com a EVM. A produ\u00e7\u00e3o de blocos continua em uma cad\u00eancia regular e permite que as fun\u00e7\u00f5es de governan\u00e7a e staking continuem.</p> <p>O modo de manuten\u00e7\u00e3o filtra (ignora) todas as chamadas fora da governan\u00e7a e staking. Uma vez que o modo de manuten\u00e7\u00e3o \u00e9 encerrado, sua cadeia processar\u00e1 quaisquer transa\u00e7\u00f5es pendentes que foram enfileiradas enquanto sua cadeia estava no modo de manuten\u00e7\u00e3o. O modo de manuten\u00e7\u00e3o destina-se a ser usado apenas como uma medida tempor\u00e1ria de emerg\u00eancia.</p> <p>Por exemplo, imagine descobrir uma explora\u00e7\u00e3o cr\u00edtica em sua rede que poderia resultar em perdas financeiras significativas se atores mal-intencionados a explorassem. Embora voc\u00ea possa resolver o problema implementando uma atualiza\u00e7\u00e3o de tempo de execu\u00e7\u00e3o, o processo leva tempo - tempo precioso durante o qual sua rede permanece vulner\u00e1vel a ataques. Uma solu\u00e7\u00e3o potencial \u00e9 ativar o modo de manuten\u00e7\u00e3o em sua rede, concluir a atualiza\u00e7\u00e3o do tempo de execu\u00e7\u00e3o e sair do modo de manuten\u00e7\u00e3o assim que a corre\u00e7\u00e3o for verificada.</p> <p>Aten\u00e7\u00e3o</p> <p>Habilitar o modo de manuten\u00e7\u00e3o em uma rede de produ\u00e7\u00e3o pode impactar significativamente os contratos em sua cadeia. Enquanto o modo de manuten\u00e7\u00e3o estiver ativado, nenhuma transa\u00e7\u00e3o de contrato inteligente \u00e9 processada, por isso \u00e9 fundamental considerar as poss\u00edveis ramifica\u00e7\u00f5es antes de ativ\u00e1-lo.</p>"},{"location":"pt/builders/manage/developer-portal/maintenance/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Teste R\u00e1pido ou Dedicado)</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Voc\u00ea pode consultar o guia de Gerenciamento do Sudo para obter instru\u00e7\u00f5es sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/maintenance/#enabling-maintenance-mode","title":"Habilitando o Modo de Manuten\u00e7\u00e3o","text":"<p>Ainda, a conta Sudo pode realizar fun\u00e7\u00f5es privilegiadas, como habilitar e desabilitar o modo de manuten\u00e7\u00e3o. Para entrar no modo de manuten\u00e7\u00e3o e interromper o processamento regular de transa\u00e7\u00f5es, navegue at\u00e9 a guia Developer do Polkadot.js Apps para sua rede com tecnologia Tanssi e clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, voc\u00ea n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps. Ent\u00e3o, siga os seguintes passos:</p> <ol> <li>Selecione a paleta maintenanceMode</li> <li>Selecione o m\u00e9todo enterMaintenanceMode</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o no pop-up resultante</li> </ol> <p></p> <p>Para verificar se o modo de manuten\u00e7\u00e3o foi habilitado, voc\u00ea pode verificar a se\u00e7\u00e3o Explorer na guia Rede e revisar os eventos recentes.</p> <p></p>"},{"location":"pt/builders/manage/developer-portal/maintenance/#exiting-maintenance-mode","title":"Sa\u00edda do Modo de Manuten\u00e7\u00e3o","text":"<p>Para sair do modo de manuten\u00e7\u00e3o e retornar sua rede \u00e0 opera\u00e7\u00e3o normal, navegue at\u00e9 a guia Developer do Polkadot.js Apps para sua rede com tecnologia Tanssi e clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, voc\u00ea n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps. Siga os seguintes passos:</p> <ol> <li>Selecione a paleta maintenanceMode</li> <li>Selecione o m\u00e9todo resumeNormalOperation</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o no pop-up resultante </li> </ol> <p>Para verificar se o modo de manuten\u00e7\u00e3o foi desabilitado, voc\u00ea pode verificar na se\u00e7\u00e3o Explorer na guia Network e revisar os eventos recentes.</p> <p></p> <p>Lembre-se que o uso do modo de manuten\u00e7\u00e3o \u00e9 uma a\u00e7\u00e3o de emerg\u00eancia que s\u00f3 deve ser ativada quando sua cadeia estiver em risco extremo. Pode valer a pena estabelecer uma pol\u00edtica para sua rede que defina gatilhos espec\u00edficos de disjuntor para determinar quando o modo de manuten\u00e7\u00e3o ser\u00e1 habilitado. O estabelecimento de uma pol\u00edtica com anteced\u00eancia tamb\u00e9m simplificar\u00e1 a tomada de decis\u00f5es durante uma potencial emerg\u00eancia.</p> <p>E \u00e9 isso! A se\u00e7\u00e3o Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede com tecnologia Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/manage/developer-portal/minting/","title":"Usando Sudo para Cunhar Tokens Nativos","text":""},{"location":"pt/builders/manage/developer-portal/minting/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Sudo \u00e9 um m\u00f3dulo que permite que chamadas de tempo de execu\u00e7\u00e3o privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo \u00e9, por vezes, referido coloquialmente como um superusu\u00e1rio ou uma conta semelhante a um deus. Isso permite que voc\u00ea realize a\u00e7\u00f5es privilegiadas no curso do gerenciamento de sua rede, como cunhar novos tokens nativos.</p> <p>Neste guia, voc\u00ea aprender\u00e1 como usar Sudo para cunhar corretamente novos tokens nativos. Este guia abrangente mostra como verificar o saldo de uma conta existente antes de atribuir a ela um novo saldo com acesso Sudo.</p>"},{"location":"pt/builders/manage/developer-portal/minting/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 do seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps. Voc\u00ea pode consultar o guia de gerenciamento do Sudo para obter instru\u00e7\u00f5es sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/minting/#minting-tokens","title":"Cunhagem de Tokens","text":"<p>Como voc\u00ea sabe, a conta Sudo tem a capacidade de realizar fun\u00e7\u00f5es privilegiadas, incluindo a cunhagem de tokens adicionais. Ao configurar sua rede no Tanssi dApp, voc\u00ea pode especificar os saldos da conta genesis. Em outras palavras, voc\u00ea tem a capacidade de dotar as contas com saldos iniciais ao iniciar sua rede Tanssi. No entanto, voc\u00ea tamb\u00e9m pode cunhar novos tokens ap\u00f3s o lan\u00e7amento com a ajuda da conta Sudo.</p> <p>Nota</p> <p>Este tutorial demonstra a atribui\u00e7\u00e3o de saldos de tokens arbitr\u00e1rios em uma rede TestNet que n\u00e3o tem valor. Voc\u00ea deve considerar cuidadosamente as ramifica\u00e7\u00f5es de criar tokens adicionais em sua pr\u00f3pria rede com tecnologia Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/minting/#checking-existing-account-balance","title":"Verificando o Saldo da Conta Existente","text":"<p>A pr\u00f3xima se\u00e7\u00e3o demonstrar\u00e1 como atribuir saldos de tokens arbitr\u00e1rios a contas usando a conta Sudo. Este processo substituir\u00e1 o saldo existente da conta especificada, portanto, verificar se a conta est\u00e1 vazia \u00e9 uma boa pr\u00e1tica antes de continuar. Para verificar o saldo de uma conta, siga estas etapas:</p> <ol> <li>Navegue at\u00e9 a guia Desenvolvedor do Polkadot.js Apps e clique em Chain State (Estado da Cadeia)</li> <li>Selecione o pallet system para consultar</li> <li>Selecione account (conta)</li> <li>Cole o endere\u00e7o da conta ou selecione-o no menu suspenso</li> <li>Pressione o \u00edcone +</li> <li>Voc\u00ea ver\u00e1 as informa\u00e7\u00f5es do saldo retornadas na parte inferior, incluindo saldos livres, reservados e congelados </li> </ol>"},{"location":"pt/builders/manage/developer-portal/minting/#assigning-balances-with-sudo","title":"Atribuindo Saldos com Sudo","text":"<p>Para atribuir um saldo de conta a uma conta, certifique-se de ter sua conta Sudo acess\u00edvel no Polkadot.js Apps. Em seguida, siga estas etapas:</p> <ol> <li>Navegue at\u00e9 a guia Developer dos Polkadot.js Apps para sua rede Tanssi</li> <li>Clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, voc\u00ea n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps</li> <li>Selecione o pallet balances</li> <li>Selecione o m\u00e9todo forceSetBalance</li> <li>Cole o endere\u00e7o da conta para dotar com tokens ou selecione-o no menu suspenso</li> <li>Insira a quantidade de tokens para dotar a conta. Neste exemplo, especificamos <code>9000000000000000000</code> para nove tokens nativos. Lembre-se que as redes EVM com tecnologia Tanssi t\u00eam 18 decimais, enquanto as redes Substrate ou personalizadas configuram os decimais ao lan\u00e7ar a cadeia. Se voc\u00ea n\u00e3o tiver certeza de quantos decimais sua rede tem, navegue at\u00e9 a guia Settings e clique em Metadata</li> <li>Pressione Submit Sudo (Enviar Sudo) e confirme a transa\u00e7\u00e3o em sua carteira</li> </ol> <p></p> <p>E \u00e9 isso! A se\u00e7\u00e3o Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/manage/developer-portal/pause-transactions/","title":"Pausando Transa\u00e7\u00f5es","text":""},{"location":"pt/builders/manage/developer-portal/pause-transactions/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O m\u00f3dulo de Pausa de Transa\u00e7\u00e3o \u00e9 um dos m\u00f3dulos embutidos inclu\u00eddos no Polkadot SDK, e est\u00e1 dispon\u00edvel em qualquer rede alimentada por Tanssi baseada nos modelos oficiais vers\u00e3o 400 ou superior.</p> <p>Este m\u00f3dulo permite que um governador de rede evite temporariamente a execu\u00e7\u00e3o de um conjunto de transa\u00e7\u00f5es selecionadas, enquanto o restante das transa\u00e7\u00f5es continua normalmente. Esse recurso \u00e9 \u00fatil em v\u00e1rios cen\u00e1rios, como desabilitar uma funcionalidade em que uma amea\u00e7a \u00e0 seguran\u00e7a foi descoberta, habilitar uma funcionalidade sazonal somente quando necess\u00e1rio e habilitar um conjunto de transa\u00e7\u00f5es exatamente na data de lan\u00e7amento.</p> <p>Em um cen\u00e1rio de emerg\u00eancia, quando um exploit cr\u00edtico \u00e9 descoberto, este m\u00f3dulo permite que a rede isole e pare apenas a funcionalidade afetada, minimizando efetivamente o impacto geral.</p> <p>Aten\u00e7\u00e3o</p> <p>No momento em que este artigo foi escrito, este m\u00f3dulo ainda n\u00e3o foi auditado; portanto, n\u00e3o \u00e9 recomendado para uso em produ\u00e7\u00e3o.</p>"},{"location":"pt/builders/manage/developer-portal/pause-transactions/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede alimentada por Tanssi (Quick Trial ou Dedicada) com o m\u00f3dulo Pausa de Transa\u00e7\u00e3o. Qualquer nova implanta\u00e7\u00e3o de rede baseada em um dos modelos servir\u00e1; caso contr\u00e1rio, certifique-se de incluir o m\u00f3dulo em seu runtime de rede personalizado</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Voc\u00ea pode consultar o guia Managing Sudo para obter instru\u00e7\u00f5es sobre como injetar sua conta Sudo no Polkadot.js Apps</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/pause-transactions/#modules-transaction-names","title":"Nomes de M\u00f3dulo e Transa\u00e7\u00e3o","text":"<p>O m\u00f3dulo Pausa de Transa\u00e7\u00e3o funciona filtrando a execu\u00e7\u00e3o de transa\u00e7\u00f5es espec\u00edficas contidas nos m\u00f3dulos inclu\u00eddos no tempo de execu\u00e7\u00e3o da rede. Para fazer isso, ele mant\u00e9m uma lista interna das transa\u00e7\u00f5es banidas, identificadas por nome de m\u00f3dulo e transa\u00e7\u00e3o. Esta lista diferencia mai\u00fasculas de min\u00fasculas e s\u00f3 funciona quando h\u00e1 uma correspond\u00eancia exata entre um item na lista de transa\u00e7\u00f5es pausadas e a transa\u00e7\u00e3o que est\u00e1 sendo processada. Portanto, o uso dos nomes exatos dos m\u00f3dulos e das transa\u00e7\u00f5es \u00e9 crucial.</p> <p>Para descobrir os nomes dos m\u00f3dulos dispon\u00edveis em seu tempo de execu\u00e7\u00e3o, voc\u00ea precisa ler a se\u00e7\u00e3o <code>construct_runtime!()</code> no arquivo <code>lib.rs</code> do seu tempo de execu\u00e7\u00e3o de rede no reposit\u00f3rio do seu projeto. Se sua rede for baseada em um dos modelos oficiais, voc\u00ea encontrar\u00e1 o arquivo no reposit\u00f3rio Tanssi:</p> <ul> <li>Para redes baseadas no modelo EVM: o arquivo lib.rs</li> <li>Para redes baseadas no modelo Substrate: o arquivo lib.rs</li> </ul> <p>O snippet a seguir \u00e9 um exemplo de como a se\u00e7\u00e3o <code>construct_runtime!()</code> se parece. Os nomes dos m\u00f3dulos s\u00e3o os localizados \u00e0 esquerda dos dois pontos.</p> <pre><code>    pub enum Runtime\n    {\n        ...\n        Migrations: pallet_migrations = 7,\n        MaintenanceMode: pallet_maintenance_mode = 8,\n        TxPause: pallet_tx_pause = 9,\n        Balances: pallet_balances = 10,\n        Multisig: pallet_multisig = 16,      \n        ...\n   }\n</code></pre> <p>Para identificar os nomes das transa\u00e7\u00f5es inclu\u00eddas em um m\u00f3dulo, voc\u00ea precisa consultar seu c\u00f3digo-fonte. Os m\u00f3dulos integrados no Substrate identificam suas transa\u00e7\u00f5es usando uma macro <code>#[pallet::call_index(INDEX)]</code>, onde <code>INDEX</code> \u00e9 um n\u00famero. No caso de um m\u00f3dulo embutido, o c\u00f3digo est\u00e1 localizado na pasta FRAME do reposit\u00f3rio Polkadot-SDK. Por exemplo, se voc\u00ea quiser saber sobre os nomes das transa\u00e7\u00f5es no m\u00f3dulo <code>Balances</code>, consulte seu arquivo lib.rs e procure os nomes das fun\u00e7\u00f5es abaixo das macros <code>#[pallet::call_index(INDEX)]</code>. O snippet a seguir \u00e9 a transa\u00e7\u00e3o <code>transfer_allow_death</code> do m\u00f3dulo <code>Balances</code>, que \u00e9 o usado como exemplo neste guia:</p> <pre><code>pub fn transfer_allow_death(\n    origin: OriginFor&lt;T&gt;,\n    dest: AccountIdLookupOf&lt;T&gt;,\n    #[pallet::compact] value: T::Balance,\n) -&gt; DispatchResult {\n    // Code\n    Ok(())\n}\n</code></pre>"},{"location":"pt/builders/manage/developer-portal/pause-transactions/#frequently-used-modules-transactions","title":"Alguns M\u00f3dulos e Transa\u00e7\u00f5es Usados com Frequ\u00eancia","text":"<p>Ao usar qualquer um dos m\u00f3dulos Substrate embutidos, o nome com o qual ele \u00e9 referenciado no tempo de execu\u00e7\u00e3o \u00e9 totalmente de responsabilidade do desenvolvedor, mas os nomes das transa\u00e7\u00f5es n\u00e3o s\u00e3o personaliz\u00e1veis. Aqui est\u00e1 uma lista de alguns dos m\u00f3dulos mais comumente usados com as transa\u00e7\u00f5es mais comumente usadas que eles cont\u00eam. Esses s\u00e3o os nomes das transa\u00e7\u00f5es a serem usados neste m\u00f3dulo Pausa de Transa\u00e7\u00e3o.</p> pallet-ethereum \u2014 Este m\u00f3dulo, junto com o m\u00f3dulo EVM, fornece compatibilidade total com o Ethereum para a rede <pre><code>| Nome da Transa\u00e7\u00e3o |        Descri\u00e7\u00e3o        |\n|:----------------:|:-------------------------:|\n|    `transact`    | Executa uma chamada Ethereum |\n</code></pre> pallet_balances \u2014 Este m\u00f3dulo fornece funcionalidade para lidar com contas e saldos para a moeda nativa da rede <pre><code>|    Nome da Transa\u00e7\u00e3o    |                                                                 Descri\u00e7\u00e3o                                                                  |\n|:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|\n| `transfer_allow_death` |      Executa uma transfer\u00eancia de saldo, excluindo a conta do remetente quando seu saldo final fica abaixo do requisito m\u00ednimo de exist\u00eancia      |\n| `transfer_keep_alive`  | Executa uma transfer\u00eancia de saldo, mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito m\u00ednimo de exist\u00eancia |\n|     `transfer_all`     |                                              Transfere todos os saldos n\u00e3o bloqueados para um destino                                               |\n|         `burn`         |                                     Queima o saldo da conta de origem, reduzindo a emiss\u00e3o total                                     |\n</code></pre> pallet_assets \u2014 Este m\u00f3dulo fornece funcionalidade para lidar com tokens fung\u00edveis <pre><code>|   Nome da Transa\u00e7\u00e3o    |                                                                Descri\u00e7\u00e3o                                                                 |\n|:---------------------:|:------------------------------------------------------------------------------------------------------------------------------------------:|\n|       `create`        |                                                   Emite uma nova classe de ativos fung\u00edveis                                                    |\n|    `start_destroy`    |                                          Inicia o processo de destrui\u00e7\u00e3o de uma classe de ativos fung\u00edveis                                           |\n|  `destroy_accounts`   |                       Destr\u00f3i todas as contas associadas a um determinado ativo para as quais o processo de destrui\u00e7\u00e3o foi iniciado                        |\n|  `destroy_approvals`  |                       Destr\u00f3i todas as aprova\u00e7\u00f5es associadas a um determinado ativo para o qual o processo de destrui\u00e7\u00e3o foi iniciado                       |\n|   `finish_destroy`    |                          Conclui o processo de destrui\u00e7\u00e3o de um determinado ativo para o qual o processo de destrui\u00e7\u00e3o foi iniciado                          |\n|        `mint`         |                                                                Cria ativos                                                                |\n|        `burn`         |                                                                Queima ativos                                                                |\n|      `transfer`       |      Executa uma transfer\u00eancia de ativos excluindo a conta do remetente quando seu saldo final fica abaixo do requisito m\u00ednimo de exist\u00eancia      |\n| `transfer_keep_alive` | Executa uma transfer\u00eancia de ativos mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito m\u00ednimo de exist\u00eancia |\n|       `freeze`        |                                          N\u00e3o permite transfer\u00eancias de um ativo de uma conta espec\u00edfica                                           |\n|        `thaw`         |                                         Permite novamente transfer\u00eancias de um ativo de uma conta espec\u00edfica                                         |\n|    `freeze_asset`     |                                                      N\u00e3o permite transfer\u00eancias de um ativo                                                       |\n|     `thaw_asset`      |                                                     Permite novamente transfer\u00eancias de um ativo                                                     |\n|    `set_metadata`     |                                                       Define os metadados para um ativo                                                       |\n|   `clear_metadata`    |                                                      Limpa os metadados para um ativo                                                      |\n</code></pre> pallet_nfts \u2014 Este m\u00f3dulo fornece fun\u00e7\u00f5es para lidar com tokens n\u00e3o fung\u00edveis <pre><code>|      Nome da Transa\u00e7\u00e3o       |                        Descri\u00e7\u00e3o                         |\n|:---------------------------:|:----------------------------------------------------------:|\n|          `create`           |       Emite uma nova cole\u00e7\u00e3o de itens n\u00e3o fung\u00edveis        |\n|          `destroy`          |        Destr\u00f3i uma cole\u00e7\u00e3o de itens n\u00e3o fung\u00edveis         |\n|           `mint`            |            Cria um item em uma cole\u00e7\u00e3o NFT              |\n|           `burn`            |          Destr\u00f3i um item de uma cole\u00e7\u00e3o NFT           |\n|         `transfer`          |                      Transfere um NFT                      |\n|    `lock_item_transfer`     |              N\u00e3o permite a transfer\u00eancia de um item              |\n|   `unlock_item_transfer`    |         Permite novamente a transfer\u00eancia de um item bloqueado         |\n|       `set_attribute`       |     Define um atributo para uma cole\u00e7\u00e3o NFT ou um item     |\n|      `clear_attribute`      |    Limpa um atributo para uma cole\u00e7\u00e3o NFT ou um item    |\n|       `set_metadata`        |               Define os metadados para um item                |\n|      `clear_metadata`       |              Limpa os metadados para um item               |\n|  `set_collection_metadata`  |  Define os metadados para uma cole\u00e7\u00e3o de itens n\u00e3o fung\u00edveis  |\n| `clear_collection_metadata` | Limpa os metadados para uma cole\u00e7\u00e3o de itens n\u00e3o fung\u00edveis |\n|         `set_price`         |                 Define o pre\u00e7o de um item                 |\n|         `buy_item`          |        Compre um item, desde que esteja \u00e0 venda         |\n</code></pre> pallet_multisig \u2014 Este m\u00f3dulo fornece fun\u00e7\u00f5es para lidar com esquemas de m\u00faltiplas assinaturas <pre><code>|    Nome da Transa\u00e7\u00e3o    |                                                                 Descri\u00e7\u00e3o                                                                  |\n|:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|\n| `as_multi_threshold_1` |                                           Registra uma chamada de m\u00faltiplas assinaturas com uma \u00fanica aprova\u00e7\u00e3o                                            |\n|       `as_multi`       | Registra uma chamada de m\u00faltiplas assinaturas a ser feita de uma conta composta, se aprovada pelo limite m\u00ednimo especificado dos outros signat\u00e1rios |\n|   `approve_as_multi`   |              Registra a aprova\u00e7\u00e3o de uma chamada de m\u00faltiplas assinaturas e despacha a chamada quando o limite de signat\u00e1rios \u00e9 atingido              |\n|   `cancel_as_multi`    |                                         Cancela uma transa\u00e7\u00e3o de m\u00faltiplas assinaturas pr\u00e9-existente e em andamento                                          |\n</code></pre>"},{"location":"pt/builders/manage/developer-portal/pause-transactions/#pausing-transactions","title":"Pausando Transa\u00e7\u00f5es","text":"<p>Como voc\u00ea sabe, a conta Sudo pode executar a\u00e7\u00f5es privilegiadas, como atualiza\u00e7\u00f5es de rede, cria\u00e7\u00e3o de novos tokens e, neste caso, pausar e despausar transa\u00e7\u00f5es.</p> <p>Para pausar uma transa\u00e7\u00e3o, navegue at\u00e9 a guia Desenvolvedor do Polkadot.js Apps para sua rede alimentada por Tanssi e clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione o m\u00f3dulo txPause</li> <li>Selecione o m\u00e9todo pause</li> <li>Insira o nome do m\u00f3dulo que cont\u00e9m a transa\u00e7\u00e3o que ser\u00e1 pausada</li> <li>Insira o nome da transa\u00e7\u00e3o que ser\u00e1 pausada</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o no pop-up resultante</li> </ol> <p>Neste exemplo, a transa\u00e7\u00e3o pausada \u00e9 <code>transfer_allow_death</code> do m\u00f3dulo <code>Balances</code>:</p> <p></p> <p>Para verificar se a transa\u00e7\u00e3o foi efetivamente pausada, tente execut\u00e1-la. Voc\u00ea deve obter um erro.</p> <p></p> <p>Aten\u00e7\u00e3o</p> <p>A transa\u00e7\u00e3o <code>pause</code> n\u00e3o verifica os nomes dos m\u00f3dulos ou transa\u00e7\u00f5es e diferencia mai\u00fasculas de min\u00fasculas, portanto, qualquer erro de digita\u00e7\u00e3o passar\u00e1 despercebido e a transa\u00e7\u00e3o ser\u00e1 executada com sucesso. Voc\u00ea sempre deve verificar se a transa\u00e7\u00e3o foi efetivamente pausada.</p>"},{"location":"pt/builders/manage/developer-portal/pause-transactions/#unpausing-transactions","title":"Despausando Transa\u00e7\u00f5es","text":"<p>Para despausar uma transa\u00e7\u00e3o e retorn\u00e1-la \u00e0 opera\u00e7\u00e3o normal, navegue at\u00e9 a guia Desenvolvedor do Polkadot.js Apps para sua rede alimentada por Tanssi e clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, voc\u00ea n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione o m\u00f3dulo txPause</li> <li>Selecione o m\u00e9todo unpause</li> <li>Insira o nome do m\u00f3dulo que cont\u00e9m a transa\u00e7\u00e3o que ser\u00e1 despausada</li> <li>Insira o nome da transa\u00e7\u00e3o que ser\u00e1 despausada</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o no pop-up resultante</li> </ol> <p>Neste exemplo, a transa\u00e7\u00e3o a ser despausada \u00e9 <code>transfer_allow_death</code> do m\u00f3dulo <code>Balances</code>:</p> <p></p> <p>A transa\u00e7\u00e3o <code>unpause</code> \u00e9 executada com sucesso somente se os par\u00e2metros do m\u00f3dulo e da transa\u00e7\u00e3o tiverem sido pausados \u200b\u200banteriormente; caso contr\u00e1rio, ela falha. Ap\u00f3s o despausamento bem-sucedido, a transa\u00e7\u00e3o pode ser chamada e executada novamente.</p> <p>E \u00e9 isso! A se\u00e7\u00e3o Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/","title":"Smart EVM - Implanta\u00e7\u00f5es de Contratos Whitelistados","text":""},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Redes com tecnologia Tanssi compat\u00edveis com EVM se beneficiam de um recurso exclusivo: o governador da rede pode definir quais contas est\u00e3o autorizadas a implantar contratos inteligentes, proibindo a a\u00e7\u00e3o para qualquer outra conta n\u00e3o whitelistada.</p> <p>Este recurso traz v\u00e1rios benef\u00edcios importantes que podem ser uma \u00f3tima op\u00e7\u00e3o para diferentes casos de uso ou contextos. Alguns desses benef\u00edcios s\u00e3o:</p> <ul> <li>Seguran\u00e7a aprimorada - ao restringir a implanta\u00e7\u00e3o a contas confi\u00e1veis, o risco de implantar contratos inteligentes maliciosos ou vulner\u00e1veis \u00e9 reduzido</li> <li>Garantia de qualidade - contas conhecidas e verificadas podem ser obrigadas a seguir padr\u00f5es de codifica\u00e7\u00e3o espec\u00edficos e passar por testes completos antes da implanta\u00e7\u00e3o</li> <li>Conformidade regulat\u00f3ria - os casos de uso que s\u00e3o altamente regulamentados podem limitar a implanta\u00e7\u00e3o para garantir que os contratos inteligentes atendam aos requisitos legais e de conformidade</li> <li>Preven\u00e7\u00e3o de spam e abuso - impedir que maus atores implantem um grande n\u00famero de contratos desnecess\u00e1rios ou prejudiciais</li> </ul> <p>Neste guia, voc\u00ea aprender\u00e1 como usar a conta Sudo para gerenciar as contas whitelistadas que podem implantar contratos inteligentes em sua rede.</p>"},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi compat\u00edvel com EVM (Teste R\u00e1pido ou Dedicado) executando o runtime 700 ou superior. Qualquer nova implanta\u00e7\u00e3o de rede baseada no modelo EVM servir\u00e1</li> <li>A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. Voc\u00ea pode consultar o Guia de Gerenciamento de Sudo para obter instru\u00e7\u00f5es sobre como injetar sua conta Sudo nos Polkadot.js Apps</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#getting-started","title":"Come\u00e7ando","text":"<p>Para seguir as pr\u00f3ximas se\u00e7\u00f5es deste guia, acesse os Polkadot.js Apps para sua rede Tanssi. O link para os Polkadot.js Apps para sua rede Tanssi pode ser encontrado em seu Painel Tanssi na se\u00e7\u00e3o Tooling.</p> <p></p> <p>Depois de acessar os Polkadot.js Apps, navegue at\u00e9 a guia Developer e clique em Sudo.</p> <p>Nota</p> <p>Se voc\u00ea n\u00e3o vir Sudo neste menu, n\u00e3o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps.</p>"},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#whitelist-accounts","title":"Contas Whitelistadas","text":"<p>Para definir as contas que ter\u00e3o autoriza\u00e7\u00e3o para implantar contratos inteligentes, comece a usar seus Polkadot.js Apps e siga as etapas a seguir:</p> <ol> <li>Selecione a paleta parameters. setParameter ser\u00e1 selecionado automaticamente no seletor de fun\u00e7\u00f5es e ContractDeployFilter no par\u00e2metro keyValue</li> <li>Duas op\u00e7\u00f5es estar\u00e3o dispon\u00edveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a op\u00e7\u00e3o AllowedAddressesToCreate se quiser whitelistar as contas para implanta\u00e7\u00f5es de contratos inteligentes e a \u00faltima para whitelistar as contas para implanta\u00e7\u00f5es indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Alterne a chave Include option</li> <li>Selecione a op\u00e7\u00e3o Whitelisted</li> <li>Insira a conta whitelistada</li> <li>Se voc\u00ea precisar inserir mais de uma conta, clique em Add item</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o em sua carteira</li> </ol> <p></p> <p>Essas mesmas etapas podem ser repetidas a qualquer momento para remover uma conta da whitelist ou para adicionar novas.</p>"},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#restoring-permission","title":"Restaurando Permiss\u00f5es para Implantar Contratos Inteligentes","text":"<p>Se voc\u00ea autorizou anteriormente algumas contas a implantar contratos inteligentes e deseja permitir que qualquer conta implante contratos inteligentes (desde que possam cobrir taxas de transa\u00e7\u00e3o regulares), comece a usar seus Polkadot.js Apps e siga as etapas a seguir:</p> <ol> <li>Selecione a paleta parameters. setParameter ser\u00e1 selecionado automaticamente no seletor de fun\u00e7\u00f5es e ContractDeployFilter no par\u00e2metro keyValue</li> <li>Duas op\u00e7\u00f5es estar\u00e3o dispon\u00edveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a op\u00e7\u00e3o AllowedAddressesToCreate se quiser limpar a whitelist para implanta\u00e7\u00f5es de contratos inteligentes e a \u00faltima para limpar a whitelist para implanta\u00e7\u00f5es indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Alterne a chave Include option</li> <li>Selecione a op\u00e7\u00e3o All</li> <li>Pressione Submit Sudo e confirme a transa\u00e7\u00e3o em sua carteira</li> </ol> <p></p>"},{"location":"pt/builders/manage/developer-portal/smart-contracts-creation-filter/#query-whitelisted-accounts","title":"Consultando as Contas Whitelistadas","text":"<p>Para obter a configura\u00e7\u00e3o atual contendo as contas whitelistadas que podem implantar contratos inteligentes, acesse os Polkadot.js Apps (conforme explicado na se\u00e7\u00e3o Come\u00e7ando), navegue at\u00e9 a guia Developer, clique em Chain state e siga as etapas a seguir:</p> <ol> <li>Selecione o armazenamento parameters</li> <li>Selecione a op\u00e7\u00e3o parameters(ContainerChainTemplateFrontierRuntimeParametersKey)</li> <li>Certifique-se de que a chave Include option est\u00e1 ligada</li> <li>Certifique-se de que a op\u00e7\u00e3o ContractDeployFilter est\u00e1 selecionada</li> <li>Duas op\u00e7\u00f5es estar\u00e3o dispon\u00edveis no seletor ContractDeployFilter: AllowedAddressesToCreate e AllowedAddressesToCreateInner. Selecione a op\u00e7\u00e3o AllowedAddressesToCreate se quiser consultar a whitelist para implanta\u00e7\u00f5es de contratos inteligentes e a \u00faltima para consultar a whitelist para implanta\u00e7\u00f5es indiretas (por meio de uma chamada de contrato inteligente)</li> <li>Clique no bot\u00e3o +</li> <li>A configura\u00e7\u00e3o atual ser\u00e1 exibida</li> </ol> <p></p>"},{"location":"pt/builders/manage/developer-portal/sudo/","title":"Gerenciando a Conta Sudo da Sua Rede","text":""},{"location":"pt/builders/manage/developer-portal/sudo/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Sudo \u00e9 um m\u00f3dulo que permite que chamadas de tempo de execu\u00e7\u00e3o privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo \u00e9, por vezes, coloquialmente referido como um superusu\u00e1rio ou uma conta semelhante a um deus. S\u00f3 pode haver uma \u00fanica conta Sudo de cada vez. No entanto, as chaves Sudo podem ser rodadas para dar privil\u00e9gios Sudo a uma nova conta.</p> <p>Todas as redes com tecnologia Tanssi v\u00eam com a paleta Sudo por padr\u00e3o, e voc\u00ea \u00e9 obrigado a designar uma conta como o endere\u00e7o Sudo ao lan\u00e7ar sua rede. Isso permite que voc\u00ea execute a\u00e7\u00f5es privilegiadas para gerenciar sua cadeia, como atualizar seu tempo de execu\u00e7\u00e3o ou cunhar novos tokens nativos. Embora a paleta Sudo seja necess\u00e1ria para lan\u00e7ar sua rede Tanssi no TestNet, voc\u00ea pode desativar a paleta Sudo e fazer a transi\u00e7\u00e3o para a governan\u00e7a descentralizada ap\u00f3s o lan\u00e7amento do MainNet.</p> <p>No guia a seguir, voc\u00ea aprender\u00e1 como visualizar a conta Sudo atual da sua rede e como alter\u00e1-la, al\u00e9m de import\u00e1-la para o Polkadot.js Apps. Existem guias semelhantes nesta se\u00e7\u00e3o explicando como usar a conta Sudo para realizar a\u00e7\u00f5es privilegiadas, como atualizar seu tempo de execu\u00e7\u00e3o e cunhar tokens nativos.</p>"},{"location":"pt/builders/manage/developer-portal/sudo/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma rede com tecnologia Tanssi (Quick Trial ou Dedicated)</li> <li>A conta Sudo da sua rede conectada ao Polkadot.js Apps da sua rede</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps","title":"Configurando o Polkadot.js Apps","text":"<p>Depois de navegar para o Polkadot.js Apps da sua rede, voc\u00ea precisar\u00e1 adicionar sua conta Sudo. Injetar sua conta Sudo no Polkadot.js Apps a partir de uma extens\u00e3o do navegador \u00e9 considerado mais seguro do que armazenar contas diretamente no navegador. No entanto, voc\u00ea ainda pode importar sua conta Sudo diretamente para o cache do navegador. Esse m\u00e9todo n\u00e3o requer o uso de nenhuma extens\u00e3o. Para importar uma conta para o Polkadot.js dessa maneira, siga as etapas:</p> <ol> <li>Clique em Configura\u00e7\u00f5es</li> <li>Em cria\u00e7\u00e3o de conta no navegador, selecione Permitir a cria\u00e7\u00e3o de conta local no navegador</li> <li>Pressione Salvar</li> </ol> <p></p> <p>Em seguida, volte para a guia contas e pressione Conta. Voc\u00ea poder\u00e1 substituir a chave privada pr\u00e9-gerada pela da sua conta Sudo.</p> <p></p> <p>Aten\u00e7\u00e3o</p> <p>O armazenamento de chaves no navegador n\u00e3o \u00e9 adequado para ambientes de produ\u00e7\u00e3o. Este exemplo \u00e9 fornecido apenas para fins de demonstra\u00e7\u00e3o em um ambiente TestNet.</p>"},{"location":"pt/builders/manage/developer-portal/sudo/#changing-the-sudo-account","title":"Alterando a Conta Sudo","text":"<p>A altera\u00e7\u00e3o da conta Sudo da sua rede com tecnologia Tanssi \u00e9 um processo simples. Tamb\u00e9m conhecido como rota\u00e7\u00e3o de suas chaves Sudo, esse processo remover\u00e1 o acesso Sudo da conta Sudo existente e conceder\u00e1 \u00e0 nova conta. S\u00f3 pode haver uma conta Sudo a qualquer momento. No entanto, voc\u00ea \u00e9 livre para alterar a conta Sudo quantas vezes quiser.</p> <p>Antes de come\u00e7ar, certifique-se de ter sua conta Sudo existente acess\u00edvel no Polkadot.js Apps. Em seguida, siga as etapas:</p> <ol> <li>Navegue at\u00e9 a guia Desenvolvedor do Polkadot.js Apps da sua rede</li> <li>Clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, n\u00e3o associou a conta Sudo ao Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada ao Polkadot.js Apps</li> <li>Selecione o t\u00edtulo Definir chave Sudo</li> <li>Selecione a nova conta para a qual voc\u00ea transferir\u00e1 os privil\u00e9gios Sudo</li> <li>Pressione Reatribuir e confirme a transa\u00e7\u00e3o em sua carteira</li> </ol> <p></p> <p>Nota</p> <p>Certifique-se de ter acesso \u00e0 nova conta Sudo. Assim que o Sudo for transferido, ele n\u00e3o poder\u00e1 ser desfeito sem acesso \u00e0 chave Sudo atual.</p> <p>E \u00e9 isso! A se\u00e7\u00e3o Portal do Desenvolvedor tem muitos mais guias sobre como gerenciar sua rede Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/manage/developer-portal/upgrade/","title":"Atualizando o Runtime da Sua Appchain com Sudo","text":""},{"location":"pt/builders/manage/developer-portal/upgrade/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Sudo \u00e9 um m\u00f3dulo que permite que chamadas de tempo de execu\u00e7\u00e3o privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo \u00e9 por vezes coloquialmente referido como um superusu\u00e1rio ou uma conta semelhante a um deus. Isso permite que voc\u00ea realize a\u00e7\u00f5es privilegiadas no curso do gerenciamento da sua appchain, como a atualiza\u00e7\u00e3o do tempo de execu\u00e7\u00e3o da sua appchain com tecnologia Tanssi.</p> <p>Neste guia, voc\u00ea aprender\u00e1 como usar o Sudo para atualizar o runtime da sua appchain. Com acesso Sudo, atualizar sua cadeia \u00e9 um processo r\u00e1pido e f\u00e1cil. Observe que as equipas de appchain em produ\u00e7\u00e3o ter\u00e3o a op\u00e7\u00e3o de eliminar gradualmente o acesso Sudo e confiar na governan\u00e7a para processar as atualiza\u00e7\u00f5es de tempo de execu\u00e7\u00e3o.</p>"},{"location":"pt/builders/manage/developer-portal/upgrade/#checking-prerequisites","title":"Verificando os Pr\u00e9-Requisitos","text":"<p>Para o exemplo neste guia, voc\u00ea precisar\u00e1 ter o seguinte:</p> <ul> <li>Uma appchain com tecnologia Tanssi (Quick Trial, Dedicated ou MainNet).</li> <li>A conta Sudo da sua appchain conectada ao portal do desenvolvedor da sua appchain. Voc\u00ea pode consultar o guia de Gerenciamento do Sudo para obter instru\u00e7\u00f5es sobre como injetar a sua conta Sudo no portal do desenvolvedor.</li> <li>O novo ficheiro bin\u00e1rio de runtime Wasm, compilado com uma vers\u00e3o superior \u00e0 atual.</li> </ul> <p>Se voc\u00ea n\u00e3o souber qual \u00e9 a conta Sudo da sua rede Tanssi, \u00e9 poss\u00edvel encontr\u00e1\u2011la no Tanssi Dashboard na se\u00e7\u00e3o Properties.</p> <p></p> <p>Warning</p> <p>\u00c9 fundamental proteger a chave da sua conta Sudo com o m\u00e1ximo de cuidado, pois ela concede acesso privilegiado \u00e0 sua rede Tanssi.</p>"},{"location":"pt/builders/manage/developer-portal/upgrade/#obtaining-wasm-runtime","title":"Obtendo o Runtime Wasm","text":"<p>Se a sua cadeia for baseada em um dos modelos oficiais, voc\u00ea pode baixar o arquivo bin\u00e1rio oficial de runtime Wasm na tabela abaixo. Os lan\u00e7amentos oficiais s\u00e3o publicados na se\u00e7\u00e3o de lan\u00e7amentos no reposit\u00f3rio Tanssi.</p> Vers\u00e3o Modelo EVM Modelo Substrate 1400 Download EVM V1400 Wasm file Download Substrate V1400 Wasm file 1300 Download EVM V1300 Wasm file Download Substrate V1300 Wasm file 1201 Download EVM V1201 Wasm file Download Substrate V1201 Wasm file 1100 Download EVM V1100 Wasm file Download Substrate V1100 Wasm file 1000 Download EVM V1000 Wasm file Download Substrate V1000 Wasm file 900 Download EVM V900 Wasm file Download Substrate V900 Wasm file 800 Download EVM V800 Wasm file Download Substrate V800 Wasm file 700 Download EVM V700 Wasm file Download Substrate V700 Wasm file 600 Download EVM V600 Wasm file Download Substrate V600 Wasm file 500 Download EVM V500 Wasm file Download Substrate V500 Wasm file 400 Download EVM V400 Wasm file Download Substrate V400 Wasm file 300 Download EVM V300 Wasm file Download Substrate V300 Wasm file 200 Download EVM V200 Wasm file Download Substrate V200 Wasm file 101 Download EVM V101 Wasm file Download Substrate V101 Wasm file 100 Download EVM V100 Wasm file Download Substrate V100 Wasm file <p>Voc\u00ea deve sempre atualizar o tempo de execu\u00e7\u00e3o seguindo as vers\u00f5es de forma ordenada, aplicando uma vers\u00e3o ap\u00f3s a outra sem pular nenhuma delas. Para isso, voc\u00ea precisa saber a vers\u00e3o atual do tempo de execu\u00e7\u00e3o da sua appchain, que voc\u00ea encontrar\u00e1 no seu Tanssi Dashboard na se\u00e7\u00e3o Propriedades. Por exemplo, se a vers\u00e3o do seu tempo de execu\u00e7\u00e3o for <code>1000</code>, voc\u00ea dever\u00e1 atualizar primeiro para <code>1100</code>, depois para <code>1201</code>, depois para <code>1300</code> e assim por diante at\u00e9 a vers\u00e3o mais recente dispon\u00edvel.</p> <p>Aten\u00e7\u00e3o</p> <p>Aplicar as atualiza\u00e7\u00f5es em ordem garante que as altera\u00e7\u00f5es (migra\u00e7\u00f5es) nas estruturas de dados internas sejam aplicadas, preservando a consist\u00eancia dos dados. Caso contr\u00e1rio, pode paralisar sua appchain.</p> <p>Nota</p> <p>Se estiver compilando o tempo de execu\u00e7\u00e3o manualmente, certifique-se de usar a vers\u00e3o Wasm <code>compact</code> e <code>compressed</code>, que \u00e9 otimizada e mais leve.</p>"},{"location":"pt/builders/manage/developer-portal/upgrade/#upgrading-your-runtime","title":"Atualizando Seu Runtime","text":"<p>Para come\u00e7ar, acesse o portal do desenvolvedor da sua appchain Tanssi, que pode ser encontrado no seu Tanssi Dashboard na se\u00e7\u00e3o Ferramentas.</p> <p></p> <p>Aten\u00e7\u00e3o</p> <p>Se a sua appchain foi implantada usando um modelo oficial e a atualiza\u00e7\u00e3o pretendida \u00e9 um runtime personalizado, certifique-se de ter alterado o nome padr\u00e3o da especifica\u00e7\u00e3o (frontier-template ou container-chain-template) para um diferente antes de construir o arquivo Wasm. Voc\u00ea tamb\u00e9m precisar\u00e1 executar a extr\u00ednseca <code>setCodeWithoutChecks</code> em vez de <code>setCode</code>.</p> <p>Com o seu tempo de execu\u00e7\u00e3o Wasm pronto para ser carregado e a sua conta Sudo acess\u00edvel no portal do desenvolvedor, siga as seguintes etapas:</p> <ol> <li>Navegue at\u00e9 a aba Desenvolvedor do portal do desenvolvedor da sua appchain Tanssi.</li> <li>Clique em Sudo. Se voc\u00ea n\u00e3o vir Sudo neste menu, \u00e9 porque voc\u00ea n\u00e3o associou a conta Sudo ao portal do desenvolvedor. Certifique-se de que a sua conta Sudo est\u00e1 injetada pela sua carteira e conectada ao portal do desenvolvedor.</li> <li>Selecione o pallet system.</li> <li>Selecione setCode.</li> <li>Alterne a chave fileUpload para habilitar o upload do seu arquivo de runtime Wasm.</li> <li>Fa\u00e7a o upload do seu runtime Wasm.</li> <li>Pressione Enviar Sudo e confirme a transa\u00e7\u00e3o na sua carteira. </li> </ol> <p>Voc\u00ea pode verificar se a atualiza\u00e7\u00e3o do seu runtime foi bem-sucedida verificando a vers\u00e3o do runtime no canto superior esquerdo. Nesse caso, voc\u00ea pode ver que o runtime da appchain com tecnologia Tanssi foi atualizado com sucesso para a vers\u00e3o <code>400</code>.</p> <p></p> <p>E \u00e9 isso! A se\u00e7\u00e3o portal do desenvolvedor tem muitos outros guias sobre como gerenciar sua appchain Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/tanssi-network/","title":"Fundamentos da Rede","text":"<p>Saiba mais sobre a rede Tanssi, as TestNets dispon\u00edveis e as principais funcionalidades e aspectos para come\u00e7ar com o desenvolvimento e a intera\u00e7\u00e3o com ela.</p>"},{"location":"pt/builders/tanssi-network/#visao-geral-da-rede","title":"Vis\u00e3o Geral da Rede","text":"<ul> <li>Token TANSSI: o token utilit\u00e1rio nativo das redes Tanssi e sua representa\u00e7\u00e3o ERC-20.</li> <li>Dancelight: a TestNet oficial da Tanssi para implanta\u00e7\u00e3o e experimenta\u00e7\u00e3o r\u00e1pidas de rede.</li> <li>Redes com tecnologia Tanssi: redes constru\u00eddas na plataforma Tanssi, alavancando seus recursos para criar blockchains personalizadas.</li> <li>Rede Demo EVM: uma rede compat\u00edvel com Ethereum de amostra que demonstra uma rede totalmente operacional com tecnologia Tanssi.</li> </ul>"},{"location":"pt/builders/tanssi-network/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/tanssi-network/#recursos-adicionais","title":"Recursos AdicionaisNetwork Toolkit","text":"<p>Mergulhe em ferramentas e recursos projetados para simplificar o processo de desenvolvimento ao construir dApps nas redes Tanssi e com tecnologia Tanssi.</p>"},{"location":"pt/builders/tanssi-network/endpoints/","title":"Endpoints da Rede","text":""},{"location":"pt/builders/tanssi-network/endpoints/#pontos-finais-da-rede","title":"Pontos Finais da Rede","text":"<p>As redes Tanssi t\u00eam dois pontos finais dispon\u00edveis para os utilizadores se conectarem: um para HTTPS e outro para WSS.</p>"},{"location":"pt/builders/tanssi-network/endpoints/#mainnet-tanssi","title":"MainNet Tanssi","text":"<p>Os pontos finais HTTPS e WSS da Tanssi Network MainNet s\u00e3o os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"},{"location":"pt/builders/tanssi-network/endpoints/#dancelight","title":"Dancelight","text":"<p>Os pontos finais HTTPS e WSS da Tanssi TestNet s\u00e3o os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"},{"location":"pt/builders/tanssi-network/endpoints/#rede-demo-evm","title":"Rede Demo EVM","text":"<p>Os pontos finais HTTPS e WSS da rede Demo EVM s\u00e3o os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"pt/builders/tanssi-network/mainnet/","title":"Comece a usar a Tanssi Network MainNet","text":""},{"location":"pt/builders/tanssi-network/mainnet/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A Tanssi Network MainNet est\u00e1 ativa, permitindo que os desenvolvedores embarquem e lancem rapidamente suas appchains em quest\u00e3o de minutos.</p> <p>Esta p\u00e1gina de refer\u00eancia r\u00e1pida oferece todos os elementos essenciais que voc\u00ea precisa para come\u00e7ar na Rede Tanssi.</p>"},{"location":"pt/builders/tanssi-network/mainnet/#tanssi-token","title":"TANSSI Token","text":"<p>Os tokens TANSSI servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implanta\u00e7\u00e3o de uma rede na Tanssi, voc\u00ea precisar\u00e1 obter tokens TANSSI.</p>"},{"location":"pt/builders/tanssi-network/mainnet/#tanssi-network-endpoints","title":"Endpoints de Rede","text":"<p>A Tanssi MainNet possui dois tipos de endpoints dispon\u00edveis para os usu\u00e1rios se conectarem: um para HTTPS e outro para WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-mainnet.network/tanssi/\n</code></pre> <pre><code>wss://services.tanssi-mainnet.network/tanssi\n</code></pre>"},{"location":"pt/builders/tanssi-network/mainnet/#tanssi-block-explorers","title":"Exploradores de Blocos","text":"<p>Para a Tanssi MainNet, voc\u00ea pode usar o seguinte explorador de blocos:</p> <ul> <li>Tanssi Network Subscan</li> <li>Polkadot.js Apps</li> </ul> <p>O suporte para exploradores de blocos adicionais est\u00e1 em andamento e, \u00e0 medida que mais exploradores suportarem a Tanssi MainNet, esta se\u00e7\u00e3o ser\u00e1 atualizada de acordo.</p>"},{"location":"pt/builders/tanssi-network/tanssi-token/","title":"Token TANSSI","text":""},{"location":"pt/builders/tanssi-network/tanssi-token/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O token da rede Tanssi \u00e9 o token de utilidade que alimenta o protocolo Tanssi. Considerando a arquitetura da Tanssi, o token existe em duas representa\u00e7\u00f5es distintas, mas interconectadas: Substrate nativo e ERC-20 Ethereum. As duas vers\u00f5es podem ser interligadas atrav\u00e9s da ponte Tanssi-Ethereum.</p> <p>Neste guia, a utilidade do token e as diferen\u00e7as entre suas duas representa\u00e7\u00f5es s\u00e3o abordadas, o que \u00e9 crucial para operadores de rede, stakers, gerentes de appchain e usu\u00e1rios em geral que desejam participar do ecossistema Tanssi.</p>"},{"location":"pt/builders/tanssi-network/tanssi-token/#token-utility","title":"Utilidade do Token","text":"<p>A Tanssi \u00e9 um protocolo de infraestrutura descentralizado que facilita a implanta\u00e7\u00e3o de appchains com l\u00f3gica personalizada. Ele permite que os desenvolvedores se concentrem no caso de uso, em vez de desviar tempo e energia para gerenciar os v\u00e1rios componentes necess\u00e1rios para que uma rede funcione sem problemas.</p> <p>A execu\u00e7\u00e3o de um protocolo descentralizado saud\u00e1vel n\u00e3o s\u00f3 requer um mecanismo de governan\u00e7a robusto para garantir que as decis\u00f5es sejam tomadas de forma transparente, mas tamb\u00e9m o alinhamento de incentivos e coordena\u00e7\u00e3o entre v\u00e1rios atores do ecossistema, incluindo desenvolvedores de appchain, operadores de n\u00f3s, operadores de sequenciadores, disponibilidade de dados e provedores de RPC, bem como usu\u00e1rios em geral. O token Tanssi serve como a espinha dorsal, fornecendo os mecanismos econ\u00f4micos necess\u00e1rios para coordenar, incentivar o comportamento adequado e proteger todo o ecossistema. Ele permite uma evolu\u00e7\u00e3o de protocolo verific\u00e1vel e imposta por c\u00f3digo por meio de um processo de tomada de decis\u00e3o totalmente na cadeia.</p> <p>O token tem v\u00e1rias utilidades:</p> <ul> <li>Governan\u00e7a on-chain: os detentores de tokens podem usar o token para propor e votar em decis\u00f5es de governan\u00e7a, como atualiza\u00e7\u00f5es de software, como gastar fundos do tesouro, alterar regras de protocolo e muito mais.</li> <li>Implanta\u00e7\u00e3o de Appchain: use o token para registrar e lan\u00e7ar seu appchain em minutos.</li> <li>Pagamento do servi\u00e7o de sequenciamento: use o token para manter seu appchain ativo.</li> <li>Recompensa de servi\u00e7os de sequenciamento e operador: obtenha tokens como recompensas pelos servi\u00e7os de seus n\u00f3s.</li> <li>Staking em sequenciadores: os detentores de tokens podem apostar em sequenciadores, recebendo recompensas sem risco de corte.</li> <li>Staking em operadores: os detentores de tokens podem apostar em operadores, recebendo recompensas por seus servi\u00e7os de valida\u00e7\u00e3o.</li> <li>Pagamento de taxas: use o token para pagar as taxas de intera\u00e7\u00e3o com a rede Tanssi.</li> </ul> <p>Nota</p> <p>Todas as taxas de transa\u00e7\u00e3o na Tanssi s\u00e3o pagas usando o token, com o valor total indo diretamente para financiar a conta do tesouro do protocolo. Esses fundos s\u00f3 podem ser gastos via governan\u00e7a.</p>"},{"location":"pt/builders/tanssi-network/tanssi-token/#token-representations","title":"Representa\u00e7\u00f5es de Token","text":"<p>A rede Tanssi \u00e9 constru\u00edda usando a estrutura Substrate, aproveitando sua arquitetura modular e alto desempenho. Portanto, o token nativo \u00e9 do tipo Substrate. Os mecanismos de cunhagem e queima do protocolo acontecem na rede Tanssi, ou, em outras palavras, acontecem na representa\u00e7\u00e3o do token Substrate.</p> <p>Al\u00e9m disso, o protocolo Tanssi conta com provedores de seguran\u00e7a externos, como o Symbiotic, para proteger o ecossistema por meio de ativos reapostados. Esse mecanismo de reaposta \u00e9 implementado no Ethereum; portanto, uma vers\u00e3o ERC-20 do token tamb\u00e9m existe para cobrir casos de uso no lado Ethereum.</p> <p>Aproveitando os recursos de bridging integrados \u00e0 Tanssi, o token pode ser convertido para (e de) a representa\u00e7\u00e3o ERC-20 no Ethereum. Quando o token \u00e9 ponteado para Ethereum, os tokens s\u00e3o travados na conta soberana da ponte, e uma mensagem \u00e9 enviada ao contrato Ethereum para cunhar a quantia equivalente em ERC-20. Esse mecanismo de travamento e cunhagem garante que a vers\u00e3o ERC-20 seja criada por meio de um mecanismo de bridging sem confian\u00e7a, mantendo um relacionamento 1:1 com o token nativo.</p> <pre><code>flowchart LR\n    subgraph Tanssi_Network [\"Rede Tanssi\"]\n        Tanssi_Substrate[\"$TANSSI (Substrate)\"]\n        Tanssi_Substrate_Utility[\"\u2713 Governan\u00e7a on-chain\n        \u2713 Implanta\u00e7\u00e3o de Appchain\n        \u2713 Recompensas de sequenciadores\n        \u2713 Staking em sequenciadores\n        \u2713 Pagamento de taxas\n        \"]\n        Tanssi_Substrate --&gt; Tanssi_Substrate_Utility\n    end\n\n    subgraph Ethereum_Network [\"Ethereum\"]\n        Tanssi_ERC20[\"$TANSSI (ERC-20)\"]\n        Tanssi_ERC20_Utility[\"\u2713 Recompensa de servi\u00e7os de operador\n        \u2713 Staking em operadores\n        &lt;pre&gt; &lt;/pre&gt;\n        \"]\n        Tanssi_ERC20 --&gt; Tanssi_ERC20_Utility\n    end\n\n    Bridge[\"Trustless Bridge\"]\n\n    Tanssi_Network &lt;--&gt; Bridge &lt;--&gt; Ethereum_Network\n\n    %% Apply custom style to utility nodes\n    classDef utility_style fill: transparent, stroke: transparent, text-align: start;\n    class Tanssi_Substrate_Utility,Tanssi_ERC20_Utility utility_style;\n    %% Make utility arrows transparent\n    linkStyle 0 stroke:transparent,fill:transparent;\n    linkStyle 1 stroke:transparent,fill:transparent;</code></pre>"},{"location":"pt/builders/tanssi-network/tanssi-token/#tanssi-substrate","title":"Tanssi (Substrate) - Token Nativo","text":"<p>O token Tanssi nativo existe na rede Tanssi como um ativo baseado em Substrate e \u00e9 a forma original do token que alimenta as opera\u00e7\u00f5es principais do protocolo.</p> <p>Este token usa como conta do tipo Substrate Sr25519, ent\u00e3o requer uma carteira como a Talisman ou qualquer outra carteira compat\u00edvel com Substrate.</p> <p>Nota</p> <p>O token nativo Tanssi (Substrate) tem doze (12) casas decimais.</p>"},{"location":"pt/builders/tanssi-network/tanssi-token/#tanssi-erc-20","title":"Tanssi (ERC-20) - Representa\u00e7\u00e3o Ethereum","text":"<p>A vers\u00e3o ERC-20 da Tanssi \u00e9 um token Ethereum padr\u00e3o que representa o token nativo na rede Ethereum. Essa vers\u00e3o \u00e9 criada por meio do mecanismo de ponte sem confian\u00e7a, utilizando uma estrat\u00e9gia de bloqueio e cunhagem, mantendo assim um relacionamento 1:1 com o token nativo.</p> <p>Este token, como qualquer outro ativo Ethereum, usa uma conta ECDSA, ent\u00e3o requer uma carteira como Metamask ou qualquer outra carteira compat\u00edvel com Ethereum.</p> <p>Nota</p> <p>O Tanssi (ERC-20) tem doze (12) casas decimais.</p>"},{"location":"pt/builders/tanssi-network/tanssi-token/#substrate-erc-20-comparison","title":"Compara\u00e7\u00e3o Tanssi (Substrate) e Tanssi (ERC-20)","text":"<p>Para entender melhor as diferen\u00e7as entre as duas representa\u00e7\u00f5es de token, a tabela a seguir fornece um resumo de seus principais recursos:</p> Recurso Tanssi (Substrate) Tanssi (ERC-20) Rede Rede Tanssi Ethereum MainNet Padr\u00e3o de Token Ativo Substrate nativo Token padr\u00e3o ERC-20 Casas Decimais Doze (12) decimais Doze (12) decimais Tipo de Conta Sr25519 ECDSA Carteiras Compat\u00edveis Talisman, SubWallet e outros MetaMask, Talisman e outras carteiras compat\u00edveis com Ethereum Principais Utilidades - Participa\u00e7\u00e3o na governan\u00e7a on-chain- Registro e implanta\u00e7\u00e3o de Appchain- Pagamento de servi\u00e7os de sequenciamento- Taxas de transa\u00e7\u00e3o na rede Tanssi- Staking em sequenciadores- Recompensas de opera\u00e7\u00e3o do sequenciador - Recompensas de valida\u00e7\u00e3o do operador- Staking em operadores Op\u00e7\u00f5es de Staking Staking de sequenciador (para manter a atividade da appchain) Staking de operador (para validar/proteger todo o ecossistema Tanssi) Convers\u00e3o de Ponte Pode ser ponteado para ERC-20, pagando taxas em $TANSSI (Substrate) Pode ser ponteado para Substrate, pagando taxas em $ETH"},{"location":"pt/builders/tanssi-network/testnet/","title":"TestNet","text":"<p>Dancelight, a TestNet oficial da Tanssi, permite que os desenvolvedores experimentem aplica\u00e7\u00f5es blockchain em um ambiente controlado antes de entrar em opera\u00e7\u00e3o. Ele fornece as ferramentas para configurar redes, interagir com vers\u00f5es de teste de protocolos e solucionar problemas para garantir uma transi\u00e7\u00e3o mais suave para a produ\u00e7\u00e3o.</p> <p>Quando estiver pronto para ver como seu projeto pode prosperar em um ambiente do mundo real, experimente o ambiente EVM de demonstra\u00e7\u00e3o. Totalmente compat\u00edvel com o Ethereum, esta configura\u00e7\u00e3o com tecnologia Tanssi apresenta os principais recursos e oferece uma experi\u00eancia imersiva, dando-lhe um vislumbre do potencial total da sua solu\u00e7\u00e3o personalizada.</p>"},{"location":"pt/builders/tanssi-network/testnet/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/tanssi-network/testnet/dancelight/","title":"Come\u00e7ar a usar o Dancelight","text":""},{"location":"pt/builders/tanssi-network/testnet/dancelight/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Dancelight \u00e9 a primeira Tanssi TestNet p\u00fablica e foi projetada para otimizar a implanta\u00e7\u00e3o de redes descentralizadas. Ela permite que as equipes embarquem e lancem rapidamente suas appchains em quest\u00e3o de minutos, fornecendo um ambiente robusto para testes e desenvolvimento.</p> <p>Esta p\u00e1gina de refer\u00eancia r\u00e1pida oferece todos os elementos essenciais que voc\u00ea precisa para come\u00e7ar a usar o Dancelight.</p>"},{"location":"pt/builders/tanssi-network/testnet/dancelight/#testnet-tokens","title":"Tokens da TestNet","text":"<p>Os tokens STAR servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implanta\u00e7\u00e3o de uma rede no Dancelight, voc\u00ea precisar\u00e1 obter tokens STAR. Siga estas etapas:</p> <ol> <li>Visite o site Tanssi Network.</li> <li>Preencha o formul\u00e1rio, fornecendo informa\u00e7\u00f5es b\u00e1sicas e seu endere\u00e7o baseado em Substrate.</li> <li>Em at\u00e9 um dia \u00fatil ap\u00f3s o envio do formul\u00e1rio, voc\u00ea receber\u00e1 tokens STAR para testes.</li> </ol> <p>Nota</p> <p>Os tokens STAR n\u00e3o t\u00eam valor. Por favor, n\u00e3o envie solicita\u00e7\u00f5es desnecess\u00e1rias.</p>"},{"location":"pt/builders/tanssi-network/testnet/dancelight/#dancelight-network-endpoints","title":"Pontos de extremidade da rede","text":"<p>Dancelight tem dois tipos de pontos de extremidade dispon\u00edveis para os usu\u00e1rios se conectarem: um para HTTPS e outro para WSS.</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight\n</code></pre>"},{"location":"pt/builders/tanssi-network/testnet/dancelight/#dancelight-block-explorers","title":"Exploradores de Blocos","text":"<p>Para o Dancelight, voc\u00ea pode usar os seguintes exploradores de blocos:</p> <ul> <li>Subscan.</li> <li>O portal do desenvolvedor.</li> </ul> <p>O suporte para exploradores de blocos adicionais est\u00e1 em andamento e, \u00e0 medida que mais exploradores suportarem o Dancelight, esta se\u00e7\u00e3o ser\u00e1 atualizada de acordo.</p>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/","title":"Rede de Demonstra\u00e7\u00e3o EVM Tanssi","text":""},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Explore as funcionalidades de uma rede totalmente compat\u00edvel com Ethereum, implantada atrav\u00e9s da Tanssi, interagindo com a rede EVM de demonstra\u00e7\u00e3o em Dancelight.</p> <p>Esta p\u00e1gina de refer\u00eancia r\u00e1pida oferece todos os elementos essenciais de que voc\u00ea precisa para interagir com esta rede de demonstra\u00e7\u00e3o.</p>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#faucet","title":"Faucet para Tokens TestNet","text":"<p>Voc\u00ea pode acessar tokens TANGO, a moeda nativa da rede de demonstra\u00e7\u00e3o EVM, na faucet no Tanssi dApp. Voc\u00ea pode receber at\u00e9 100 tokens TANGO a cada 12 horas.</p> <p>Para solicitar tokens da faucet, acesse o Tanssi dApp e pressione Adicionar ao MetaMask.</p> <p></p> <p>Em seguida, siga estas etapas:</p> <ol> <li>Pressione Solicitar Tokens</li> <li>Selecione a conta que voc\u00ea gostaria de receber tokens TANGO e pressione Avan\u00e7ar</li> <li>Pressione Conectar</li> </ol> <p></p> <p>Nota</p> <p>Tokens TANGO n\u00e3o t\u00eam valor. Por favor, n\u00e3o envie spam para a faucet com solicita\u00e7\u00f5es desnecess\u00e1rias.</p> <p>Seus tokens ser\u00e3o distribu\u00eddos em breve, e voc\u00ea pode verificar seu saldo de tokens TANGO pesquisando seu endere\u00e7o no [explorador](https://dancelight-2001-blockscout.tanssi-chains.network/){target=_blank}.</p>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#network-endpoints","title":"Endpoints de Rede","text":"<p>Os endpoints HTTPS e WSS da rede EVM de demonstra\u00e7\u00e3o s\u00e3o os seguintes:</p> HTTPSWSS <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#block-explorers","title":"Exploradores de Blocos","text":"<p>Para a rede EVM de demonstra\u00e7\u00e3o, voc\u00ea pode usar qualquer um dos seguintes exploradores:</p> <ul> <li>Polkadot.js Apps (API Substrate)</li> <li>Blockscout (API Ethereum)</li> <li>Expedition (API Ethereum)</li> </ul>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#chain-id","title":"ID da Cadeia","text":"<p>A rede EVM de demonstra\u00e7\u00e3o tem um ID de cadeia de: <code>5678</code>, que \u00e9 <code>0x162E</code> em hexadecimal.</p>"},{"location":"pt/builders/tanssi-network/testnet/demo-evm-network/#quick-start","title":"In\u00edcio R\u00e1pido","text":"<p>Voc\u00ea pode interagir com uma rede EVM alimentada por Tanssi usando bibliotecas Ethereum padr\u00e3o, como Ethers.js, Web3.js e Web3.py. Para come\u00e7ar rapidamente, voc\u00ea precisar\u00e1 criar um provedor conectado a uma rede EVM Tanssi: // Insira sua URL RPC aqui</p> Ethers.jsWeb3.jsWeb3.py <pre><code>import { ethers } from \"ethers\";\n\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insira sua URL RPC aqui\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/', \n    chainId: 5678, // 0x162E em hexadecimal,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <pre><code>const Web3 = require('web3');\n\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <pre><code>from web3 import Web3\n\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/')) \n</code></pre>"},{"location":"pt/builders/toolkit/","title":"Kit de ferramentas","text":"<p>A se\u00e7\u00e3o Toolkit \u00e9 o seu centro de recursos completo para construir, implantar e gerenciar redes baseadas em Tanssi. Ela re\u00fane ferramentas Ethereum e Substrate, como bibliotecas, ambientes de desenvolvimento, precompiles, m\u00e9todos JSON-RPC e muito mais. Seja aprimorando uma rede existente ou implementando novos recursos, este kit de ferramentas oferece tudo o que voc\u00ea precisa para simplificar o desenvolvimento e a opera\u00e7\u00e3o da sua rede.</p> <p>Conselho</p> <p>Se voc\u00ea estiver trabalhando com uma rede compat\u00edvel com EVM, pode usar as ferramentas Substrate para interagir com as funcionalidades de baixo n\u00edvel da sua rede. Com isso, voc\u00ea pode interagir com m\u00f3dulos de tempo de execu\u00e7\u00e3o personalizados, consultar o armazenamento, gerenciar a governan\u00e7a ou trabalhar com recursos exclusivos do Substrate.</p>"},{"location":"pt/builders/toolkit/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/","title":"Ferramentas Ethereum","text":"<p>Desenvolver em cadeias compat\u00edveis com EVM baseadas em Tanssi requer a compreens\u00e3o de como interagir com o blockchain de forma eficaz. Seja voc\u00ea construindo aplicativos descentralizados (dApps), implantando contratos inteligentes ou consultando dados de blockchain, o uso das ferramentas e fluxos de trabalho corretos \u00e9 essencial.</p> <p>Esta se\u00e7\u00e3o oferece uma vis\u00e3o geral das principais ferramentas e fluxos de trabalho que os desenvolvedores usam para interagir com essas redes, ajudando a aprimorar seu fluxo de trabalho de desenvolvimento.</p> <p>Pronto para mergulhar? Confira algumas das seguintes ferramentas:</p> <ul> <li>Ambientes de desenvolvimento - Remix, Foundry e Hardhat</li> <li>Bibliotecas - Ethers.js, viem e Web3.js</li> <li>Carteiras - MetaMask, SubWallet e Talisman</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/rpc/","title":"M\u00e9todos da API JSON-RPC","text":""},{"location":"pt/builders/toolkit/ethereum-api/rpc/#standard-rpc-methods","title":"M\u00e9todos Ethereum padr\u00e3o","text":"<p>A compatibilidade EVM da Tanssi \u00e9 derivada do Frontier e segue de perto a compatibilidade Ethereum do Moonbeam. Os n\u00f3s da Tanssi suportam uma ampla variedade de m\u00e9todos JSON-RPC padr\u00e3o do Ethereum.</p> <p>Nem todos os m\u00e9todos s\u00e3o suportados; alguns retornam valores padr\u00e3o (especialmente os ligados ao PoW). Abaixo est\u00e1 a lista dos m\u00e9todos Ethereum JSON-RPC suportados na Tanssi para que os desenvolvedores saibam o que est\u00e1 dispon\u00edvel ao interagir com redes EVM da Tanssi.</p> <p>M\u00e9todos b\u00e1sicos da API Ethereum suportados:</p> <ul> <li>eth_protocolVersion \u2014 retorna <code>1</code> por padr\u00e3o</li> <li>eth_syncing \u2014 retorna um objeto com o status de sincroniza\u00e7\u00e3o ou <code>false</code></li> <li>eth_hashrate \u2014 retorna <code>\"0x0\"</code> por padr\u00e3o</li> <li>eth_coinbase \u2014 retorna o autor do \u00faltimo bloco (n\u00e3o necessariamente finalizado)</li> <li>eth_mining \u2014 retorna <code>false</code> por padr\u00e3o</li> <li>eth_chainId \u2014 retorna o chain ID usado para assinar no bloco atual</li> <li>eth_gasPrice \u2014 retorna a base fee por unidade de gas. Atualmente \u00e9 o gas price m\u00ednimo da rede</li> <li>eth_accounts \u2014 lista de endere\u00e7os do cliente</li> <li>eth_blockNumber \u2014 maior n\u00famero de bloco dispon\u00edvel</li> <li>eth_getBalance \u2014 saldo do endere\u00e7o fornecido</li> <li>eth_getStorageAt \u2014 conte\u00fado do storage em um endere\u00e7o</li> <li>eth_getBlockByHash \u2014 informa\u00e7\u00f5es do bloco por hash, incluindo <code>baseFeePerGas</code> em blocos p\u00f3s-London</li> <li>eth_getBlockByNumber \u2014 informa\u00e7\u00f5es do bloco por n\u00famero, incluindo <code>baseFeePerGas</code> em blocos p\u00f3s-London</li> <li>eth_getBlockReceipts \u2014 todos os receipts de transa\u00e7\u00f5es de um bloco</li> <li>eth_getTransactionCount \u2014 n\u00famero de transa\u00e7\u00f5es (nonce) enviadas pelo endere\u00e7o</li> <li>eth_getBlockTransactionCountByHash \u2014 n\u00famero de transa\u00e7\u00f5es em um bloco por hash</li> <li>eth_getBlockTransactionCountByNumber \u2014 n\u00famero de transa\u00e7\u00f5es em um bloco por n\u00famero</li> <li>eth_getUncleCountByBlockHash \u2014 retorna <code>\"0x0\"</code> por padr\u00e3o</li> <li>eth_getUncleCountByBlockNumber \u2014 retorna <code>\"0x0\"</code> por padr\u00e3o</li> <li>eth_getCode \u2014 c\u00f3digo no endere\u00e7o informado e bloco informado</li> <li>eth_sendTransaction \u2014 cria transa\u00e7\u00e3o de chamada ou cria\u00e7\u00e3o de contrato (se houver c\u00f3digo em <code>data</code>). Retorna o hash da transa\u00e7\u00e3o ou zero hash se ainda n\u00e3o dispon\u00edvel</li> <li>eth_sendRawTransaction \u2014 cria transa\u00e7\u00e3o de chamada ou cria\u00e7\u00e3o para transa\u00e7\u00f5es assinadas. Retorna hash ou zero hash se ainda n\u00e3o dispon\u00edvel</li> <li>eth_call \u2014 executa chamada sem criar transa\u00e7\u00e3o, retornando o valor da execu\u00e7\u00e3o</li> <li>eth_estimateGas \u2014 estima o gas necess\u00e1rio para uma transa\u00e7\u00e3o. Pode receber <code>gasPrice</code> ou <code>maxFeePerGas</code> e <code>maxPriorityFeePerGas</code></li> <li>eth_feeHistory \u2014 retorna <code>baseFeePerGas</code>, <code>gasUsedRatio</code>, <code>oldestBlock</code> e <code>reward</code> para um intervalo de at\u00e9 1024 blocos</li> <li>eth_getTransactionByHash \u2014 informa\u00e7\u00f5es de uma transa\u00e7\u00e3o por hash; transa\u00e7\u00f5es EIP-1559 incluem <code>maxPriorityFeePerGas</code> e <code>maxFeePerGas</code></li> <li>eth_getTransactionByBlockHashAndIndex \u2014 informa\u00e7\u00f5es de uma transa\u00e7\u00e3o por hash do bloco e \u00edndice; inclui campos EIP-1559</li> <li>eth_getTransactionByBlockNumberAndIndex \u2014 informa\u00e7\u00f5es de uma transa\u00e7\u00e3o por n\u00famero do bloco e \u00edndice; inclui campos EIP-1559</li> <li>eth_getTransactionReceipt \u2014 receipt de uma transa\u00e7\u00e3o por hash</li> <li>eth_getUncleByBlockHashAndIndex \u2014 retorna <code>null</code> por padr\u00e3o</li> <li>eth_getUncleByBlockNumberAndIndex \u2014 retorna <code>null</code> por padr\u00e3o</li> <li>eth_getLogs \u2014 array de logs que correspondem ao filtro</li> <li>eth_newFilter \u2014 cria filtro com base nos par\u00e2metros fornecidos; retorna o ID do filtro</li> <li>eth_newBlockFilter \u2014 cria filtro para avisar quando chegar um novo bloco; retorna ID</li> <li>eth_getFilterChanges \u2014 m\u00e9todo de polling para filtros; retorna logs desde o \u00faltimo poll</li> <li>eth_getFilterLogs \u2014 array de logs que correspondem ao filtro com ID fornecido</li> <li>eth_uninstallFilter \u2014 remove um filtro pelo ID; use quando o polling n\u00e3o for mais necess\u00e1rio (filtros expiram se n\u00e3o forem consultados)</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/rpc/#custom-json-rpc-methods","title":"M\u00e9todos JSON-RPC personalizados","text":"<p>Os n\u00f3s da Tanssi exp\u00f5em dois endpoints personalizados: <code>frnt_isBlockFinalized</code> e <code>frnt_isTxFinalized</code>. Como a Tanssi tem finaliza\u00e7\u00e3o determin\u00edstica, \u00e9 poss\u00edvel saber com certeza se um bloco ou transa\u00e7\u00e3o est\u00e1 finalizado ou n\u00e3o. Esses endpoints ajudam a verificar a finaliza\u00e7\u00e3o de eventos on-chain.</p> frnt_isBlockFinalized - verifica a finaliza\u00e7\u00e3o do bloco pelo hash Par\u00e2metrosRetornoExemplo <ul> <li><code>block_hash</code> string - hash do bloco (aceita hash estilo Substrate ou Ethereum)</li> </ul> <p>boolean - <code>true</code> se o bloco estiver finalizado; <code>false</code> se n\u00e3o estiver finalizado ou n\u00e3o encontrado</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isBlockFinalized\",\n  \"params\": [\"INSERT_BLOCK_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> frnt_isTxFinalized - verifica a finaliza\u00e7\u00e3o de uma transa\u00e7\u00e3o pelo hash EVM Par\u00e2metrosRetornoExemplo <ul> <li><code>tx_hash</code> string - hash EVM da transa\u00e7\u00e3o</li> </ul> <p>boolean - <code>true</code> se a transa\u00e7\u00e3o estiver finalizada; <code>false</code> se n\u00e3o estiver finalizada ou n\u00e3o encontrada</p> <pre><code>curl -H \"Content-Type: application/json\" -X POST --data '{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"frnt_isTxFinalized\",\n  \"params\": [\"INSERT_TRANSACTION_HASH\"]\n}' https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/","title":"Ambientes de Desenvolvimento","text":"<p>Estabelecer um ambiente de desenvolvimento eficaz \u00e9 crucial para construir, testar e implantar contratos inteligentes de forma eficiente. Os ambientes de desenvolvimento simplificam o processo de constru\u00e7\u00e3o de aplica\u00e7\u00f5es blockchain, abstraindo muitas das complexidades subjacentes envolvidas na intera\u00e7\u00e3o com as redes blockchain. Eles fornecem as ferramentas e estruturas necess\u00e1rias para:</p> <ul> <li>Escrever, compilar, testar e implantar contratos inteligentes Solidity</li> <li>Simular intera\u00e7\u00f5es blockchain localmente para teste e depura\u00e7\u00e3o</li> <li>Automatizar fluxos de trabalho para implanta\u00e7\u00f5es mais r\u00e1pidas</li> </ul> <p>Cada ambiente de desenvolvimento ajuda voc\u00ea a alcan\u00e7ar o mesmo objetivo, construir e implantar aplica\u00e7\u00f5es blockchain, mas eles o fazem de maneiras \u00fanicas. Por exemplo, IDEs baseadas em navegador como Remix fornecem uma maneira r\u00e1pida e acess\u00edvel de come\u00e7ar a codificar, enquanto ferramentas como Foundry e Hardhat atendem aos desenvolvedores que preferem fluxos de trabalho espec\u00edficos, como uma abordagem Solidity-first ou integrada ao JavaScript. Escolha aquele que melhor se alinha \u00e0s suas necessidades e estilo de desenvolvimento.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/","title":"Usando Foundry para implantar na sua rede EVM","text":""},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Foundry \u00e9 um ambiente de desenvolvimento Ethereum escrito em Rust que ajuda a gerenciar depend\u00eancias, compilar projetos, executar testes, implantar contratos e interagir com blockchains pela linha de comando. Foundry interage diretamente com a API Ethereum das redes EVM baseadas na Tanssi, ent\u00e3o voc\u00ea pode us\u00e1-lo para implantar e interagir com contratos inteligentes na sua rede Tanssi.</p> <p>Quatro ferramentas comp\u00f5em o Foundry:</p> <ul> <li>Forge \u2013 compila, testa e implanta contratos</li> <li>Cast \u2013 CLI para interagir com contratos</li> <li>Anvil \u2013 n\u00f3 TestNet local para desenvolvimento que pode bifurcar redes existentes</li> <li>Chisel \u2013 REPL Solidity para testar rapidamente trechos de c\u00f3digo</li> </ul> <p>Este guia mostra como usar o Foundry para compilar, implantar e depurar contratos Ethereum na rede EVM de demonstra\u00e7\u00e3o. Para sua pr\u00f3pria rede Tanssi, basta trocar a URL RPC e o Chain ID nos exemplos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1 de:</p> <ul> <li>Uma conta com fundos</li> <li>Foundry instalado</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#creating-a-foundry-project","title":"Criando um projeto Foundry","text":"<p>Crie um projeto Foundry se ainda n\u00e3o tiver um:</p> <ol> <li> <p>Instale o Foundry (no Windows \u00e9 necess\u00e1rio instalar Rust e compilar a partir da fonte):</p> UbuntuMacOSWindows <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl -L https://foundry.paradigm.xyz | bash foundryup\n</code></pre> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\ncargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked\n</code></pre> <p>Ap\u00f3s instalar, talvez seja necess\u00e1rio reiniciar o terminal ou adicionar <code>foundryup</code> ao PATH.</p> </li> <li> <p>Inicialize o projeto, que criar\u00e1 uma pasta com tr\u00eas subpastas:</p> <pre><code>forge init foundry\n</code></pre> </li> </ol> <p>Se aparecer um erro sobre diret\u00f3rio Git j\u00e1 existente, fa\u00e7a um commit (ou um commit falso) e execute novamente.</p> <p>O projeto padr\u00e3o cria:</p> <ul> <li><code>lib</code> \u2013 depend\u00eancias como subm\u00f3dulos git  </li> <li><code>src</code> \u2013 seus contratos inteligentes  </li> <li><code>test</code> \u2013 testes Forge em Solidity  </li> </ul> <p>Um reposit\u00f3rio git e um <code>.gitignore</code> pr\u00e9-preenchido tamb\u00e9m s\u00e3o criados.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#the-src-folder","title":"A pasta <code>src</code>","text":"<p>O reposit\u00f3rio padr\u00e3o inclui <code>Counter.sol</code> em <code>src</code>, <code>Counter.s.sol</code> em <code>script</code> e <code>Counter.t.sol</code> em <code>test</code>. Exclua-os para evitar erros ao compilar/implantar <code>MyToken.sol</code>:</p> <pre><code>rm src/Counter.sol script/Counter.s.sol test/Counter.t.sol\n</code></pre> <p>Crie o contrato ERC-20 de exemplo:</p> <pre><code>cd src\ntouch MyToken.sol\n</code></pre> <p>Abra o arquivo e adicione:</p> <pre><code>pragma solidity ^0.8.0;\n\n// Import OpenZeppelin Contract\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p>Antes de compilar, instale os contratos OpenZeppelin como depend\u00eancia. O Foundry usa subm\u00f3dulos git por padr\u00e3o; use o reposit\u00f3rio GitHub:</p> <pre><code>forge install OpenZeppelin/openzeppelin-contracts\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#compiling-solidity","title":"Compilando Solidity","text":"<p>Depois das depend\u00eancias, compile o contrato:</p> <pre><code>forge build\n</code></pre> <p></p> <p>Ser\u00e3o criadas as pastas <code>out</code> e <code>cache</code> (j\u00e1 ignoradas no <code>.gitignore</code>) com ABI e bytecode.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#deploying-the-contract","title":"Implantando o contrato","text":"<p>Para implantar com o Forge \u00e9 um comando s\u00f3, mas requer endpoint RPC, chave privada financiada e argumentos do construtor. <code>MyToken.sol</code> pede oferta inicial; o exemplo usa 100:</p> <pre><code>forge create --rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--constructor-args 100 \\\n--private-key INSERT_YOUR_PRIVATE_KEY \\\nsrc/MyToken.sol:MyToken\n</code></pre> <p>Ap\u00f3s alguns segundos o contrato \u00e9 implantado; o endere\u00e7o aparece no terminal.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#interacting-with-the-contract","title":"Interagindo com o contrato","text":"<p>Use o Cast (CLI) para fazer chamadas RPC.</p> <p>Recupere o nome do token (substitua <code>INSERT_YOUR_CONTRACT_ADDRESS</code>):</p> <pre><code>cast call INSERT_YOUR_CONTRACT_ADDRESS \"name()\" --rpc-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Converta o retorno hexadecimal para ASCII:</p> <pre><code>cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000\n</code></pre> <p>Para queimar tokens enviando-os ao endere\u00e7o zero:</p> <pre><code>cast send --private-key INSERT_YOUR_PRIVATE_KEY \\\n--rpc-url https://services.tanssi-testnet.network/dancelight-2001/ \\\n--chain 5678 \\\nINSERT_YOUR_CONTRACT_ADDRESS \\\n\"transfer(address,uint256)\" 0x0000000000000000000000000000000000000001 1\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#forking-with-anvil","title":"Bifurcando com Anvil","text":"<p>Anvil \u00e9 um n\u00f3 local que pode bifurcar redes. Para bifurcar a rede demo EVM:</p> <pre><code>anvil --fork-url https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>A inst\u00e2ncia ter\u00e1 10 contas de desenvolvimento pr\u00e9-financiadas. Verifique o \u00faltimo bloco e compare com a rede demo:</p> <pre><code>curl --data '{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}' -H \"Content-Type: application/json\" -X POST localhost:8545\n</code></pre> <p>Depois, voc\u00ea pode implantar novos contratos ou interagir com os existentes. Exemplo para ver saldo dos tokens cunhados:</p> <pre><code>cast call INSERT_CONTRACT_ADDRESS \"balanceOf(address)(uint256)\" INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#using-chisel","title":"Usando Chisel","text":"<p>Chisel \u00e9 um REPL Solidity. Escreva Solidity direto no console para testar rapidamente, sem montar projeto ou implantar contrato.</p> <p>Para iniciar:</p> <pre><code>chisel\n</code></pre> <p>Exemplo de codifica\u00e7\u00e3o ABI:</p> <pre><code>bytes memory myData = abi.encode(100, true, \"Build with Tanssi\");\n</code></pre> <p>Veja como o valor \u00e9 armazenado em mem\u00f3ria:</p> <pre><code>!memdump\n</code></pre> <p>Descubra a posi\u00e7\u00e3o na pilha:</p> <pre><code>!rawstack myData\n</code></pre> <p>Voc\u00ea ver\u00e1 que <code>myData</code> est\u00e1 em <code>0x80</code>; o dump de mem\u00f3ria mostrar\u00e1 os valores correspondentes.</p> <p>Limpe o estado do Chisel se quiser recome\u00e7ar:</p> <pre><code>!clear\n</code></pre> <p>Voc\u00ea tamb\u00e9m pode avaliar express\u00f5es diretamente:</p> <pre><code>abi.encode(100, true, \"Build with Tanssi\")\n</code></pre> <p>Para persistir estado:</p> <pre><code>uint256 myNumber = 101;\n!save 1\n!quit\n</code></pre> <p>Depois, liste e carregue:</p> <pre><code>chisel list\nchisel load 1\n!rawstack myNumber\n</code></pre> <p>\u00c9 poss\u00edvel bifurcar dentro do Chisel:</p> <pre><code>!fork https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>E consultar, por exemplo, saldo de uma conta:</p> <pre><code>0x44236223aB4291b93EEd10E4B511B37a398DEE55.balance\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/foundry/#foundry-with-hardhat","title":"Foundry com Hardhat","text":"<p>Se voc\u00ea precisa integrar a um projeto j\u00e1 configurado em Hardhat, \u00e9 poss\u00edvel criar um projeto h\u00edbrido com o plugin hardhat-foundry:</p> <pre><code>npm init\nnpm install --save-dev hardhat @nomicfoundation/hardhat-foundry\nnpx hardhat init\n</code></pre> <p>Edite <code>hardhat.config.js</code> para incluir:</p> <pre><code>require('@nomicfoundation/hardhat-foundry');\n</code></pre> <p>Mova os contratos de <code>contracts</code> para <code>src</code> e ajuste <code>foundry.toml</code> para incluir <code>lib</code> e <code>node_modules</code>:</p> <pre><code>[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', 'node_modules']\nsolc = '0.8.20'\nevm_version = 'london'\n</code></pre> <p>Agora <code>forge build</code> e <code>npx hardhat compile</code> funcionam; <code>forge test</code> testa Solidity e <code>npx hardhat test</code> testa JavaScript. Voc\u00ea pode unificar em um script:</p> <pre><code>\"scripts\": {\n  \"test\": \"npx hardhat test &amp;&amp; forge test\"\n}\n</code></pre> <p>Parab\u00e9ns, voc\u00ea implantou e interagiu com contratos na sua rede EVM Tanssi usando o Foundry! Para saber mais, consulte o Foundry Book.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/","title":"Usando Hardhat para implantar na sua rede EVM","text":""},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Hardhat \u00e9 um ambiente de desenvolvimento Ethereum que ajuda a gerenciar e automatizar as tarefas recorrentes inerentes \u00e0 cria\u00e7\u00e3o de contratos inteligentes e dApps. Ele funciona com qualquer rede EVM, incluindo as redes compat\u00edveis com a Tanssi, para compilar e implantar contratos de forma transparente.</p> <p>Este guia mostra como compilar, implantar e interagir com contratos inteligentes Ethereum na rede EVM de demonstra\u00e7\u00e3o da Tanssi. Voc\u00ea pode adaptar para sua pr\u00f3pria rede Tanssi adicionando a URL RPC dela \u00e0 sua carteira EVM e alternando para essa rede.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Para este guia, voc\u00ea precisar\u00e1 do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. Voc\u00ea pode seguir este guia para configurar o MetaMask para a rede EVM de demonstra\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project","title":"Criando um projeto Hardhat","text":"<p>Se ainda n\u00e3o tiver um projeto Hardhat, crie um seguindo os passos:</p> <ol> <li> <p>Crie um diret\u00f3rio para o projeto</p> <pre><code>mkdir hardhat &amp;&amp; cd hardhat\n</code></pre> </li> <li> <p>Inicialize o projeto, o que criar\u00e1 um <code>package.json</code></p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Instale o Hardhat</p> <pre><code>npm install hardhat\n</code></pre> </li> <li> <p>Crie o projeto</p> <pre><code>npx hardhat init\n</code></pre> <p>Nota</p> <p><code>npx</code> executa bin\u00e1rios instalados localmente no projeto. Embora seja poss\u00edvel instalar o Hardhat globalmente, \u00e9 recomend\u00e1vel instal\u00e1-lo localmente para controlar a vers\u00e3o por projeto.</p> </li> <li> <p>Um menu aparecer\u00e1 permitindo criar um novo projeto ou usar um exemplo. Para este guia, escolha Create an empty hardhat.config.js</p> </li> </ol> npx hardhat init 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0888 8888888888\u00a0\u00a08888b.\u00a0\u00a0888d888\u00a0.d88888\u00a088888b.\u00a0\u00a0\u00a08888b.\u00a0\u00a0888888 888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888P\"\u00a0\u00a0d88\"\u00a0888\u00a0888\u00a0\"88b\u00a0\u00a0\u00a0\u00a0\u00a0\"88b\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0.d888888\u00a0888\u00a0\u00a0\u00a0\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0.d888888\u00a0888 888\u00a0\u00a0\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0\u00a0\u00a0Y88b\u00a0888\u00a0888\u00a0\u00a0888\u00a0888\u00a0\u00a0888\u00a0Y88b. 888\u00a0\u00a0\u00a0\u00a0888\u00a0\"Y888888\u00a0888\u00a0\u00a0\u00a0\u00a0\u00a0\"Y88888\u00a0888\u00a0\u00a0888\u00a0\"Y888888\u00a0\u00a0\"Y888 \ud83d\udc77 Welcome to Hardhat v2.22.2 \ud83d\udc77\u200d \u00a0What do you want to do? \u2026 \u00a0\u00a0Create a JavaScript project  \u00a0\u00a0Create a TypeScript project  \u00a0\u00a0Create a TypeScript project (with Viem)  \u00a0\u00a0Quit  <p>Isso criar\u00e1 um arquivo de configura\u00e7\u00e3o Hardhat (<code>hardhat.config.js</code>) no diret\u00f3rio do projeto.</p> <p>Quando o projeto estiver pronto, instale tamb\u00e9m o plugin Ethers para usar a biblioteca Ethers.js com a rede:</p> <pre><code>npm install @nomicfoundation/hardhat-ethers ethers\n</code></pre> <p>Al\u00e9m disso, instale o plugin <code>hardhat-ignition-ethers</code> para implantar contratos com o Hardhat Ignition:</p> <pre><code>npm install --save-dev @nomicfoundation/hardhat-ignition-ethers\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#the-contract-file","title":"O arquivo do contrato","text":"<p>Com o projeto vazio criado, crie o diret\u00f3rio <code>contracts</code>:</p> <pre><code>mkdir contracts &amp;&amp; cd contracts\n</code></pre> <p>O contrato de exemplo que ser\u00e1 implantado se chama <code>Box</code> e armazena um valor recuper\u00e1vel depois. No diret\u00f3rio <code>contracts</code>, crie o arquivo <code>Box.sol</code>:</p> <pre><code>touch Box.sol\n</code></pre> <p>Abra o arquivo e adicione o contrato:</p> <pre><code>// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Box {\n    uint256 private value;\n\n    // Emitido quando o valor armazenado \u00e9 alterado\n    event ValueChanged(uint256 newValue);\n\n    // Armazena um novo valor no contrato\n    function store(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n\n    // L\u00ea o \u00faltimo valor armazenado\n    function retrieve() public view returns (uint256) {\n        return value;\n    }\n}\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#hardhat-configuration-file","title":"O arquivo de configura\u00e7\u00e3o do Hardhat","text":"<p>Antes de implantar na sua rede Tanssi, ajuste o <code>hardhat.config.js</code> e crie um arquivo seguro para armazenar sua chave privada.</p> <p>Exemplo de configura\u00e7\u00e3o para usar a rede EVM de demonstra\u00e7\u00e3o ou a sua rede Tanssi:</p> <pre><code>// 1. Importe os plugins Ethers e Hardhat Ignition necess\u00e1rios para interagir com o contrato\nrequire('@nomicfoundation/hardhat-ethers');\nrequire('@nomicfoundation/hardhat-ignition-ethers');\n\n// 2. Adicione sua chave privada com tokens da sua rede Tanssi\n// Isto \u00e9 apenas para exemplo \u2014 **nunca armazene suas chaves privadas em um arquivo JavaScript**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\nmodule.exports = {\n  // 3. Especifique a vers\u00e3o do Solidity\n  solidity: '0.8.1',\n  networks: {\n    // 4. Adicione a especifica\u00e7\u00e3o da sua rede EVM da Tanssi\n    dancelight: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Preencha o ChainID EVM da sua rede Tanssi\n      accounts: [privateKey]\n    }\n  }\n};\n</code></pre> <p>Pronto para implantar!</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#compiling-solidity","title":"Compilando Solidity","text":"<p>Compile o contrato com:</p> <pre><code>npx hardhat compile\n</code></pre> npx hardhat compile Compiled 8 Solidity files successfully (evm target: paris). <p>Ap\u00f3s a compila\u00e7\u00e3o, o diret\u00f3rio <code>artifacts</code> \u00e9 criado com bytecode e metadados (<code>.json</code>). Considere adicion\u00e1-lo ao <code>.gitignore</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#deploying-the-contract","title":"Implantando o contrato","text":"<p>A implanta\u00e7\u00e3o usar\u00e1 o Hardhat Ignition, um framework declarativo para implanta\u00e7\u00f5es. Saiba mais na documenta\u00e7\u00e3o do Ignition.</p> <p>Crie a estrutura para o m\u00f3dulo Ignition:</p> <pre><code>mkdir ignition ignition/modules &amp;&amp; touch ignition/modules/Box.js\n</code></pre> <p>Depois, escreva o m\u00f3dulo do Ignition seguindo estes passos:</p> <ol> <li>Importe <code>buildModule</code> do Hardhat Ignition</li> <li>Exporte um m\u00f3dulo usando <code>buildModule</code></li> <li>Use <code>getAccount</code> para selecionar a conta de deploy</li> <li>Defina gas price e gas limit customizados, se necess\u00e1rio</li> <li>Fa\u00e7a o deploy do contrato <code>Box</code></li> <li>Retorne um objeto com o contrato para us\u00e1-lo em testes e scripts</li> </ol> <pre><code>// 1.  Import the `buildModule` function from the Hardhat Ignition module\nconst { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');\n\n// 2. Export a module using `buildModule`\nmodule.exports = buildModule('BoxModule', (m) =&gt; {\n  // 3. Use the `getAccount` method to select the deployer account\n  const deployer = m.getAccount(0);\n\n  // 4. Specify custom gas price and gas limit settings for the deployment\n  const customGasPrice = 50000000000n;\n  const customGasLimit = 1000000;\n\n  // 5. Deploy the `Box` contract using the selected deployer account and custom gas settings\n  const box = m.contract('Box', [], {\n    from: deployer,\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // 6. Return an object from the module including references to deployed contracts. This makes the deployed `Box` contract accessible for interaction in tests and scripts\n  return { box };\n});\n</code></pre> <p>Para executar o script e implantar o <code>Box.sol</code>, especifique o nome da rede conforme definido em <code>hardhat.config.js</code>. Sem rede, o Hardhat usa a rede local por padr\u00e3o.</p> <pre><code>npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight\n</code></pre> <p>Confirme a rede quando solicitado. Em alguns segundos, o contrato ser\u00e1 implantado e o endere\u00e7o aparecer\u00e1 no terminal. Se for outra rede Tanssi, ajuste o nome da rede para combinar com o <code>hardhat.config.js</code>.</p>  npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight \u2705 Confirm deploy to network dancelight (5678)? \u2026 yes Hardhat Ignition \ud83d\ude80 Deploying [ BoxModule ] Batch #1 Executed BoxModule#Box [ BoxModule ] successfully deployed \ud83d\ude80 Deployed Addresses BoxModule#Box - 0xa84caB60db6541573a091e5C622fB79e175E17be <p>Parab\u00e9ns, o contrato est\u00e1 ativo! Guarde o endere\u00e7o para interagir na pr\u00f3xima etapa.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/hardhat/#interacting-with-the-contract","title":"Interagindo com o contrato","text":"<p>Para interagir com o contrato implantado, abra o <code>console</code> do Hardhat:</p> <pre><code>npx hardhat console --network dancelight\n</code></pre> <p>Execute, linha a linha:</p> <ol> <li> <p>Crie uma inst\u00e2ncia local de <code>Box.sol</code></p> <pre><code>const Box = await ethers.getContractFactory('Box');\n</code></pre> </li> <li> <p>Conecte a inst\u00e2ncia ao contrato implantado usando o endere\u00e7o</p> <pre><code>const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');\n</code></pre> </li> <li> <p>Interaja com o contrato; por exemplo, chame <code>store</code> e salve um valor simples</p> <pre><code>await box.store(5);\n</code></pre> </li> </ol> <p>Sua conta EVM assinar\u00e1 a transa\u00e7\u00e3o e a transmitir\u00e1. A sa\u00edda se parecer\u00e1 com:</p> npx hardhat console --network dancelight Welcome to Node.js v20.9.0. Type \".help\" for more information.  const Box = await ethers.getContractFactory('Box'); undefined  const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be'); undefined  await box.store(5); ContractTransactionResponse {     provider: HardhatEthersProvider { ... },     blockNumber: null,     blockHash: null,     index: undefined,     hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',     type: 2,     to: '0xa84caB60db6541573a091e5C622fB79e175E17be',     from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',     nonce: 87,     gasLimit: 45881n,     gasPrice: 1107421875n,     maxPriorityFeePerGas: 1n,     maxFeePerGas: 1107421875n,     data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',     value: 0n,     chainId: 5678n,     signature: Signature { r: \"0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc\", s: \"0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d\", yParity: 0, networkV: null },     accessList: [],     blobVersionedHashes: null     }  await box.retrieve(); 5n <p>Note seu endere\u00e7o em <code>from</code>, o endere\u00e7o do contrato e os dados enviados. Para recuperar o valor:</p> <pre><code>await box.retrieve();\n</code></pre> <p>Voc\u00ea dever\u00e1 ver <code>5</code> ou o valor armazenado.</p> <p>Nota</p> <p>Se executar o retrieve imediatamente ap\u00f3s armazenar, pode ver o valor antigo. Tente novamente ap\u00f3s alguns instantes.</p> <p>Parab\u00e9ns, voc\u00ea implantou e interagiu com um contrato usando o Hardhat!</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/","title":"Usando Remix para implantar na sua rede EVM da Tanssi","text":""},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores de dApps em redes EVM baseadas na Tanssi podem usar o Remix, um dos ambientes de desenvolvimento Ethereum mais populares, para criar, compilar e implantar contratos inteligentes. O Remix funciona com qualquer rede EVM gra\u00e7as \u00e0 compatibilidade das redes EVM da Tanssi.</p> <p>Este guia mostra como criar e implantar um contrato Solidity na rede EVM de demonstra\u00e7\u00e3o da Tanssi usando a IDE Remix. Para sua pr\u00f3pria rede Tanssi, basta adicionar a URL RPC dela \u00e0 sua carteira EVM e alternar para essa rede.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1 do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. Siga este guia para configurar o MetaMask para a rede EVM de demonstra\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/#getting-started-with-remix","title":"Come\u00e7ando com o Remix","text":"<p>Acesse o Remix e v\u00e1 para a aba File Explorer.</p> <p></p> <p>Crie um novo arquivo para o contrato Solidity:</p> <ol> <li>Clique em Create New File no File Explorer</li> <li>Nomeie, por exemplo, <code>MyToken.sol</code></li> </ol> <p></p> <p>Cole o contrato abaixo no editor:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/audit/2023-03/contracts/token/ERC20/ERC20.sol';\n\n// This ERC-20 contract mints the specified amount of tokens to the contract creator.\ncontract MyToken is ERC20 {\n  constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MYTOK\") {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <p></p> <p>\u00c9 um ERC-20 simples baseado no modelo atual do OpenZeppelin. Cria <code>MyToken</code> com s\u00edmbolo <code>MYTOK</code> e cunha todo o fornecimento inicial para o criador.</p> <p>Para compilar:</p> <ol> <li>Abra a aba Solidity compiler</li> <li>Clique em Compile MyToken.sol</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/#deploying-a-contract-to-your-network-using-remix","title":"Implantando um contrato com Remix","text":"<p>V\u00e1 para Deployment, mude ENVIRONMENT de JavaScript VM para Injected Web3 para usar o provedor do MetaMask apontando para sua rede Tanssi.</p> <p></p> <p>Permita que o Remix se conecte ao MetaMask:</p> <ol> <li>Selecione a(s) conta(s)</li> <li>Clique em Next</li> <li>Clique em Connect</li> </ol> <p></p> <p>Para implantar o token:</p> <ol> <li>Ao lado de Deploy, informe o fornecimento inicial <code>8000000000000000000000000</code> (8 milh\u00f5es com 18 decimais) e clique em Deploy</li> <li>Confirme a transa\u00e7\u00e3o no MetaMask</li> </ol> <p></p> <p>Ap\u00f3s a confirma\u00e7\u00e3o, o contrato aparece em Deployed Contracts. Copie o endere\u00e7o se precisar.</p> <p></p> <p>Para interagir:</p> <ol> <li>Expanda o contrato em Deployed Contracts</li> <li>Em balanceOf, cole seu endere\u00e7o e clique balanceOf para ver o saldo</li> <li>Veja Decimals, Name, Symbol e Initial Supply</li> <li>Copie o endere\u00e7o do contrato (bot\u00e3o ao lado do nome)</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/remix/#interacting-with-an-erc-20-on-your-network-from-metamask","title":"Interagindo com o ERC-20 no MetaMask","text":"<p>Abra o MetaMask na conta que implantou o contrato e adicione o token:</p> <ol> <li>Aba Tokens \u2192 Import tokens</li> </ol> <p></p> <ol> <li>Cole o endere\u00e7o do contrato em Token contract address (s\u00edmbolo e decimais preenchem automaticamente) \u2192 Next</li> </ol> <p></p> <p>Confirme em Import; voc\u00ea ver\u00e1 8 milh\u00f5es de MyTokens.</p> <p></p> <p>Envie 500 MyTokens para outra conta (Send), escolha o destinat\u00e1rio e confirme.</p> <p></p> <p>Ap\u00f3s a conclus\u00e3o, o saldo \u00e9 reduzido.</p> <p></p> <p>Voc\u00ea pode verificar a transa\u00e7\u00e3o no explorador da sua rede Tanssi.</p> <p></p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/","title":"Usando thirdweb na Tanssi","text":""},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>thirdweb \u00e9 um framework completo de desenvolvimento Web3 com ferramentas para criar contratos, dApps e muito mais. Voc\u00ea pode usar contratos predefinidos ou criar os seus, implantar via CLI e interagir com SDKs em v\u00e1rias linguagens (React, TypeScript, etc.). Para ver tudo o que o thirdweb oferece, consulte a documenta\u00e7\u00e3o oficial.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#create-contract","title":"Criar contrato","text":"<p>Para criar um novo contrato com a CLI do thirdweb:</p> <ol> <li>No terminal:    <pre><code>npx thirdweb create contract\n</code></pre></li> <li>Responda aos prompts:</li> <li>Nome do projeto</li> <li>Framework: Hardhat ou Foundry</li> <li>Nome do contrato</li> <li>Tipo base: Empty, ERC20, ERC721, ou ERC1155</li> <li>Extens\u00f5es opcionais (lista)</li> <li>Abra o projeto no editor; o contrato estar\u00e1 em <code>contracts/</code>.</li> </ol> <p>Exemplo de contrato <code>ERC721Base</code> sem extens\u00f5es:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@thirdweb-dev/contracts/base/ERC721Base.sol';\n\ncontract Contract is ERC721Base {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _royaltyRecipient,\n        uint128 _royaltyBps\n    ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}\n}\n</code></pre> <p>Ele herda <code>ERC721Base</code> importando o contrato, declarando a heran\u00e7a e implementando o construtor.</p> <p>Depois de ajustar a l\u00f3gica, implante na rede EVM da Tanssi (veja Implantar).</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel implantar contratos prontos (NFT, token, marketplace) direto da p\u00e1gina Explore:</p> <ol> <li>Acesse a p\u00e1gina Explore</li> <li>Escolha o tipo de contrato</li> <li>Siga os prompts para configurar e implantar</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#deploy-contract","title":"Implantar contrato","text":"<p>O <code>deploy</code> do thirdweb implanta contratos em qualquer rede EVM sem expor chave privada ou configurar RPC manualmente.</p> <ol> <li>No diret\u00f3rio <code>contracts</code> do projeto, execute:    <pre><code>npx thirdweb deploy\n</code></pre>    Isso compila os contratos, permite escolher qual implantar e envia o ABI para o IPFS.</li> <li>No dashboard que abre, preencha par\u00e2metros como:</li> <li><code>_name</code> \u2013 nome do contrato</li> <li><code>_symbol</code> \u2013 s\u00edmbolo</li> <li><code>_royaltyRecipient</code> \u2013 carteira que recebe royalties de vendas secund\u00e1rias</li> <li><code>_royaltyBps</code> \u2013 basis points (ex.: 500 = 5%)</li> <li>Selecione a rede (demo EVM da Tanssi ou sua pr\u00f3pria).</li> <li>Ajuste configura\u00e7\u00f5es extras no dashboard (subir NFTs, permiss\u00f5es, etc.).</li> </ol> <p></p> <p>Mais detalhes em thirdweb Deploy.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#create-application","title":"Criar aplica\u00e7\u00e3o","text":"<p>O thirdweb oferece SDKs para React, React Native, TypeScript, Unity, etc. Para criar um app:</p> <ol> <li>No terminal:    <pre><code>npx thirdweb create --app\n</code></pre></li> <li>Escolha:</li> <li>Nome do projeto</li> <li>Framework: Next.js, Vite ou React Native (exemplo usa Vite)</li> </ol> <p>Depois use o SDK (React/TypeScript) para interagir com o contrato.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#specify-client-id","title":"Informar Client ID","text":"<p>Voc\u00ea precisa de um Client ID (API key) do thirdweb. Crie um gratuitamente em Settings \u2192 API Keys:</p> <ol> <li>D\u00ea um nome ao API key</li> <li>Defina dom\u00ednios permitidos (para dev, pode permitir todos)</li> <li>Confirme</li> </ol> <p>Coloque o Client ID no <code>.env</code> na raiz do projeto. Exemplo (app Vite) em <code>client.ts</code>:</p> client.ts<pre><code>import { createThirdwebClient } from 'thirdweb';\n\n// Substitua pelo seu Client ID\nconst clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;\n\nexport const client = createThirdwebClient({\n  clientId: clientId,\n});\n</code></pre> <p>Nota</p> <p>Se n\u00e3o definir o Client ID corretamente no <code>.env</code>, o app pode aparecer em branco. Corrija o Client ID primeiro.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#run-locally","title":"Rodar localmente","text":"<p>Para testar local:</p> <pre><code>yarn dev\n</code></pre> <p>Veja o endere\u00e7o/porta no console e abra no navegador.</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#configure-chain","title":"Configurar chain","text":"<p>Como Tanssi n\u00e3o vem na lista padr\u00e3o de <code>@thirdweb/chains</code>, defina uma chain customizada com <code>defineChain</code>:</p> chains.ts<pre><code>import { defineChain } from 'thirdweb';\nconst tanssi = defineChain({\n  id: 5678,\n  rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#thirdweb-sdk","title":"SDK do thirdweb","text":"<p>Resumo de m\u00e9todos comuns do SDK:</p>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#accounts-and-wallets","title":"Contas e carteiras","text":"<p>Conta (SDK) = um endere\u00e7o capaz de assinar; n\u00e3o \u201cconecta/desconecta\u201d. Carteira agrupa contas, conecta/desconecta e delega assinatura.</p> <p>Exemplo: inicializar e conectar MetaMask, assinar e enviar transa\u00e7\u00e3o. (Ver snippet <code>initialize.ts</code>):</p> initialize.ts <pre><code>import { sendTransaction } from 'thirdweb';\n// MetaMask wallet used for example, the pattern is the same for all wallets\nimport { createWallet } from 'thirdweb/wallets';\n\n// Initialize the wallet. thirdweb supports 300+ wallet connectors\nconst wallet = createWallet('io.metamask');\n\n// Connect the wallet. This returns a promise that resolves to the connected account\nconst account = await wallet.connect({\n  // Pass the client you created with `createThirdwebClient()`\n  client,\n});\n\n// Sign and send a transaction with the account. Returns the transaction hash\nconst { transactionHash } = await sendTransaction({\n  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send\n  transaction,\n  // Pass the account to sign the transaction with\n  account,\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#get-contract","title":"Obter contrato","text":"<p>Use <code>getContract</code> para conectar-se a um contrato (ex.: incrementer na rede demo EVM da Tanssi):</p> <pre><code>import { getContract } from 'thirdweb';\n\nconst contract = await getContract({\n  client,\n  address: '0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D',\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#read-data","title":"Ler dados","text":"<p>Use <code>readContract</code> para ler estados:</p> <pre><code>import { readContract } from 'thirdweb';\n\nconst value = await readContract({\n  contract,\n  method: 'function number() view returns (uint256)',\n  params: [],\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#write-transactions","title":"Escrever transa\u00e7\u00f5es","text":"<p>Use <code>sendTransaction</code> para enviar transa\u00e7\u00f5es (lembre-se de conectar carteira/conta):</p> <pre><code>import { sendTransaction, prepareContractCall } from 'thirdweb';\n\nconst transaction = prepareContractCall({\n  contract,\n  method: 'function increment()',\n  params: [],\n});\n\nconst { transactionHash } = await sendTransaction({\n  account,\n  transaction,\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#events","title":"Eventos","text":"<p>Obtenha logs com <code>getContractEvents</code>:</p> <pre><code>import { getContractEvents } from 'thirdweb';\n\nconst events = await getContractEvents({\n  contract,\n  fromBlock: 0n,\n  toBlock: 'latest',\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#storage","title":"Armazenamento IPFS","text":"<p>Use <code>upload</code> para enviar dados ao IPFS:</p> <pre><code>import { upload } from 'thirdweb/storage';\n\nconst uri = await upload({\n  client,\n  files: [\n    {\n      name: 'metadata.json',\n      data: JSON.stringify({ name: 'Meu NFT', description: 'Exemplo' }),\n    },\n  ],\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/dev-env/thirdweb/#conclusao","title":"Conclus\u00e3o","text":"<p>Com a CLI, o Deploy e os SDKs do thirdweb, voc\u00ea consegue criar, implantar e interagir com contratos na sua rede EVM da Tanssi com rapidez. Consulte a documenta\u00e7\u00e3o do thirdweb para recursos avan\u00e7ados.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/libraries/","title":"Bibliotecas","text":"<p>As bibliotecas s\u00e3o ferramentas essenciais para interagir com redes blockchain. Elas fornecem fun\u00e7\u00f5es e abstra\u00e7\u00f5es pr\u00e9-constru\u00eddas que simplificam tarefas como leitura e escrita de dados de cadeia. Essas bibliotecas eliminam a necessidade de lidar com solicita\u00e7\u00f5es brutas da blockchain, tornando mais f\u00e1cil para os desenvolvedores constru\u00edrem e implantarem aplicativos descentralizados, garantindo a compatibilidade com o Ethereum e outras redes compat\u00edveis com EVM.</p> <p>Algumas das principais capacidades de trabalhar com bibliotecas incluem:</p> <ul> <li>Gerenciamento de transa\u00e7\u00f5es - criar, assinar e transmitir transa\u00e7\u00f5es</li> <li>Intera\u00e7\u00f5es com contratos inteligentes - simplificar a chamada de fun\u00e7\u00f5es de contrato, decodificar respostas e lidar com eventos de contrato</li> <li>Integra\u00e7\u00e3o de carteira - facilitar integra\u00e7\u00f5es de carteira seguras para transacionar com a rede</li> <li>An\u00e1lise de dados de blockchain - decodificar e interpretar estruturas de dados complexas retornadas por contratos inteligentes</li> <li>Monitoramento de eventos - ouvir eventos emitidos por contratos e acionar a\u00e7\u00f5es espec\u00edficas do aplicativo</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/","title":"Biblioteca JavaScript Ethers.js","text":""},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A biblioteca Ethers.js fornece ferramentas para interagir com n\u00f3s Ethereum usando JavaScript, semelhante \u00e0 Web3.js. As redes EVM alimentadas pela Tanssi oferecem uma API compat\u00edvel com Ethereum/JSON-RPC, ent\u00e3o voc\u00ea pode usar Ethers.js para interagir com uma rede EVM da Tanssi como faria no Ethereum. Para mais detalhes, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Neste guia voc\u00ea aprender\u00e1 a usar Ethers.js na sua rede EVM da Tanssi. Para demonstrar, enviaremos uma transa\u00e7\u00e3o e implantaremos um contrato em uma appchain EVM de demonstra\u00e7\u00e3o rodando no Dancelight. Para sua pr\u00f3pria appchain Tanssi, basta trocar o endpoint.</p> <p>Se preferir v\u00eddeo, veja os tutoriais no topo desta p\u00e1gina sobre Enviar transa\u00e7\u00f5es com Ethers.js e Implantar contratos com Ethers.js.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia voc\u00ea precisar\u00e1:</p> <ul> <li>De uma conta com fundos na rede EVM da Tanssi que estiver usando para testes</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#install-ethersjs","title":"Instalando Ethers.js","text":"<p>Instale a biblioteca Ethers.js e o compilador Solidity:</p> npmyarn <pre><code>npm install ethers solc@0.8.0\n</code></pre> <pre><code>yarn add ethers solc@0.8.0\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#setting-up-the-ethers-provider","title":"Configurando o provedor Ethers","text":"<p>Os scripts a seguir usam um provedor Ethers para falar com a rede.</p> <ol> <li>Importe <code>ethers</code></li> <li>Defina <code>providerRPC</code> com <code>name</code>, <code>rpc</code> e <code>chainId</code> da rede</li> <li>Crie o <code>provider</code> com <code>ethers.JsonRpcProvider</code></li> </ol> <pre><code>// 1. Importe ethers\nimport { ethers } from \"ethers\";\n\n// 2. Defina as configura\u00e7\u00f5es da rede\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    // Insira aqui sua URL RPC\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001/',\n    chainId: 5678, // 0x162E em hexadecimal,\n  },\n};\n// 3. Crie o provider do ethers\nconst provider = new ethers.JsonRpcProvider(\n  providerRPC.evmNetwork.rpc, \n  {\n    chainId: providerRPC.evmNetwork.chainId,\n    name: providerRPC.evmNetwork.name,\n  }\n);\n</code></pre> <p>Guarde este trecho; ele \u00e9 reutilizado nos scripts abaixo.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#send-a-transaction","title":"Enviar uma transa\u00e7\u00e3o","text":"<p>Criaremos dois scripts: um para consultar saldos e outro para enviar a transa\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#check-balances-script","title":"Script de saldos","text":"<p>Crie o arquivo:</p> <pre><code>touch balances.js\n</code></pre> <p>Depois monte o script:</p> <ol> <li>Inclua o provedor</li> <li>Defina <code>addressFrom</code> e <code>addressTo</code></li> <li>Crie a fun\u00e7\u00e3o <code>balances</code></li> <li>Use <code>provider.getBalance</code> e <code>ethers.formatEther</code> para exibir os saldos</li> <li>Chame <code>balances()</code></li> </ol> <pre><code>// 1. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 2. Crie as vari\u00e1veis de endere\u00e7o\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Crie a fun\u00e7\u00e3o de saldos\nconst balances = async () =&gt; {\n  // 4. Busque os saldos\n  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 5. Chamar a fun\u00e7\u00e3o de saldos\nbalances();\n</code></pre> Ver o script completo <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define addresses\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balances\n  const balanceFrom = ethers.formatEther(\n    await provider.getBalance(addressFrom)\n  );\n  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call the balances function\nbalances();\n</code></pre> <p>Execute:</p> <pre><code>node balances.js\n</code></pre> <p>Saldos ser\u00e3o exibidos em TANGO.</p> node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 20.0 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 1.0 TANGO"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#send-transaction-script","title":"Script de envio de transa\u00e7\u00e3o","text":"<p>Crie o arquivo:</p> <pre><code>touch transaction.js\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> e <code>addressTo</code> (n\u00e3o armazene chaves reais em arquivos JS)</li> <li>Crie a wallet com <code>privateKey</code> e <code>provider</code></li> <li>Crie a fun\u00e7\u00e3o <code>send</code></li> <li>Monte o objeto de transa\u00e7\u00e3o (<code>to</code>, <code>value</code> com <code>ethers.parseEther</code>)</li> <li>Envie com <code>wallet.sendTransaction</code> e aguarde o recibo</li> <li>Chame <code>send()</code></li> </ol> <pre><code>// 1. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 2. Crie as vari\u00e1veis da conta\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 3. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 4. Crie a fun\u00e7\u00e3o de envio\nconst send = async () =&gt; {\n  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);\n\n  // 5. Crie o objeto da tx\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // 6. Assine e envie a tx \u2014 aguarde o recibo\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// 7. Chame a fun\u00e7\u00e3o de envio\nsend();\n</code></pre> Ver o script completo <pre><code>// Import ethers\nimport { ethers } from 'ethers';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\nconst wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${wallet.address} to ${addressTo}`\n  );\n\n  // Create transaction\n  const tx = {\n    to: addressTo,\n    value: ethers.parseEther('1'),\n  };\n\n  // Send transaction and get hash\n  const createReceipt = await wallet.sendTransaction(tx);\n  await createReceipt.wait();\n  console.log(`Transaction successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the send function\nsend();\n</code></pre> <p>Rode com:</p> <pre><code>node transaction.js\n</code></pre> <p>O hash ser\u00e1 exibido. Use <code>balances.js</code> antes/depois para confirmar a mudan\u00e7a de saldo.</p> node transaction.js Attempting to send transaction from 0x44236223aB4291b93EEd10E4B511B37a398DEE55 to 0x8841701 Dba3639B254D9CEe712E49D188A1e941e      Transaction successful with hash: 0x29d87c00704b949cb4cc04fdc6c98d53b3c0ec4fb3ffe0c52864a73 b586f563c    node balances.js The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 18.999958 TANGO      The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 2.0 TANGO"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-a-contract","title":"Implantar um contrato","text":"<p>O contrato que voc\u00ea ir\u00e1 compilar e implantar nas pr\u00f3ximas se\u00e7\u00f5es \u00e9 um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o c\u00f3digo Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A fun\u00e7\u00e3o <code>constructor</code>, executada quando o contrato \u00e9 implantado, define o valor inicial da vari\u00e1vel <code>number</code> armazenada on-chain (padr\u00e3o \u00e9 0). A fun\u00e7\u00e3o <code>increment</code> soma o <code>_value</code> informado ao n\u00famero atual, mas exige uma transa\u00e7\u00e3o, pois modifica o dado armazenado. Por fim, a fun\u00e7\u00e3o <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato \u00e9 apenas um exemplo simples para fins ilustrativos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#compile-contract-script","title":"Script de compila\u00e7\u00e3o","text":"<p>Nesta se\u00e7\u00e3o, voc\u00ea criar\u00e1 um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para come\u00e7ar, crie o arquivo <code>compile.js</code> executando:</p> <pre><code>touch compile.js\n</code></pre> <p>Em seguida, escreva o script e conclua estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conte\u00fado de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato usando <code>solc.compile</code> com o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implanta\u00e7\u00e3o</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#deploy-contract-script","title":"Script de deploy","text":"<p>Compile <code>Incrementer.sol</code> e depois crie <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe o contrato de <code>compile.js</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> (n\u00e3o salve chaves reais em JS)</li> <li>Guarde <code>bytecode</code> e <code>abi</code></li> <li>Crie a wallet</li> <li>Crie a <code>ContractFactory</code></li> <li>Crie a fun\u00e7\u00e3o <code>deploy</code></li> <li>Use <code>incrementer.deploy(5)</code> e aguarde o recibo</li> <li>Chame <code>deploy()</code></li> </ol> <pre><code>// 1. Importe o arquivo do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 3. Crie as vari\u00e1veis da conta\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\n\n// 4. Salve o bytecode e o ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 6. Crie a inst\u00e2ncia do contrato com o assinante\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// 7. Crie a fun\u00e7\u00e3o de deploy\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // 8. Envie a tx (valor inicial definido como 5) e aguarde o recibo\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// 9. Chame a fun\u00e7\u00e3o de deploy\ndeploy();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Define accounts and wallet\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Load contract info\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create contract instance with signer\nconst incrementer = new ethers.ContractFactory(abi, bytecode, wallet);\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${wallet.address}`);\n\n  // Send tx (initial value set to 5) and wait for receipt\n  const contract = await incrementer.deploy(5);\n  const txReceipt = await contract.deploymentTransaction().wait();\n\n  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);\n};\n\n// Call the deploy function\ndeploy();\n</code></pre> <p>Execute:</p> <pre><code>node deploy.js\n</code></pre> <p>O endere\u00e7o do contrato ser\u00e1 exibido.</p> node deploy.js Attempting to deploy from account: 0x44236223aB4291b93EEd10E4B511B37a398DEE55      Contract deployed at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#read-contract-data","title":"Ler dados do contrato (calls)","text":"<p>Calls n\u00e3o alteram estado; nenhuma transa\u00e7\u00e3o \u00e9 enviada. Crie <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe o <code>contractFile</code> de <code>compile.js</code></li> <li>Inclua o provedor</li> <li>Defina <code>contractAddress</code></li> <li>Crie a inst\u00e2ncia com <code>ethers.Contract</code></li> <li>Crie a fun\u00e7\u00e3o <code>get</code></li> <li>Chame <code>incrementer.number()</code> e exiba o valor</li> <li>Chame <code>get()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 3. Vari\u00e1vel do endere\u00e7o do contrato\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Crie a inst\u00e2ncia do contrato\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// 5. Crie a fun\u00e7\u00e3o get\nconst get = async () =&gt; {\n  console.log(`Fazendo uma chamada para o contrato no endere\u00e7o: ${contractAddress}`);\n\n  // 6. Chame o contrato \n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Chame a fun\u00e7\u00e3o get\nget();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Contract address variable\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  provider\n);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.number();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>Rode com:</p> <pre><code>node get.js\n</code></pre> node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 5"},{"location":"pt/builders/toolkit/ethereum-api/libraries/ethersjs/#interact-with-contract","title":"Interagir com o contrato (send)","text":"<p>Sends alteram estado e exigem transa\u00e7\u00e3o. Crie <code>increment.js</code> e <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p><code>increment.js</code>:</p> <ol> <li>Importe <code>contractFile</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code>, <code>contractAddress</code>, <code>_value</code> (n\u00e3o salve chaves reais em JS)</li> <li>Crie a wallet</li> <li>Crie a inst\u00e2ncia do contrato com signer</li> <li>Crie a fun\u00e7\u00e3o <code>increment</code></li> <li>Chame <code>incrementer.increment(_value)</code> e aguarde recibo</li> <li>Chame <code>increment()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 3. Crie as vari\u00e1veis\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// 4. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Crie a inst\u00e2ncia do contrato com o assinante\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Crie a fun\u00e7\u00e3o de incremento\nconst increment = async () =&gt; {\n  console.log(\n    `Chamando a fun\u00e7\u00e3o de incremento por ${_value} no contrato no endere\u00e7o: ${contractAddress}`\n  );\n\n  // 7. Assine e envie a tx e aguarde o recibo\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Chame a fun\u00e7\u00e3o de incremento\nincrement();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.increment(_value);\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the increment function\nincrement();\n</code></pre> <p><code>reset.js</code>:</p> <ol> <li>Importe <code>contractFile</code></li> <li>Inclua o provedor</li> <li>Defina <code>privateKey</code> e <code>contractAddress</code></li> <li>Crie a wallet</li> <li>Crie a inst\u00e2ncia do contrato com signer</li> <li>Crie a fun\u00e7\u00e3o <code>reset</code></li> <li>Chame <code>incrementer.reset()</code> e aguarde recibo</li> <li>Chame <code>reset()</code></li> </ol> <pre><code>// 1. Importe o ABI do contrato\nimport contractFile from './compile';\n\n// 2. Adicione aqui a l\u00f3gica do provider do Ethers:\n// {...}\n\n// 3. Crie as vari\u00e1veis\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// 4. Crie a wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// 5. Crie a inst\u00e2ncia do contrato com o assinante\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// 6. Crie a fun\u00e7\u00e3o de reset\nconst reset = async () =&gt; {\n  console.log(`Chamando a fun\u00e7\u00e3o de reset no contrato no endere\u00e7o: ${contractAddress}`);\n\n  // 7. Assine e envie a tx e aguarde o recibo\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// 8. Chame a fun\u00e7\u00e3o de reset\nreset();\n</code></pre> Ver o script completo <pre><code>// Import ethers and compile\nimport { ethers } from 'ethers';\nimport contractFile from './compile.js';\n\n// Define network configurations\nconst providerRPC = {\n  evmNetwork: {\n    name: 'dancelight-evm-network',\n    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n    chainId: 5678, // 0x162E in hex,\n  },\n};\n\n// Create ethers provider\nconst provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {\n  chainId: providerRPC.evmNetwork.chainId,\n  name: providerRPC.evmNetwork.name,\n});\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create wallet\nlet wallet = new ethers.Wallet(accountFrom.privateKey, provider);\n\n// Create contract instance with signer\nconst incrementer = new ethers.Contract(\n  contractAddress,\n  contractFile.abi,\n  wallet\n);\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign and send tx and wait for receipt\n  const createReceipt = await incrementer.reset();\n  await createReceipt.wait();\n\n  console.log(`Tx successful with hash: ${createReceipt.hash}`);\n};\n\n// Call the reset function\nreset();\n</code></pre> <p>Rode:</p> <pre><code>node increment.js\nnode reset.js\n</code></pre> <p>Use <code>get.js</code> junto para confirmar a mudan\u00e7a de valor.</p> node increment.js Calling the reset function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2      Tx successful with hash: 0xb689da50a43e98b5a83ff64757afbf100be12e2db6ff4d0504168f262cc08fb0    node get.js Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2      The current number stored is: 0       As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/","title":"Biblioteca viem TypeScript Ethereum","text":""},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>viem \u00e9 uma biblioteca TypeScript modular que fornece abstra\u00e7\u00f5es sobre a API JSON-RPC, facilitando a intera\u00e7\u00e3o com n\u00f3s Ethereum. Como as redes EVM da Tanssi exp\u00f5em uma API compat\u00edvel com Ethereum/JSON-RPC, voc\u00ea pode usar viem para interagir com qualquer rede EVM Tanssi. Veja a documenta\u00e7\u00e3o do viem para mais detalhes.</p> <p>Neste guia, voc\u00ea ver\u00e1 como usar viem para enviar uma transa\u00e7\u00e3o e implantar um contrato na rede EVM de demonstra\u00e7\u00e3o. O mesmo fluxo se aplica a qualquer rede EVM da Tanssi.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Para os exemplos, voc\u00ea precisar\u00e1 de:</p> <ul> <li>Uma conta com fundos na rede EVM Tanssi que estiver usando</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#installing-viem","title":"Instalando viem","text":"<p>Crie um projeto TypeScript b\u00e1sico e instale depend\u00eancias:</p> <pre><code>mkdir viem-examples &amp;&amp; cd viem-examples &amp;&amp; npm init --y\n</code></pre> <p>Instale viem e o compilador Solidity:</p> npmyarn <pre><code>npm install typescript ts-node viem solc@0.8.0\n</code></pre> <pre><code>yarn add typescript ts-node viem solc@0.8.0\n</code></pre> <p>Gere o <code>tsconfig</code>:</p> <pre><code>npx tsc --init\n</code></pre> <p>Nota</p> <p>Tutorial criado usando Node.js v18.18.0.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#setting-up-a-viem-provider","title":"Configurar um cliente viem (provedor)","text":"<p>Voc\u00ea pode criar: - um cliente de leitura com <code>createPublicClient</code>, para saldos/dados; ou - um cliente de escrita com <code>createWalletClient</code>, para enviar transa\u00e7\u00f5es.</p> <p>Primeiro defina a cadeia com <code>defineChain</code>, informando todos os campos (incluindo <code>public</code> e <code>default</code> RPC).</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#for-reading-chain-data","title":"Para ler dados da cadeia","text":"<p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code> e <code>defineChain</code> de <code>viem</code>.</li> <li>Defina os detalhes da cadeia (inclua URLs <code>public</code> e <code>default</code>).</li> <li>Crie o <code>client</code> com <code>createPublicClient</code>, passando rede e RPC HTTP.</li> </ol> <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#for-writing-chain-data","title":"Para gravar dados da cadeia","text":"<p>Passos:</p> <ol> <li>Importe <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code> de <code>viem</code> e <code>privateKeyToAccount</code> de <code>viem/accounts</code>.</li> <li>Defina os detalhes da cadeia (inclua URLs <code>public</code> e <code>default</code>).</li> <li>Crie a conta com <code>privateKeyToAccount</code>.</li> <li>Crie o <code>client</code> com <code>createWalletClient</code>, passando conta, rede e RPC HTTP.</li> </ol> <p>Remember</p> <p>Demonstra\u00e7\u00e3o apenas. Nunca salve chave privada em arquivo TypeScript.</p> <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport { createWalletClient, http, defineChain } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create your account using the privateKeyToAccount function\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\n\n//4. Create a wallet client for writing chain data\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n</code></pre> <p>Nota</p> <p>Para carteiras de navegador, veja este exemplo (onde <code>demo</code> \u00e9 a rede definida em <code>defineChain</code>): <pre><code>const [account] = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n});\nconst walletClient = createWalletClient({\n  account,\n  chain: demo,\n  transport: custom(window.ethereum),\n});\n</code></pre></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#send-transaction","title":"Enviar uma transa\u00e7\u00e3o","text":"<p>Criaremos dois scripts: um para saldos e outro para enviar a transa\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#check-balances-script","title":"Script de saldos","text":"<p>Crie o arquivo:</p> <pre><code>touch balances.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code>, <code>formatEther</code>, <code>defineChain</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente p\u00fablico.</li> <li>Defina <code>addressFrom</code> e <code>addressTo</code>.</li> <li>Crie a fun\u00e7\u00e3o <code>balances</code> usando <code>publicClient.getBalance</code>.</li> <li>Formate com <code>formatEther</code> e exiba.</li> <li>Chame <code>balances()</code>.</li> </ol> Ver balances.ts <pre><code>// 1. Import the necessary components from viem\nimport { createPublicClient, http, formatEther, defineChain } from 'viem';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'UNIT',\n    symbol: 'UNIT',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 5. Create balances function\nconst balances = async () =&gt; {\n  // 6. Fetch balances\n  const balanceFrom = formatEther(\n    await publicClient.getBalance({ address: addressFrom })\n  );\n  const balanceTo = formatEther(\n    await publicClient.getBalance({ address: addressTo })\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// 7. Call the balances function\nbalances();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node balances.ts\n</code></pre> <p>Saldos em TANGO ser\u00e3o exibidos.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#send-transaction-script","title":"Script de envio","text":"<p>Crie o arquivo:</p> <pre><code>touch transaction.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>parseEther</code>, <code>defineChain</code> e <code>privateKeyToAccount</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) com sua chave (n\u00e3o salve chaves reais em TS).</li> <li>Configure o cliente p\u00fablico (leitura) para aguardar recibo.</li> <li>Defina <code>addressTo</code>.</li> <li>Crie <code>send()</code> com o objeto da transa\u00e7\u00e3o.</li> <li>Envie com <code>walletClient.sendTransaction</code> e aguarde o hash.</li> <li>Aguarde o recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>send()</code>.</li> </ol> Ver transaction.ts <pre><code>// 1. Import the necessary components from viem and viem/accounts\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  parseEther,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create to address variable\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// 6. Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${account.address} to ${addressTo}`\n  );\n\n  // 7. Sign and send transaction\n  const hash = await walletClient.sendTransaction({\n    to: addressTo,\n    value: parseEther('1'),\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call the send function\nsend();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node transaction.ts\n</code></pre> <p>Voc\u00ea ver\u00e1 o hash; use <code>balances.ts</code> antes/depois para confirmar saldos.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#deploy-contract","title":"Implantar um contrato","text":"<p>O contrato que voc\u00ea ir\u00e1 compilar e implantar nas pr\u00f3ximas se\u00e7\u00f5es \u00e9 um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o c\u00f3digo Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A fun\u00e7\u00e3o <code>constructor</code>, executada quando o contrato \u00e9 implantado, define o valor inicial da vari\u00e1vel <code>number</code> armazenada on-chain (padr\u00e3o \u00e9 0). A fun\u00e7\u00e3o <code>increment</code> soma o <code>_value</code> informado ao n\u00famero atual, mas exige uma transa\u00e7\u00e3o, pois modifica o dado armazenado. Por fim, a fun\u00e7\u00e3o <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato \u00e9 apenas um exemplo simples para fins ilustrativos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#compile-contract-script","title":"Script de compila\u00e7\u00e3o","text":"<p>Nesta se\u00e7\u00e3o, voc\u00ea criar\u00e1 um script em TypeScript que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para come\u00e7ar, crie o arquivo <code>compile.ts</code> executando:</p> <pre><code>touch compile.ts\n</code></pre> <p>Depois, escreva o script seguindo estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conte\u00fado de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato com <code>solc.compile</code> usando o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implanta\u00e7\u00e3o</li> </ol> <pre><code>// 1. Import packages\nconst fs = require('fs');\nconst solc = require('solc');\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#deploy-contract-script","title":"Script de deploy","text":"<p>Compile <code>Incrementer.sol</code> e crie <code>deploy.ts</code>:</p> <pre><code>touch deploy.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code>, <code>privateKeyToAccount</code> e o <code>contractFile</code> de <code>compile.ts</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) para implantar (n\u00e3o salve chaves reais em TS).</li> <li>Configure o cliente p\u00fablico (leitura) para obter recibo.</li> <li>Carregue <code>bytecode</code> e <code>abi</code>.</li> <li>Crie a fun\u00e7\u00e3o <code>deploy</code>.</li> <li>Use <code>walletClient.deployContract</code> com ABI, bytecode, conta e valor inicial.</li> <li>Aguarde recibo/leitura conforme necess\u00e1rio.</li> <li>Chame <code>deploy()</code>.</li> </ol> Ver deploy.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Load contract information\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\nconst _initialNumber = 5;\n\n// 6. Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account: ${account.address}`);\n\n  // 7. Send transaction (initial value set to 5)\n  const contract = await walletClient.deployContract({\n    abi,\n    account,\n    bytecode,\n    args: [_initialNumber],\n  });\n\n  // 8. Get the transaction receipt for the deployment\n  const transaction = await publicClient.waitForTransactionReceipt({\n    hash: contract,\n  });\n\n  console.log(`Contract deployed at address: ${transaction.contractAddress}`);\n};\n\n// 9. Call the deploy function\ndeploy();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node deploy.ts\n</code></pre> <p>O endere\u00e7o do contrato ser\u00e1 exibido.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#read-contract-data","title":"Ler dados do contrato (calls)","text":"<p>Calls n\u00e3o alteram estado; n\u00e3o precisam de transa\u00e7\u00e3o. Crie <code>get.ts</code>:</p> <pre><code>touch get.ts\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>http</code>, <code>defineChain</code> e <code>contractFile</code> de <code>compile.ts</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente p\u00fablico.</li> <li>Defina <code>contractAddress</code> e <code>abi</code>.</li> <li>Crie a fun\u00e7\u00e3o <code>get</code>.</li> <li>Chame <code>publicClient.readContract</code> (fun\u00e7\u00e3o <code>number</code>) e exiba o valor.</li> <li>Chame <code>get()</code>.</li> </ol> Ver get.ts <pre><code>// 1. Update import\nimport { createPublicClient, http, defineChain } from 'viem';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a public client for reading chain data\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n// 4. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 5. Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // 6. Call contract\n  const data = await publicClient.readContract({\n    abi,\n    functionName: 'number',\n    address: contractAddress,\n    args: [],\n  });\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// 7. Call get function\nget();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node get.ts\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/viem/#interact-with-contract","title":"Interagir com o contrato (sends)","text":"<p>Sends alteram estado e exigem transa\u00e7\u00e3o. Crie <code>increment.ts</code> e <code>reset.ts</code>:</p> <pre><code>touch increment.ts reset.ts\n</code></pre> <p><code>increment.ts</code>:</p> <ol> <li>Importe <code>createPublicClient</code>, <code>createWalletClient</code>, <code>http</code>, <code>defineChain</code>, <code>privateKeyToAccount</code> e <code>contractFile</code>.</li> <li>Defina a cadeia (inclua URLs <code>public</code>/<code>default</code>).</li> <li>Configure o cliente de carteira (escrita) (n\u00e3o salve chaves reais em TS).</li> <li>Configure o cliente p\u00fablico (leitura) para recibo.</li> <li>Defina <code>contractAddress</code>, <code>abi</code>, <code>_value</code>.</li> <li>Crie <code>increment()</code>.</li> <li>Chame <code>walletClient.writeContract</code> com <code>_value</code> e aguarde hash.</li> <li>Aguarde recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>increment()</code>.</li> </ol> Ver increment.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\nconst _value = 3;\n\n// 6. Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'increment',\n    address: contractAddress,\n    args: [_value],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call increment function\nincrement();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node increment.ts\n</code></pre> <p></p> <p><code>reset.ts</code>:</p> <ol> <li>Importe as mesmas depend\u00eancias de <code>increment.ts</code>.</li> <li>Defina a cadeia.</li> <li>Configure clientes de carteira e p\u00fablico.</li> <li>Defina <code>contractAddress</code> e <code>abi</code>.</li> <li>Crie <code>reset()</code>.</li> <li>Chame <code>walletClient.writeContract</code> (fun\u00e7\u00e3o <code>reset</code>) e aguarde hash.</li> <li>Aguarde recibo com <code>publicClient.waitForTransactionReceipt</code>.</li> <li>Chame <code>reset()</code>.</li> </ol> Ver reset.ts <pre><code>// 1. Update import\nimport {\n  createPublicClient,\n  createWalletClient,\n  http,\n  defineChain,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport contractFile from './compile';\n\n// 2. Specify the details of your EVM network\nexport const demoEVM = defineChain({\n  id: 5678,\n  name: 'demo',\n  network: 'demo',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'TANGO',\n    symbol: 'TANGO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n    public: {\n      http: ['https://services.tanssi-testnet.network/dancelight-2001'],\n      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',\n    },\n  },\n});\n\n// 3. Create a wallet client for writing chain data\n// The private key must be prepended with `0x` to avoid errors\nconst account = privateKeyToAccount('INSERT_PRIVATE_KEY');\nconst rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';\nconst walletClient = createWalletClient({\n  account,\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 4. Create a public client for reading chain data\nconst publicClient = createPublicClient({\n  chain: demoEVM,\n  transport: http(rpcUrl),\n});\n\n// 5. Create contract variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst abi = contractFile.abi;\n\n// 6. Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // 7. Call contract\n  const hash = await walletClient.writeContract({\n    abi,\n    functionName: 'reset',\n    address: contractAddress,\n    args: [],\n  });\n\n  // 8. Wait for the transaction receipt\n  await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  console.log(`Transaction successful with hash: ${hash}`);\n};\n\n// 9. Call reset function\nreset();\n</code></pre> <p>Execute:</p> <pre><code>npx ts-node reset.ts\n</code></pre> <p></p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/","title":"Biblioteca JavaScript Web3.js","text":""},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Web3.js \u00e9 um conjunto de bibliotecas que permite interagir com n\u00f3s Ethereum via HTTP, IPC ou WebSocket em JavaScript. As redes EVM da Tanssi exp\u00f5em uma API compat\u00edvel com Ethereum/JSON-RPC, ent\u00e3o voc\u00ea pode usar Web3.js para falar com um n\u00f3 EVM da Tanssi como se estivesse no Ethereum. Consulte a documenta\u00e7\u00e3o para mais detalhes.</p> <p>Neste guia voc\u00ea configura o Web3.js para sua rede EVM da Tanssi e usa a biblioteca para enviar uma transa\u00e7\u00e3o e implantar um contrato em uma rede de demonstra\u00e7\u00e3o executando no Dancelight. Para sua rede, basta trocar o endpoint.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1:</p> <ul> <li>De uma conta com fundos na rede EVM Tanssi usada nos testes</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#installing-web3js","title":"Instalando Web3.js","text":"<p>Instale Web3.js e o compilador Solidity:</p> npmyarn <pre><code>npm install web3 solc@0.8.0\n</code></pre> <pre><code>yarn add web3 solc@0.8.0\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#setting-up-the-web3-provider","title":"Configurando o provedor Web3","text":"<p>Os scripts a seguir usam um provedor Web3 para se conectar \u00e0 rede.</p> <ol> <li>Importe <code>Web3</code>.</li> <li>Crie o provedor definindo a URL RPC (altere para sua rede quando necess\u00e1rio).</li> </ol> <pre><code>// 1. Importe o Web3\nconst Web3 = require('web3');\n\n// 2. Crie o provider do Web3 e insira sua URL RPC\nconst web3 = new Web3(\n  'https://services.tanssi-testnet.network/dancelight-2001/'\n);\n</code></pre> <p>Guarde este trecho; ele ser\u00e1 reutilizado.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#send-a-transaction","title":"Enviar uma transa\u00e7\u00e3o","text":"<p>Dois scripts: um para consultar saldos e outro para enviar a transa\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#check-balances-script","title":"Script de saldos","text":"<p>Crie o arquivo:</p> <pre><code>touch balances.js\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor Web3.</li> <li>Defina <code>addressFrom</code> e <code>addressTo</code>.</li> <li>Crie <code>balances()</code>.</li> <li>Use <code>web3.eth.getBalance</code> + <code>web3.utils.fromWei</code> para exibir em TANGO.</li> <li>Chame <code>balances()</code>.</li> </ol> <pre><code>// 1. Adicione aqui a l\u00f3gica do provider do Web3:\n// {...}\n\n// 2. Crie as vari\u00e1veis de endere\u00e7o\nconst addressFrom = 'INSERIR_ENDERECO_DE';\nconst addressTo = 'INSERIR_ENDERECO_PARA';\n\n// 3. Crie a fun\u00e7\u00e3o de saldos\nconst balances = async () =&gt; {\n  // 4. Busque as informa\u00e7\u00f5es de saldo\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`O saldo de ${addressFrom} \u00e9: ${balanceFrom} TANGO`);\n  console.log(`O saldo de ${addressTo} \u00e9: ${balanceTo} TANGO`);\n};\n\n// 5. Chamar a fun\u00e7\u00e3o de saldos\nbalances();\n</code></pre> Visualizar o script completo <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst addressFrom = 'INSERT_ADDRESS_FROM';\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create balances function\nconst balances = async () =&gt; {\n  // Fetch balance info\n  const balanceFrom = web3.utils.fromWei(\n    await web3.eth.getBalance(addressFrom),\n    'ether'\n  );\n  const balanceTo = web3.utils.fromWei(\n    await web3.eth.getBalance(addressTo),\n    'ether'\n  );\n\n  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);\n  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);\n};\n\n// Call balances function\nbalances();\n</code></pre> <p>Execute:</p> <pre><code>node balances.js\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#send-transaction-script","title":"Script de envio de transa\u00e7\u00e3o","text":"<p>Crie o arquivo:</p> <pre><code>touch transaction.js\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor Web3.</li> <li>Defina <code>addressFrom</code> (com <code>privateKey</code>) e <code>addressTo</code>. N\u00e3o armazene chaves reais em arquivos JS.</li> <li>Crie <code>send()</code> para assinar e enviar.</li> <li>Assine com <code>web3.eth.accounts.signTransaction</code> (gas, to, value).</li> <li>Envie com <code>web3.eth.sendSignedTransaction</code> e aguarde recibo.</li> <li>Chame <code>send()</code>.</li> </ol> <pre><code>// 1. Adicione aqui a l\u00f3gica do provider do Web3:\n// {...}\n\n// 2. Crie as vari\u00e1veis da conta\nconst accountFrom = {\n  privateKey: 'INSERIR_SUA_CHAVE_PRIVADA',\n  address: 'INSERIR_ENDERECO_PUBLICO_DA_CHAVE',\n};\nconst addressTo = 'INSERIR_ENDERECO_PARA'; // Altere para o endere\u00e7o desejado\n\n// 3. Crie a fun\u00e7\u00e3o de envio\nconst send = async () =&gt; {\n  console.log(\n    `Tentando enviar a transa\u00e7\u00e3o de ${accountFrom.address} para ${addressTo}`\n  );\n\n  // 4. Assine a tx com a chave privada\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // 5. Envie a tx e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transa\u00e7\u00e3o bem-sucedida com hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// 6. Chame a fun\u00e7\u00e3o de envio\nsend();\n</code></pre> Visualizar o script completo <pre><code>// Import Web3\nconst Web3 = require('web3');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create account variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\nconst addressTo = 'INSERT_ADDRESS_TO';\n\n// Create send function\nconst send = async () =&gt; {\n  console.log(\n    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      gas: 21000,\n      to: addressTo,\n      value: web3.utils.toWei('1', 'ether'),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(\n    `Transaction successful with hash: ${createReceipt.transactionHash}`\n  );\n};\n\n// Call send function\nsend();\n</code></pre> <p>Execute:</p> <pre><code>node transaction.js\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#deploy-a-contract","title":"Implantar um contrato","text":"<p>O contrato que voc\u00ea ir\u00e1 compilar e implantar nas pr\u00f3ximas se\u00e7\u00f5es \u00e9 um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o c\u00f3digo Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A fun\u00e7\u00e3o <code>constructor</code>, executada quando o contrato \u00e9 implantado, define o valor inicial da vari\u00e1vel <code>number</code> armazenada on-chain (padr\u00e3o \u00e9 0). A fun\u00e7\u00e3o <code>increment</code> soma o <code>_value</code> informado ao n\u00famero atual, mas exige uma transa\u00e7\u00e3o, pois modifica o dado armazenado. Por fim, a fun\u00e7\u00e3o <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato \u00e9 apenas um exemplo simples para fins ilustrativos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#compile-contract-script","title":"Script de compila\u00e7\u00e3o","text":"<p>Nesta se\u00e7\u00e3o, voc\u00ea criar\u00e1 um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato <code>Incrementer.sol</code>. Para come\u00e7ar, crie o arquivo <code>compile.js</code> executando:</p> <pre><code>touch compile.js\n</code></pre> <p>Em seguida, escreva o script e conclua estas etapas:</p> <ol> <li>Importe os pacotes <code>fs</code> e <code>solc</code></li> <li>Use <code>fs.readFileSync</code> para ler e salvar o conte\u00fado de <code>Incrementer.sol</code> em <code>source</code></li> <li>Monte o objeto <code>input</code> para o compilador Solidity especificando <code>language</code>, <code>sources</code> e <code>settings</code></li> <li>Compile o contrato usando <code>solc.compile</code> com o objeto <code>input</code></li> <li>Extraia o contrato compilado e exporte-o para ser usado no script de implanta\u00e7\u00e3o</li> </ol> <pre><code>// 1. Import packages\nimport fs from 'fs';\nimport solc from 'solc';\n\n// 2. Get path and load contract\nconst source = fs.readFileSync('Incrementer.sol', 'utf8');\n\n// 3. Create input object\nconst input = {\n  language: 'Solidity',\n  sources: {\n    'Incrementer.sol': {\n      content: source,\n    },\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*'],\n      },\n    },\n  },\n};\n// 4. Compile the contract\nconst tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\nconst contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];\n\n// 5. Export contract data\nexport default contractFile;\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#deploy-contract-script","title":"Script de deploy","text":"<p>Compile <code>Incrementer.sol</code> e crie <code>deploy.js</code>:</p> <pre><code>touch deploy.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe o contrato de <code>compile.js</code>.</li> <li>Inclua o provedor Web3.</li> <li>Defina <code>addressFrom</code>/<code>privateKey</code>. N\u00e3o salve chaves reais em JS.</li> <li>Guarde <code>bytecode</code> e <code>abi</code>.</li> <li>Crie <code>deploy()</code>.</li> <li>Instancie o contrato: <code>new web3.eth.Contract(abi)</code>.</li> <li>Construa o deploy com <code>deploy({ data: bytecode, arguments: [5] })</code>.</li> <li>Assine com <code>web3.eth.accounts.signTransaction</code> (data, gas).</li> <li>Envie com <code>web3.eth.sendSignedTransaction</code> e aguarde recibo.</li> <li>Chame <code>deploy()</code>.</li> </ol> <pre><code>// 1. Importe o arquivo do contrato\nconst contractFile = require('./compile');\n\n// 2. Adicione aqui a l\u00f3gica do provider do Web3:\n// {...}\n\n// 3. Crie as vari\u00e1veis de endere\u00e7o\nconst accountFrom = {\n  privateKey: 'INSERIR_CHAVE_PRIVADA',\n  address: 'INSERIR_ENDERECO_PUBLICO_DA_CHAVE_PRIVADA',\n};\n\n// 4. Obtenha o bytecode e o ABI\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// 5. Crie a fun\u00e7\u00e3o de deploy\nconst deploy = async () =&gt; {\n  console.log(`Tentando implantar da conta ${accountFrom.address}`);\n\n  // 6. Crie a inst\u00e2ncia do contrato\n  const incrementer = new web3.eth.Contract(abi);\n\n  // 7. Crie a tx do construtor\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // 8. Assine a transa\u00e7\u00e3o e envie\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // 9. Envie a tx e aguarde o recibo\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contrato implantado no endere\u00e7o: ${createReceipt.contractAddress}`);\n};\n\n// 10. Chamar a fun\u00e7\u00e3o de deploy\ndeploy();\n</code></pre> Visualizar o script completo <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst contractFile = require('./compile');\n\n// Add the Web3 provider logic here\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst accountFrom = {\n  privateKey: 'INSERT_PRIVATE_KEY',\n  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',\n};\n\n// Get the bytecode and API\nconst bytecode = contractFile.evm.bytecode.object;\nconst abi = contractFile.abi;\n\n// Create deploy function\nconst deploy = async () =&gt; {\n  console.log(`Attempting to deploy from account ${accountFrom.address}`);\n\n  // Create contract instance\n  const incrementer = new web3.eth.Contract(abi);\n\n  // Create constructor tx with initial value of 5\n  const incrementerTx = incrementer.deploy({\n    data: bytecode,\n    arguments: [5],\n  });\n\n  // Sign transacation and send\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      data: incrementerTx.encodeABI(),\n      gas: await incrementerTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);\n};\n\n// Call deploy function\ndeploy();\n</code></pre> <p>Execute:</p> <pre><code>node deploy.js\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#read-contract-data","title":"Ler dados do contrato (calls)","text":"<p>Calls n\u00e3o mudam estado; n\u00e3o precisam de transa\u00e7\u00e3o. Crie <code>get.js</code>:</p> <pre><code>touch get.js\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>abi</code> de <code>compile.js</code>.</li> <li>Inclua o provedor Web3.</li> <li>Defina <code>contractAddress</code>.</li> <li>Instancie: <code>new web3.eth.Contract(abi, contractAddress)</code>.</li> <li>Crie <code>get()</code>.</li> <li>Chame <code>incrementer.methods.number().call()</code> e exiba.</li> <li>Chame <code>get()</code>.</li> </ol> <pre><code>// 1. Importe o ABI do contrato\nconst { abi } = require('./compile');\n\n// 2. Adicione aqui a l\u00f3gica do provider do Web3:\n// {...}\n\n// 3. Endere\u00e7o do contrato\nconst contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';\n\n// 4. Crie a inst\u00e2ncia do contrato\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// 5. Crie a fun\u00e7\u00e3o get\nconst get = async () =&gt; {\n  console.log(`Fazendo uma chamada para o contrato no endere\u00e7o: ${contractAddress}`);\n\n  // 6. Chamar o contrato\n  const data = await incrementer.methods.number().call();\n\n  console.log(`O n\u00famero atual armazenado \u00e9: ${data}`);\n};\n\n// 7. Chamar a fun\u00e7\u00e3o get\nget();\n</code></pre> Visualizar o script completo <pre><code>// Import web3 and the contract file\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create address variables\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Create get function\nconst get = async () =&gt; {\n  console.log(`Making a call to contract at address: ${contractAddress}`);\n\n  // Call contract\n  const data = await incrementer.methods.number().call();\n\n  console.log(`The current number stored is: ${data}`);\n};\n\n// Call get function\nget();\n</code></pre> <p>Execute:</p> <pre><code>node get.js\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3js/#interact-with-contract","title":"Interagir com o contrato (sends)","text":"<p>Sends mudam estado, exigem transa\u00e7\u00e3o. Crie <code>increment.js</code> e <code>reset.js</code>:</p> <pre><code>touch increment.js reset.js\n</code></pre> <p><code>increment.js</code>:</p> <ol> <li>Importe <code>abi</code>.</li> <li>Inclua o provedor.</li> <li>Defina <code>privateKey</code>, <code>contractAddress</code>, <code>_value</code> (n\u00e3o salve chaves reais em JS).</li> <li>Instancie o contrato.</li> <li>Construa <code>incrementTx = incrementer.methods.increment(_value)</code>.</li> <li>Crie <code>increment()</code>.</li> <li>Assine com <code>signTransaction</code> (to, data, gas) e envie com <code>sendSignedTransaction</code>.</li> <li>Aguarde recibo; exiba o hash.</li> <li>Chame <code>increment()</code>.</li> </ol> Visualizar o script completo <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst _value = 3;\n\n// Create contract instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build increment tx\nconst incrementTx = incrementer.methods.increment(_value);\n\n// Create increment function\nconst increment = async () =&gt; {\n  console.log(\n    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`\n  );\n\n  // Sign Tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: incrementTx.encodeABI(),\n      gas: await incrementTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send Tx and Wait for Receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call increment function\nincrement();\n</code></pre> <p><code>reset.js</code> segue o mesmo padr\u00e3o, mas chamando <code>reset()</code> sem argumentos:</p> Visualizar reset.js <pre><code>// Import Web3 and the contract abi\nconst Web3 = require('web3');\nconst { abi } = require('./compile');\n\n// Add the Web3 provider logic here:\nconst providerRPC = {\n  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here\n};\nconst web3 = new Web3(providerRPC.evmNetwork);\n\n// Create variables\nconst accountFrom = {\n  privateKey: 'INSERT_YOUR_PRIVATE_KEY',\n};\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n// Create Contract Instance\nconst incrementer = new web3.eth.Contract(abi, contractAddress);\n\n// Build reset tx\nconst resetTx = incrementer.methods.reset();\n\n// Create reset function\nconst reset = async () =&gt; {\n  console.log(\n    `Calling the reset function in contract at address: ${contractAddress}`\n  );\n\n  // Sign tx with PK\n  const createTransaction = await web3.eth.accounts.signTransaction(\n    {\n      to: contractAddress,\n      data: resetTx.encodeABI(),\n      gas: await resetTx.estimateGas(),\n    },\n    accountFrom.privateKey\n  );\n\n  // Send tx and wait for receipt\n  const createReceipt = await web3.eth.sendSignedTransaction(\n    createTransaction.rawTransaction\n  );\n  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);\n};\n\n// Call reset function\nreset();\n</code></pre> <p>Execute:</p> <pre><code>node increment.js\nnode reset.js\n</code></pre> <p>Use <code>get.js</code> junto para confirmar as mudan\u00e7as.</p> <p></p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/","title":"Biblioteca Python Web3.py","text":""},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Web3.py \u00e9 um conjunto de bibliotecas que permite interagir com n\u00f3s Ethereum via HTTP, IPC ou WebSocket em Python. As redes EVM da Tanssi exp\u00f5em uma API compat\u00edvel com Ethereum/JSON-RPC, ent\u00e3o voc\u00ea pode usar Web3.py para falar com um n\u00f3 EVM da Tanssi como se estivesse no Ethereum. Veja a documenta\u00e7\u00e3o para mais detalhes.</p> <p>Neste guia, voc\u00ea configurar\u00e1 o Web3.py para sua rede EVM da Tanssi e usar\u00e1 a biblioteca para enviar uma transa\u00e7\u00e3o e implantar um contrato em uma appchain de demonstra\u00e7\u00e3o executando no Dancelight. Para sua rede, basta trocar o endpoint.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Al\u00e9m disso, certifique-se de ter o Python 3 e um gerenciador de pacotes como o pip instalados.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1:</p> <ul> <li>De uma conta com fundos na rede EVM Tanssi usada nos testes</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#install-web3py","title":"Instalando Web3.py","text":"<p>Instale Web3.py e o compilador Solidity:</p> <pre><code>pip3 install web3 py-solc-x\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#setting-up-the-web3py-provider","title":"Configurando o provedor Web3.py","text":"<p>Os scripts a seguir usam um provedor Web3.py para se conectar \u00e0 rede.</p> <ol> <li>Importe <code>web3</code>.</li> <li>Crie o provedor HTTP com a URL RPC da rede.</li> </ol> <pre><code># 1. Importe web3.py\nfrom web3 import Web3\n\n# 2. Crie o provedor web3.py\n# Insira sua URL RPC aqui\nweb3 = Web3(Web3.HTTPProvider('https://services.tanssi-testnet.network/dancelight-2001/'))\n</code></pre> <p>Guarde este trecho; ele \u00e9 reutilizado nos scripts seguintes.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#send-a-transaction","title":"Enviar uma transa\u00e7\u00e3o","text":"<p>Dois scripts: um para saldos e outro para enviar.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#check-balances-script","title":"Script de saldos","text":"<p>Crie o arquivo:</p> <pre><code>touch balances.py\n</code></pre> <p>Passos:</p> <ol> <li>Inclua o provedor Web3.</li> <li>Defina <code>address_from</code> e <code>address_to</code>.</li> <li>Use <code>web3.eth.get_balance</code> e <code>web3.from_wei</code> para exibir em TANGO.</li> </ol> <pre><code># 1. Import web3.py\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 2. Create address variables\naddress_from = \"INSERT_ADDRESS_FROM\"\naddress_to = \"INSERT_ADDRESS_TO\"\n\n# 4. Fetch balance data\nbalance_from = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_from)), \"ether\"\n)\nbalance_to = web3.from_wei(\n    web3.eth.get_balance(Web3.to_checksum_address(address_to)), \"ether\"\n)\n\nprint(f\"The balance of { address_from } is: { balance_from } TANGO\")\nprint(f\"The balance of { address_to } is: { balance_to } TANGO\")\n</code></pre> <p>Execute:</p> <pre><code>python3 balances.py\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#send-transaction-script","title":"Script de envio","text":"<p>Crie o arquivo:</p> <pre><code>touch transaction.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py e <code>rpc_gas_price_strategy</code>.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code> (com <code>private_key</code>) e <code>address_to</code>. N\u00e3o armazene chaves reais em arquivos Python.</li> <li>Defina a estrat\u00e9gia de gas price com <code>rpc_gas_price_strategy</code>.</li> <li>Monte e assine a transa\u00e7\u00e3o com <code>sign_transaction</code> (nonce, gas, gasPrice, to, value). Use <code>get_transaction_count</code> para nonce, <code>generate_gas_price</code> para gasPrice e <code>to_wei</code> para valor.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo com <code>wait_for_transaction_receipt</code>.</li> </ol> <pre><code># 1. Add imports\nfrom web3 import Web3\nfrom web3.gas_strategies.rpc import rpc_gas_price_strategy\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variables\naccount_from = {\n    \"private_key\": \"INSERT_ YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_ PUBLIC_ADDRESS_OF_PK\",\n}\naddress_to = \"INSERT_ ADDRESS_TO\"\n\nprint(\n    f'Attempting to send transaction from { account_from[\"address\"] } to { address_to }'\n)\n\n# 4. Set the gas price strategy\nweb3.eth.set_gas_price_strategy(rpc_gas_price_strategy)\n\n# 5. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    {\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n        \"gasPrice\": web3.eth.generate_gas_price(),\n        \"gas\": 21000,\n        \"to\": Web3.to_checksum_address(address_to),\n        \"value\": web3.to_wei(\"1\", \"ether\"),\n    },\n    account_from[\"private_key\"],\n)\n\n# 6. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Transaction successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 transaction.py\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#deploy-a-contract","title":"Implantar um contrato","text":"<p>O contrato que voc\u00ea ir\u00e1 compilar e implantar nas pr\u00f3ximas se\u00e7\u00f5es \u00e9 um simples incrementador, chamado <code>Incrementer.sol</code>. Comece criando o arquivo do contrato:</p> <pre><code>touch Incrementer.sol\n</code></pre> <p>Depois, adicione o c\u00f3digo Solidity ao arquivo:</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Incrementer {\n    uint256 public number;\n\n    constructor(uint256 _initialNumber) {\n        number = _initialNumber;\n    }\n\n    function increment(uint256 _value) public {\n        number = number + _value;\n    }\n\n    function reset() public {\n        number = 0;\n    }\n}\n</code></pre> <p>A fun\u00e7\u00e3o <code>constructor</code>, executada quando o contrato \u00e9 implantado, define o valor inicial da vari\u00e1vel <code>number</code> armazenada on-chain (padr\u00e3o \u00e9 0). A fun\u00e7\u00e3o <code>increment</code> soma o <code>_value</code> informado ao n\u00famero atual, mas exige uma transa\u00e7\u00e3o, pois modifica o dado armazenado. Por fim, a fun\u00e7\u00e3o <code>reset</code> zera o valor armazenado.</p> <p>Note</p> <p>Este contrato \u00e9 apenas um exemplo simples para fins ilustrativos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#compile-contract-script","title":"Script de compila\u00e7\u00e3o","text":"<p>Crie <code>compile.py</code>:</p> <pre><code>touch compile.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe <code>solcx</code>.</li> <li>(Opcional) Instale o solc com <code>solcx.install_solc</code>.</li> <li>Compile <code>Incrementer.sol</code> com <code>solcx.compile_files</code>.</li> <li>Exporte ABI e bytecode.</li> </ol> <pre><code># 1. Import solcx\nimport solcx\n\n# 2. If you haven't already installed the Solidity compiler, uncomment the following line\n# solcx.install_solc()\n\n# 3. Compile contract\ntemp_file = solcx.compile_files(\n    \"Incrementer.sol\",\n    output_values=[\"abi\", \"bin\"],\n    # solc_version='0.8.19'\n)\n\n# 4. Export contract data\nabi = temp_file[\"Incrementer.sol:Incrementer\"][\"abi\"]\nbytecode = temp_file[\"Incrementer.sol:Incrementer\"][\"bin\"]\n</code></pre> <p>Nota</p> <p>Se aparecer erro de solc n\u00e3o instalado, descomente a etapa 2 no snippet.</p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#deploy-contract-script","title":"Script de deploy","text":"<p>Compile primeiro; depois crie <code>deploy.py</code>:</p> <pre><code>touch deploy.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py, ABI e bytecode.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code>/<code>private_key</code> (n\u00e3o salve chaves reais em Python).</li> <li>Crie inst\u00e2ncia do contrato com ABI/bytecode.</li> <li>Construa a tx do construtor (valor inicial 5) com <code>build_transaction</code>, incluindo <code>from</code> e <code>nonce</code>.</li> <li>Assine com <code>sign_transaction</code>.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo com <code>wait_for_transaction_receipt</code>.</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi, bytecode\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\n\nprint(f'Attempting to deploy from account: { account_from[\"address\"] }')\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# 5. Build constructor tx\nconstruct_txn = Incrementer.constructor(5).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(\n    construct_txn, account_from[\"private_key\"]\n)\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Contract deployed at address: { tx_receipt.contractAddress }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 deploy.py\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#read-contract-data","title":"Ler dados do contrato (calls)","text":"<p>Calls n\u00e3o mudam estado; n\u00e3o precisam de transa\u00e7\u00e3o. Crie <code>get.py</code>:</p> <pre><code>touch get.py\n</code></pre> <p>Passos:</p> <ol> <li>Importe Web3.py e o ABI.</li> <li>Inclua o provedor.</li> <li>Defina <code>contract_address</code>.</li> <li>Instancie o contrato com ABI/endere\u00e7o.</li> <li>Chame <code>number()</code> e exiba.</li> </ol> <pre><code># 1. Import the ABI\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create address variable\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Making a call to contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Call Contract\nnumber = Incrementer.functions.number().call()\nprint(f\"The current number stored is: { number } \")\n</code></pre> <p>Execute:</p> <pre><code>python3 get.py\n</code></pre> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/libraries/web3py/#interact-with-contract","title":"Interagir com o contrato (sends)","text":"<p>Sends alteram estado; exigem transa\u00e7\u00e3o. Crie <code>increment.py</code> e <code>reset.py</code>:</p> <pre><code>touch increment.py reset.py\n</code></pre> <p><code>increment.py</code>:</p> <ol> <li>Importe Web3.py e ABI.</li> <li>Inclua o provedor.</li> <li>Defina <code>account_from</code>/<code>private_key</code>, <code>contract_address</code>, <code>value</code> (n\u00e3o salve chaves reais em Python).</li> <li>Instancie o contrato.</li> <li>Construa a tx de incremento com <code>build_transaction</code> (from, nonce).</li> <li>Assine com <code>sign_transaction</code>.</li> <li>Envie com <code>send_raw_transaction</code> e aguarde recibo.</li> </ol> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\nvalue = 3\n\nprint(\n    f\"Calling the increment by { value } function in contract at address: { contract_address }\"\n)\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build increment tx\nincrement_tx = Incrementer.functions.increment(value).build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(increment_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 increment.py\n</code></pre> <p></p> <p><code>reset.py</code> segue o mesmo padr\u00e3o chamando <code>reset()</code> sem argumentos:</p> <pre><code># 1. Add imports\nfrom compile import abi\nfrom web3 import Web3\n\n# 2. Create web3.py provider\nprovider_rpc = {\n    # Insert your RPC URL here\n    \"evm_network\": \"https://services.tanssi-testnet.network/dancelight-2001\",\n}\nweb3 = Web3(Web3.HTTPProvider(provider_rpc[\"evm_network\"]))\n\n# 3. Create variables\naccount_from = {\n    \"private_key\": \"INSERT_YOUR_PRIVATE_KEY\",\n    \"address\": \"INSERT_PUBLIC_ADDRESS_OF_PK\",\n}\ncontract_address = \"INSERT_CONTRACT_ADDRESS\"\n\nprint(f\"Calling the reset function in contract at address: { contract_address }\")\n\n# 4. Create contract instance\nIncrementer = web3.eth.contract(address=contract_address, abi=abi)\n\n# 5. Build reset tx\nreset_tx = Incrementer.functions.reset().build_transaction(\n    {\n        \"from\": Web3.to_checksum_address(account_from[\"address\"]),\n        \"nonce\": web3.eth.get_transaction_count(\n            Web3.to_checksum_address(account_from[\"address\"])\n        ),\n    }\n)\n\n# 6. Sign tx with PK\ntx_create = web3.eth.account.sign_transaction(reset_tx, account_from[\"private_key\"])\n\n# 7. Send tx and wait for receipt\ntx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)\ntx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n\nprint(f\"Tx successful with hash: { tx_receipt.transactionHash.hex() }\")\n</code></pre> <p>Execute:</p> <pre><code>python3 reset.py\n</code></pre> <p></p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/precompiles/","title":"Precompiles","text":"<p>Precompiles s\u00e3o m\u00f3dulos de blockchain integrados, projetados para lidar com tarefas espec\u00edficas de forma mais eficiente do que contratos inteligentes padr\u00e3o. Esses m\u00f3dulos s\u00e3o pr\u00e9-implantados em endere\u00e7os fixos e fornecem solu\u00e7\u00f5es otimizadas para opera\u00e7\u00f5es como fun\u00e7\u00f5es criptogr\u00e1ficas, processamento de transa\u00e7\u00f5es em lote e gerenciamento de tokens.</p> <p>Como as redes alimentadas pela Tanssi s\u00e3o baseadas em Substrate, os contratos precompilados podem suportar fun\u00e7\u00f5es compat\u00edveis com Ethereum e opera\u00e7\u00f5es espec\u00edficas para a cadeia Substrate subjacente. Essa abordagem dupla garante que os desenvolvedores possam interagir com ferramentas Ethereum familiares, ao mesmo tempo em que aproveitam o desempenho e a flexibilidade exclusivos oferecidos pelo Substrate.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/#fluxo-de-interacao-com-precompiles","title":"Fluxo de Intera\u00e7\u00e3o com Precompiles","text":"<p>O fluxo abaixo ilustra como as solicita\u00e7\u00f5es do usu\u00e1rio passam pela interface Ethereum, interagem com precompiles e, por fim, acessam a funcionalidade Substrate, simplificando opera\u00e7\u00f5es complexas para uma integra\u00e7\u00e3o perfeita.</p> <pre><code>graph LR\n\n    A[Usu\u00e1rio]\n    B[Interface Ethereum]\n    C[Precompile]\n    D[Interface Substrate]\n\n    A --&gt;|Interage atrav\u00e9s de| B\n    B --&gt;|Chama| C\n    C --&gt;|Acessa| D</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/#referencia-rapida-de-enderecos-precompile","title":"Refer\u00eancia R\u00e1pida de Endere\u00e7os Precompile","text":"Precompile Endere\u00e7o Native Token ERC-20 <pre><code>0x0000000000000000000000000000000000000800</code></pre> Call Permit <pre><code>0x0000000000000000000000000000000000000802</code></pre> Proxy <pre><code>0x0000000000000000000000000000000000000805</code></pre> Batch Transactions <pre><code>0x0000000000000000000000000000000000000801</code></pre> <p>Para saber mais sobre cada precompile, confira os guias listados na se\u00e7\u00e3o a seguir.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/#explore-esta-secao","title":"Explore esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/","title":"Interagindo com o Batch Precompile","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O Batch Precompile em redes EVM com tecnologia Tanssi permite que desenvolvedores agrupem v\u00e1rias chamadas EVM em uma \u00fanica transa\u00e7\u00e3o.</p> <p>Sem o precompile, um usu\u00e1rio precisaria confirmar v\u00e1rias transa\u00e7\u00f5es (por exemplo, aprovar um token e logo em seguida transferi-lo). Com o Batch Precompile, a experi\u00eancia melhora porque o usu\u00e1rio confirma apenas uma transa\u00e7\u00e3o, reduzindo tamb\u00e9m o g\u00e1s pago por taxas b\u00e1sicas m\u00faltiplas.</p> <p>O precompile interage diretamente com o pallet EVM do Substrate. A conta que chama a fun\u00e7\u00e3o em lote atua como <code>msg.sender</code> para todas as subtransa\u00e7\u00f5es e cada contrato de destino altera o seu pr\u00f3prio armazenamento (diferente de <code>delegatecall</code>).</p> <p>O Batch Precompile est\u00e1 localizado no seguinte endere\u00e7o:</p> <pre><code>0x0000000000000000000000000000000000000801\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequ\u00eancias inesperadas. As precompiladas do Tanssi s\u00e3o derivadas das do Moonbeam; portanto, familiarize-se com as considera\u00e7\u00f5es de seguran\u00e7a das precompiladas do Moonbeam.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#the-batch-interface","title":"A interface Solidity em lote","text":"<p><code>Batch.sol</code> \u00e9 a interface Solidity para os tr\u00eas m\u00e9todos do precompile.</p> Batch.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The Batch contract's address.\naddress constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000801;\n\n/// @dev The Batch contract's instance.\nBatch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Batch precompile\n/// @dev Allows to perform multiple calls throught one call to the precompile.\n/// Can be used by EOA to do multiple calls in a single transaction.\n/// @custom:address 0x0000000000000000000000000000000000000801\ninterface Batch {\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting following subcalls will still be attempted.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 79df4b9c\n    function batchSome(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, no more subcalls will be executed but\n    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector cf0491c7\n    function batchSomeUntilFailure(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// @dev Batch multiple calls into a single transaction.\n    /// All calls are performed from the address calling this precompile.\n    ///\n    /// In case of one subcall reverting, the entire batch will revert.\n    ///\n    /// @param to List of addresses to call.\n    /// @param value List of values for each subcall. If array is shorter than \"to\" then additional\n    /// calls will be performed with a value of 0.\n    /// @param callData Call data for each `to` address. If array is shorter than \"to\" then\n    /// additional calls will be performed with an empty call data.\n    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.\n    /// If array is shorter than \"to\" then the remaining gas available will be used.\n    /// @custom:selector 96e292b8\n    function batchAll(\n        address[] memory to,\n        uint256[] memory value,\n        bytes[] memory callData,\n        uint64[] memory gasLimit\n    ) external;\n\n    /// Emitted when a subcall succeeds.\n    event SubcallSucceeded(uint256 index);\n\n    /// Emitted when a subcall fails.\n    event SubcallFailed(uint256 index);\n}\n</code></pre> <p>A interface inclui as fun\u00e7\u00f5es:</p> batchSome(address[] to, uint256[] value, bytes[] callData, uint64[] gasLimit) \u2014 executa v\u00e1rias chamadas. Cada \u00edndice dos arrays comp\u00f5e uma subchamada. Se uma subchamada reverter, as seguintes ainda ser\u00e3o tentadas Par\u00e2metros <ul> <li><code>to</code> - lista de endere\u00e7os das subtransa\u00e7\u00f5es</li> <li><code>value</code> - valores em moeda nativa para cada subtransa\u00e7\u00e3o; se a lista for menor que <code>to</code>, os demais valores ser\u00e3o 0</li> <li><code>callData</code> - dados de chamada para cada subtransa\u00e7\u00e3o; se a lista for menor que <code>to</code>, as restantes n\u00e3o ter\u00e3o dados</li> <li><code>gasLimit</code> - limite de g\u00e1s de cada subtransa\u00e7\u00e3o; 0 encaminha todo o g\u00e1s restante. Se a lista for menor que <code>to</code>, as seguintes receber\u00e3o todo o g\u00e1s restante</li> </ul> batchSomeUntilFailure(... ) \u2014 igual ao anterior, por\u00e9m interrompe ao primeiro erro batchAll(... ) \u2014 executa v\u00e1rias chamadas de forma at\u00f4mica. Se uma subchamada reverter, todas revertem <p>Eventos emitidos:</p> <ul> <li>SubcallSucceeded(uint256 index) \u2014 emitido quando uma subchamada com o \u00edndice informado \u00e9 bem-sucedida</li> <li>SubcallFailed(uint256 index) \u2014 emitido quando uma subchamada com o \u00edndice informado falha</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#interact-with-the-solidity-interface","title":"Interaja com a interface Solidity","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#checking-prerequisites","title":"Verifique os pr\u00e9-requisitos","text":"<ul> <li>Carteira compat\u00edvel com EVM configurada para sua rede (por exemplo, MetaMask)</li> <li>Conta com tokens nativos suficientes</li> <li>Opcional: rede de demonstra\u00e7\u00e3o EVM no Tanssi dApp</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#example-contract","title":"Contrato de exemplo","text":"<p>Usaremos <code>SimpleContract.sol</code> para demonstrar intera\u00e7\u00f5es em lote:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.0;\n\ncontract SimpleContract {\n    mapping(uint256 =&gt; string) public messages;\n\n    function setMessage(uint256 id, string calldata message) external {\n        messages[id] = message;\n    }\n}\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#remix-set-up","title":"Configura\u00e7\u00e3o do Remix","text":"<ol> <li>Abra Remix.</li> <li>Crie os arquivos Batch.sol e SimpleContract.sol com o conte\u00fado correspondente.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#compile-the-contract","title":"Compile os contratos","text":"<ol> <li>Abra Batch.sol e clique em Compile Batch.sol (aba Compile).  </li> <li>Repita para SimpleContract.sol.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#access-the-precompile","title":"Acesse o precompile","text":"<ol> <li>Na aba Deploy and Run, escolha Injected Provider - MetaMask em ENVIRONMENT.  </li> <li>Selecione Batch.sol em CONTRACT.  </li> <li>No campo At Address, insira <code>0x0000000000000000000000000000000000000801</code> e clique em At Address.    O contrato BATCH aparecer\u00e1 em Deployed Contracts.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#deploy-example-contract","title":"Implemente o contrato de exemplo","text":"<ol> <li>Ainda na aba Deploy and Run, selecione SimpleContract em CONTRACT.  </li> <li>Clique em Deploy e confirme no MetaMask.    O SIMPLECONTRACT aparecer\u00e1 em Deployed Contracts.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#send-native-currency-via-precompile","title":"Envie moeda nativa via precompile","text":"<p>Para usar batchAll e enviar tokens nativos de forma at\u00f4mica:</p> <ol> <li>Expanda o contrato BATCH em Deployed Contracts.</li> <li>Abra batchAll.</li> <li>Preencha:  </li> <li>to: <code>[\\\"ENDERECO_1\\\",\\\"ENDERECO_2\\\"]</code> </li> <li>value: <code>[\\\"1000000000000000000\\\",\\\"2000000000000000000\\\"]</code> (exemplo: 1 e 2 tokens)  </li> <li>callData: <code>[]</code> </li> <li>gasLimit: <code>[]</code></li> <li>Clique em transact e confirme no MetaMask.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#find-a-contract-interactions-call-data","title":"Obtenha o call data de uma intera\u00e7\u00e3o de contrato","text":"<ol> <li>Em SIMPLECONTRACT, expanda setMessage.  </li> <li>Preencha id (ex.: <code>1</code>) e message (ex.: <code>\"tanssi\"</code>).  </li> <li>Clique no \u00edcone de copiar ao lado de transact para obter o call data codificado.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#function-interaction-via-precompile","title":"Interaja com fun\u00e7\u00f5es via precompile","text":"<p>Para chamar duas vezes <code>setMessage</code> de forma at\u00f4mica:</p> <ol> <li>Copie o endere\u00e7o de SIMPLECONTRACT.  </li> <li>Em batchAll, preencha:  </li> <li>to: <code>[\\\"ENDERECO_CONTRATO\\\",\\\"ENDERECO_CONTRATO\\\"]</code> </li> <li>value: <code>[0,0]</code> </li> <li>callData: <code>[\\\"CALLDATA_1\\\",\\\"CALLDATA_2\\\"]</code> (obtidos no passo anterior)  </li> <li>gasLimit: <code>[]</code> (ou limites espec\u00edficos)</li> <li>Clique em transact e confirme no MetaMask.</li> </ol> <p>Ap\u00f3s a execu\u00e7\u00e3o, consulte a fun\u00e7\u00e3o messages do <code>SimpleContract.sol</code> para verificar os valores definidos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#combining-subtransactions","title":"Combinando subtransa\u00e7\u00f5es","text":"<p>Voc\u00ea pode mesclar transfer\u00eancias nativas e chamadas de contrato na mesma transa\u00e7\u00e3o em lote. Forne\u00e7a arrays alinhados (mesmo tamanho ou valores padr\u00e3o) para <code>to</code>, <code>value</code>, <code>callData</code> e <code>gasLimit</code>. O precompile cuida do roteamento e garante a execu\u00e7\u00e3o conforme a fun\u00e7\u00e3o escolhida (<code>batchSome</code>, <code>batchSomeUntilFailure</code> ou <code>batchAll</code>).</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/batch/#ethereum-development-libraries","title":"Bibliotecas de desenvolvimento Ethereum","text":"<p>As fun\u00e7\u00f5es do precompile tamb\u00e9m podem ser usadas por bibliotecas:</p> Ethers.jsWeb3.jsWeb3.py <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Use ABI to create an interface\nconst yourContractInterface = new ethers.Interface(abi);\n\n// Find call data for the setMessage function\nconst callData = yourContractInterface.encodeFunctionData(\n  'INSERT_FUNCTION_NAME',\n  [\n    'INSERT_INPUT_1',\n    'INSERT_INPUT_2',\n    // ...\n  ]\n);\n</code></pre> <pre><code>// Import the contract ABI\nconst { abi } = require('./INSERT_ABI_PATH');\n\n// Find call data for the setMessage function\nconst callData = web3.eth.abi.encodeFunctionCall(abi, [\n  'INSERT_INPUT_1',\n  'INSERT_INPUT_2',\n  // ...\n]);\n</code></pre> <pre><code># Import the ABI and bytecode\nfrom compile import abi, bytecode\n\n# Create contract instance\nyour_contract = web3.eth.contract(abi=abi, bytecode=bytecode)\n\n# Encode the contract call\ncall_data = your_contract.encodeABI(\n    fn_name=\"INSERT_FUNCTION_NAME\", args=[\"INSERT_INPUT_1\", \"INSERT_INPUT_2\", ...]\n)\n</code></pre> <p>Nota</p> <p>Adapte os exemplos para produ\u00e7\u00e3o e garanta valida\u00e7\u00e3o de entradas, controle de g\u00e1s e tratamento de erros adequados.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/","title":"Interagindo com o Call Permit Precompile","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O Call Permit Precompile permite que um usu\u00e1rio assine um permit EIP-712 para qualquer chamada EVM, que pode ser despachada por qualquer pessoa ou contrato inteligente. O despachante paga as taxas, viabilizando transa\u00e7\u00f5es \u201cgasless\u201d para o signat\u00e1rio (desde que a chamada n\u00e3o envie valor).</p> <p>O Call Permit Precompile est\u00e1 localizado no seguinte endere\u00e7o:</p> <pre><code>0x0000000000000000000000000000000000000802\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequ\u00eancias inesperadas. As precompiladas do Tanssi s\u00e3o derivadas das do Moonbeam; portanto, familiarize-se com as considera\u00e7\u00f5es de seguran\u00e7a das precompiladas do Moonbeam.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#the-call-permit-interface","title":"Interface Solidity","text":"<p><code>CallPermit.sol</code> exp\u00f5e tr\u00eas fun\u00e7\u00f5es principais:</p> CallPermit.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The CallPermit contract's address.\naddress constant CALL_PERMIT_ADDRESS = 0x0000000000000000000000000000000000000802;\n\n/// @dev The CallPermit contract's instance.\nCallPermit constant CALL_PERMIT_CONTRACT = CallPermit(CALL_PERMIT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title Call Permit Interface\n/// @dev The interface aims to be a general-purpose tool to perform gas-less transactions. It uses the EIP-712 standard,\n/// and signed messages can be dispatched by another network participant with a transaction\n/// @custom:address 0x0000000000000000000000000000000000000802\ninterface CallPermit {\n    /// @dev Dispatch a call on the behalf of an other user with a EIP712 permit.\n    /// Will revert if the permit is not valid or if the dispatched call reverts or errors (such as\n    /// out of gas).\n    /// If successful the EIP712 nonce is increased to prevent this permit to be replayed.\n    /// @param from Who made the permit and want its call to be dispatched on their behalf.\n    /// @param to Which address the call is made to.\n    /// @param value Value being transferred from the \"from\" account.\n    /// @param data Call data\n    /// @param gaslimit Gaslimit the dispatched call requires.\n    ///     Providing it prevents the dispatcher to manipulate the gaslimit.\n    /// @param deadline Deadline in UNIX seconds after which the permit will no longer be valid.\n    /// @param v V part of the signature.\n    /// @param r R part of the signature.\n    /// @param s S part of the signature.\n    /// @return output Output of the call.\n    /// @custom:selector b5ea0966\n    function dispatch(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint64 gaslimit,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (bytes memory output);\n\n    /// @dev Returns the current nonce for given owner.\n    /// A permit must have this nonce to be consumed, which will\n    /// increase the nonce by one.\n    /// @custom:selector 7ecebe00\n    function nonces(address owner) external view returns (uint256);\n\n    /// @dev Returns the EIP712 domain separator. It is used to avoid replay\n    /// attacks across assets or other similar EIP712 message structures.\n    /// @custom:selector 3644e515\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n</code></pre> <ul> <li>dispatch(from, to, value, data, gasLimit, deadline, v, r, s) \u2014 executa a chamada assinada; falha se o permit for inv\u00e1lido ou se a chamada revertir. Aumenta o nonce do signat\u00e1rio ap\u00f3s sucesso.  </li> <li>nonces(owner) \u2014 retorna o nonce atual de <code>owner</code>.  </li> <li>DOMAIN_SEPARATOR() \u2014 retorna o separador de dom\u00ednio EIP-712 usado para evitar replay.</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#domain_separator-e-assinatura","title":"DOMAIN_SEPARATOR e assinatura","text":"<p>O separador segue o EIP-712 com <code>name = \"Call Permit Precompile\"</code>, <code>version = \"1\"</code>, <code>chainId</code> da rede e o endere\u00e7o do precompile como <code>verifyingContract</code>. A mensagem assinada inclui <code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code> e o <code>nonce</code> atual.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#setup-the-example-contract","title":"Preparar contratos de exemplo","text":"<p>Use o contrato <code>SetMessage.sol</code> para demonstrar:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\ncontract SetMessage {\n    string storedMessage;\n\n    function set(string calldata x) public {\n        storedMessage = x;\n    }\n\n    function get() public view returns (string memory) {\n        return storedMessage;\n    }\n}\n</code></pre> <p>No Remix:</p> <ol> <li>Crie arquivos CallPermit.sol e SetMessage.sol.  </li> <li>Compile ambos.  </li> <li>Implemente SetMessage.sol normalmente.  </li> <li>Acesse o Call Permit Precompile clicando em At Address e informando <code>0x0000000000000000000000000000000000000802</code>.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#generate-call-permit-signature","title":"Gerar a assinatura","text":"<p>Voc\u00ea pode gerar a assinatura com Ethers.js usando EIP-712:</p> <pre><code>import { ethers } from 'ethers';\n\nconst from = 'INSERT_FROM_ADDRESS';\nconst to = 'INSERT_TO_ADDRESS';\nconst value = 0;\nconst data =\n  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';\nconst gaslimit = 100000;\nconst nonce = 'INSERT_SIGNERS_NONCE';\nconst deadline = 'INSERT_DEADLINE';\n\nconst createPermitMessageData = () =&gt; {\n  const message = {\n    from: from,\n    to: to,\n    value: value,\n    data: data,\n    gaslimit: gaslimit,\n    nonce: nonce,\n    deadline: deadline,\n  };\n\n  const typedData = {\n    types: {\n      CallPermit: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'gaslimit', type: 'uint64' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n      ],\n    },\n    primaryType: 'CallPermit',\n    domain: {\n      name: 'Call Permit Precompile',\n      version: '1',\n      chainId: INSERT-CHAIN-ID,\n      verifyingContract: '0x0000000000000000000000000000000000000802',\n    },\n    message: message,\n  };\n\n  return {\n    typedData,\n    message,\n  };\n};\n\nconst messageData = createPermitMessageData();\n\n// For demo purposes only. Never store your private key in a JavaScript/TypeScript file\nconst privateKey = 'INSERT_PRIVATE_KEY';\nconst wallet = new ethers.Wallet(privateKey);\n\nconst signature = await wallet.signTypedData(messageData.typedData.domain, messageData.typedData.types, messageData.message);\n\nconsole.log(`Transaction successful with hash: ${signature}`);\n\nconst ethersSignature = ethers.Signature.from(signature);\nconst formattedSignature = {\n  r: ethersSignature.r,\n  s: ethersSignature.s,\n  v: ethersSignature.v,\n};\n\nconsole.log(formattedSignature);\n</code></pre> <p>Preencha:</p> <ul> <li><code>from</code>: endere\u00e7o que autoriza.  </li> <li><code>to</code>: endere\u00e7o do contrato alvo.  </li> <li><code>value</code>: normalmente <code>0</code> (a menos que envie valor).  </li> <li><code>data</code>: dados da chamada (ABI-encoded).  </li> <li><code>gasLimit</code>: limite de g\u00e1s desejado para a chamada.  </li> <li><code>deadline</code>: timestamp UNIX em que o permit expira.  </li> <li><code>chainId</code>: ID da rede.  </li> <li><code>nonce</code>: obtido via <code>nonces(from)</code> no precompile.</li> </ul> <p>Execute <code>node getSignature.js</code> e copie <code>v</code>, <code>r</code>, <code>s</code> para usar na chamada <code>dispatch</code>.</p> <p>Remember</p> <p>Guarde chaves privadas em seguran\u00e7a; o exemplo destina-se apenas a testes.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/call-permit/#dispatch-a-call","title":"Despachar a chamada","text":"<ol> <li>No Remix, expanda o contrato Call Permit.  </li> <li>Preencha os mesmos argumentos usados para assinar (<code>from</code>, <code>to</code>, <code>value</code>, <code>data</code>, <code>gasLimit</code>, <code>deadline</code>, <code>v</code>, <code>r</code>, <code>s</code>).  </li> <li>Clique em transact e confirme no MetaMask.  </li> <li>Verifique o efeito no contrato (<code>SetMessage.sol</code> &gt; get deve retornar a nova mensagem).</li> </ol> <p>Parab\u00e9ns! Voc\u00ea assinou e despachou uma chamada com o Call Permit Precompile.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/","title":"Transfer\u00eancias de Tokens Cross-Chain Nativas","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As redes com tecnologia Tanssi possuem comunica\u00e7\u00e3o cross-chain nativa via XCM, permitindo transfer\u00eancias r\u00e1pidas e seguras entre cadeias. O precompile XCM exp\u00f5e uma interface de contrato que abstrai a complexidade da camada Substrate, permitindo iniciar transfer\u00eancias cross-chain como qualquer outra chamada de contrato.</p> <p>O precompile XCM est\u00e1 localizado no endere\u00e7o:</p> <pre><code>0x0000000000000000000000000000000000000804\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequ\u00eancias inesperadas. As precompiladas do Tanssi s\u00e3o derivadas das do Moonbeam; portanto, familiarize-se com as considera\u00e7\u00f5es de seguran\u00e7a das precompiladas do Moonbeam.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#the-xcm-solidity-interface","title":"Interface Solidity XCM","text":"<p><code>XCMInterface.sol</code> define as estruturas e fun\u00e7\u00f5es do precompile.</p> XCMInterface.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The XCM contract's address.\naddress constant XCM_CONTRACT_ADDRESS = 0x0000000000000000000000000000000000000804;\n\n/// @dev The XCM contract's instance.\nXCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);\n\n/// @author The Moonbeam Team\n/// @title XCM precompile Interface\n/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.\ninterface XCM {\n    // A location is defined by its number of parents and the encoded junctions (interior)\n    struct Location {\n        uint8 parents;\n        bytes[] interior;\n    }\n\n    // Support for Weights V2\n    struct Weight {\n        uint64 refTime;\n        uint64 proofSize;\n    }\n\n    // A way to represent fungible assets in XCM using Location format\n    struct AssetLocationInfo {\n        Location location;\n        uint256 amount;\n    }\n\n    // A way to represent fungible assets in XCM using address format\n    struct AssetAddressInfo {\n        address asset;\n        uint256 amount;\n    }\n\n    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 59df8416\n    /// @param dest The destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on dest.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight) \n    function transferAssetsLocation(\n        Location memory dest,\n        Location memory beneficiary,\n        AssetLocationInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 20 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector b489262e\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara20(\n        uint32 paraId,\n        address beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to a 32 byte-like parachain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector 4461e6f5\n    /// @param paraId The para-id of the destination chain.\n    /// @param beneficiary The actual account that will receive the tokens on paraId destination.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToPara32(\n        uint32 paraId,\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n\n    /// @dev Function to send assets via XCM to the relay chain \n    /// using transfer_assets() pallet-xcm extrinsic.\n    /// @custom:selector d7c89659\n    /// @param beneficiary The actual account that will receive the tokens on the relay chain.\n    /// @param assets The combination (array) of assets to send.\n    /// @param feeAssetItem The index of the asset that will be used to pay for fees.\n    /// @param weight The weight to be used for the whole XCM operation.\n    /// (uint64::MAX in refTime means Unlimited weight)\n    function transferAssetsToRelay(\n        bytes32 beneficiary,\n        AssetAddressInfo[] memory assets,\n        uint32 feeAssetItem,\n        Weight memory weight\n    ) external;\n}\n</code></pre> <p>Principais fun\u00e7\u00f5es:</p> transferAssetsToPara20(paraId, beneficiary, assets, feeAssetItem, weight) \u2014 envia ativos para outra rede compat\u00edvel com EVM Par\u00e2metros <ul> <li><code>paraId</code> ++uint32++ \u2014 ID da rede de destino  </li> <li><code>beneficiary</code> ++address++ \u2014 conta ECDSA na cadeia de destino  </li> <li><code>assets</code> ++AssetAddressInfo[]++ \u2014 lista de ativos e quantidades  </li> <li><code>feeAssetItem</code> ++uint32++ \u2014 \u00edndice do ativo usado para taxas  </li> <li><code>weight</code> ++Weight++ \u2014 peso m\u00e1ximo (g\u00e1s); <code>uint64::MAX</code> em <code>refTime</code> equivale a ilimitado  </li> </ul> transferAssetsToPara32(paraId, beneficiary, assets, feeAssetItem, weight) \u2014 envia ativos para uma rede Substrate Par\u00e2metros <ul> <li><code>paraId</code> ++uint32++ \u2014 ID da rede de destino  </li> <li><code>beneficiary</code> ++bytes32++ \u2014 conta SR25519 na cadeia de destino  </li> <li><code>assets</code> ++AssetAddressInfo[]++ \u2014 lista de ativos e quantidades  </li> <li><code>feeAssetItem</code> ++uint32++ \u2014 \u00edndice do ativo usado para taxas  </li> <li><code>weight</code> ++Weight++ \u2014 peso m\u00e1ximo  </li> </ul> transferAssetsToRelay(beneficiary, assets, feeAssetItem, weight) \u2014 envia ativos para a relay chain transferAssetsLocation(dest, beneficiary, assets, feeAssetItem, weight) \u2014 envia ativos usando multilocations gen\u00e9ricos"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#interact-with-the-solidity-interface","title":"Interaja com a interface Solidity","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#checking-prerequisites","title":"Pr\u00e9-requisitos","text":"<ul> <li>Carteira EVM configurada e conta com tokens nativos.  </li> <li>Canais XCM configurados com a cadeia de destino (veja Gerenciar canais cross-chain).  </li> <li>Se o token for nativo da sua rede, a cadeia de destino deve registrar o ativo estrangeiro.</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#remix-set-up","title":"Configura\u00e7\u00e3o no Remix","text":"<ol> <li>Abra Remix.  </li> <li>Crie XcmInterface.sol com o conte\u00fado da interface.  </li> <li>Compile em Compile XCMInterface.sol.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#access-the-contract","title":"Acesse o precompile","text":"<ol> <li>Aba Deploy and Run \u2192 Injected Provider - MetaMask.  </li> <li>Selecione XCM - XcmInterface.sol em CONTRACT.  </li> <li>No campo At Address, informe <code>0x0000000000000000000000000000000000000804</code> e clique At Address. O contrato aparecer\u00e1 em Deployed Contracts.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-evm-chains","title":"Enviar tokens para outra rede EVM","text":"<ol> <li>Expanda transferAssetsToPara20.  </li> <li>Preencha <code>paraId</code>, <code>beneficiary</code> (endere\u00e7o EVM), <code>assets</code> (ex.: <code>[[ \"0x0000000000000000000000000000000000000800\", 1000000000000000000 ]]</code>), <code>feeAssetItem</code> e <code>weight</code>.  </li> <li>Clique transact e confirme no MetaMask. Aguarde alguns blocos para o saldo chegar \u00e0 cadeia de destino.</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-substrate-chains","title":"Enviar tokens para uma rede Substrate","text":"<p>Use transferAssetsToPara32 com <code>beneficiary</code> SR25519 (bytes32) e demais campos an\u00e1logos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-to-relay-chain","title":"Enviar tokens para a relay chain","text":"<p>Use transferAssetsToRelay com <code>beneficiary</code> SR25519, <code>assets</code>, <code>feeAssetItem</code>, <code>weight</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/#transfer-locations","title":"Usar multilocations gen\u00e9ricas","text":"<p>transferAssetsLocation aceita <code>dest</code>, <code>beneficiary</code> e <code>assets</code> como multilocations XCM, permitindo destinos mais gen\u00e9ricos. Preencha os arrays conforme a multilocation desejada, o \u00edndice do ativo para taxas e o <code>weight</code>, ent\u00e3o chame transact.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/","title":"Pr\u00e9-compilado ERC-20 do Token Nativo","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O contrato precompilado ERC-20 do token nativo em redes EVM com Tanssi permite que os desenvolvedores interajam com o token nativo do protocolo por meio de uma interface ERC-20. Embora o token nativo da sua rede n\u00e3o seja um ERC-20, agora voc\u00ea pode interagir com ele como se fosse um ERC-20 puro.</p> <p>Um dos principais benef\u00edcios dessa precompilada \u00e9 eliminar a necessidade de ter uma representa\u00e7\u00e3o embrulhada do token do protocolo como um smart contract ERC-20, como o WETH no Ethereum. Al\u00e9m disso, ela minimiza a necessidade de m\u00faltiplas representa\u00e7\u00f5es embrulhadas do mesmo token do protocolo. Consequentemente, dApps que precisam interagir com o token do protocolo via interface ERC-20 podem faz\u00ea-lo sem precisar de um contrato separado.</p> <p>Por baixo dos panos, a precompilada ERC-20 executa a\u00e7\u00f5es espec\u00edficas do Substrate relacionadas ao m\u00f3dulo de saldos do Substrate, escrito em Rust. O m\u00f3dulo de saldos fornece funcionalidades para lidar com diversos tipos de saldos.</p> <p>Este guia mostrar\u00e1 como interagir com os tokens UNIT, os tokens nativos do protocolo para redes de teste r\u00e1pido no Dancelight, por meio da precompilada ERC-20. Voc\u00ea pode seguir e adaptar este guia para interagir com a sua pr\u00f3pria rede.</p> <p>A precompilada est\u00e1 localizada no endere\u00e7o:</p> <pre><code>0x0000000000000000000000000000000000000800\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequ\u00eancias inesperadas. As precompiladas do Tanssi s\u00e3o derivadas das do Moonbeam; portanto, familiarize-se com as considera\u00e7\u00f5es de seguran\u00e7a das precompiladas do Moonbeam.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#the-erc20-interface","title":"Interface Solidity do ERC-20","text":"<p>A interface <code>ERC20.sol</code> nas redes EVM do Tanssi segue o Padr\u00e3o de Token EIP-20, que define as fun\u00e7\u00f5es e eventos exigidos para um token interoperar com diferentes aplica\u00e7\u00f5es.</p> ERC20.sol <pre><code>/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n</code></pre> <p>Nota</p> <p>A precompilada ERC-20 n\u00e3o inclui as fun\u00e7\u00f5es <code>deposit</code> e <code>withdraw</code> nem os eventos associados esperados de um token embrulhado, como o WETH.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#interact-with-the-solidity-interface","title":"Interagir com a interface Solidity","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para acompanhar este tutorial, voc\u00ea precisar\u00e1 ter sua carteira configurada para funcionar com sua rede EVM com Tanssi e uma conta financiada com tokens nativos. Voc\u00ea pode adicionar sua rede EVM ao MetaMask com um clique no Tanssi dApp ou configurar o MetaMask para Tanssi com a rede EVM de demonstra\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#add-token-to-evm-wallet","title":"Adicionar token a uma carteira EVM","text":"<p>Se quiser interagir com o token nativo da rede como um ERC-20, adicione um token personalizado \u00e0 sua carteira compat\u00edvel com EVM usando o endere\u00e7o da precompilada. Esta se\u00e7\u00e3o mostra como adicionar um ativo externo ao MetaMask.</p> <p>Para come\u00e7ar, abra o MetaMask, certifique-se de estar conectado \u00e0 sua rede e:</p> <ol> <li>Acesse a aba Assets</li> <li>Clique em Import tokens</li> </ol> <p></p> <p>Agora, crie o token personalizado:</p> <ol> <li>Informe o endere\u00e7o da precompilada \u2014 <code>0x0000000000000000000000000000000000000800</code>. Ao inserir o endere\u00e7o, os campos Token Symbol e Token Decimal devem ser preenchidos automaticamente. Caso n\u00e3o aconte\u00e7a, use <code>UNIT</code> como s\u00edmbolo e <code>18</code> para casas decimais (o padr\u00e3o das redes EVM do Tanssi, igual ao Ethereum)</li> <li>Clique em Next</li> </ol> <p></p> <p>O MetaMask solicitar\u00e1 a confirma\u00e7\u00e3o da importa\u00e7\u00e3o. Revise os detalhes e clique em Import Tokens para importar os tokens UNIT para sua carteira.</p> <p></p> <p>Pronto! Voc\u00ea adicionou o token UNIT como um ERC-20 personalizado na sua rede EVM do Tanssi.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#remix-set-up","title":"Configura\u00e7\u00e3o do Remix","text":"<p>Voc\u00ea pode interagir com a precompilada ERC-20 usando o Remix. Para adicion\u00e1-la ao Remix, voc\u00ea precisar\u00e1:</p> <ol> <li>Obter uma c\u00f3pia do <code>ERC20.sol</code></li> <li>Colar o conte\u00fado em um arquivo chamado <code>IERC20.sol</code> no Remix</li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#compile-the-contract","title":"Compilar o contrato","text":"<p>Em seguida, compile a interface no Remix:</p> <ol> <li>Clique na aba Compile (segunda de cima para baixo)</li> <li>Compile a interface clicando em Compile IERC20.sol</li> </ol> <p></p> <p>Quando a compila\u00e7\u00e3o terminar, aparecer\u00e1 um check verde ao lado da aba Compile.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#access-the-contract","title":"Acessar o contrato","text":"<p>Em vez de implantar a precompilada, voc\u00ea acessar\u00e1 a interface informando o endere\u00e7o do contrato j\u00e1 disponibilizado:</p> <ol> <li>Clique na aba Deploy and Run logo abaixo de Compile no Remix. Lembre-se de que contratos precompilados j\u00e1 est\u00e3o acess\u00edveis em seus endere\u00e7os, portanto n\u00e3o h\u00e1 etapa de implanta\u00e7\u00e3o</li> <li>Certifique-se de que Injected Web3 est\u00e1 selecionado em ENVIRONMENT. Ao escolher Injected Web3, o MetaMask pode solicitar conex\u00e3o com o Remix caso ainda n\u00e3o esteja</li> <li>Verifique se a conta correta aparece em ACCOUNT</li> <li>Garanta que IERC20 - IERC20.sol esteja selecionado em CONTRACT. Como \u00e9 um contrato precompilado, n\u00e3o h\u00e1 implanta\u00e7\u00e3o; voc\u00ea informar\u00e1 o endere\u00e7o da precompilada em At Address</li> <li>Informe o endere\u00e7o da precompilada ERC-20: <code>0x0000000000000000000000000000000000000800</code> e clique em At Address</li> </ol> <p></p> <p>A precompilada IERC20 aparecer\u00e1 na lista de Deployed Contracts.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#get-basic-token-information","title":"Obter informa\u00e7\u00f5es b\u00e1sicas do token","text":"<p>A interface ERC-20 permite obter rapidamente informa\u00e7\u00f5es como oferta total, nome, s\u00edmbolo e casas decimais. Para isso:</p> <ol> <li>Expanda o contrato IERC20 em Deployed Contracts</li> <li>Clique em decimals para obter as casas decimais do token nativo</li> <li>Clique em name para obter o nome do token</li> <li>Clique em symbol para obter o s\u00edmbolo do token</li> <li>Clique em totalSupply para obter a oferta total de tokens nativos na rede</li> </ol> <p></p> <p>Os resultados de cada chamada aparecem sob as respectivas fun\u00e7\u00f5es.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#get-account-balance","title":"Consultar saldo de uma conta","text":"<p>Para checar o saldo de qualquer endere\u00e7o na rede usando <code>balanceOf</code>:</p> <ol> <li>Expanda a fun\u00e7\u00e3o balanceOf</li> <li>Informe o endere\u00e7o a consultar em owner</li> <li>Clique em call</li> </ol> <p></p> <p>O saldo ser\u00e1 exibido abaixo da fun\u00e7\u00e3o <code>balanceOf</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#approve-a-spend","title":"Aprovar um gasto","text":"<p>Para aprovar uma autoriza\u00e7\u00e3o de gasto, forne\u00e7a um endere\u00e7o para o spender e o n\u00famero de tokens permitidos. O spender pode ser uma EOA ou um contrato inteligente. Exemplo: autorizar 1 UNIT.</p> <ol> <li>Expanda approve</li> <li>Insira o endere\u00e7o do spender (use a segunda conta criada)</li> <li>Informe o valor que o spender pode gastar em value. Exemplo: 1 UNIT em Wei (<code>1000000000000000000</code>)</li> <li>Clique em transact</li> <li>O MetaMask abrir\u00e1 para voc\u00ea revisar e confirmar a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Ap\u00f3s a confirma\u00e7\u00e3o, o saldo da sua conta permanece o mesmo porque apenas a permiss\u00e3o foi concedida; nenhum gasto foi feito. Na pr\u00f3xima se\u00e7\u00e3o, usaremos <code>allowance</code> para verificar a permiss\u00e3o.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#get-allowance-of-spender","title":"Verificar a permiss\u00e3o do spender","text":"<p>Para checar se o spender recebeu a autoriza\u00e7\u00e3o:</p> <ol> <li>Expanda allowance</li> <li>Informe seu endere\u00e7o em owner</li> <li>Informe o endere\u00e7o do spender usado anteriormente</li> <li>Clique em call</li> </ol> <p></p> <p>O valor exibido deve equivaler a 1 UNIT (<code>1000000000000000000</code>).</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#send-transfer","title":"Enviar transfer\u00eancia padr\u00e3o","text":"<p>Para enviar tokens diretamente da sua conta a outra:</p> <ol> <li>Expanda transfer</li> <li>Insira o endere\u00e7o de destino</li> <li>Informe a quantidade de UNIT a enviar (ex.: 1 UNIT = <code>1000000000000000000</code>)</li> <li>Clique em transact</li> <li>Confirme a transa\u00e7\u00e3o no MetaMask</li> </ol> <p></p> <p>Ap\u00f3s a conclus\u00e3o, verifique seu saldo via <code>balanceOf</code> ou no MetaMask. O saldo deve ter diminu\u00eddo em 1 UNIT, e o destinat\u00e1rio deve ter recebido 1 UNIT.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/erc20/#send-transferfrom","title":"Enviar transfer\u00eancia a partir de uma conta espec\u00edfica","text":"<p>At\u00e9 agora, voc\u00ea aprovou 1 UNIT para o spender e enviou 1 UNIT com <code>transfer</code>. A fun\u00e7\u00e3o <code>transferFrom</code> permite definir de qual endere\u00e7o sair\u00e3o os tokens. Para este exemplo, use a conta do spender para transferir o valor autorizado do owner para o spender.</p> <p>Primeiro, mude para a conta do spender no MetaMask; o endere\u00e7o selecionado em Remix ser\u00e1 o do spender.</p> <p></p> <p>Em seguida, envie a transfer\u00eancia:</p> <ol> <li>Expanda transferFrom</li> <li>Informe seu endere\u00e7o como owner no campo from</li> <li>Informe o destinat\u00e1rio (o spender) no campo to</li> <li>Informe a quantidade de UNIT (a autoriza\u00e7\u00e3o \u00e9 de 1 UNIT, ent\u00e3o use <code>1000000000000000000</code>)</li> <li>Clique em transact</li> </ol> <p></p> <p>Depois da transa\u00e7\u00e3o, confira o saldo do owner e do spender com <code>balanceOf</code>. O saldo do spender ter\u00e1 aumentado em 1 UNIT e a permiss\u00e3o ter\u00e1 sido consumida. Para confirmar que n\u00e3o h\u00e1 mais permiss\u00e3o, chame <code>allowance</code> passando os endere\u00e7os do owner e do spender; o resultado deve ser 0.</p> <p></p> <p>E \u00e9 isso! Voc\u00ea interagiu com a precompilada ERC-20 usando MetaMask e Remix.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/","title":"Ativos Externos como ERC-20","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Como apresentado no artigo Comunica\u00e7\u00e3o Cross-Chain Nativa, as redes implantadas atrav\u00e9s do Tanssi podem se comunicar e interagir com qualquer outra rede no ecossistema. Este ambiente multi-chain leva a um mundo multi-ativo, onde a transfer\u00eancia perfeita de ativos, dados e valor entre diferentes redes amplia as possibilidades de construir casos de uso em diversos setores, como finan\u00e7as (DeFi), ativos do mundo real (RWAs) e outros.</p> <p>Ativos externos s\u00e3o tokens nativos de outra blockchain, ou, em outras palavras, ativos cuja cadeia de reserva n\u00e3o \u00e9 a cadeia com a qual voc\u00ea est\u00e1 interagindo. As redes Tanssi podem registrar ativos externos para permitir sua entrada. Para fazer isso, \u00e9 necess\u00e1rio estabelecer um canal XCM com a outra cadeia e, em seguida, registrar um de seus ativos nativos como um ativo externo. Os ativos externos registrados se comportam, em certa medida, da mesma forma que os locais.</p> <p>A pr\u00e9-compila\u00e7\u00e3o de ativos ERC-20 permite que as redes baseadas no modelo Tanssi EVM acessem qualquer ativo externo registrado atrav\u00e9s da interface ERC-20 padr\u00e3o. Consequentemente, contratos inteligentes implantados na rede podem interagir com esses ativos da mesma forma que fariam com qualquer outro ERC-20 regular.</p> <p>O endere\u00e7o que representa o contrato ERC-20 \u00e9 formado com as primeiras trinta e seis posi\u00e7\u00f5es (dezoito bytes) definidas para o valor m\u00e1ximo e as \u00faltimas quatro posi\u00e7\u00f5es (dois bytes) substitu\u00eddas pela representa\u00e7\u00e3o hexadecimal do identificador de ativo registrado:</p> <p>Por exemplo, para o ativo cujo ID \u00e9 <code>1</code>, as \u00faltimas quatro posi\u00e7\u00f5es devem ser substitu\u00eddas por <code>0001</code>, e para um ativo com um ID de <code>10</code>, essas quatro posi\u00e7\u00f5es devem ser substitu\u00eddas por <code>000A</code>.</p> <p>--8\\&lt;-- 'text/pt/builders/toolkit/ethereum-api/precompiles/security-note.md'</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#prerequisites","title":"Pr\u00e9-requisitos","text":"<p>Para acompanhar o conte\u00fado deste guia, voc\u00ea precisar\u00e1:</p> <ul> <li>Acesso a uma rede Tanssi EVM executando runtime 500 ou superior</li> <li>Um canal XCM bidirecional estabelecido para outra cadeia. Para gerenciar os canais da sua rede, consulte o artigo Gerenciar Canais de Comunica\u00e7\u00e3o Cross-Chain</li> <li>Um ativo externo registrado. Uma vez que os canais XCM estejam abertos, o registro de ativos pode ser facilmente feito usando o dApp, conforme explicado no guia Registrar Ativos Externos</li> <li>Finalmente, voc\u00ea precisar\u00e1 de uma carteira compat\u00edvel com EVM configurada para funcionar com sua rede. Voc\u00ea tamb\u00e9m pode conectar sua carteira \u00e0 rede demo EVM.</li> </ul> <p>Os exemplos neste guia s\u00e3o baseados na rede demo Tanssi EVM, que j\u00e1 possui canais abertos para outras redes e ativos externos registrados, como mostra a imagem a seguir:</p> <ol> <li>O ativo externo registrado (UNIT) que ser\u00e1 usado nas se\u00e7\u00f5es a seguir</li> <li>Outros ativos externos dispon\u00edveis ainda n\u00e3o registrados</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#the-erc20-interface","title":"A Interface Solidity ERC-20","text":"<p>A interface <code>ERC20.sol</code> nas redes Tanssi EVM segue o EIP-20 Token Standard, que \u00e9 a interface API padr\u00e3o para tokens dentro de contratos inteligentes. O padr\u00e3o define as fun\u00e7\u00f5es e eventos necess\u00e1rios que um contrato de token deve implementar para ser interoper\u00e1vel com diferentes aplica\u00e7\u00f5es.</p> ERC20.sol <pre><code>    ```solidity\n\n/ SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @dev The IERC20 contract's address.\naddress constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The IERC20 contract's instance.\nIERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);\n\n/// @title ERC20 interface\n/// @dev see https://github.com/ethereum/EIPs/issues/20\n/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface IERC20 {\n    /// @dev Returns the name of the token.\n    /// @custom:selector 06fdde03\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    /// @custom:selector 95d89b41\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    /// @custom:selector 313ce567\n    function decimals() external view returns (uint8);\n\n    /// @dev Total number of tokens in existence\n    /// @custom:selector 18160ddd\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Gets the balance of the specified address.\n    /// @custom:selector 70a08231\n    /// @param owner The address to query the balance of.\n    /// @return An uint256 representing the amount owned by the passed address.\n    function balanceOf(address owner) external view returns (uint256);\n\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n    /// @custom:selector dd62ed3e\n    /// @param owner address The address which owns the funds.\n    /// @param spender address The address which will spend the funds.\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Transfer token for a specified address\n    /// @custom:selector a9059cbb\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\n    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    /// @custom:selector 095ea7b3\n    /// @param spender The address which will spend the funds.\n    /// @param value The amount of tokens to be spent.\n    /// @return true, this cannot fail\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /// @dev Transfer tokens from one address to another\n    /// @custom:selector 23b872dd\n    /// @param from address The address which you want to send tokens from\n    /// @param to address The address which you want to transfer to\n    /// @param value uint256 the amount of tokens to be transferred\n    /// @return true if the transfer was succesful, revert otherwise.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /// @dev Event emited when a transfer has been performed.\n    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n    /// @param from address The address sending the tokens\n    /// @param to address The address receiving the tokens.\n    /// @param value uint256 The amount of tokens transfered.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Event emited when an approval has been registered.\n    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n    /// @param owner address Owner of the tokens.\n    /// @param spender address Allowed spender.\n    /// @param value uint256 Amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/// @title Native currency wrapper interface.\n/// @dev Allow compatibility with dApps expecting this precompile to be\n/// a WETH-like contract.\ninterface WrappedNativeCurrency {\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Returns funds to sender as this precompile tokens and the native tokens are the same.\n    /// @custom:selector d0e30db0\n    function deposit() external payable;\n\n    /// @dev Provide compatibility for contracts that expect wETH design.\n    /// Does nothing.\n    /// @custom:selector 2e1a7d4d\n    /// @param value uint256 The amount to withdraw/unwrap.\n    function withdraw(uint256 value) external;\n\n    /// @dev Event emited when deposit() has been called.\n    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"wrapped\".\n    event Deposit(address indexed owner, uint256 value);\n\n    /// @dev Event emited when withdraw(uint256) has been called.\n    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65\n    /// @param owner address Owner of the tokens\n    /// @param value uint256 The amount of tokens \"unwrapped\".\n    event Withdrawal(address indexed owner, uint256 value);\n}\n\n    ```\n</code></pre> <p>Nota</p> <p>A pr\u00e9-compila\u00e7\u00e3o de ativos externos ERC-20 n\u00e3o inclui fun\u00e7\u00f5es <code>deposit</code> e <code>withdraw</code> e eventos subsequentes esperados de um contrato de token embrulhado, como WETH.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#add-token-to-evm-wallet","title":"Adicionar Token \u00e0 uma Carteira EVM","text":"<p>Se voc\u00ea quiser interagir com os ativos externos registrados da sua rede como faria com um ERC-20, pode adicion\u00e1-los \u00e0 sua carteira usando o prefixo de endere\u00e7o de pr\u00e9-compila\u00e7\u00e3o e o ID do ativo. Esta se\u00e7\u00e3o ir\u00e1 gui\u00e1-lo atrav\u00e9s da adi\u00e7\u00e3o de um ativo externo ao MetaMask.</p> <p>Para come\u00e7ar, abra o MetaMask e certifique-se de que voc\u00ea est\u00e1 conectado \u00e0 sua rede e:</p> <ol> <li> <p>V\u00e1 para a aba Tokens</p> </li> <li> <p>Clique em Importar tokens</p> </li> </ol> <p></p> <p>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001</p> <p>```</p> <ol> <li>Insira o endere\u00e7o de pr\u00e9-compila\u00e7\u00e3o para o endere\u00e7o do contrato do token. Ao inserir o endere\u00e7o, os campos S\u00edmbolo do token e Decimais do token devem ser preenchidos automaticamente. Se n\u00e3o preencherem, voc\u00ea pode inserir <code>UNIT</code> para o s\u00edmbolo e <code>12</code> para as casas decimais</li> <li>Clique em Pr\u00f3ximo</li> </ol> <p></p> <p>MetaMask solicitar\u00e1 que voc\u00ea confirme a importa\u00e7\u00e3o. Voc\u00ea pode verificar os detalhes do token e clicar em Importar tokens para importar tokens UNIT para sua carteira.</p> <p></p> <p>E \u00e9 isso! Voc\u00ea adicionou com sucesso o ativo externo do token UNIT como um token ERC-20 personalizado na rede demo Tanssi EVM.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#interact-with-the-solidity-interface-via-remix","title":"Interagir com a interface Solidity via Remix","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#remix-set-up","title":"Configura\u00e7\u00e3o do Remix","text":"<p>Voc\u00ea pode interagir com a pr\u00e9-compila\u00e7\u00e3o de ativos externos ERC-20 usando Remix. Para adicionar a pr\u00e9-compila\u00e7\u00e3o ao Remix, voc\u00ea precisar\u00e1:</p> <ol> <li>Obter uma c\u00f3pia de <code>ERC20.sol</code></li> <li>Cole o conte\u00fado do arquivo em um arquivo Remix chamado <code>IERC20.sol</code></li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#compile-the-contract","title":"Compilar o contrato","text":"<p>Em seguida, voc\u00ea precisar\u00e1 compilar a interface no Remix:</p> <ol> <li>Clique na aba Compilar, a segunda de cima</li> <li>Compile a interface clicando em Compilar IERC20.sol</li> </ol> <p></p> <p>Quando a compila\u00e7\u00e3o for conclu\u00edda, voc\u00ea ver\u00e1 uma marca de sele\u00e7\u00e3o verde ao lado da aba Compilar.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#access-the-contract","title":"Acessar o contrato","text":"<p>Em vez de implantar o contrato inteligente, voc\u00ea acessar\u00e1 a interface atrav\u00e9s do endere\u00e7o da pr\u00e9-compila\u00e7\u00e3o de ativos externos:</p> <ol> <li>Clique na aba Deploy and Run diretamente abaixo da aba Compilar no Remix. Observe que os contratos pr\u00e9-compilados j\u00e1 est\u00e3o acess\u00edveis em seus respectivos endere\u00e7os. Portanto, n\u00e3o h\u00e1 nenhuma etapa de implanta\u00e7\u00e3o</li> <li>Certifique-se de que Injected Web3 esteja selecionado no menu suspenso ENVIRONMENT. Depois de selecionar Injected Web3, voc\u00ea pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ela ainda n\u00e3o esteja conectada</li> <li>Certifique-se de que a conta correta seja exibida em ACCOUNT</li> <li>Certifique-se de que IERC20 - IERC20.sol esteja selecionado no menu suspenso CONTRACT. Dado que \u00e9 um contrato pr\u00e9-compilado, n\u00e3o h\u00e1 nenhuma etapa de implanta\u00e7\u00e3o. Em vez disso, voc\u00ea fornecer\u00e1 o endere\u00e7o da pr\u00e9-compila\u00e7\u00e3o no campo At Address</li> <li>Forne\u00e7a o endere\u00e7o da pr\u00e9-compila\u00e7\u00e3o ERC-20 (que \u00e9 <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001</code> neste exemplo) e clique em At Address</li> <li>A pr\u00e9-compila\u00e7\u00e3o IERC20 aparecer\u00e1 na lista de Deployed Contracts</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-basic-token-information","title":"Obter informa\u00e7\u00f5es b\u00e1sicas do token","text":"<p>A interface ERC-20 permite obter rapidamente informa\u00e7\u00f5es sobre o token, incluindo a oferta total do token, nome, s\u00edmbolo e casas decimais. Voc\u00ea pode recuperar essas informa\u00e7\u00f5es seguindo estas etapas:</p> <ol> <li>Expanda o contrato IERC20 em Deployed Contracts</li> <li>Clique em decimals para obter as casas decimais do token do protocolo nativo da sua rede</li> <li>Clique em name para obter o nome do token</li> <li>Clique em symbol para obter o s\u00edmbolo do token</li> <li>Clique em totalSupply para obter a oferta total de tokens nativos em sua rede</li> </ol> <p></p> <p>Os resultados de cada chamada de fun\u00e7\u00e3o s\u00e3o exibidos sob as respectivas fun\u00e7\u00f5es.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#get-account-balance","title":"Obter Saldo da Conta","text":"<p>Voc\u00ea pode verificar o saldo de qualquer endere\u00e7o em sua rede chamando a fun\u00e7\u00e3o <code>balanceOf</code> e passando um endere\u00e7o:</p> <ol> <li>Expanda a fun\u00e7\u00e3o balanceOf</li> <li>Insira um endere\u00e7o para o qual voc\u00ea gostaria de verificar o saldo para o owner</li> <li>Clique em call</li> </ol> <p></p> <p>Seu saldo ser\u00e1 exibido na fun\u00e7\u00e3o <code>balanceOf</code>.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/#send-transfer","title":"Enviar transfer\u00eancia","text":"<p>Para enviar tokens da sua conta diretamente para outra conta, voc\u00ea pode chamar a fun\u00e7\u00e3o <code>transfer</code> seguindo estas etapas:</p> <ol> <li>Expanda a fun\u00e7\u00e3o transfer</li> <li>Insira o endere\u00e7o para enviar tokens UNIT</li> <li>Insira a quantidade de tokens UNIT para enviar. Para este exemplo, voc\u00ea pode enviar 1 token UNIT (<code>1000000000000</code>)</li> <li>Clique em transact</li> <li>O MetaMask aparecer\u00e1 e voc\u00ea ser\u00e1 solicitado a revisar os detalhes da transa\u00e7\u00e3o. Clique em Confirmar para enviar a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Assim que a transa\u00e7\u00e3o for conclu\u00edda, voc\u00ea poder\u00e1 verificar seu saldo usando a fun\u00e7\u00e3o <code>balanceOf</code> ou olhando para o MetaMask. Voc\u00ea notar\u00e1 que seu saldo diminuiu em 1 token UNIT. Voc\u00ea tamb\u00e9m pode usar a fun\u00e7\u00e3o <code>balanceOf</code> para garantir que o saldo dos destinat\u00e1rios tenha aumentado em 1 token UNIT, conforme o esperado.</p> <p>E \u00e9 isso! Voc\u00ea interagiu com sucesso com a pr\u00e9-compila\u00e7\u00e3o de ativos externos ERC-20 usando MetaMask e Remix!</p> <p>--8\\&lt;-- 'text/pt/_disclaimers/third-party-content.pt.md'</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/","title":"Interagindo com o Proxy Precompile","text":""},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A Proxy Precompile permite que as contas definam contas proxy por meio da API Ethereum. As contas proxy podem realizar a\u00e7\u00f5es limitadas em nome da conta com proxy, como governan\u00e7a, transfer\u00eancias de saldo, gerenciamento ou transa\u00e7\u00f5es privilegiadas, entre outras.</p> <p>Se um usu\u00e1rio quisesse fornecer a outro usu\u00e1rio acesso a um n\u00famero limitado de a\u00e7\u00f5es em seu nome, tradicionalmente, o \u00fanico m\u00e9todo para faz\u00ea-lo seria compartilhar a chave privada dessa conta. No entanto, as redes EVM com tecnologia Tanssi incluem o m\u00f3dulo proxy, fornecendo uma camada adicional de seguran\u00e7a. Com proxies, muitas contas podem realizar a\u00e7\u00f5es para uma conta prim\u00e1ria, e tais permiss\u00f5es podem ser revogadas a qualquer momento. Isto \u00e9 melhor se, por exemplo, um usu\u00e1rio quiser manter sua carteira segura em armazenamento a frio, mas ainda quiser acessar partes da funcionalidade da carteira, como governan\u00e7a ou staking.</p> <p>Nota</p> <p>O Proxy Precompile s\u00f3 pode ser chamado de uma Externally Owned Account (EOA) ou pela Batch Precompile.</p> <p>Para saber mais sobre contas proxy e como configur\u00e1-las para seus pr\u00f3prios prop\u00f3sitos sem o uso do Proxy Precompile, visite a p\u00e1gina Proxy Accounts.</p> <p>A Proxy Precompile est\u00e1 localizada no seguinte endere\u00e7o:</p> <pre><code>0x0000000000000000000000000000000000000805\n</code></pre> <p>Note</p> <p>O uso de precompiladas pode trazer consequ\u00eancias inesperadas. As precompiladas do Tanssi s\u00e3o derivadas das do Moonbeam; portanto, familiarize-se com as considera\u00e7\u00f5es de seguran\u00e7a das precompiladas do Moonbeam.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#prerequisites","title":"Pr\u00e9-requisitos","text":"<p>Para acompanhar o conte\u00fado deste guia, voc\u00ea precisar\u00e1:</p> <ul> <li>Acesso a uma rede EVM com tecnologia Tanssi executando runtime 700 ou superior</li> <li>Uma carteira compat\u00edvel com EVM configurada para funcionar com sua rede. Voc\u00ea tamb\u00e9m pode conectar sua carteira \u00e0 rede EVM de demonstra\u00e7\u00e3o</li> <li>Uma conta com fundos suficientes para pagar as taxas e dep\u00f3sitos necess\u00e1rios</li> <li>Uma segunda conta que voc\u00ea controla para usar como proxy</li> </ul>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#the-proxy-solidity-interface","title":"A Interface Solidity do Proxy","text":"<p><code>Proxy.sol</code> \u00e9 uma interface que permite que desenvolvedores interajam com as fun\u00e7\u00f5es da precompila\u00e7\u00e3o.</p> Proxy.sol <pre><code>// SPDX-License-Identifier: GPL-3.0-only\npragma solidity &gt;=0.8.3;\n\n/// @author The Moonsong Labs Team\n/// @title Pallet Proxy Interface\n/// @title The interface through which solidity contracts will interact with the Proxy pallet\ninterface Proxy {\n    /// @dev Defines the proxy permission types.\n    /// The values start at `0` (most permissive) and are represented as `uint8`\n    enum ProxyType {\n        Any,\n        NonTransfer,\n        Governance,\n        Staking,\n        CancelProxy,\n        Balances,\n        AuthorMapping,\n        IdentityJudgement\n    }\n\n    /// @dev Register a proxy account for the sender that is able to make calls on its behalf\n    /// @custom:selector 74a34dd3\n    /// @param delegate The account that the caller would like to make a proxy\n    /// @param proxyType The permissions allowed for this proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function addProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Removes a proxy account from the sender\n    /// @custom:selector fef3f708\n    /// @param delegate The account that the caller would like to remove as a proxy\n    /// @param proxyType The permissions currently enabled for the removed proxy account\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    function removeProxy(\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external;\n\n    /// @dev Unregister all proxy accounts for the sender\n    /// @custom:selector 14a5b5fa\n    function removeProxies() external;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 0d3cff86\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxy(\n        address real,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender\n    /// is authorised for through `addProxy`\n    /// @custom:selector 685b9d2f\n    /// @param real The account that the proxy will make a call on behalf of\n    /// @param forceProxyType Specify the exact proxy type to be used and checked for this call\n    /// @param callTo Recipient of the call to be made by the `real` account\n    /// @param callData Data of the call to be made by the `real` account\n    function proxyForceType(\n        address real,\n        ProxyType forceProxyType,\n        address callTo,\n        bytes memory callData\n    ) external payable;\n\n    /// @dev Checks if the caller has an account proxied with a given proxy type\n    /// @custom:selector e26d38ed\n    /// @param real The real account that maybe has a proxy\n    /// @param delegate The account that the caller has maybe proxied\n    /// @param proxyType The permissions allowed for the proxy\n    /// @param delay The announcement period required of the initial proxy, will generally be zero\n    /// @return exists True if a proxy exists, False otherwise\n    function isProxy(\n        address real,\n        address delegate,\n        ProxyType proxyType,\n        uint32 delay\n    ) external view returns (bool exists);\n}\n</code></pre> <p>A interface inclui as estruturas de dados necess\u00e1rias, juntamente com as seguintes fun\u00e7\u00f5es:</p> addProxy(delegate, proxyType, delay) \u2014 registra uma conta proxy para o remetente ap\u00f3s um n\u00famero especificado de blocos <code>delay</code> (geralmente zero). Falhar\u00e1 se um proxy para o chamador j\u00e1 existir Par\u00e2metrosExemplo <ul> <li><code>delegate</code> address - o endere\u00e7o do proxy</li> <li><code>proxyType</code> ProxyType - o tipo de delega\u00e7\u00e3o que define as fun\u00e7\u00f5es espec\u00edficas que o proxy ter\u00e1 permiss\u00e3o para executar</li> <li><code>delay</code> uint32 - n\u00famero de blocos a esperar at\u00e9 que o proxy seja habilitado</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxy(delegate, proxyType, delay) \u2014 remove um proxy registrado para o remetente Par\u00e2metrosExemplo <ul> <li><code>delegate</code> address - o endere\u00e7o do proxy a ser removido</li> <li><code>proxyType</code> ProxyType - o tipo de delega\u00e7\u00e3o a ser removido</li> <li><code>delay</code> uint32 - n\u00famero de blocos a esperar at\u00e9 que a remo\u00e7\u00e3o entre em vigor</li> </ul> <ul> <li><code>delegate</code> - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> removeProxies() \u2014 remove todas as contas proxy delegadas ao remetente isProxy(real, delegate, proxyType, delay) \u2014 retorna <code>true</code> se o endere\u00e7o delegado for um proxy do tipo <code>proxyType</code>, para o endere\u00e7o <code>real</code>, com o <code>delay</code> especificado Par\u00e2metrosExemplo <ul> <li><code>real</code> address - a conta que concede permiss\u00f5es ao proxy</li> <li><code>delegate</code> address - o endere\u00e7o do proxy</li> <li><code>proxyType</code> ProxyType - o tipo de delega\u00e7\u00e3o</li> <li><code>delay</code> uint32 - n\u00famero de blocos a aguardar</li> </ul> <ul> <li><code>delegate</code> - 0xbB8919d5DDfc85F4D15820a9e58018f1cfB39a2F</li> <li><code>proxyType</code> - \"Any\"</li> <li><code>delay</code> - 0</li> </ul> <p>O par\u00e2metro <code>proxyType</code> \u00e9 definido pela seguinte enumera\u00e7\u00e3o <code>ProxyType</code>, onde os valores come\u00e7am em <code>0</code> com o tipo de proxy mais permissivo e s\u00e3o representados como valores <code>uint8</code>:</p> <pre><code>enum ProxyType {\n    Any,\n    NonTransfer,\n    Governance,\n    Staking,\n    CancelProxy,\n    Balances,\n    AuthorMapping,\n    IdentityJudgement\n}\n</code></pre>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#proxy-types","title":"Tipos de Proxy","text":"<p>H\u00e1 v\u00e1rios tipos de fun\u00e7\u00f5es de proxy que podem ser delegadas a contas, representadas em <code>Proxy.sol</code> atrav\u00e9s da enumera\u00e7\u00e3o <code>ProxyType</code>. A lista a seguir inclui todos os proxies poss\u00edveis e o tipo de transa\u00e7\u00f5es que eles podem fazer em nome da conta principal:</p> <ul> <li>Any \u2014 o proxy any permitir\u00e1 que a conta proxy fa\u00e7a qualquer tipo de transa\u00e7\u00e3o. Observe que as transfer\u00eancias de saldo s\u00f3 s\u00e3o permitidas para EOAs, n\u00e3o para contratos ou Precompiles</li> <li>NonTransfer \u2014 o proxy de n\u00e3o transfer\u00eancia permite que a conta proxy fa\u00e7a qualquer tipo de transa\u00e7\u00e3o em que o <code>msg.value</code> seja verificado como zero</li> <li>Governance - o proxy de governan\u00e7a permitir\u00e1 que a conta proxy fa\u00e7a qualquer tipo de transa\u00e7\u00e3o relacionada \u00e0 governan\u00e7a</li> <li>CancelProxy - o proxy de cancelamento permitir\u00e1 que a conta proxy rejeite e remova an\u00fancios de proxy atrasados \u200b\u200b(da conta principal). Atualmente, esta n\u00e3o \u00e9 uma a\u00e7\u00e3o suportada pelo Proxy Precompile</li> <li>Balances - o proxy de saldos permitir\u00e1 que a conta proxy fa\u00e7a apenas transfer\u00eancias de saldo para EOAs</li> </ul> <p>Nota</p> <p>A interface Solidity cont\u00e9m mais tipos de proxy do que os listados acima. A lista anterior inclui apenas os tipos de proxy implementados no baseline EVM Template.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#interact-with-the-solidity-interface-via-remix","title":"Interaja com a interface Solidity via Remix","text":"<p>Esta se\u00e7\u00e3o ir\u00e1 gui\u00e1-lo pelas etapas para criar um proxy, verificar sua cria\u00e7\u00e3o e revogar os privil\u00e9gios do proxy. Estes exemplos s\u00e3o baseados na Tanssi demo EVM Network e usam Metamask. Este guia pode ser adaptado para sua pr\u00f3pria rede EVM com tecnologia Tanssi adicionando a URL RPC da sua rede para a carteira EVM de sua escolha.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#remix-set-up","title":"Configura\u00e7\u00e3o do Remix","text":"<p>Voc\u00ea pode interagir com a precompila\u00e7\u00e3o do Proxy usando Remix. Para adicionar a precompila\u00e7\u00e3o ao Remix, voc\u00ea precisar\u00e1:</p> <ol> <li>Obter uma c\u00f3pia de <code>Proxy.sol</code></li> <li>Cole o conte\u00fado do arquivo em um arquivo Remix chamado <code>Proxy.sol</code></li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#compile-the-contract","title":"Compile o Contrato","text":"<p>Em seguida, voc\u00ea precisar\u00e1 compilar a interface no Remix:</p> <ol> <li>Clique na guia Compilar, a segunda de cima</li> <li>Em seguida, para compilar a interface, clique em Compilar Proxy.sol</li> </ol> <p></p> <p>Quando a compila\u00e7\u00e3o estiver conclu\u00edda, voc\u00ea ver\u00e1 uma marca de sele\u00e7\u00e3o verde ao lado da guia Compilar.</p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#access-the-contract","title":"Acessar o Contrato","text":"<p>Em vez de implantar o contrato inteligente, voc\u00ea acessar\u00e1 a interface atrav\u00e9s de seu endere\u00e7o:</p> <ol> <li>Clique na guia Deploy and Run diretamente abaixo da guia Compile no Remix</li> <li>Certifique-se de que Injected Provider - Metamask esteja selecionado no menu suspenso ENVIRONMENT. Voc\u00ea pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ainda n\u00e3o esteja conectado</li> <li>Certifique-se de que a conta prim\u00e1ria seja exibida em ACCOUNT</li> <li>Certifique-se de que Proxy - Proxy.sol esteja selecionado no menu suspenso CONTRACT. Dado que \u00e9 um contrato pr\u00e9-compilado, n\u00e3o h\u00e1 etapa de implanta\u00e7\u00e3o. Em vez disso, voc\u00ea fornecer\u00e1 o endere\u00e7o da precompila\u00e7\u00e3o no campo At Address</li> <li>Forne\u00e7a o endere\u00e7o da precompila\u00e7\u00e3o do Proxy (que \u00e9 <code>0x0000000000000000000000000000000000000805</code> neste exemplo) e clique em At Address</li> <li>A precompila\u00e7\u00e3o do Proxy aparecer\u00e1 na lista de Deployed Contracts </li> </ol>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#add-proxy","title":"Adicionar um Proxy","text":"<p>Voc\u00ea pode adicionar proxies para sua conta chamando as fun\u00e7\u00f5es de precompila\u00e7\u00e3o. No exemplo a seguir, voc\u00ea adicionar\u00e1 um proxy autorizado a executar qualquer transa\u00e7\u00e3o em seu nome:</p> <ol> <li>Expanda o contrato Proxy Precompile para ver as fun\u00e7\u00f5es dispon\u00edveis</li> <li>Encontre a fun\u00e7\u00e3o addProxy e pressione o bot\u00e3o para expandir a se\u00e7\u00e3o</li> <li>Insira o endere\u00e7o de sua segunda conta como delegate, <code>0</code> como proxyType, o que significa <code>any</code>, e <code>0</code> como delay</li> <li>Clique em transact</li> <li>O MetaMask aparecer\u00e1 e voc\u00ea ser\u00e1 solicitado a revisar os detalhes da transa\u00e7\u00e3o. Clique em Confirmar para executar a transa\u00e7\u00e3o</li> </ol> <p>Nota</p> <p>Ao construir a transa\u00e7\u00e3o no Remix, o proxyType \u00e9 representado como um <code>uint8</code>, em vez do enum <code>ProxyType</code> esperado. Em Solidity, os enums s\u00e3o compilados como <code>uint8</code>, ent\u00e3o, quando voc\u00ea passa <code>0</code> para proxyType, voc\u00ea indica o primeiro elemento no enum <code>ProxyType</code>, que \u00e9 o proxy <code>any</code>.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#check-proxy","title":"Verifique uma exist\u00eancia de Proxy","text":"<p>A fun\u00e7\u00e3o <code>isProxy</code> verifica se uma conta proxy existe. Ap\u00f3s criar um proxy na etapa anterior, use os mesmos par\u00e2metros para verificar se o proxy foi adicionado com sucesso:</p> <ol> <li>Expanda a fun\u00e7\u00e3o isProxy</li> <li>Insira sua conta principal como real, sua segunda conta (proxy) como delegate, <code>0</code> como proxyType e <code>0</code> como delay</li> <li>Clique em call</li> <li>As fun\u00e7\u00f5es retornam se existe um proxy ou n\u00e3o. Neste exemplo, o proxy existe, portanto, a fun\u00e7\u00e3o retorna <code>true</code></li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/precompiles/proxy/#remove-proxy","title":"Remover um Proxy","text":"<p>Voc\u00ea pode revogar uma permiss\u00e3o de proxy quando n\u00e3o for mais necess\u00e1ria. Ap\u00f3s criar um proxy na Adicionar Proxy, etapa, ele pode ser removido seguindo estas etapas:</p> <ol> <li>Expanda a fun\u00e7\u00e3o removeProxy</li> <li>Insira a conta proxy como delegate, <code>0</code> como proxyType e <code>0</code> como delay</li> <li>Clique em transact</li> <li>O MetaMask aparecer\u00e1 e voc\u00ea ser\u00e1 solicitado a revisar os detalhes da transa\u00e7\u00e3o. Clique em Confirmar para executar a transa\u00e7\u00e3o</li> </ol> <p>Depois que a transa\u00e7\u00e3o for confirmada, se voc\u00ea repetir as etapas para verificar a exist\u00eancia de um proxy, o resultado dever\u00e1 ser <code>false</code>.</p> <p></p> <p>E \u00e9 isso! Voc\u00ea interagiu com sucesso com a precompila\u00e7\u00e3o do Proxy usando MetaMask e Remix!</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/wallets/","title":"Carteiras","text":"<p>Carteiras s\u00e3o ferramentas digitais que permitem aos usu\u00e1rios armazenar, gerenciar e transacionar com seguran\u00e7a seus ativos digitais. Elas armazenam as chaves criptogr\u00e1ficas necess\u00e1rias para acessar ativos digitais e permitem executar transa\u00e7\u00f5es em redes blockchain.</p> <p>Para redes compat\u00edveis com EVM, voc\u00ea pode usar qualquer carteira que suporte EVM, com a flexibilidade de adicionar configura\u00e7\u00f5es de rede personalizadas, permitindo conex\u00e3o e intera\u00e7\u00e3o cont\u00ednuas com sua rede.</p> <p>As p\u00e1ginas desta se\u00e7\u00e3o fornecem uma vis\u00e3o geral de como come\u00e7ar com v\u00e1rios provedores de carteira. Ela aborda como criar e importar contas, conectar-se \u00e0 sua rede e come\u00e7ar a interagir com ela.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/ledger/","title":"Interagindo com EVM appchains com tecnologia Tanssi Usando Ledger","text":""},{"location":"pt/builders/toolkit/ethereum-api/wallets/ledger/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de EVM appchains com tecnologia Tanssi, como a demonstra\u00e7\u00e3o Tanssi, t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. Em rela\u00e7\u00e3o \u00e0s carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, Ledger \u00e9 uma das op\u00e7\u00f5es mais populares. A Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.</p> <p>Os dispositivos Ledger s\u00e3o carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles s\u00e3o usados para verificar e assinar as transa\u00e7\u00f5es, mas ainda precisam de uma camada de software para fornecer a interface do usu\u00e1rio que interage com as redes, constr\u00f3i as transa\u00e7\u00f5es e envia as transa\u00e7\u00f5es assinadas de volta para a rede assim que o usu\u00e1rio as tiver verificado.</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias para usar seu dispositivo Ledger com EVM appchains com tecnologia Tanssi.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/ledger/#setting-up-ledger-device","title":"Configurando seu dispositivo Ledger","text":"<p>Se voc\u00ea tem um dispositivo Ledger novo, consulte o site oficial para obter um guia sobre como inici\u00e1-lo com a configura\u00e7\u00e3o inicial.</p> <p>Agora, com seu Ledger j\u00e1 iniciado, instale o aplicativo Ethereum seguindo as seguintes etapas:</p> <ol> <li>Abra o aplicativo Ledger Live em seu computador.</li> <li>V\u00e1 para My Ledger.</li> <li>Conecte e desbloqueie o dispositivo.</li> </ol> <p>Por fim, procure o aplicativo Ethereum (ETH) no Ledger Live e instale-o em seu dispositivo.</p> <p></p> <p>E \u00e9 isso. Seu dispositivo agora tem uma conta Ethereum e \u00e9 capaz de assinar transa\u00e7\u00f5es em qualquer EVM appchain com tecnologia Tanssi.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/ledger/#adding-Ledger-hot-wallet","title":"Adicionando o Ledger a uma carteira quente","text":"<p>Conforme apresentado na introdu\u00e7\u00e3o, uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usu\u00e1rios verifiquem e assinem transa\u00e7\u00f5es. No entanto, por design, ela n\u00e3o pode interagir com blockchains ou dApps sozinha, nem oferece uma interface do usu\u00e1rio para gerenciar ativos. Para complementar o dispositivo, uma carteira quente \u00e9 necess\u00e1ria. O usu\u00e1rio pode escolher qualquer carteira compat\u00edvel com Ethereum.</p> <p>Para fins de demonstra\u00e7\u00e3o, mostraremos como configurar Metamask para funcionar com sua carteira de hardware, mas essas etapas s\u00e3o geralmente aplic\u00e1veis a qualquer outra carteira que suporte Ledger. Para seguir as etapas, certifique-se de ter o Metamask instalado em seu navegador, abra a extens\u00e3o e clique no \u00edcone suspenso ao lado do nome da conta.</p> <p></p> <p>Agora clique no bot\u00e3o + Adicionar conta ou carteira de hardware.</p> <p></p> <p>Selecione Carteira de hardware nas op\u00e7\u00f5es dispon\u00edveis.</p> <p></p> <p>Na tela seguinte:</p> <ol> <li>Selecione a caixa LEDGER. Voc\u00ea ser\u00e1 solicitado a conectar seu Ledger, desbloque\u00e1-lo e abrir o aplicativo Ethereum.</li> <li>Clique em Continuar.</li> </ol> <p></p> <p>Finalmente, voc\u00ea ser\u00e1 apresentado com uma lista de contas derivadas. Selecione aquela que voc\u00ea deseja importar, clique em Desbloquear e pronto! Sua carteira Metamask agora pode assinar transa\u00e7\u00f5es usando seu dispositivo Ledger.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/","title":"Interagindo com sua Rede EVM Tanssi Usando MetaMask","text":""},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores que constroem dApps em cima de redes EVM alimentadas por Tanssi podem aproveitar seus recursos de compatibilidade Ethereum integrando carteiras Ethereum conhecidas, como MetaMask. Ao fazer isso, eles podem usar a biblioteca injetada que MetaMask fornece para interagir com a rede EVM Tanssi.</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias: desde a instala\u00e7\u00e3o da Metamask, configura\u00e7\u00e3o de uma carteira e, finalmente, conectando-a \u00e0 sua rede EVM Tanssi.</p> <p>Nota</p> <p>Voc\u00ea nunca deve compartilhar sua frase semente (mnem\u00f4nico) ou chave privada com ningu\u00e9m. Isso lhes d\u00e1 acesso direto aos seus fundos. Este guia \u00e9 apenas para fins educacionais.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension","title":"Instale a Extens\u00e3o MetaMask","text":"<p>Primeiro, voc\u00ea come\u00e7ar\u00e1 com uma instala\u00e7\u00e3o MetaMask nova e padr\u00e3o da Chrome store. Ap\u00f3s baixar, instalar e inicializar a extens\u00e3o, siga as etapas de Come\u00e7ar para configurar a carteira. L\u00e1, voc\u00ea precisa criar uma carteira, definir uma senha e armazenar sua frase secreta de backup (isso d\u00e1 acesso direto aos seus fundos, portanto, certifique-se de armazen\u00e1-los em um local seguro).</p> <p>Nota</p> <p>A extens\u00e3o do navegador Metamask \u00e9 compat\u00edvel com Chrome, navegadores baseados em Chromium (como Microsoft Edge e Opera) e Firefox. Metamask tamb\u00e9m est\u00e1 dispon\u00edvel como um aplicativo m\u00f3vel para dispositivos iOS e Android.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#setup-a-wallet","title":"Configurar uma Carteira","text":"<p>Ap\u00f3s instalar MetaMask, a configura\u00e7\u00e3o abrir\u00e1 automaticamente uma nova tarefa com uma tela de boas-vindas. Aqui, voc\u00ea tem duas op\u00e7\u00f5es:</p> <ul> <li>Criar uma nova carteira - voc\u00ea passar\u00e1 por algumas etapas para obter uma nova frase semente. Certifique-se de armazenar esta frase com seguran\u00e7a e n\u00e3o compartilh\u00e1-la publicamente</li> <li>Importar uma carteira existente - voc\u00ea j\u00e1 tem uma frase semente armazenada e deseja restaurar uma conta a partir dessa frase de recupera\u00e7\u00e3o</li> </ul> <p></p> <p>Depois de clicar na op\u00e7\u00e3o que se adapta \u00e0s suas necessidades, siga as etapas e voc\u00ea dever\u00e1 estar totalmente configurado.</p> <p>Nota</p> <p>V\u00e1rias contas podem ser derivadas de uma frase semente alterando o que \u00e9 conhecido como o \u00edndice de endere\u00e7o. Por padr\u00e3o, ao criar ou importar uma conta a partir da frase semente, voc\u00ea obt\u00e9m a conta com o \u00edndice de endere\u00e7o 0. Voc\u00ea pode obter os outros \u00edndices apenas adicionando novas contas na tela principal da Metamask.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#import-accounts","title":"Importar Contas","text":"<p>Depois de criar uma carteira ou importar uma existente, voc\u00ea tamb\u00e9m pode importar qualquer conta para a MetaMask se tiver as chaves privadas.</p> <p>Para este exemplo, voc\u00ea usar\u00e1 chaves privadas da conta de desenvolvimento. Clique no bot\u00e3o de troca de conta para importar uma conta usando suas chaves privadas. \u00c9 onde diz Account 1.</p> <p></p> <p>Em seguida, clique em Import Account.</p> <p></p> <p>Finalmente, insira as chaves privadas da conta que voc\u00ea est\u00e1 tentando importar. Depois de inserir a chave privada, clique em Import.</p> <p></p> <p>Voc\u00ea deve terminar com uma Conta 2 importada que se parece com isto:</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#connect-metamask-to-evm-network","title":"Conecte a MetaMask \u00e0 sua Rede EVM Tanssi","text":"<p>Depois de ter MetaMask instalado e ter criado ou importado uma conta, voc\u00ea pode conect\u00e1-la \u00e0 sua rede EVM Tanssi. Para fazer isso, siga os seguintes passos:</p> <ol> <li>Clique no menu do seletor de rede no canto superior esquerdo</li> <li>Selecione Adicionar Rede</li> </ol> <p></p> <p>Em seguida, v\u00e1 para a parte inferior da p\u00e1gina e clique em Adicionar rede manualmente:</p> <p></p> <p>Aqui, voc\u00ea pode configurar a MetaMask para as seguintes redes:</p> Vari\u00e1vel Valor Nome da Rede <code>Tanssi demo EVM appchain</code> RPC URL <code>https://services.tanssi-testnet.network/dancelight-2001/</code> Chain ID <code>5678</code> S\u00edmbolo (Opcional) <code>TANGO</code> Explorador de Blocos (Opcional) <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code> <p>Para fazer isso, preencha as seguintes informa\u00e7\u00f5es:</p> <ol> <li>Nome da rede - nome que representa a rede \u00e0 qual voc\u00ea est\u00e1 se conectando</li> <li>RPC URL - Endpoint RPC da rede</li> <li>Chain ID - ID da cadeia da rede compat\u00edvel com Ethereum</li> <li>S\u00edmbolo - (opcional) s\u00edmbolo do token nativo da rede</li> <li>Explorador de Blocos - (opcional) URL do explorador de blocos</li> <li>Depois de verificar todas as informa\u00e7\u00f5es, clique em Salvar </li> </ol> <p>Depois de adicionar a rede, voc\u00ea ser\u00e1 redirecionado para uma tela informando que voc\u00ea adicionou uma rede com sucesso. Al\u00e9m disso, voc\u00ea ser\u00e1 solicitado a Mudar para Tanssi demo EVM appchain, a rede adicionada neste exemplo.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/metamask/#interact-with-network","title":"Interaja com a Rede","text":"<p>Depois de conectar a Metamask \u00e0 sua rede EVM Tanssi, voc\u00ea pode come\u00e7ar a usar sua carteira por:</p> <ul> <li>Solicitando tokens TANGO do demo EVM network faucet</li> <li>Enviando uma transfer\u00eancia de token para outro endere\u00e7o</li> <li>Adicionando ERC-20s \u00e0 Metamask e interagindo com eles</li> <li>Adicionando ERC-721s \u00e0 Metamask e interagindo com eles</li> </ul>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/","title":"Interagindo com Sua Rede EVM Tanssi Usando o SubWallet","text":""},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de redes EVM alimentadas por Tanssi t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. Gra\u00e7as \u00e0 sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, incluindo SubWallet.</p> <p>SubWallet \u00e9 uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API do Ethereum, mas voc\u00ea pode consultar um tutorial semelhante para interagir com o SubWallet usando a API do Substrate. A extens\u00e3o da carteira do navegador SubWallet pode ser baixada para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. O SubWallet tamb\u00e9m possui um aplicativo m\u00f3vel para iOS e Android, mas isso est\u00e1 al\u00e9m do escopo deste guia. Um painel de ativos online completo \u00e9 acess\u00edvel em web.subwallet.app.</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias, desde a instala\u00e7\u00e3o do SubWallet at\u00e9 a configura\u00e7\u00e3o de uma carteira, conectando-a \u00e0 sua rede EVM Tanssi e enviando fundos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/#creating-your-first-ethereum-account","title":"Criando Sua Primeira Conta Ethereum","text":"<p>Primeiro, baixe e instale a extens\u00e3o SubWallet. A cria\u00e7\u00e3o de uma nova conta gerar\u00e1 uma frase semente que pode derivar v\u00e1rias contas Ethereum e Substrate. Por padr\u00e3o, o SubWallet gerar\u00e1 uma \u00fanica conta Ethereum e uma \u00fanica conta Substrate, mas voc\u00ea pode facilmente derivar mais da mesma frase semente. Clique em Criar uma nova conta para come\u00e7ar.</p> <p></p> <p>Na tela seguinte, voc\u00ea ser\u00e1 solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a fazer backup de sua frase semente. Esta \u00e9 uma etapa importante, especialmente porque voc\u00ea tem a op\u00e7\u00e3o de, posteriormente, derivar contas adicionais desta frase semente.</p> <p></p> <p>Nota</p> <p>Voc\u00ea nunca deve compartilhar sua frase semente (mnem\u00f4nico) ou chave privada com ningu\u00e9m. Isso lhes d\u00e1 acesso direto aos seus fundos. Este guia \u00e9 apenas para fins educacionais.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/#importing-an-existing-evm-account","title":"Importando uma Conta EVM Existente","text":"<p>\u00c9 claro que voc\u00ea pode importar uma conta EVM existente para o SubWallet. Para come\u00e7ar, siga estas etapas:</p> <ol> <li>Pressione o bot\u00e3o Todas as contas na parte superior</li> <li>Pressione o \u00edcone Importar conta</li> </ol> <p></p> <p>Na tela seguinte, selecione o m\u00e9todo pelo qual voc\u00ea gostaria de importar a conta existente.</p> <p></p> <p>Na tela seguinte, voc\u00ea poder\u00e1 fornecer a frase semente relevante, a chave privada, o arquivo JSON ou o c\u00f3digo QR, e poder\u00e1 come\u00e7ar a usar sua nova conta imediatamente.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/#configuring-subwallet-for-your-evm-network","title":"Configurando o SubWallet para Sua Rede EVM","text":"<p>Para configurar o SubWallet para sua rede EVM alimentada por Tanssi, pressione o \u00edcone Mais op\u00e7\u00f5es no canto superior esquerdo. Em seguida, clique em Gerenciar redes. Pressione o \u00edcone +. Na p\u00e1gina seguinte, voc\u00ea ser\u00e1 solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstra\u00e7\u00e3o, a rede EVM de demonstra\u00e7\u00e3o \u00e9 usada aqui, mas voc\u00ea pode substituir esses detalhes pelos detalhes da sua pr\u00f3pria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:</p> <ol> <li>Cole a URL HTTPS RPC de sua rede Tanssi. A URL RPC da rede EVM de demonstra\u00e7\u00e3o \u00e9 <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Outros par\u00e2metros ser\u00e3o preenchidos automaticamente</li> <li>Cole a URL do explorador de blocos de sua rede Tanssi. A URL do explorador de blocos da rede EVM de demonstra\u00e7\u00e3o \u00e9 <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Pressione Salvar</li> </ol> <p></p> <p>Por padr\u00e3o, todos os saldos s\u00e3o ocultos no SubWallet, mas se voc\u00ea pressionar o \u00edcone de olho, poder\u00e1 alternar a visibilidade do saldo.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/subwallet/#sending-assets-on-your-evm-network","title":"Enviando Ativos em Sua Rede EVM","text":"<p>Para transferir o token nativo da sua rede Tanssi, siga estas etapas:</p> <ol> <li>Especifique o ativo a ser enviado</li> <li>Especifique a cadeia de destino (neste caso, a mesma cadeia da qual voc\u00ea est\u00e1 enviando)</li> <li>Insira o endere\u00e7o de destino</li> <li>Insira o n\u00famero de tokens a serem enviados</li> <li>Veja os detalhes da transa\u00e7\u00e3o e pressione Transferir e, em seguida, Aprovar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configura\u00e7\u00e3o do SubWallet para trabalhar com sua rede EVM Tanssi, mas o SubWallet tamb\u00e9m \u00e9 uma carteira completa para contas Substrate (Polkadot). Na se\u00e7\u00e3o da API do Substrate, voc\u00ea encontrar\u00e1 um guia semelhante para configurar o SubWallet para uso com sua rede Substrate.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/","title":"Interagindo com sua Rede EVM Tanssi Usando Talisman","text":""},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de redes EVM alimentadas pela Tanssi t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. Gra\u00e7as \u00e0 sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, como a Talisman.</p> <p>A Talisman \u00e9 uma carteira Web3 que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Ethereum, mas voc\u00ea pode conferir um tutorial semelhante para interagir com a Talisman usando a API Substrate. A extens\u00e3o de navegador da carteira Talisman est\u00e1 dispon\u00edvel no Google Chrome e Brave, e um painel de ativos correspondente est\u00e1 acess\u00edvel em app.talisman.xyz</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias, desde a instala\u00e7\u00e3o do Talisman at\u00e9 a configura\u00e7\u00e3o de uma carteira, conectando-a \u00e0 sua rede EVM Tanssi e enviando fundos.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#setting-up-talisman","title":"Configurando o Talisman","text":"<p>Primeiro, baixe e instale a extens\u00e3o Talisman. Este guia cobrir\u00e1 primeiro a cria\u00e7\u00e3o de uma nova carteira e, posteriormente, abordar\u00e1 a importa\u00e7\u00e3o de uma existente. Revise os termos e condi\u00e7\u00f5es e, em seguida, pressione Come\u00e7ar.</p> <p></p> <p>Na tela seguinte, voc\u00ea ser\u00e1 solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#creating-an-ethereum-account","title":"Criando uma Conta Ethereum","text":"<p>Para criar sua primeira conta Ethereum, siga as seguintes etapas:</p> <ol> <li>Selecione a op\u00e7\u00e3o Ethereum</li> <li>D\u00ea um nome \u00e0 sua conta</li> <li>Pressione Criar</li> </ol> <p></p> <p>Ap\u00f3s criar sua primeira conta, voc\u00ea ser\u00e1 solicitado a fazer backup de sua frase de semente. Esta \u00e9 uma etapa importante, especialmente porque voc\u00ea tem a op\u00e7\u00e3o de derivar posteriormente contas adicionais dessa frase de semente.</p> <p></p> <p>Nota</p> <p>Voc\u00ea nunca deve compartilhar sua frase de semente (mnem\u00f4nico) ou chave privada com ningu\u00e9m. Isso lhes d\u00e1 acesso direto aos seus fundos. Este guia \u00e9 apenas para fins educacionais.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#importing-an-existing-evm-account","title":"Importando uma Conta EVM Existente","text":"<p>\u00c9 claro que voc\u00ea pode importar uma conta EVM existente para o Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Pressione Adicionar conta</li> <li>Pressione Importar</li> <li>Selecione Importar via frase de recupera\u00e7\u00e3o (observe que isso funciona para sementes e chaves privadas)</li> </ol> <p></p> <p>Na tela seguinte, siga as seguintes etapas:</p> <ol> <li>Selecione o tipo de conta Ethereum</li> <li>Forne\u00e7a um nome para sua conta</li> <li>Cole sua semente ou chave privada</li> <li>Se voc\u00ea importou uma frase de semente mnem\u00f4nica na etapa anterior, selecione quais contas voc\u00ea gostaria de importar</li> <li>Pressione Importar</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#configuring-talisman-for-your-evm-network","title":"Configurando o Talisman para sua Rede EVM","text":"<p>Para configurar o Talisman para sua rede EVM Tanssi, abra a extens\u00e3o Talisman e clique na guia Mais Op\u00e7\u00f5es. Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione Configura\u00e7\u00f5es</li> <li>Marque a caixa Habilitar testnets</li> <li>Pressione Adicionar Rede</li> </ol> <p></p> <p>Na p\u00e1gina seguinte, voc\u00ea ser\u00e1 solicitado a inserir os detalhes da rede para sua rede alimentada pela Tanssi. Para fins de demonstra\u00e7\u00e3o, a rede EVM de demonstra\u00e7\u00e3o \u00e9 usada aqui, mas voc\u00ea pode substituir esses detalhes por sua pr\u00f3pria rede. Para adicionar sua rede ao Talisman, siga as seguintes etapas:</p> <ol> <li>Cole a URL RPC da sua rede alimentada pela Tanssi. A URL RPC da rede EVM de demonstra\u00e7\u00e3o \u00e9 <code>https://services.tanssi-testnet.network/dancelight-2001/</code>. Outros par\u00e2metros ser\u00e3o preenchidos automaticamente</li> <li>Cole a URL do explorador de blocos da sua rede alimentada pela Tanssi. A URL do explorador de blocos da rede EVM de demonstra\u00e7\u00e3o \u00e9 <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> <li>Marque a caixa Esta \u00e9 uma testnet, se aplic\u00e1vel</li> <li>Pressione Adicionar Rede</li> </ol> <p></p> <p>Se voc\u00ea tiver um saldo de tokens em sua conta rec\u00e9m-criada para sua rede, ver\u00e1 o saldo no painel Talisman.</p>"},{"location":"pt/builders/toolkit/ethereum-api/wallets/talisman/#sending-assets-on-your-evm-network","title":"Enviando Ativos em Sua Rede EVM","text":"<p>Para transferir o token nativo da sua rede Tanssi, siga as seguintes etapas:</p> <ol> <li>Clique no \u00edcone Enviar</li> <li>Clique na conta Enviar de desejada</li> <li>Digite o endere\u00e7o de destino</li> <li>Digite a quantidade de tokens a serem enviados</li> <li>Revise os detalhes da transa\u00e7\u00e3o e, em seguida, pressione Revisar e, posteriormente, Confirmar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configura\u00e7\u00e3o do Talisman para trabalhar com sua rede EVM alimentada pela Tanssi, mas o Talisman tamb\u00e9m \u00e9 uma carteira completa para contas Substrate (Polkadot). Na se\u00e7\u00e3o da API Substrate, voc\u00ea encontrar\u00e1 um tutorial semelhante para configurar o Talisman para trabalhar com cadeias baseadas em Substrate.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/","title":"Integra\u00e7\u00f5es","text":"<p>Descubra integra\u00e7\u00f5es que permitem estender a funcionalidade de seus dApps desenvolvidos com Tanssi. Essas integra\u00e7\u00f5es permitem a intera\u00e7\u00e3o perfeita com fontes de dados externas, aprimoram a experi\u00eancia do usu\u00e1rio e habilitam recursos avan\u00e7ados como feeds de dados on-chain, an\u00e1lise e suporte a carteiras.</p> <p>Pronto para come\u00e7ar a construir? Confira as seguintes integra\u00e7\u00f5es:</p> <ul> <li>Oracles - Acurast, Band e Phala</li> <li>Indexadores - SQD</li> <li>Carteiras - RainbowKit</li> </ul>"},{"location":"pt/builders/toolkit/integrations/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/integrations/indexers/","title":"Indexadores","text":"<p>Os indexadores permitem a ingest\u00e3o, o processamento e a consulta eficientes de dados de blockchain, fornecendo aos desenvolvedores ferramentas poderosas para criar aplica\u00e7\u00f5es responsivas e ricas em dados em redes alimentadas pelo Tanssi.</p> <p>As principais caracter\u00edsticas dos indexadores incluem:</p> <ul> <li>Velocidade de acesso a dados aprimorada - consulta mais r\u00e1pida de dados na cadeia, organizando e indexando-os, permitindo tempos de recupera\u00e7\u00e3o mais r\u00e1pidos</li> <li>Agrega\u00e7\u00e3o de dados - ingerir e transformar dados que s\u00e3o mais f\u00e1ceis de consultar e trabalhar com grandes quantidades de dados</li> <li>Capacidades de consulta aprimoradas - usar m\u00e9todos de consulta sofisticados, como filtragem, classifica\u00e7\u00e3o e pagina\u00e7\u00e3o</li> <li>Atualiza\u00e7\u00f5es de dados em tempo real - a sincroniza\u00e7\u00e3o com o blockchain permite que as aplica\u00e7\u00f5es acessem as informa\u00e7\u00f5es mais recentes assim que estiverem dispon\u00edveis</li> </ul>"},{"location":"pt/builders/toolkit/integrations/indexers/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/","title":"SQD","text":"<p>SQD \u00e9 um servi\u00e7o de indexa\u00e7\u00e3o e consulta de blockchain projetado para facilitar aos desenvolvedores a cria\u00e7\u00e3o de aplica\u00e7\u00f5es ricas em dados em cadeias baseadas em Substrate, como as redes com tecnologia Tanssi. Ele fornece uma solu\u00e7\u00e3o eficiente e escal\u00e1vel para processamento, indexa\u00e7\u00e3o e consulta de dados on-chain, permitindo que os desenvolvedores interajam facilmente com os dados de blockchain de que precisam, sem lidar diretamente com as complexidades dos dados brutos de blockchain.</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/","title":"Indexando transfer\u00eancias ERC-20 em uma rede EVM Tanssi","text":""},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>SQD \u00e9 uma rede de dados que permite recuperar informa\u00e7\u00f5es de mais de 100 cadeias usando um data lake descentralizado e um SDK open source. Em termos simples, \u00e9 um ETL com servidor GraphQL embutido, oferecendo filtragem, pagina\u00e7\u00e3o e busca em texto.</p> <p>A SQD oferece suporte nativo a EVM e Substrate, com arquivos/processadores para ambos. Assim, \u00e9 poss\u00edvel extrair logs EVM e entidades Substrate (eventos, extr\u00ednsecos, storage) em um \u00fanico projeto e servir via um \u00fanico endpoint GraphQL. Para apenas dados EVM, use o arquivo/processador EVM.</p> <p>Este tutorial mostra, passo a passo, como criar um Squid para indexar dados EVM. H\u00e1 uma vers\u00e3o completa no reposit\u00f3rio tanssiSquid.</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#check-prerequisites","title":"Verificar pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1 de:</p> <ul> <li>Docker instalado</li> <li>Docker Compose instalado</li> <li>Um projeto Hardhat vazio (veja Criando um Projeto Hardhat)</li> </ul> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#deploy-an-erc20-with-hardhat","title":"Implantar um ERC-20 com Hardhat","text":"<p>Implante um token para ter eventos a indexar (ou use um j\u00e1 existente na demo EVM). Exemplo de contrato <code>MyTok.sol</code>:</p> <p>1) Instale depend\u00eancias:</p> npm <pre><code>npm install @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> yarn <pre><code>yarn add @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts\n</code></pre> <p>2) Ajuste <code>hardhat.config.js</code> com sua RPC/conta:</p> hardhat.config.js <pre><code>// 1. Import the Ethers plugin required to interact with the contract\nrequire('@nomicfoundation/hardhat-ethers');\n\n// 2. Add your private key that is funded with tokens of your Tanssi-powered network\n// This is for example purposes only - **never store your private keys in a JavaScript file**\nconst privateKey = 'INSERT_PRIVATE_KEY';\n\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n  // 3. Specify the Solidity version\n  solidity: '0.8.20',\n  networks: {\n    // 4. Add the network specification for your Tanssi EVM network\n    demo: {\n      url: 'https://services.tanssi-testnet.network/dancelight-2001/',\n      chainId: 5678, // Fill in the EVM ChainID for your Tanssi-powered network\n      accounts: [privateKey],\n    },\n  },\n};\n</code></pre> <p>Remember</p> <p>N\u00e3o armazene chaves privadas em arquivos de c\u00f3digo; use um gerenciador de segredos.</p> <p>3) Crie o contrato:</p> <pre><code>mkdir -p contracts &amp;&amp; touch contracts/MyTok.sol\n</code></pre> MyTok.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyTok is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") Ownable(msg.sender) {\n        _mint(msg.sender, 50000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n</code></pre> <p>4) Compile:</p> <pre><code>npx hardhat compile\n</code></pre> <p>5) Implante e registre o endere\u00e7o:</p> <pre><code>mkdir -p scripts &amp;&amp; touch scripts/deploy.js\nnpx hardhat run scripts/deploy.js --network demo\n</code></pre> deploy.js <pre><code>// scripts/deploy.js\nconst hre = require('hardhat');\nrequire('@nomicfoundation/hardhat-ethers');\n\nasync function main() {\n  // Get ERC-20 contract\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // This is a temporary stopgap solution to a bug\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Deploy the contract providing a gas price and gas limit\n  const myTok = await MyTok.deploy({\n    gasPrice: customGasPrice,\n    gasLimit: customGasLimit,\n  });\n\n  // Wait for the deployment\n  await myTok.waitForDeployment();\n\n  console.log(`Contract deployed to ${myTok.target}`);\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre> <p>6) Dispare algumas transfer\u00eancias para gerar eventos:</p> <pre><code>touch scripts/transactions.js\nnpx hardhat run scripts/transactions.js --network demo\n</code></pre> transactions.js <pre><code>// We require the Hardhat Runtime Environment explicitly here. This is optional\n// but useful for running the script in a standalone fashion through `node &lt;script&gt;`.\n//\n// You can also run a script with `npx hardhat run &lt;script&gt;`. If you do that, Hardhat\n// will compile your contracts, add the Hardhat Runtime Environment's members to the\n// global scope, and execute the script.\nconst hre = require('hardhat');\n\nasync function main() {\n  // Get Contract ABI\n  const MyTok = await hre.ethers.getContractFactory('MyTok');\n\n  // Define custom gas price and gas limit\n  // Gas price is typically specified in 'wei' and gas limit is just a number\n  // You can use Ethers.js utility functions to convert from gwei or ether if needed\n  const customGasPrice = 50000000000; // example for 50 gwei\n  const customGasLimit = 5000000; // example gas limit\n\n  // Plug ABI to address\n  const myTok = await MyTok.attach('INSERT_CONTRACT_ADDRESS');\n\n  const value = 100000000000000000n;\n\n  let tx;\n  // Transfer to Baltathar\n  tx = await myTok.transfer(\n    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);\n\n  // Transfer to Charleth\n  tx = await myTok.transfer(\n    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);\n\n  // Transfer to Dorothy\n  tx = await myTok.transfer(\n    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);\n\n  // Transfer to Ethan\n  tx = await myTok.transfer(\n    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',\n    value,\n    {\n      gasPrice: customGasPrice,\n      gasLimit: customGasLimit,\n    }\n  );\n  await tx.wait();\n  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);\n}\n\n// We recommend this pattern to be able to use async/await everywhere\n// and properly handle errors.\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exitCode = 1;\n});\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#create-a-squid-project","title":"Criar um projeto Squid","text":"<p>Instale o CLI e inicie o template EVM:</p> <pre><code>npm i -g @subsquid/cli@latest\nsqd init tanssi-squid --template evm\ncd tanssi-squid &amp;&amp; npm ci\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#set-up-the-indexer-for-erc-20-transfers","title":"Configurar o indexador de transfer\u00eancias ERC-20","text":"<p>1) Definir esquema GraphQL:</p> schema.graphql <pre><code>type Account @entity {\n  \"Account address\"\n  id: ID!\n  transfersFrom: [Transfer!] @derivedFrom(field: \"from\")\n  transfersTo: [Transfer!] @derivedFrom(field: \"to\")\n}\n\ntype Transfer @entity {\n  id: ID!\n  blockNumber: Int!\n  timestamp: DateTime!\n  txHash: String!\n  from: Account!\n  to: Account!\n  amount: BigInt!\n}\n</code></pre> <pre><code>sqd codegen\n</code></pre> <p>2) Adicionar ABI gen\u00e9rica do ERC-20 em <code>abi/erc20.json</code> e gerar interfaces:</p> ERC-20 ABI <pre><code>[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_from\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"payable\": true,\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }\n]\n</code></pre> <pre><code>sqd typegen\n</code></pre> <p>3) Configurar <code>processor.ts</code>: fonte de dados, endere\u00e7o do contrato, evento <code>Transfer</code>, intervalo de blocos e campos.</p> <pre><code>.setDataSource({\n  chain: {\n    url: assertNotNull('https://services.tanssi-testnet.network/dancelight-2001/'),\n    rateLimit: 300,\n  },\n})\n.addLog({\n  address: [contractAddress],\n  topic0: [erc20.events.Transfer.topic],\n  transaction: true,\n})\n.setBlockRange({ from: 632400 })\n.setFields({\n  log: { topics: true, data: true },\n  transaction: { hash: true },\n})\n</code></pre> <p>Imports necess\u00e1rios:</p> <pre><code>import { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n</code></pre> processor.ts <pre><code>import { assertNotNull } from '@subsquid/util-internal';\nimport {\n  BlockHeader,\n  DataHandlerContext,\n  EvmBatchProcessor,\n  EvmBatchProcessorFields,\n  Log as _Log,\n  Transaction as _Transaction,\n} from '@subsquid/evm-processor';\nimport { Store } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\n\n// Here you'll need to import the contract\nexport const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();\n\nexport const processor = new EvmBatchProcessor()\n  .setDataSource({\n    chain: {\n      url: assertNotNull(\n        'https://services.tanssi-testnet.network/dancelight-2001'\n      ),\n      rateLimit: 300,\n    },\n  })\n  .setFinalityConfirmation(10)\n  .setFields({\n    log: {\n      topics: true,\n      data: true,\n    },\n    transaction: {\n      hash: true,\n    },\n  })\n  .addLog({\n    address: [contractAddress],\n    topic0: [erc20.events.Transfer.topic],\n    transaction: true,\n  })\n  .setBlockRange({\n    from: INSERT_START_BLOCK, // Note the lack of quotes here\n  });\n\nexport type Fields = EvmBatchProcessorFields&lt;typeof processor&gt;;\nexport type Block = BlockHeader&lt;Fields&gt;;\nexport type Log = _Log&lt;Fields&gt;;\nexport type Transaction = _Transaction&lt;Fields&gt;;\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#transform-and-save-the-data","title":"Transformar e salvar os dados","text":"<p>Em <code>main.ts</code>, decodifique o evento <code>Transfer</code>, obtenha contas envolvidas, crie entidades e grave via TypeORM.</p> main.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\n// 1. Iterate through all selected blocks and look for transfer events,\n// storing the relevant events in an array of transfer events\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  let transfers: TransferEvent[] = [];\n\n  for (let block of ctx.blocks) {\n    for (let log of block.logs) {\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  await processTransfers(ctx, transfers);\n});\n\n// 2. Define an interface to hold the data from the transfer events\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\n// 3. Extract and decode ERC-20 transfer event data from a log entry\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\n// 4. Enrich and insert data into typeorm database\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  await ctx.store.upsert(Array.from(accounts.values()));\n  await ctx.store.insert(transfers);\n}\n\n// 5. Helper function to get account object\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#run-the-indexer","title":"Executar o indexador","text":"<pre><code>sqd build\nsqd up\nsqd migration:generate\nsqd migration:apply\nsqd process\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#query-your-squid","title":"Consultar seu Squid","text":"<pre><code>sqd serve\n</code></pre> <p>Acesse <code>http://localhost:4350/graphql</code> e fa\u00e7a queries, por exemplo:</p> Exemplo de query <pre><code>query {\n  accounts {\n    id\n    transfersFrom {\n      id\n      blockNumber\n      timestamp\n      txHash\n      to {\n        id\n      }\n      amount\n    }\n    transfersTo {\n      id\n      blockNumber\n      timestamp\n      txHash\n      from {\n        id\n      }\n      amount\n    }\n  }\n}\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/#debug-your-squid","title":"Depurar seu Squid","text":"<p>Habilite logs detalhados no <code>.env</code>:</p> <pre><code>SQD_DEBUG=*\n</code></pre> <p>Voc\u00ea pode adicionar logs em <code>main.ts</code> (veja exemplo com logging):</p> main-with-logging.ts <pre><code>import { In } from 'typeorm';\nimport { assertNotNull } from '@subsquid/evm-processor';\nimport { TypeormDatabase } from '@subsquid/typeorm-store';\nimport * as erc20 from './abi/erc20';\nimport { Account, Transfer } from './model';\nimport {\n  Block,\n  contractAddress,\n  Log,\n  Transaction,\n  processor,\n} from './processor';\n\nprocessor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) =&gt; {\n  ctx.log.info('Processor started');\n  let transfers: TransferEvent[] = [];\n\n  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);\n  for (let block of ctx.blocks) {\n    ctx.log.debug(`Processing block number ${block.header.height}`);\n    for (let log of block.logs) {\n      ctx.log.debug(`Processing log with address ${log.address}`);\n      if (\n        log.address === contractAddress &amp;&amp;\n        log.topics[0] === erc20.events.Transfer.topic\n      ) {\n        ctx.log.info(`Transfer event found in block ${block.header.height}`);\n        transfers.push(getTransfer(ctx, log));\n      }\n    }\n  }\n\n  ctx.log.info(`Found ${transfers.length} transfers, processing...`);\n  await processTransfers(ctx, transfers);\n  ctx.log.info('Processor finished');\n});\n\ninterface TransferEvent {\n  id: string;\n  block: Block;\n  transaction: Transaction;\n  from: string;\n  to: string;\n  amount: bigint;\n}\n\nfunction getTransfer(ctx: any, log: Log): TransferEvent {\n  let event = erc20.events.Transfer.decode(log);\n\n  let from = event.from.toLowerCase();\n  let to = event.to.toLowerCase();\n  let amount = event.value;\n\n  let transaction = assertNotNull(log.transaction, `Missing transaction`);\n\n  ctx.log.debug(\n    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`\n  );\n  return {\n    id: log.id,\n    block: log.block,\n    transaction,\n    from,\n    to,\n    amount,\n  };\n}\n\nasync function processTransfers(ctx: any, transfersData: TransferEvent[]) {\n  ctx.log.info('Starting to process transfer data');\n  let accountIds = new Set&lt;string&gt;();\n  for (let t of transfersData) {\n    accountIds.add(t.from);\n    accountIds.add(t.to);\n  }\n\n  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);\n  let accounts = await ctx.store\n    .findBy(Account, { id: In([...accountIds]) })\n    .then((q: any[]) =&gt; new Map(q.map((i: any) =&gt; [i.id, i])));\n  ctx.log.info(\n    `Accounts fetched, processing ${transfersData.length} transfers`\n  );\n\n  let transfers: Transfer[] = [];\n\n  for (let t of transfersData) {\n    let { id, block, transaction, amount } = t;\n\n    let from = getAccount(accounts, t.from);\n    let to = getAccount(accounts, t.to);\n\n    transfers.push(\n      new Transfer({\n        id,\n        blockNumber: block.height,\n        timestamp: new Date(block.timestamp),\n        txHash: transaction.hash,\n        from,\n        to,\n        amount,\n      })\n    );\n  }\n\n  ctx.log.debug(`Upserting ${accounts.size} accounts`);\n  await ctx.store.upsert(Array.from(accounts.values()));\n  ctx.log.debug(`Inserting ${transfers.length} transfers`);\n  await ctx.store.insert(transfers);\n  ctx.log.info('Transfer data processing completed');\n}\n\nfunction getAccount(m: Map&lt;string, Account&gt;, id: string): Account {\n  let acc = m.get(id);\n  if (acc == null) {\n    acc = new Account();\n    acc.id = id;\n    m.set(id, acc);\n  }\n  return acc;\n}\n</code></pre> <p>Erros comuns:</p> <ul> <li>Porta ocupada pelo banco: pare inst\u00e2ncias anteriores (<code>sqd down</code>).  </li> <li><code>ECONNREFUSED</code>: suba o banco com <code>sqd up</code> antes de gerar/apply migrations.  </li> <li>Sem eventos detectados: confirme o endere\u00e7o do contrato em min\u00fasculas (<code>.toLowerCase()</code>) e t\u00f3picos corretos.</li> </ul>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/indexers/sqd/quick-start/","title":"Indexando uma Rede Tanssi com SQD","text":""},{"location":"pt/builders/toolkit/integrations/indexers/sqd/quick-start/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>SQD \u00e9 uma rede de dados que permite recuperar dados de blockchain de mais de 100 cadeias de forma r\u00e1pida e econ\u00f4mica usando o data lake descentralizado da SQD e o SDK open-source. Em termos simples, o SQD funciona como uma ferramenta ETL (extrair, transformar e carregar) com um servidor GraphQL inclu\u00eddo. Ele oferece filtragem abrangente, pagina\u00e7\u00e3o e at\u00e9 pesquisa de texto completo. O SQD tem suporte nativo e completo para dados EVM e Substrate, at\u00e9 no mesmo projeto.</p> <p>Este guia r\u00e1pido mostra como criar um projeto Squid e configur\u00e1-lo para indexar dados em uma rede com tecnologia Tanssi. H\u00e1 uma se\u00e7\u00e3o para redes Substrate e outra para redes EVM. Se voc\u00ea estiver em uma rede EVM, pode usar a se\u00e7\u00e3o Substrate caso tamb\u00e9m precise indexar dados Substrate.</p> <p>Para um tutorial mais completo para redes EVM, confira Indexando Transfer\u00eancias ERC-20 em uma Rede EVM Tanssi.</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/quick-start/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<p>Para os exemplos deste guia, voc\u00ea vai precisar de:</p> <ul> <li>Node.js vers\u00e3o 16 ou superior</li> <li>Docker</li> <li>Squid CLI</li> </ul>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/quick-start/#index-substrate-networks","title":"Indexar uma rede Substrate Tanssi","text":"<p>Para come\u00e7ar a indexar dados Substrate na sua rede Tanssi, crie um projeto Squid e configure-o para sua rede com estes passos:</p> <ol> <li> <p>Crie um projeto Squid baseado no template Substrate executando:</p> <pre><code>sqd init INSERT_SQUID_NAME --template substrate\n</code></pre> <p>Para mais detalhes sobre este template, veja o guia Primeiros passos: Cadeias Substrate na documenta\u00e7\u00e3o da SQD.</p> </li> <li> <p>No diret\u00f3rio raiz do projeto, instale as depend\u00eancias:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Ajuste <code>src/processor.ts</code> para apontar para o RPC da sua rede Tanssi. Remova a linha <code>archive: lookupArchive</code>, pois n\u00e3o ser\u00e1 usado um arquivo Squid. Especifique o RPC da sua rede Substrate Tanssi, pois o endpoint \u00e9 usado para ingerir os dados da cadeia:</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> </li> <li> <p>Suba o Postgres executando:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspecione e execute o processador:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Em outro terminal, no mesmo diret\u00f3rio, inicie o servidor GraphQL:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>Consulte o Squid Substrate de template com a query abaixo. Se voc\u00ea modificar o template para indexar dados diferentes, ajuste a query conforme necess\u00e1rio:</p> <pre><code>query MyQuery {\n  accountsConnection(orderBy: id_ASC) {\n    totalCount\n  }\n}\n</code></pre> </li> </ol> <p>Pronto! Agora voc\u00ea pode atualizar <code>schema.graphql</code>, <code>src/main.ts</code>, <code>typegen.json</code> e <code>src/processor.ts</code> para indexar os dados que precisa.</p>"},{"location":"pt/builders/toolkit/integrations/indexers/sqd/quick-start/#index-evm-networks","title":"Indexar uma rede EVM Tanssi","text":"<p>Para indexar dados EVM em uma rede EVM Tanssi, crie um projeto Squid e configure-o assim:</p> <ol> <li> <p>Crie um projeto Squid para EVM usando o template EVM gen\u00e9rico ou o template ABI para dados de um contrato espec\u00edfico.</p> EVMABI <pre><code>sqd init INSERT_SQUID_NAME --template evm\n</code></pre> <pre><code>sqd init INSERT_SQUID_NAME --template abi\n</code></pre> <p>Para saber mais sobre esses templates, consulte:</p> <ul> <li>Primeiros passos: Cadeias EVM</li> <li>In\u00edcio r\u00e1pido: Ferramentas de gera\u00e7\u00e3o Squid</li> </ul> </li> <li> <p>No diret\u00f3rio raiz do projeto, instale as depend\u00eancias:</p> <pre><code>npm ci\n</code></pre> </li> <li> <p>Ajuste <code>src/processor.ts</code> para apontar para o RPC da sua rede Tanssi. Remova a linha <code>archive: lookupArchive('eth-mainnet')</code>, pois n\u00e3o ser\u00e1 usado um arquivo Squid. Abaixo, o RPC da rede EVM de demonstra\u00e7\u00e3o \u00e9 usado como exemplo; substitua pelo seu:</p> <pre><code>const processor = new EvmBatchProcessor();\nprocessor.setDataSource({\n  chain: 'INSERT_RPC_URL',\n})\n</code></pre> <p>Nota</p> <p>Para testar na rede EVM de demonstra\u00e7\u00e3o, voc\u00ea pode usar este RPC:</p> <pre><code>https://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> </li> <li> <p>Suba o Postgres executando:</p> <pre><code>sqd up\n</code></pre> </li> <li> <p>Inspecione e execute o processador:</p> <pre><code>sqd process\n</code></pre> </li> <li> <p>Em outro terminal, inicie o servidor GraphQL:</p> <pre><code>sqd serve\n</code></pre> </li> <li> <p>Execute consultas no playground GraphQL em <code>http://localhost:4350/graphql</code>, por exemplo:</p> <pre><code>query MyQuery {\n  burns(orderBy: value_DESC) {\n    address\n    block\n    id\n    txHash\n    value\n  }\n}\n</code></pre> </li> </ol> <p>Pronto! Agora voc\u00ea pode atualizar <code>schema.graphql</code>, <code>src/main.ts</code> e <code>src/processor.ts</code> para indexar os dados necess\u00e1rios.</p> <p>Para um guia passo a passo mais completo, veja o tutorial Indexando Transfer\u00eancias ERC-20 em uma Rede EVM Tanssi.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/oracles/","title":"Oracles","text":"<p>Or\u00e1culos de blockchain s\u00e3o servi\u00e7os que permitem que blockchains interajam com fontes de dados externas, preenchendo a lacuna entre contratos inteligentes e informa\u00e7\u00f5es do mundo real. Os or\u00e1culos s\u00e3o essenciais para aplica\u00e7\u00f5es din\u00e2micas que dependem de dados fora da cadeia precisos e oportunos.</p> <p>As principais caracter\u00edsticas dos or\u00e1culos incluem:</p> <ul> <li>Conectividade externa - permitindo que contratos inteligentes busquem e utilizem dados do mundo real</li> <li>Automa\u00e7\u00e3o - acionar a execu\u00e7\u00e3o de contratos com base em condi\u00e7\u00f5es externas</li> <li>Flexibilidade - suportar v\u00e1rios tipos de dados, como feeds de pre\u00e7os, atualiza\u00e7\u00f5es meteorol\u00f3gicas e resultados esportivos</li> </ul>"},{"location":"pt/builders/toolkit/integrations/oracles/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/","title":"Acessando feeds de pre\u00e7o com Acurast","text":""},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Acurast oferece computa\u00e7\u00e3o permissionless, confi\u00e1vel e acess\u00edvel para implantar aplica\u00e7\u00f5es. Um dos usos \u00e9 permitir que desenvolvedores criem or\u00e1culos push/pull, consultando APIs off-chain para trazer pre\u00e7os on-chain. Os dados s\u00e3o processados de forma confidencial pelos Processors e enviados a contratos de redes EVM compat\u00edveis com Tanssi via a interface padr\u00e3o Chainlink Aggregator.</p> <p>Este tutorial mostra um demo de como interagir com feeds de pre\u00e7o fornecidos pela Acurast na rede EVM de demonstra\u00e7\u00e3o do Tanssi. Voc\u00ea tamb\u00e9m pode implantar seus pr\u00f3prios feeds na sua rede EVM com tecnologia Tanssi. Para produ\u00e7\u00e3o, \u00e9 altamente recomend\u00e1vel contatar a equipe Acurast para auxiliar no lan\u00e7amento e garantir a integridade do processo.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#what-is-acurast","title":"O que \u00e9 Acurast?","text":"<p>Acurast \u00e9 uma nuvem descentralizada e sem servidor em que qualquer pessoa pode contribuir poder de computa\u00e7\u00e3o (inclusive com celulares) e receber recompensas. Esses Processors formam uma rede distribu\u00edda mundialmente. Processors e desenvolvedores interagem pelo Acurast Console.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#fetch-price-data","title":"Obter dados de pre\u00e7o","text":"<p>Voc\u00ea pode desenhar o feed de pre\u00e7o Acurast como quiser. Os dados ficam em uma s\u00e9rie de contratos (um por feed) e podem ser consultados via a interface do agregador. O feed demo usa a mesma interface de pre\u00e7o da Chainlink:</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>Na interface, cinco fun\u00e7\u00f5es retornam dados: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code> e <code>latestRoundData</code>. Consulte a refer\u00eancia da Chainlink para detalhes.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#interacting-with-price-feeds-demo-evm-network","title":"Interagir com feeds na rede EVM demo do Tanssi","text":"<p>Vamos usar o feed BTC/USDT j\u00e1 implantado (veja Ativos suportados). O contrato do agregador no Blockscout:</p> <pre><code>0x02093b190D9462d964C11587f7DedD92718D7B56\n</code></pre> <p>Como interagir pelo Remix:</p> <ol> <li>Conecte a MetaMask \u00e0 rede EVM demo (guia Remix).  </li> <li>Cole o contrato Aggregator em um novo arquivo e compile.  </li> <li>Em Deploy and Run, defina ENVIRONMENT para Injected Provider -- MetaMask.  </li> <li>Selecione AggregatorV3Interface em CONTRACT.  </li> <li>No campo At Address, informe <code>0x02093b190D9462d964C11587f7DedD92718D7B56</code> e clique At Address.</li> </ol> <p></p> <p></p> <p>Para consultar:</p> <ol> <li>Expanda AggregatorV3Interface.  </li> <li>Clique em decimals para ver quantas casas decimais o pre\u00e7o usa.  </li> <li>Clique em description para verificar o par.  </li> <li>Clique em latestRoundData para ver o pre\u00e7o mais recente (retornado em int256 answer).</li> </ol> <p></p> <p>Lembre-se de ajustar pelo n\u00famero de decimais informado por <code>decimals()</code>. Ex.: se o feed retorna <code>51933620000</code> e <code>decimals = 6</code>, o pre\u00e7o \u00e9 <code>51,933.62</code>.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#supported-assets","title":"Ativos suportados","text":"<p>Exemplo de chamada de API usada no demo:</p> <pre><code>curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"\n</code></pre> <p>Sa\u00edda de exemplo:</p> curl \"https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT\"  {\"symbol\":\"BTCUSDT\",\"price\":\"51917.61000000\"} <p>Nota</p> <p>Este exemplo usa apenas uma fonte (uma exchange). \u00c9 poss\u00edvel construir scripts que agreguem m\u00faltiplas fontes.</p> <p>Por design, a Acurast pode suportar o feed de qualquer ativo acess\u00edvel por API.</p> <p>Feeds implantados na rede EVM demo:</p> Ativo/Par Contrato agregador AAVE/USDT 0x6239Ff749De3a21DC219bcFeF9d27B0dfE171F42 BTC/USDT 0x02093b190D9462d964C11587f7DedD92718D7B56 CRV/USDT 0x01F143dfd745861902dA396ad7dfca962e5C83cA DAI/USDT 0x73aF6b14b73059686a9B93Cd28b2dEABF76AeC92 ETH/USDT 0x007c3F3cc99302c19792F73b7434E3eCbbC3db25 USDC/USDT 0xe4a46ef4cFbf87D026C3eB293b7672998d932F62 USDT/USD 0xf9c885E3A5846CEA887a0D69655BC08e52afe569 <p>Esses endere\u00e7os est\u00e3o dispon\u00edveis para testes, mas voc\u00ea pode implantar feeds adicionais para outros pares conforme necess\u00e1rio.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#designing-and-launching-your-own-price-feed","title":"Criar e lan\u00e7ar seu pr\u00f3prio feed de pre\u00e7o","text":"<p>Voc\u00ea pode criar seu pr\u00f3prio feed Acurast na rede EVM do Tanssi. Este tutorial \u00e9 apenas demonstrativo; para produ\u00e7\u00e3o, contate a equipe Acurast.</p> <p>S\u00e3o necess\u00e1rios dois componentes: contrato e script. No exemplo anterior de intera\u00e7\u00e3o com BTC/USD usamos a interface Chainlink porque \u00e9 simples de demonstrar. O contrato subjacente segue a interface Chainlink Aggregator, mas o demo adiciona eventos e l\u00f3gica exemplo. C\u00f3digo de contrato e script est\u00e3o no reposit\u00f3rio da Acurast.</p> <p>O contrato de demo <code>InsecureDummyPriceFeed.sol</code> emite eventos quando o pre\u00e7o \u00e9 atualizado e quando um novo round inicia. O m\u00e9todo <code>setPrice</code> \u00e9 inseguro e serve apenas para mostrar onde adicionar consenso, controle de acesso etc.</p> InsecureDummyPriceFeed.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/**\nThis Dummy Oracle is compatible with Chainlink's AggregatorV2V3Interface, meaning projects currently using\nChainlink can seamlessly migrate. The updating of the price feed happens in the interval you specified on\nthe Acurast script.\n\nAt the moment no check on the signer/source is being performed, making this implementation INSECURE. However\nwith a minimal effort you can extend the \"setPrice\" entrypoint to reflext the kind of logic you are looking for\n(i.e. Aggregation Consensus, Check sources, thresholds, etc).\n**/\n\ncontract DummyChainlinkCompatibleOracle is AggregatorV2V3Interface {\n    int256 private latestPrice;\n    uint256 private latestPriceTimestamp;\n    uint256 private latestRoundId;\n\n    // Assuming price can be set without restriction for simplicity\n    // In a real-world scenario, there should be access control mechanisms\n    function setPrice(int256 _price) external {\n        latestPrice = _price;\n        latestPriceTimestamp = block.timestamp;\n        latestRoundId++;\n\n        emit AnswerUpdated(latestPrice, latestRoundId, latestPriceTimestamp);\n        emit NewRound(latestRoundId, msg.sender, latestPriceTimestamp);\n    }\n\n    // AggregatorInterface functions\n    function latestAnswer() external view override returns (int256) {\n        return latestPrice;\n    }\n\n    function latestTimestamp() external view override returns (uint256) {\n        return latestPriceTimestamp;\n    }\n\n    function latestRound() external view override returns (uint256) {\n        return latestRoundId;\n    }\n\n    function getAnswer(uint256 _roundId) external view override returns (int256) {\n        if(_roundId == latestRoundId) {\n            return latestPrice;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    function getTimestamp(uint256 _roundId) external view override returns (uint256) {\n        if(_roundId == latestRoundId) {\n            return latestPriceTimestamp;\n        }\n        return 0; // Simplification, should handle historical data\n    }\n\n    // AggregatorV3Interface functions\n    function decimals() external pure override returns (uint8) {\n        return 6; // Assume a common decimal value for simplicity\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"Sample Price Feed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId == latestRoundId, \"Only latest round data available\");\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));\n    }\n}\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>O contrato de demonstra\u00e7\u00e3o tem vulnerabilidades e n\u00e3o possui controles de acesso; n\u00e3o use em produ\u00e7\u00e3o.</p> <p>Antes de prosseguir, implante o contrato do seu feed na rede EVM do Tanssi (ou na rede demo). Guarde o endere\u00e7o, pois ser\u00e1 usado no script Acurast.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/acurast/#construindo-o-script-acurast","title":"Construindo o script Acurast","text":"<p>O script Acurast atualiza o oracle on-chain com os pre\u00e7os, fazendo a ponte entre o feed de pre\u00e7o da rede Tanssi e a rede Acurast. No console voc\u00ea define par\u00e2metros como frequ\u00eancia, agenda e recompensa dos Processors. Para publicar jobs voc\u00ea precisar\u00e1 de tokens cACU (pegue no faucet) \u2014 eles s\u00e3o a moeda nativa da rede Canary da Acurast.</p> <p>O script atualiza o oracle on-chain com pre\u00e7os. Exemplo de script:</p> AcurastScript.js <pre><code>/**\n * This Oracle Script observes the BTC USDT Pair and posts the price on-chain.\n * Deploying the script is easy using console.acurast.com and simply copy/pasting\n * this script. Make sure to update `DESTINATION_CONTRACT` and `EVM_RPC_NODE` to\n * reflect your deployment. For RPC's with API keys like i.e. infura make sure\n * to work with the Acurast confidential environment variables. After having set\n * them for your job, you can access them easily with a `_STD_.env[\"MY_KEY\"]`. They\n * also come in handy for paid API KEYs, that you don't want to share publicly.\n */\n\nconst DESTINATION_CONTRACT = 'INSERT_CONTRACT_ADDRESS';\nconst EVM_RPC_NODE = 'INSERT_NETWORK_RPC_URL';\n\nhttpGET(\n  'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',\n  {},\n  (response, certificate) =&gt; {\n    if (\n      certificate ===\n      '4795062d13e1ed971c6b6e5699764681e4d090bad39a7ef367cc9cb705652384'\n    ) {\n      //const price = BigInt(JSON.parse(response)[\"price\"] * 10 ** 18); // if you need more precision, just keep in mind that JS stored bigger numbers in float format, rounding up/down your stuff.\n      const price = BigInt(JSON.parse(response)['price'] * 10 ** 6);\n      const int256AsBytes = '0x' + price.toString(16).padStart(64, '0');\n      const payload = '0x' + _STD_.chains.ethereum.abi.encode(int256AsBytes);\n      _STD_.chains.ethereum.fulfill(\n        EVM_RPC_NODE,\n        DESTINATION_CONTRACT,\n        payload,\n        {\n          methodSignature: 'setPrice(int256)',\n          gasLimit: '9000000',\n          maxFeePerGas: '2550000000',\n          maxPriorityFeePerGas: '2550000000',\n        },\n        (opHash) =&gt; {\n          console.log('Succeeded: ' + opHash);\n        },\n        (err) =&gt; {\n          console.log('Failed: ' + err);\n        }\n      );\n    }\n  },\n  (err) =&gt; {\n    console.log('Failed: ' + err);\n  }\n);\n</code></pre> <p>Se voc\u00ea reutilizar o script de exemplo da Acurast, lembre-se de atualizar o endere\u00e7o do contrato e o RPC da sua rede.</p> <p>No console Acurast, configure o job:</p> <ol> <li>Create Jobs \u2192 cadeia Moonbeam, ambiente Moonbase (Tanssi herda a compatibilidade EVM do Moonbeam).  </li> <li>Selecione Price Feeds.  </li> <li>Cole o script (altere o endere\u00e7o do contrato implantado e o RPC da sua rede \u2014 dispon\u00edvel no Tanssi dApp).  </li> <li>Opcional: teste o c\u00f3digo; erros aparecem no console do navegador.  </li> <li>Em seguida, defina Use Public Processors, Interval, hor\u00e1rio de in\u00edcio/fim, intervalo em minutos, dura\u00e7\u00e3o e max start delay.  </li> <li>Defina o Number of processors (mais processadores exigem mais cACU; obtenha no faucet).  </li> <li>Defina o Max Reward por execu\u00e7\u00e3o (exemplo: <code>0.01</code> cACU).  </li> <li>Revise e clique Publish Job. Depois acompanhe o status na mesma p\u00e1gina.</li> </ol> <p></p> <p></p> <p>Na tela seguinte voc\u00ea pode monitorar o status do job publicado.</p> <p>Para mais detalhes sobre como construir e acessar feeds de pre\u00e7o na sua rede EVM Tanssi, consulte a documenta\u00e7\u00e3o da Acurast.</p> <p>Com isso voc\u00ea tem um fluxo completo: contrato on-chain, script de atualiza\u00e7\u00e3o e job publicado na Acurast para manter o feed de pre\u00e7os ativo.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/oracles/band/","title":"Acessando feeds de pre\u00e7os com o Band Protocol","text":""},{"location":"pt/builders/toolkit/integrations/oracles/band/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Band Protocol \u00e9 uma rede de or\u00e1culos descentralizada que fornece dados confi\u00e1veis, seguros e em tempo real para contratos inteligentes em v\u00e1rias redes blockchain.</p> <p>O protocolo \u00e9 constru\u00eddo sobre o BandChain, uma rede projetada para ser compat\u00edvel com a maioria das cadeias compat\u00edveis com EVM, como as redes EVM movidas a Tanssi e estruturas de desenvolvimento de blockchain. O protocolo visa fornecer uma solu\u00e7\u00e3o que seja:</p> <ul> <li>Descentralizada, aproveitando o poder computacional de uma rede de validadores</li> <li>Flex\u00edvel, suportando uma ampla gama de fontes e formatos de dados, facilitando as integra\u00e7\u00f5es</li> <li>Escal\u00e1vel, projetada para lidar com altos volumes de solicita\u00e7\u00f5es de dados</li> <li>Acess\u00edvel, permitindo que os usu\u00e1rios solicitem dados apenas quando precisarem e paguem as taxas associadas</li> </ul> <p>O Band Protocol est\u00e1 atualmente implantado em muitos blockchains (Moonbeam, por exemplo) em diferentes ecossistemas. Para implantar o or\u00e1culo em sua rede, entre em contato diretamente com a equipe do Band Protocol.</p> <p>Este tutorial ir\u00e1 gui\u00e1-lo pelas etapas para interagir com feeds de pre\u00e7os usando o or\u00e1culo do Band Protocol na rede compat\u00edvel com EVM de demonstra\u00e7\u00e3o da Tanssi.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/band/#setup-on-demo-evm-network","title":"Configura\u00e7\u00e3o na rede de demonstra\u00e7\u00e3o EVM da Tanssi","text":"<p>O or\u00e1culo do Band Protocol j\u00e1 est\u00e1 implantado na rede de demonstra\u00e7\u00e3o EVM da Tanssi e configurado para fornecer pre\u00e7os para os tokens <code>ETH</code> e <code>DOT</code>.</p> <p>Os feeds de pre\u00e7os s\u00e3o enviados regularmente para um contrato inteligente que pode ser acessado no seguinte endere\u00e7o:</p> <pre><code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68\n</code></pre> <p>O smart pode ser interagir com usando a interface:</p> IStdReference.sol <pre><code>// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.26;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    } \n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory);\n}\n</code></pre> <p>Como visto acima na interface, existem duas fun\u00e7\u00f5es para buscar dados:</p> getReferenceData (_base, _quote) \u2014 busca o pre\u00e7o de um determinado par base/cota\u00e7\u00e3o Par\u00e2metrosExemplo <ul> <li><code>_base</code> string memory - o token para o qual voc\u00ea deseja obter o pre\u00e7o</li> <li><code>_quote</code> string memory - o token (ou <code>USD</code>) no qual o pre\u00e7o \u00e9 expresso</li> </ul> <ul> <li><code>_base</code> - ETH</li> <li><code>_quote</code> - USD</li> </ul> getReferenceDataBulk (_bases, _quotes) \u2014 busca pre\u00e7os para os pares base/cota\u00e7\u00e3o fornecidos simultaneamente Par\u00e2metrosExemplo <ul> <li><code>_bases</code> string[] memory - a lista de tokens base para os quais voc\u00ea deseja obter os pre\u00e7os</li> <li><code>_quotes</code> string[] memory - a lista de tokens (ou <code>USD</code>) nos quais os pre\u00e7os s\u00e3o expressos</li> </ul> <ul> <li><code>_bases</code> - [\"ETH\", \"DOT\"]</li> <li><code>_quotes</code> - [\"USD\", \"USD\"]</li> </ul> <p>A resposta para ambas as fun\u00e7\u00f5es consiste nos seguintes dados, agrupados em uma tupla no caso de <code>getReferenceData</code> e uma lista de tuplas (uma tupla por par) no caso de <code>getReferenceDataBulk</code>:</p> <ul> <li><code>rate</code> uint256 - pre\u00e7o para o par base/cota\u00e7\u00e3o fornecido. Observe que o resultado deve ser ajustado para considerar dezoito casas decimais</li> <li><code>lastUpdatedBase</code> uint256 - carimbo de data/hora da atualiza\u00e7\u00e3o para o par\u00e2metro <code>_base</code>, expresso em \u00e9pocas UNIX, que \u00e9 o n\u00famero de segundos que se passaram desde <code>01-01-1970 00:00:00 UT</code></li> <li><code>lastUpdatedQuote</code> uint256 - carimbo de data/hora da atualiza\u00e7\u00e3o para o par\u00e2metro <code>_quote</code>, expresso em \u00e9pocas UNIX, que \u00e9 o n\u00famero de segundos que se passaram desde <code>01-01-1970 00:00:00 UT</code></li> </ul>"},{"location":"pt/builders/toolkit/integrations/oracles/band/#fetching-price-feeds-remix","title":"Obtendo feeds de pre\u00e7o usando o Remix","text":"<p>Nesta se\u00e7\u00e3o, usaremos o remix para buscar o pre\u00e7o do par <code>ETH/USD</code>.</p> <p>Primeiro, certifique-se de ter uma carteira compat\u00edvel com EVM conectada \u00e0 rede de demonstra\u00e7\u00e3o EVM. MetaMask \u00e9 usado como exemplo neste guia. Agora, acesse o Remix, cole a interface <code>IStdReference</code> em um novo arquivo e compile-o.</p> <p></p> <p>Em seguida, siga estas etapas:</p> <ol> <li>V\u00e1 para a aba Deploy &amp; Run Transactions</li> <li>Defina o ENVIRONMENT como Injected Provider -- MetaMask</li> <li>Selecione o contrato <code>IStdReference.sol</code> no menu suspenso CONTRACT</li> <li>Insira o endere\u00e7o do contrato do feed de dados, que \u00e9 <code>0x8c064bCf7C0DA3B3b090BAbFE8f3323534D84d68</code> na rede de demonstra\u00e7\u00e3o EVM no campo At Address e clique no bot\u00e3o At Address</li> </ol> <p></p> <p>O contrato agora deve estar acess\u00edvel. Para interagir com ele, siga estas etapas:</p> <ol> <li>Expanda o contrato IStdReference para revelar as fun\u00e7\u00f5es dispon\u00edveis</li> <li>Expanda getReferenceData e defina os par\u00e2metros de entrada <code>_base</code> e <code>_quote</code> como <code>ETH</code> e <code>USD</code>, respectivamente</li> <li>Clique em Call</li> <li>O resultado mostrar\u00e1 tr\u00eas valores: o pre\u00e7o, a hora da atualiza\u00e7\u00e3o para o par\u00e2metro <code>_base</code> e a hora da atualiza\u00e7\u00e3o para o par\u00e2metro <code>_quote</code></li> </ol> <p></p> <p>Observe que, para obter um pre\u00e7o leg\u00edvel do feed de pre\u00e7os, \u00e9 essencial ajustar as casas decimais do feed, que s\u00e3o dezoito. Por exemplo, o exemplo acima mostra um valor de <code>2361167929271984201806</code>, correspondente a um pre\u00e7o de <code>ETH</code> de <code>$2,361.167929271984201806</code> expresso em <code>USD</code>. Al\u00e9m disso, observe que os valores do carimbo de data/hora da atualiza\u00e7\u00e3o s\u00e3o expressos em tempo de \u00e9poca UNIX, expresso como o n\u00famero de segundos que se passaram desde <code>01-01-1970 00:00:00 UT</code>.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/oracles/phala/","title":"Lan\u00e7ando feeds de pre\u00e7os com Phala","text":""},{"location":"pt/builders/toolkit/integrations/oracles/phala/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Phala Network \u00e9 uma rede de computa\u00e7\u00e3o off-chain apoiada por Secure Enclaves que permite a desenvolvedores criar contratos inteligentes potentes conectados a componentes off-chain, chamados Phat Contracts. Os Phat Contracts foram projetados para oferecer funcionalidades que superam as limita\u00e7\u00f5es de contratos tradicionais (armazenamento, custo, computa\u00e7\u00e3o), mantendo-se trustless, verific\u00e1veis e sem permiss\u00e3o. Para saber mais sobre a arquitetura da Phala, consulte a documenta\u00e7\u00e3o.</p> <p>A Phala n\u00e3o \u00e9, por si s\u00f3, uma rede de or\u00e1culos; ela habilita v\u00e1rias capacidades de computa\u00e7\u00e3o off-chain, incluindo uma rede descentralizada de or\u00e1culos. A Phala tamb\u00e9m oferece o Phala Bricks, um conjunto de ferramentas que facilita lan\u00e7ar rapidamente esse tipo de funcionalidade sem precisar construir tudo do zero.</p> <p>Este tutorial mostra um demo de como interagir com feeds de pre\u00e7o habilitados por Phat Contracts na rede EVM de demonstra\u00e7\u00e3o do Tanssi. Em seguida, voc\u00ea ver\u00e1 como implantar feeds de pre\u00e7o na sua rede EVM com tecnologia Tanssi. Para produ\u00e7\u00e3o, \u00e9 altamente recomend\u00e1vel contatar a equipe Phala para auxiliar no lan\u00e7amento e garantir a integridade do processo.</p> <p>Se voc\u00ea j\u00e1 usa outro provedor de or\u00e1culos, a Phala serve como camada de execu\u00e7\u00e3o confidencial para trazer esses dados para sua rede Tanssi. \u00c9 poss\u00edvel adaptar o fluxo descrito aqui para outros feeds ou APIs, mantendo a mesma interface de consumo no contrato EVM.</p> <p>Al\u00e9m disso, por usar enclaves seguros, a Phala reduz a superf\u00edcie de ataque ao processar dados sens\u00edveis ou agregados de m\u00faltiplas fontes, refor\u00e7ando a confian\u00e7a no resultado final consumido pelos dApps.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#how-phala-enables-price-feeds","title":"Como a Phala habilita feeds de pre\u00e7o","text":"<p>A Phala espelha os Chainlink Price Feeds do Ethereum Mainnet. Esses feeds s\u00e3o amplamente adotados e sua coleta/agraga\u00e7\u00e3o \u00e9 feita por v\u00e1rios operadores de n\u00f3 independentes, evitando depend\u00eancia de uma \u00fanica fonte de verdade e reduzindo risco de manipula\u00e7\u00e3o.</p> <p>O componente central do desenho do sistema \u00e9 o Secure Enclave, que processa as mensagens recebidas da blockchain Phala (fila de mensagens criptografada) e garante execu\u00e7\u00e3o fiel mesmo com trabalhadores maliciosos. A blockchain Phala solicita a atualiza\u00e7\u00e3o do feed; os workers off-chain buscam os pre\u00e7os no Ethereum Mainnet e devolvem para a blockchain Phala.</p> <p>Al\u00e9m de replicar or\u00e1culos existentes, \u00e9 poss\u00edvel criar novos or\u00e1culos buscando dados off-chain via Phat Contracts. No exemplo de Phat-EVM Oracle, os pre\u00e7os v\u00eam da API do CoinGecko e podem ser enviados continuamente (push) ou solicitados pelo contrato EVM (pull).</p> <p>Em resumo: a Phala funciona como uma ponte segura entre dados externos e sua rede EVM, permitindo reutilizar feeds consolidados da Chainlink ou construir integra\u00e7\u00f5es sob medida usando Phat Contracts.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#fetch-price-data","title":"Buscar dados de pre\u00e7o","text":"<p>H\u00e1 v\u00e1rios feeds dispon\u00edveis na rede EVM demo. Os feeds habilitados por Phat Contracts usam a mesma interface dos feeds Chainlink. Cada feed fica em um contrato e pode ser consultado pela interface agregadora:</p> <p>Voc\u00ea tamb\u00e9m pode reutilizar a mesma interface para feeds personalizados que a sua equipe decidir publicar, mantendo uma API consistente para contratos e frontends.</p> AggregatorV3Interface.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    /**\n     * Returns the decimals to offset on the getLatestPrice call\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * Returns the description of the underlying price feed aggregator\n     */\n    function description() external view returns (string memory);\n\n    /**\n     * Returns the version number representing the type of aggregator the proxy points to\n     */\n    function version() external view returns (uint256);\n\n    /**\n     * Returns price data about a specific round\n     */\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    /**\n     * Returns price data from the latest round\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n</code></pre> <p>A interface exp\u00f5e cinco fun\u00e7\u00f5es: <code>decimals</code>, <code>description</code>, <code>version</code>, <code>getRoundData</code> e <code>latestRoundData</code>. Para mais detalhes, veja a refer\u00eancia da Chainlink.</p> <p>Essas fun\u00e7\u00f5es permitem consultar metadados do feed, verificar o par de ativos, e obter o pre\u00e7o mais recente ou de uma rodada espec\u00edfica.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#supported-assets","title":"Ativos suportados","text":"<p>A Phala obt\u00e9m os feeds espelhando os feeds Chainlink do Ethereum Mainnet. H\u00e1 contratos para a rede EVM demo e para o Ethereum Mainnet:</p> Rede EVM demo TanssiEthereum Mainnet Par de Ativos Contrato agregador AAVE/USD 0x2E1640853bB2dD9f47831582665477865F9240DB BTC/USD 0x89BC5048d634859aef743fF2152363c0e83a6a49 CRV/USD 0xf38b25b79A72393Fca2Af88cf948D98c64726273 DAI/USD 0x1f56d8c7D72CE2210Ef340E00119CDac2b05449B ETH/USD 0x739d71fC66397a28B3A3b7d40eeB865CA05f0185 USDC/USD 0x4b8331Ce5Ae6cd33bE669c10Ded9AeBA774Bf252 USDT/USD 0x5018c16707500D2C89a0446C08f347A024f55AE3 Par de Ativos Contrato agregador AAVE/USD 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 BTC/USD 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c CRV/USD 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f DAI/USD 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 ETH/USD 0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419 USDC/USD 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6 USDT/USD 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#interacting-with-price-feeds-demo-evm-network","title":"Interagir com feeds na rede EVM demo","text":"<ol> <li>Conecte a MetaMask \u00e0 rede EVM demo (veja o guia Implantar contratos com Remix) e certifique-se de que a MetaMask est\u00e1 nessa rede.  </li> <li>Cole o contrato Aggregator em um novo arquivo no Remix e compile.  </li> <li>V\u00e1 para Deploy and Run Transactions \u2192 ENVIRONMENT = Injected Provider -- MetaMask.  </li> <li>Selecione AggregatorV3Interface em CONTRACT.  </li> <li>No campo At Address, insira o endere\u00e7o do feed desejado (ex.: BTC/USD <code>0x89BC5048d634859aef743fF2152363c0e83a6a49</code>) e clique em At Address.</li> </ol> <p>Para consultar:</p> <ol> <li>Expanda AggregatorV3Interface.  </li> <li>Clique em decimals para ver quantas casas decimais o feed usa.  </li> <li>Clique em description para verificar o par.  </li> <li>Clique em latestRoundData para ver o pre\u00e7o mais recente (int256 answer).</li> </ol> <p></p> <p>Para obter um pre\u00e7o leg\u00edvel, ajuste pelo valor de <code>decimals()</code>. Ex.: se o retorno for <code>5230364122303</code> e <code>decimals=8</code>, o pre\u00e7o \u00e9 <code>52.303,64</code>.</p> <p>Se preferir outro feed (DAI, ETH etc.), basta repetir os passos usando o endere\u00e7o correspondente da tabela de ativos suportados.</p> <p>Caso esteja depurando valores inesperados, valide se o <code>decimals()</code> retornado confere com o esperado para aquele par. Diverg\u00eancias de escala s\u00e3o a causa mais comum de leituras \u201cestranhas\u201d no front-end.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#launching-price-feeds-on-an-evm-network","title":"Lan\u00e7ando feeds de pre\u00e7o em uma rede EVM","text":"<p>\u00c9 f\u00e1cil lan\u00e7ar feeds em uma rede EVM do Tanssi! As etapas a seguir funcionam para redes Trial e dedicadas em Dancelight. Este guia \u00e9 demonstrativo; para produ\u00e7\u00e3o, contate a equipe Phala.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#setup","title":"Setup","text":"<p>Clone o reposit\u00f3rio Phala Mirrored Price Feed e instale depend\u00eancias:</p> <pre><code>cd mirrored-price-feed/ &amp;&amp; yarn install\n</code></pre> <p>Crie o <code>.env</code> a partir do exemplo:</p> <pre><code>cp env.example .env\n</code></pre> <p>Edite o <code>.env</code> e insira a chave privada de uma conta financiada na sua rede e o RPC da sua rede. Se estiver na sua pr\u00f3pria rede, financie uma conta de teste via Sudo (dados no Tanssi dApp). Os demais campos podem ficar em branco.</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\nRPC_URL=INSERT_YOUR_NETWORK_RPC_URL\nVERIFIER_URL=\nVERIFY_ADDRESS=\n</code></pre> <p>Nota</p> <p>Nunca compartilhe frase semente ou chave privada. Este guia \u00e9 apenas educacional.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#configure-deployment-script","title":"Configurar script de implanta\u00e7\u00e3o","text":"<p>Edite <code>scripts/OffchainAggregator.s.sol</code>. Ele recebe <code>decimals</code> (mantenha <code>8</code>) e a descri\u00e7\u00e3o do feed (ex.: <code>BTC / USD</code>). Use exatamente as descri\u00e7\u00f5es suportadas listadas em Ativos suportados, ou o feed n\u00e3o funcionar\u00e1.</p> OffchainAggregator.s.sol <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Script, console2} from \"forge-std/Script.sol\";\nimport {OffchainAggregator} from \"../src/OffchainAggregator.sol\";\n\ncontract OffchainAggregatorScript is Script {\n    function setUp() public {}\n\n    function run() public {\n        vm.startBroadcast();\n        OffchainAggregator aggregator = new OffchainAggregator(\n          8,\n          'BTC / USD'\n        );\n        console2.log(address(aggregator));\n        vm.stopBroadcast();\n    }\n}\n</code></pre> <p>Em <code>feeder.ts</code>, insira os detalhes da sua cadeia (RPC, chainId). O array <code>mainnetFeedContracts</code> (endere\u00e7os do Mainnet) permanece. Limpe <code>aggregatorContracts</code> por enquanto \u2014 mais adiante voc\u00ea adicionar\u00e1 os endere\u00e7os implantados na sua rede.</p> feeder.ts <pre><code>import {\n  createPublicClient,\n  http,\n  parseAbi,\n  createWalletClient,\n  defineChain,\n} from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst mainnetFeedContracts = {\n  'AAVE-USD': '0x547a514d5e3769680Ce22B2361c10Ea13619e8a9',\n  'CRV-USD': '0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f',\n  'ETH-USD': '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419',\n  'BTC-USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',\n  'DAI-USD': '0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9',\n  'USDT-USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D',\n  'USDC-USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',\n};\n\nconst aggregatorContracts = {};\n\nconst abi = parseAbi([\n  'function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n  'function transmit(uint80 _roundId, int192 _answer, uint64 _timestamp) external',\n  'function getRoundData(uint80 _roundId) public view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',\n]);\n\n// Insert your network details here\nconst chain = defineChain({\n  id: INSERT_EVM_CHAIN_ID,\n  name: 'dancelight-evm-network',\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n});\n\nconst publicClient = createPublicClient({\n  chain: mainnet,\n  transport: http(),\n});\n\nconst targetChainPublicClient = createPublicClient({\n  chain,\n  transport: http(),\n});\n\nasync function getLatestRoundData(pair: string) {\n  const address = mainnetFeedContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} mainnet feed contract did not exist.`);\n  }\n  const data = await publicClient.readContract({\n    address,\n    abi,\n    functionName: 'latestRoundData',\n  });\n  return data;\n}\n\nasync function getRoundDataFromAggregator(pair: string, roundId: number) {\n  const address = aggregatorContracts[pair];\n  if (!address) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const publicClient = createPublicClient({\n    chain,\n    transport: http(),\n  });\n  try {\n    const data = await publicClient.readContract({\n      address,\n      abi,\n      functionName: 'getRoundData',\n      args: [roundId],\n    });\n    return data;\n  } catch {}\n}\n\nasync function updateFeed(\n  walletClient: ReturnType&lt;createWalletClient&gt;,\n  pair: string\n) {\n  if (!aggregatorContracts[pair]) {\n    throw new Error(`${pair} aggregator contract did not exist.`);\n  }\n  const [roundId, answer, startedAt, updatedAt, answeredInRound] =\n    await getLatestRoundData(pair);\n  const aggregatorRoundId = Number(roundId &amp; BigInt('0xFFFFFFFFFFFFFFFF'));\n  const data = await getRoundDataFromAggregator(pair, aggregatorRoundId);\n  if (data[1] === answer) {\n    console.info(\n      `${pair} aggregatorRoundId ${aggregatorRoundId} data exists: ${data}`\n    );\n    return;\n  }\n\n  const hash = await walletClient.writeContract({\n    address: aggregatorContracts[pair],\n    abi,\n    functionName: 'transmit',\n    args: [roundId, answer, startedAt],\n  });\n  await targetChainPublicClient.waitForTransactionReceipt({ hash });\n  console.info(`${pair} updated, transmit tx hash: ${hash}`);\n}\n\nasync function main() {\n  if (!process.env.PRIVATE_KEY) {\n    throw new Error('missing process.env.PRIVATE_KEY');\n  }\n  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account,\n  });\n  for (const pair in aggregatorContracts) {\n    await updateFeed(walletClient, pair);\n  }\n}\n\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((err) =&gt; {\n    console.error(err);\n    process.exit(1);\n  });\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#build-and-test","title":"Build e testes","text":"<pre><code>yarn build\nyarn test\n</code></pre> <p>Sa\u00edda esperada:</p> yarn build yarn run v1.22.10  forge build [.] compiling No files changed, compilation skipped \u2728 Done in 0.765. yarn test yarn run v1.22.10  forge test [.] compiling No files changed, compilation skipped Running 1 test for test/OffchainAggregator.t.sol:OffchainAggregatorTest [PASS] test_transmit() (gas: 60497) Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.96ms Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests) \u2728 Done in 0.765."},{"location":"pt/builders/toolkit/integrations/oracles/phala/#deploy","title":"Deploy","text":"<p>Para implantar o contrato agregador do par escolhido:</p> <pre><code>yarn deploy\n</code></pre> <p>Anote o endere\u00e7o retornado.</p> Waiting for receipts. [O0:00:18]\u3010######################################################\u3011 1/1 receipts CO.0s) #####7796 \u2705 [Success]Hash: Oxfb2f2dc6a35286c4595ce6e2bb64c93425b14c310a53f8224df0520666329fd \u2705 Contract Address: OxBc788db88C3344a24706754c1203a267790D626 Block: 4049 Paid: 0.002392252 ETH (598063 gas * 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json ========================== ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL. Total Paid: 0.002392252 ETH (598063 gas * avg 4 gwei) Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json Sensitive values saved to: /Users/kevin/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json \u2728 Done in 30.765s."},{"location":"pt/builders/toolkit/integrations/oracles/phala/#access-aggregator-contract","title":"Acessar o contrato agregador","text":"<p>No Remix, com a MetaMask na sua rede EVM, cole o endere\u00e7o implantado em At Address. Expanda AggregatorV3Interface e clique em latestRoundData \u2014 inicialmente deve retornar <code>0</code> (sem pre\u00e7o atualizado ainda).</p> <p> </p> <p>Se ainda n\u00e3o tiver sua rede configurada na MetaMask, use o bot\u00e3o Add to MetaMask no dashboard do Tanssi dApp para adicion\u00e1-la rapidamente.</p>"},{"location":"pt/builders/toolkit/integrations/oracles/phala/#Trigger","title":"Disparar atualiza\u00e7\u00e3o de pre\u00e7o","text":"<p>Inclua o endere\u00e7o do agregador em <code>aggregatorContracts</code> no <code>feeder.ts</code>:</p> <pre><code>const aggregatorContracts = {\n  'BTC-USD': 'INSIRA_ENDERECO_DO_AGREGADOR',\n}\n</code></pre> <p>Depois execute:</p> <pre><code>npx tsx feeder.ts\n</code></pre> npx tsx feeder.ts BTC-USD updated, transmit tx hash: Oxf1797cfc5bd71e2d848b099cae197ff30dafb5f6947481a5ef6c69271e059a96 <p>No Remix, chame latestRoundData novamente para ver o pre\u00e7o atualizado.</p> <p></p> <p>Para mais informa\u00e7\u00f5es sobre uso da Phala para dados off-chain, veja os docs da Phala.</p> <p>Essa abordagem completa (contrato + script + atualiza\u00e7\u00e3o via feeder) garante que os feeds fiquem sincronizados com as fontes da Chainlink no Mainnet e que sua rede Tanssi receba pre\u00e7os confi\u00e1veis.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/integrations/wallet-integrations/","title":"Integra\u00e7\u00f5es de Carteiras","text":"<p>As integra\u00e7\u00f5es de carteiras s\u00e3o essenciais para permitir as intera\u00e7\u00f5es dos utilizadores com aplica\u00e7\u00f5es descentralizadas (dApps), permitindo que os utilizadores gerenciem de forma segura os seus ativos digitais, assinem transa\u00e7\u00f5es e autentiquem a sua identidade. Estas integra\u00e7\u00f5es fornecem aos desenvolvedores as ferramentas para construir aplica\u00e7\u00f5es que podem interagir com as carteiras dos utilizadores, facilitando transa\u00e7\u00f5es e intera\u00e7\u00f5es blockchain de forma amig\u00e1vel.</p> <p>As principais caracter\u00edsticas das integra\u00e7\u00f5es de carteira incluem:</p> <ul> <li>Suporte multi-carteira - suporte imediato para v\u00e1rios provedores de carteira, reduzindo a necessidade de integra\u00e7\u00e3o personalizada</li> <li>Experi\u00eancia do utilizador aprimorada - os utilizadores podem facilmente conectar-se usando sua carteira preferida atrav\u00e9s de uma interface de utilizador intuitiva</li> <li>Componentes de IU pr\u00e9-constru\u00eddos - componentes de IU prontos para usar para conex\u00e3o de carteira, exibi\u00e7\u00e3o de conta e gerenciamento de saldo, agilizando o desenvolvimento</li> <li>Personaliza\u00e7\u00e3o - personalize a apar\u00eancia e o comportamento do modal da carteira para corresponder \u00e0 sua marca e ao design da interface do utilizador</li> </ul>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/#explore-esta-seccao","title":"Explore Esta Sec\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/","title":"Integrar RainbowKit a uma rede Tanssi","text":""},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>RainbowKit \u00e9 uma biblioteca React que adiciona conex\u00e3o de carteiras a um dApp. Ela suporta v\u00e1rias carteiras e oferece recursos como alternar cadeias, resolver endere\u00e7os ENS e exibir saldo. O RainbowKit traz op\u00e7\u00f5es de customiza\u00e7\u00e3o para cadeias compat\u00edveis com EVM, facilitando conectar carteiras a redes personalizadas.</p> <p>O RainbowKit agrupa v\u00e1rias ferramentas para simplificar a conex\u00e3o de carteiras em um dApp:</p> <ul> <li>Wagmi \u2014 hooks React para contas, carteiras, contratos, transa\u00e7\u00f5es, assinatura, ENS e mais</li> <li>viem \u2014 interface TypeScript com primitivas de baixo n\u00edvel para interagir com Ethereum</li> <li>WalletConnect \u2014 adiciona conex\u00f5es criptografadas e UX aprimorada (ex.: conectar carteira m\u00f3vel via QR)</li> <li>TanStack Query \u2014 ajuda a gerenciar e atualizar estado de servidor no app</li> </ul> <p>Usando essas pe\u00e7as juntas, voc\u00ea evita reimplementar fluxo de conex\u00e3o, persist\u00eancia de sess\u00e3o, atualiza\u00e7\u00e3o de saldo e troca de redes, acelerando a entrega do dApp.</p> <p>Este guia explica como adicionar o RainbowKit a um dApp em uma rede com tecnologia Tanssi usando a CLI, al\u00e9m de op\u00e7\u00f5es para personalizar a integra\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#quick-start","title":"In\u00edcio r\u00e1pido","text":"<p>Para come\u00e7ar um projeto novo, o RainbowKit pode gerar um esqueleto via CLI com RainbowKit e Wagmi em uma aplica\u00e7\u00e3o Next.js. Use o gerenciador de pacotes de sua prefer\u00eancia:</p> npmpnpmyarn <pre><code>npm init @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>pnpm create @rainbow-me/rainbowkit@latest\n</code></pre> <pre><code>yarn create @rainbow-me/rainbowkit\n</code></pre> <p>O script pedir\u00e1 o nome do projeto, criar\u00e1 o diret\u00f3rio com o boilerplate e instalar\u00e1 as depend\u00eancias.</p> npm init @rainbow-me/rainbowkit@latest   \ud83c\udf08 Welcome to RainbowKit!  rainbow-demo  \ud83d\ude80 Creating a new RainbowKit app in /Users/papermoon/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo  \ud83d\udce6 Installing dependencies with npm. This could take a while. \ud83d\udcda Initializing git repository  \ud83c\udf08 Done! Thanks for using RainbowKit \ud83d\ude4f  \ud83d\udc49 To get started, run cd rainbow-demo and then npm run dev <p>Em seguida, inicie o servidor de desenvolvimento e abra <code>http://localhost:3000</code>:</p> npmpnpmyarn <pre><code>cd INSERT_PROJECT_NAME\nnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\npnpm run dev\n</code></pre> <pre><code>cd INSERT_PROJECT_NAME\nyarn dev\n</code></pre> <p>Voc\u00ea ver\u00e1 a tela inicial:</p> <p></p> <p>Abra o projeto no editor e veja o arquivo <code>wagmi.ts</code>. \u00c9 nele que voc\u00ea configura as cadeias dispon\u00edveis para conex\u00e3o.</p> <p>Como a rede EVM demo \u00e9 uma rede personalizada do Tanssi, ela n\u00e3o pode ser importada direto de <code>wagmi/chains</code>. Defina a cadeia manualmente em <code>wagmi.ts</code>.</p> <p>Configura\u00e7\u00e3o para a rede EVM demo do Tanssi:</p> Demo EVM Network src/wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'TODO: get project id from...',\n  chains: [demoEVMChain], \n  ssr: true,\n});\n</code></pre> <p>Atualize <code>wagmi.ts</code> conforme acima para suportar a rede demo. A pr\u00f3xima se\u00e7\u00e3o mostra como obter o <code>projectId</code> do WalletConnect.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#configuracao-manual","title":"Configura\u00e7\u00e3o manual","text":"<p>As se\u00e7\u00f5es seguintes mostram como integrar o RainbowKit em um app React existente: instalar depend\u00eancias, configurar cadeias, disponibilizar o RainbowKit no dApp, definir a cadeia padr\u00e3o do Connect Wallet e personalizar o tema. O exemplo usa a rede EVM demo do Tanssi, mas pode ser adaptado mudando o RPC.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#checking-prerequisites","title":"Verificando pr\u00e9-requisitos","text":"<ul> <li>Uma rede compat\u00edvel com EVM no Tanssi</li> <li>Um dApp existente em React</li> <li>Exemplos do reposit\u00f3rio RainbowKit (h\u00e1 templates para v\u00e1rios frameworks)</li> <li>Para seguir este guia, crie um projeto Next.js (Typescript + App Router) seguindo a instala\u00e7\u00e3o autom\u00e1tica em Next.js</li> <li>A carteira deve suportar redes personalizadas (a rede demo ser\u00e1 adicionada manualmente)</li> <li>Um <code>projectId</code> do WalletConnect (gratuito):<ol> <li>V\u00e1 em WalletConnect Cloud</li> <li>Em Projects, clique Create</li> <li>Preencha as informa\u00e7\u00f5es (pode deixar Homepage URL em branco se n\u00e3o estiver deployado)</li> <li>Escolha o SDK AppKit</li> <li>Escolha o ambiente (React neste guia)</li> <li>Copie o <code>projectId</code> no menu lateral ou no snippet do Quickstart</li> </ol> </li> </ul>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#getting-started","title":"Come\u00e7ando","text":"<p>Instale RainbowKit e depend\u00eancias:</p> npmpnpmyarn <pre><code>npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <pre><code>yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query\n</code></pre> <p>Suba o servidor de desenvolvimento:</p> npmpnpmyarn <pre><code>npm run dev\n</code></pre> <pre><code>pnpm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <p>Abra <code>http://localhost:3000</code>.</p> <p>Para testar, conecte a carteira MetaMask na rede EVM demo do Tanssi. Adicione a rede no MetaMask:</p> <ol> <li>Configura\u00e7\u00f5es &gt; Redes &gt; Adicionar Rede</li> <li>Preencha:</li> <li>Nome: <code>Demo EVM Chain</code></li> <li>RPC URL: <code>https://services.tanssi-testnet.network/dancelight-2001/</code></li> <li>Chain ID: <code>5678</code></li> <li>S\u00edmbolo: <code>TANGO</code></li> <li>Block Explorer: <code>https://dancelight-2001-blockscout.tanssi-chains.network/</code></li> </ol> <p>Para instru\u00e7\u00f5es detalhadas, veja Conecte o MetaMask \u00e0 sua Rede EVM Tanssi.</p> <p>Depois, adicione o <code>projectId</code> ao app:</p> <ol> <li> <p>Crie <code>.env.local</code> na raiz:</p> <pre><code>touch .env.local\n</code></pre> </li> <li> <p>Adicione o ID:</p> .env.local<pre><code>NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'\n</code></pre> </li> <li> <p>Confirme que <code>.env*.local</code> est\u00e1 no <code>.gitignore</code> para evitar commit.</p> </li> </ol> <p>Se voc\u00ea usa v\u00e1rios ambientes (dev/homologa\u00e7\u00e3o/prod), crie um <code>projectId</code> separado para cada um e valide se o dom\u00ednio cadastrado no WalletConnect Cloud corresponde ao ambiente correto.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#conectar-o-dapp-ao-metamask","title":"Conectar o dApp ao MetaMask","text":"<p>Passos principais:</p> <ol> <li>Importar RainbowKit, Wagmi e TanStack Query</li> <li>Configurar o Wagmi</li> <li>Envolver o app com providers</li> <li>Adicionar o bot\u00e3o de conex\u00e3o</li> </ol> <p>Seguir essa ordem garante que o estado de conex\u00e3o e os modais do RainbowKit funcionem em toda a aplica\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#importar-rainbowkit-wagmi-e-tanstack-query","title":"Importar RainbowKit, Wagmi e TanStack Query","text":"<p>Crie <code>wagmi.ts</code> na raiz com imports e a cadeia demo EVM:</p> <pre><code>touch wagmi.ts\n</code></pre> wagmi.ts<pre><code>import '@rainbow-me/rainbowkit/styles.css';\nimport { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { WagmiProvider } from 'wagmi';\nimport { QueryClientProvider, QueryClient } from '@tanstack/react-query';\n\nimport { type Chain } from 'viem'\n\nexport const demoEVMChain = {\n  id: 5678,\n  name: \"Tanssi demo EVM Network\",\n  nativeCurrency: { name: \"TANGO\", symbol: \"TANGO\", decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }\n  },\n  blockExplorers: {\n    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }\n  },\n} as const satisfies Chain\n\n\nexport const config = getDefaultConfig({\n  appName: 'My Tanssi-powered Network',\n  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',\n  chains: [demoEVMChain ], \n  ssr: true,\n});\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#envolver-o-aplicativo-com-providers","title":"Envolver o aplicativo com providers","text":"<p>Crie <code>providers.tsx</code> para incluir <code>WagmiProvider</code> e <code>QueryClientProvider</code>:</p> <pre><code>cd app &amp;&amp; touch providers.tsx\n</code></pre> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider } from '@rainbow-me/rainbowkit';\nimport { config } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider&gt;{children}&lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Depois, edite <code>app/layout.tsx</code> para usar <code>Providers</code>:</p> layout.tsx<pre><code>import type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport '@rainbow-me/rainbowkit/styles.css';\nimport { Providers } from './providers';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'My Tanssi dApp',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &lt;html lang='en'&gt;\n      &lt;body&gt;\n        &lt;Providers&gt;{children}&lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#adicionar-o-botao-connect","title":"Adicionar o bot\u00e3o Connect","text":"<p>Use o componente <code>ConnectButton</code> (pode ficar em <code>page.tsx</code> ou em um header/nav):</p> page.tsx<pre><code>import { ConnectButton } from '@rainbow-me/rainbowkit';\n\nexport default function Home() {\n  return (\n    &lt;div className=\"flex h-screen items-center justify-center\"&gt;\n      &lt;ConnectButton /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Com o servidor rodando, aparecer\u00e1 Connect Wallet; clicar abre o modal RainbowKit. Selecione MetaMask e conecte. A configura\u00e7\u00e3o padr\u00e3o usa a Demo EVM Chain e mostra rede, saldo do token nativo e endere\u00e7o.</p> <p>Se voc\u00ea tiver v\u00e1rios bot\u00f5es ou p\u00e1ginas, considere criar um componente compartilhado para evitar duplicar l\u00f3gica de conex\u00e3o e estiliza\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#personalizar-o-rainbowkit","title":"Personalizar o RainbowKit","text":"<p>O RainbowKit facilita a conex\u00e3o e permite customizar UI/UX. Veja todas as op\u00e7\u00f5es na docs do RainbowKit. Aqui vamos definir a cadeia inicial e aplicar tema customizado.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#definir-cadeia-inicial","title":"Definir cadeia inicial","text":"<p>O RainbowKit conecta na primeira cadeia da lista do Wagmi. Melhor \u00e9 usar <code>initialChain</code> no <code>RainbowKitProvider</code>. Em <code>providers.tsx</code>, defina:</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider initialChain={demoEVMChain}&gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n\n}\n</code></pre> <p>Isso for\u00e7a conectar primeiro na Demo EVM Chain.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#definir-cores-de-tema","title":"Definir cores de tema","text":"<p>Use <code>lightTheme</code>, <code>darkTheme</code> ou <code>midnightTheme</code>. Exemplo com tema escuro customizado (adicione <code>darkTheme</code> ao import):</p> providers.tsx<pre><code>'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';\nimport { config, demoEVMChain } from '../wagmi';\n\nconst queryClient = new QueryClient();\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &lt;WagmiProvider config={config}&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;RainbowKitProvider\n          initialChain={demoEVMChain}\n          theme={darkTheme({\n            accentColor: '#189B9B', // Tanssi accent color\n            accentColorForeground: 'white',\n            borderRadius: 'medium',\n            fontStack: 'system',\n            overlayBlur: 'small'\n          })}\n        &gt;\n          {children}\n        &lt;/RainbowKitProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/WagmiProvider&gt;\n  );\n}\n</code></pre> <p>Campos: - <code>accentColor</code> \u2014 cor prim\u00e1ria (ex.: #189B9B do Tanssi) - <code>accentColorForeground</code> \u2014 cor do texto sobre a prim\u00e1ria - <code>borderRadius</code> \u2014 arredondamento - <code>fontStack</code> \u2014 fontes (ex.: <code>system</code>) - <code>overlayBlur</code> \u2014 desfoque de fundo em modais</p> <p>Voc\u00ea pode ainda ajustar \u00edcones, textos do modal e posi\u00e7\u00e3o do bot\u00e3o criando um tema customizado ou sobrescrevendo componentes via props do <code>ConnectButton</code>.</p> <p>Conselho</p> <p>Teste temas e cores para combinar com o estilo do seu dApp.</p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#lidar-com-desconexoes","title":"Lidar com desconex\u00f5es","text":""},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-dapp","title":"Desconectar no dApp","text":"<p>O modal RainbowKit inclui Disconnect; clique na seta ao lado da conta e depois Disconnect.</p> <p></p>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#disconnect-from-metamask","title":"Desconectar no MetaMask","text":"<ol> <li>Abra a extens\u00e3o MetaMask  </li> <li>Clique nos tr\u00eas pontos (canto superior direito)  </li> <li>Selecione Connected sites </li> <li>Revise e clique Disconnect nos sites desejados</li> </ol>"},{"location":"pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/#final-result","title":"Resultado final","text":"<p>O bot\u00e3o Connect Wallet deve usar a cor definida em <code>accentColor</code>; o modal tamb\u00e9m. Escolha MetaMask, assine e veja a rede EVM demo conectada com o saldo de TANGO sem precisar trocar manualmente.</p> <p>Se desejar suportar redes adicionais, basta adicion\u00e1-las em <code>wagmi.ts</code> e fornecer RPCs confi\u00e1veis; o modal exibir\u00e1 as op\u00e7\u00f5es no Switch Networks respeitando a ordem definida. Verifique tamb\u00e9m se os explorers configurados respondem corretamente para evitar erros de UX.</p> <p></p> <p>Mais op\u00e7\u00f5es est\u00e3o na docs do RainbowKit. C\u00f3digo completo no reposit\u00f3rio rainbowkit-manual-build-demo.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/","title":"Ferramentas Substrate","text":"<p>Ao desenvolver no Tanssi ou em qualquer rede com tecnologia Tanssi, \u00e9 importante entender a infraestrutura subjacente que impulsiona essas cadeias. Constru\u00eddas sobre o framework Substrate, essas redes oferecem uma base robusta e flex\u00edvel para a constru\u00e7\u00e3o de aplica\u00e7\u00f5es e servi\u00e7os descentralizados. Interagir com a API Substrate \u00e9 fundamental para interagir com as funcionalidades principais do blockchain.</p> <p>Quer voc\u00ea esteja construindo aplica\u00e7\u00f5es descentralizadas (dApps), implantando contratos inteligentes ou consultando dados de blockchain, ter as ferramentas e fluxos de trabalho corretos para interagir com esta API ajudar\u00e1 voc\u00ea a otimizar o desenvolvimento e garantir uma integra\u00e7\u00e3o perfeita com a rede.</p> <p>Pronto para mergulhar? Confira algumas das seguintes ferramentas:</p> <ul> <li>Ambientes de desenvolvimento - Chopsticks</li> <li>Bibliotecas - API Polkadot.js e API REST Sidecar</li> <li>Carteiras - SubWallet e Talisman</li> </ul>"},{"location":"pt/builders/toolkit/substrate-api/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/","title":"Configure Seu Espa\u00e7o de Trabalho","text":"<p>A constru\u00e7\u00e3o no Substrate envolve trabalhar com uma estrutura de blockchain flex\u00edvel e modular. Ao contr\u00e1rio das blockchains tradicionais, a arquitetura baseada em paletes do Substrate permite que os desenvolvedores criem blockchains personalizadas e integrem recursos especializados, o que requer um ambiente de desenvolvimento adaptado \u00e0s suas complexidades.</p> <p>Nesta se\u00e7\u00e3o, voc\u00ea explorar\u00e1 ferramentas e t\u00e9cnicas que podem ajud\u00e1-lo a alcan\u00e7ar o seguinte com um ambiente de desenvolvimento Substrate:</p> <ul> <li>Configura\u00e7\u00e3o do ambiente local - inicie um ambiente de teste sem lidar com a complexidade de configurar um n\u00f3 Substrate manualmente</li> <li>Intera\u00e7\u00e3o com a rede - conecte-se e interaja com redes Tanssi e alimentadas por Tanssi</li> <li>Simula\u00e7\u00e3o de transa\u00e7\u00e3o - teste e simule transa\u00e7\u00f5es em redes bifurcadas para avaliar as altera\u00e7\u00f5es antes de implantar</li> <li>Depura\u00e7\u00e3o - use ferramentas de depura\u00e7\u00e3o para solucionar problemas e analisar o fluxo de transa\u00e7\u00f5es, transi\u00e7\u00f5es de estado e muito mais em um ambiente controlado</li> </ul>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/","title":"Como usar Chopsticks para bifurcar sua rede","text":""},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Chopsticks fornece um m\u00e9todo amig\u00e1vel para desenvolvedores de bifurcar localmente as cadeias Substrate-based existentes. Ele permite a reprodu\u00e7\u00e3o de blocos para examinar facilmente como as transa\u00e7\u00f5es afetam o estado, a bifurca\u00e7\u00e3o de v\u00e1rias redes Tanssi para testes XCM e muito mais. Isso capacita os desenvolvedores a testar e experimentar suas configura\u00e7\u00f5es de blockchain personalizadas em um ambiente de desenvolvimento local sem implantar uma rede ao vivo.</p> <p>No geral, o Chopsticks visa simplificar o processo de constru\u00e7\u00e3o de aplicativos blockchain no Substrate e torn\u00e1-lo acess\u00edvel a uma gama mais ampla de desenvolvedores.</p> <p>Este artigo abordar\u00e1 o uso do Chopsticks para bifurcar e interagir com uma c\u00f3pia local de uma rede Tanssi.</p> <p>Nota</p> <p>O Chopsticks atualmente n\u00e3o oferece suporte a chamadas feitas via Ethereum JSON-RPC. Consequentemente, voc\u00ea n\u00e3o pode bifurcar sua cadeia usando o Chopsticks e conectar o Metamask a ela.</p>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#prerequisites","title":"Pr\u00e9-requisitos","text":"<p>Para acompanhar este tutorial, voc\u00ea precisar\u00e1 clonar o reposit\u00f3rio junto com seus subm\u00f3dulos(Smoldot):</p> <pre><code>git clone --recurse-submodules https://github.com/AcalaNetwork/chopsticks.git\n</code></pre> <p>Em seguida, entre na pasta e instale as depend\u00eancias usando yarn:</p> <pre><code> cd chopsticks &amp;&amp; yarn\n</code></pre> <p>Finalmente, construa o projeto:</p> <pre><code>yarn build-wasm\n</code></pre> <p>Agora o ambiente de desenvolvimento est\u00e1 pronto para come\u00e7ar a testar e depurar redes implantadas na Tanssi.</p>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#forking-demo-chain","title":"Bifurcando uma rede EVM de demonstra\u00e7\u00e3o com Chopsticks","text":"<p>Para bifurcar uma rede Tanssi usando o Chopsticks, execute o comando com apenas o endpoint RPC como um par\u00e2metro:</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <p>Este comando iniciar\u00e1 um clone local da cadeia como estava no bloco mais recente.</p>      chopsticks % yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001         [01:59:42.628] INFO (xcm/59650): Frontier Container 2001 RPC listening on port 8000    <p>Normalmente, os par\u00e2metros de configura\u00e7\u00e3o s\u00e3o armazenados em um arquivo de configura\u00e7\u00e3o, como s\u00e3o as configura\u00e7\u00f5es na pasta <code>configs</code> do reposit\u00f3rio para as cadeias de retransmiss\u00e3o e parachains implantadas no ecossistema Dotsama. O seguinte arquivo de configura\u00e7\u00e3o funciona para a rede EVM de demonstra\u00e7\u00e3o, substituindo a conta sudo da cadeia pela de Alith e, adicionalmente, financiando a conta com tokens:</p> <pre><code>endpoint: wss://services.tanssi-testnet.network/dancelight-2001/\nmock-signature-host: true\nallow-unresolved-imports: true\ndb: ./tmp/db_ftrcon.sqlite\n\nimport-storage:\n  System:\n    Account:\n      - - - \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\" # Alith\n        - providers: 1\n          sufficients: 1\n          consumers: 1\n          data:\n            free: \"100000000000000000000000\"\n  Sudo:\n    Key: \"0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac\"\n</code></pre> <p>O arquivo de configura\u00e7\u00e3o aceita todos os seguintes par\u00e2metros:</p> Op\u00e7\u00e3o Descri\u00e7\u00e3o <code>genesis</code> O link para um arquivo genesis bruto de uma parachain para construir a bifurca\u00e7\u00e3o, em vez de um endpoint. <code>timestamp</code> Carimbo de data/hora do bloco para bifurcar. <code>endpoint</code> O endpoint da parachain para bifurcar. <code>block</code> Use para especificar em qual bloco hash ou n\u00famero reproduzir a bifurca\u00e7\u00e3o. <code>wasm-override</code> Caminho do Wasm para usar como tempo de execu\u00e7\u00e3o da parachain em vez do tempo de execu\u00e7\u00e3o do endpoint. <code>db</code> Caminho para o nome do arquivo que armazena ou armazenar\u00e1 o banco de dados da parachain. <code>config</code> Caminho ou URL do arquivo de configura\u00e7\u00e3o. <code>port</code> A porta para expor um endpoint em. <code>build-block-mode</code> Como os blocos devem ser constru\u00eddos na bifurca\u00e7\u00e3o: batch, manual, instant\u00e2neo. <code>import-storage</code> Um caminho de arquivo de armazenamento JSON/YAML predefinido para substituir no armazenamento da parachain. <code>allow-unresolved-imports</code> Se deve permitir importa\u00e7\u00f5es Wasm n\u00e3o resolvidas ao usar um Wasm para construir a parachain. <code>html</code> Incluir para gerar a visualiza\u00e7\u00e3o de diferen\u00e7a de armazenamento entre os blocos. <code>mock-signature-host</code> Simular host de assinatura para que qualquer assinatura comece com <code>0xdeadbeef</code> e preenchida por <code>0xcd</code> seja considerada v\u00e1lida. <p>Voc\u00ea pode executar o comando <code>yarn start</code> para bifurcar cadeias, especificando um arquivo de configura\u00e7\u00e3o local. Alternativamente, o nome ou a URL do GitHub podem ser usados \u200b\u200bse a cadeia estiver listada na pasta <code>configs</code> do reposit\u00f3rio.</p> Caminho do arquivo localNome da cadeiaURL do GitHub <pre><code>yarn start --config=configs/polkadot.yml\n</code></pre> <pre><code>yarn start --config=polkadot\n</code></pre> <pre><code>yarn start \\\n--config=https://github.com/AcalaNetwork/chopsticks.git/master/configs/polkadot.yml\n</code></pre> <p>Todas as configura\u00e7\u00f5es (exceto <code>genesis</code> e <code>timestamp</code>) tamb\u00e9m podem ser passadas como flags para configurar o ambiente completamente na linha de comando. Por exemplo, o seguinte comando bifurca a rede EVM de demonstra\u00e7\u00e3o no bloco 100.</p> <pre><code>yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001/ --block 100\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#interacting-with-a-fork","title":"Interagindo com uma bifurca\u00e7\u00e3o","text":"<p>Ao executar uma bifurca\u00e7\u00e3o, por padr\u00e3o, ela estar\u00e1 acess\u00edvel em:</p> <pre><code>ws://localhost:8000\n</code></pre> <p>Voc\u00ea pode interagir com a parachain por meio de bibliotecas como Polkadot.js e sua interface de usu\u00e1rio, Polkadot.js Apps.</p> <p></p> <p>Voc\u00ea deve ser capaz de interagir com a cadeia bifurcada como faria com a real.</p> <p>Nota</p> <p>Se seu navegador n\u00e3o puder se conectar ao endpoint WebSocket fornecido pelo Chopsticks, talvez seja necess\u00e1rio permitir conex\u00f5es inseguras para o URL do Polkadot.js Apps. Outra solu\u00e7\u00e3o \u00e9 executar a vers\u00e3o Docker do Polkadot.js Apps.</p>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#replaying-blocks","title":"Reexecutando blocos","text":"<p>Se voc\u00ea deseja reproduzir um bloco e recuperar suas informa\u00e7\u00f5es para dissecar os efeitos de uma extr\u00ednseca, pode usar o comando <code>yarn start run-block</code>. Suas seguintes flags s\u00e3o:</p> Sinalizador Descri\u00e7\u00e3o <code>endpoint</code> O endpoint da parachain para bifurcar. <code>block</code> Use para especificar em qual bloco hash ou n\u00famero reproduzir a bifurca\u00e7\u00e3o. <code>wasm-override</code> Caminho do Wasm para usar como tempo de execu\u00e7\u00e3o da parachain em vez do tempo de execu\u00e7\u00e3o do endpoint. <code>db</code> Caminho para o nome do arquivo que armazena ou armazenar\u00e1 o banco de dados da parachain. <code>config</code> Caminho ou URL do arquivo de configura\u00e7\u00e3o. <code>output-path=/[file_path]</code> Use para imprimir os resultados em um arquivo JSON em vez de imprimi-lo no console. <code>open</code> Se deve abrir a representa\u00e7\u00e3o HTML. <p>Por exemplo, a execu\u00e7\u00e3o do seguinte comando reexecutar\u00e1 o bloco 1000 das redes EVM de demonstra\u00e7\u00e3o e gravar\u00e1 a diferen\u00e7a de armazenamento e outros dados em um arquivo <code>chain-output.json</code>:</p> <pre><code>yarn start run-block  \\\n--endpoint wss://services.tanssi-testnet.network/dancelight-2001/  \\\n--output-path=./chain-output.json  \\\n--block 1000\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/dev-env/chopsticks/#websocket-commands","title":"Comandos WebSocket","text":"<p>O servidor WebSocket interno do Chopstick possui endpoints especiais que permitem a manipula\u00e7\u00e3o da cadeia Substrate local.</p> <p>Estes s\u00e3o os m\u00e9todos que podem ser invocados e seus par\u00e2metros:</p> dev_newBlock (options) \u2014 Gera um ou mais blocos novos Par\u00e2metrosExemplo <ul> <li>options - <code>{ \"to\": number, \"count\": number }</code> - um objeto JSON onde <code>\\\"to\\\"</code> criar\u00e1 blocos at\u00e9 um determinado valor, e <code>\\\"count\\\"</code> aumentar\u00e1 em um certo n\u00famero de blocos. Use apenas uma entrada por vez dentro do objeto JSON</li> </ul> <p><code>``js import { WsProvider } from '@polkadot/api' const ws = new WsProvider(</code>ws://localhost:8000`) // Cria cinco novos blocos await ws.send('dev_newBlock', [{ count: 5 }])</p> dev_setStorage (values, blockHash) \u2014 Cria ou sobrescreve o valor de qualquer armazenamento Par\u00e2metrosExemplo <ul> <li>values - Object - um objeto JSON semelhante ao caminho para um valor de armazenamento, semelhante ao que voc\u00ea recuperaria via Polkadot.js  </li> <li>blockHash - String - opcional, o hash do bloco em que o valor do armazenamento \u00e9 alterado  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Substitui a chave sudo\nawait ws.send('dev_setStorage', \n    [{\"Sudo\": { \"Key\": \"0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b\" }}]\n);\n</code></pre> dev_timeTravel (date) \u2014 Define o carimbo de data/hora do bloco para o valor da data Par\u00e2metrosExemplo <ul> <li>date - Date - uma string compat\u00edvel com a biblioteca JavaScript Date que mudar\u00e1 o carimbo de data/hora em que os pr\u00f3ximos blocos a serem criados ser\u00e3o. Todos os blocos futuros ser\u00e3o criados sequencialmente ap\u00f3s esse ponto no tempo  </li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Define o carimbo de data/hora do bloco para 15 de agosto de 2030\nawait ws.send('dev_timeTravel', [\"2030-08-15T00:00:00\"]);\n</code></pre> dev_setHead (hashOrNumber) \u2014 Define o cabe\u00e7alho do blockchain para um hash ou n\u00famero espec\u00edfico Par\u00e2metrosExemplo <ul> <li>hashOrNumber - number | string - se encontrado, o cabe\u00e7alho da cadeia ser\u00e1 definido para o bloco com o n\u00famero do bloco ou hash do bloco deste valor</li> </ul> <pre><code>import { WsProvider } from '@polkadot/api';\nconst ws = new WsProvider(`ws://localhost:8000`);\n// Define o cabe\u00e7alho para o n\u00famero do bloco 500\nawait ws.send('dev_setHead', [500]);\n</code></pre>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/libraries/","title":"Bibliotecas","text":"<p>Como Tanssi e as redes baseadas em Tanssi s\u00e3o constru\u00eddas no Substrate, os desenvolvedores podem utilizar bibliotecas personalizadas para a API Substrate para aproveitar os recursos distintos da rede.</p> <p>Essas bibliotecas simplificam a intera\u00e7\u00e3o com a arquitetura modular do Substrate, ajudando voc\u00ea a navegar pelas complexidades dos m\u00f3dulos personalizados com facilidade e acelerar seu processo de desenvolvimento.</p> <p>Alguns recursos principais de trabalhar com bibliotecas incluem:</p> <ul> <li>Gerenciamento de transa\u00e7\u00f5es - construir e assinar transa\u00e7\u00f5es para enviar extr\u00ednsecas (mudan\u00e7as de estado) para o blockchain</li> <li>Intera\u00e7\u00e3o com m\u00f3dulos personalizados - invocar as fun\u00e7\u00f5es expostas de um m\u00f3dulo, para consultar dados da cadeia ou acionar mudan\u00e7as de estado</li> <li>Gerenciamento de contas - criar pares de chaves criptogr\u00e1ficas para assinar transa\u00e7\u00f5es e gerenciar informa\u00e7\u00f5es de contas na cadeia, como saldos</li> </ul>"},{"location":"pt/builders/toolkit/substrate-api/libraries/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/","title":"Biblioteca da API Polkadot.js","text":""},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Polkadot.js \u00e9 um conjunto de ferramentas que permite interagir com blockchains baseadas em Substrate, como a sua rede com Tanssi! A API Polkadot.js \u00e9 um de seus componentes: uma biblioteca que permite aos desenvolvedores consultar a rede e interagir com as interfaces Substrate do n\u00f3 usando JavaScript, possibilitando ler e escrever dados na rede.</p> <p>Voc\u00ea pode usar a API Polkadot.js para consultar dados on-chain e enviar transa\u00e7\u00f5es pelo lado Substrate da sua rede Tanssi. \u00c9 poss\u00edvel consultar constantes do runtime, estado da cadeia, eventos, dados de transa\u00e7\u00f5es (extr\u00ednsecas) e muito mais.</p> <p>Aqui voc\u00ea encontra uma vis\u00e3o geral das funcionalidades dispon\u00edveis e exemplos de c\u00f3digo em TypeScript para come\u00e7ar a interagir com sua rede Tanssi usando a biblioteca Polkadot.js API.</p> <p>Nota do editor (atualiza\u00e7\u00e3o 2025)</p> <p>Polkadot.js \u00e9 o nome do conjunto de ferramentas para intera\u00e7\u00e3o com blockchains Substrate. Embora o nome fa\u00e7a refer\u00eancia ao Polkadot, a biblioteca \u00e9 agn\u00f3stica de cadeia e funciona com qualquer rede baseada em Substrate, incluindo o Tanssi.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#installing-polkadot.js-api-library","title":"Instalar a API Polkadot.js","text":"<p>Primeiro, instale a biblioteca Polkadot.js API e a biblioteca RLP usando um gerenciador de pacotes como <code>yarn</code>. Ambas s\u00e3o necess\u00e1rias para executar os exemplos deste guia.</p> <p>Instale no diret\u00f3rio do projeto com:</p> npmyarn <pre><code>npm i @polkadot/api\nnpm i @polkadot/util-rlp\n</code></pre> <pre><code>yarn add @polkadot/api\nyarn add @polkadot/util-rlp\n</code></pre> <p>A biblioteca tamb\u00e9m inclui outros componentes centrais, como o Keyring para gerenciamento de contas e utilit\u00e1rios usados ao longo do guia.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-an-API-provider-instance","title":"Criar uma inst\u00e2ncia do provedor da API","text":"<p>Para interagir com sua rede Tanssi usando a Polkadot.js API, crie uma inst\u00e2ncia da API. Construa o <code>WsProvider</code> usando o endpoint WebSocket da sua rede Tanssi.</p> <pre><code>// Importar\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construir provedor da API\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Seu c\u00f3digo aqui\n\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#metadata-and-dynamic-api-decoration","title":"Metadata e decora\u00e7\u00e3o din\u00e2mica da API","text":"<p>Quando a API Polkadot.js se conecta a um n\u00f3, uma das primeiras a\u00e7\u00f5es \u00e9 recuperar a metadata e decorar a API com base nela. A metadata fornece a estrutura:</p> <pre><code>api.&lt;type&gt;.&lt;module&gt;.&lt;section&gt;\n</code></pre> <p>Onde <code>&lt;type&gt;</code> pode ser:</p> <ul> <li><code>query</code> \u2014 endpoints de leitura de estado</li> <li><code>tx</code> \u2014 endpoints relacionados a transa\u00e7\u00f5es</li> <li><code>rpc</code> \u2014 endpoints espec\u00edficos para chamadas RPC</li> <li><code>consts</code> \u2014 endpoints para constantes do runtime</li> </ul> <p>Nada em <code>api.{query, tx, rpc, consts}.&lt;module&gt;.&lt;method&gt;</code> \u00e9 hardcoded. Isso torna a biblioteca modular e adapt\u00e1vel a qualquer cadeia Substrate com diferentes m\u00f3dulos, como sua rede Tanssi.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#querying-for-information","title":"Consultar dados on-chain","text":""},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#state-queries","title":"Consultas de estado","text":"<p>Recuperam informa\u00e7\u00f5es sobre o estado atual da cadeia. Esses endpoints geralmente t\u00eam a forma <code>api.query.&lt;module&gt;.&lt;method&gt;</code>, decorados a partir da metadata. Liste endpoints inspecionando <code>api.query</code>, por exemplo:</p> <pre><code>console.log(api.query);\n</code></pre> <p>Ap\u00f3s inicializar a API, voc\u00ea pode obter informa\u00e7\u00f5es b\u00e1sicas de conta com:</p> <pre><code>// Definir endere\u00e7o da carteira\nconst addr = 'INSERT_ADDRESS';\n\n// Obter o \u00faltimo timestamp\nconst now = await api.query.timestamp.now();\n\n// Obter saldo da conta e nonce atual via m\u00f3dulo system\nconst { nonce, data: balance } = await api.query.system.account(addr);\n\nconsole.log(\n  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n);\n</code></pre> Veja o script completo <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Retrieve the last timestamp via the timestamp module\n  const now = await api.query.timestamp.now();\n\n  // Retrieve the account balance &amp; current nonce via the system module\n  const { nonce, data: balance } = await api.query.system.account(addr);\n\n  console.log(\n    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#rpc-queries","title":"Consultas RPC","text":"<p>As chamadas RPC s\u00e3o a base para transmiss\u00e3o de dados com o n\u00f3. Endpoints como <code>api.query</code>, <code>api.tx</code> ou <code>api.derive</code> encapsulam chamadas RPC, fornecendo informa\u00e7\u00f5es no formato esperado pelo n\u00f3. Liste endpoints via:</p> <pre><code>console.log(api.rpc);\n</code></pre> <p>O <code>api.rpc</code> segue formato semelhante ao <code>api.query</code>. Por exemplo, ap\u00f3s inicializar a API, obtenha dados da cadeia e o cabe\u00e7alho mais recente:</p> <pre><code>// Obter nome da cadeia\nconst chain = await api.rpc.system.chain();\n\n// Obter o cabe\u00e7alho mais recente\nconst lastHeader = await api.rpc.chain.getHeader();\n\n// Registrar as informa\u00e7\u00f5es\nconsole.log(\n  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Retrieve the latest header\n  const lastHeader = await api.rpc.chain.getHeader();\n\n  // Log the information\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#query-subscriptions","title":"Consultas por assinatura","text":"<p>O <code>rpc</code> tamb\u00e9m oferece endpoints de assinatura. Ap\u00f3s inicializar a API, voc\u00ea pode ouvir novos blocos:</p> <pre><code>// Obter nome da cadeia\nconst chain = await api.rpc.system.chain();\n\n// Assinar novos cabe\u00e7alhos\nawait api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n  console.log(\n    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n  );\n});\n</code></pre> <p>O padr\u00e3o geral em <code>api.rpc.subscribe*</code> \u00e9 passar um callback que \u00e9 acionado a cada novo item importado.</p> <p>Chamadas em <code>api.query.*</code> tamb\u00e9m aceitam callbacks para modo assinado, inclusive chamadas com par\u00e2metros. Exemplo para monitorar saldo de uma conta:</p> <pre><code>// Definir endere\u00e7o da carteira\nconst addr = 'INSERT_ADDRESS';\n\n// Assinar mudan\u00e7as de saldo para uma conta espec\u00edfica\nawait api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n  console.log(\n    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n  );\n});\n</code></pre> Veja o script completo <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain name\n  const chain = await api.rpc.system.chain();\n\n  // Subscribe to the new headers\n  await api.rpc.chain.subscribeNewHeads((lastHeader) =&gt; {\n    console.log(\n      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`\n    );\n  });\n\n  // Define wallet address\n  const addr = 'INSERT_ADDRESS';\n\n  // Subscribe to balance changes for a specified account\n  await api.query.system.account(addr, ({ nonce, data: balance }) =&gt; {\n    console.log(\n      `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`\n    );\n\n    // Handle API disconnect here if needed\n  });\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#keyrings","title":"Criar um Keyring para uma conta","text":"<p>O objeto Keyring mant\u00e9m pares de chaves e assina quaisquer dados, seja transfer\u00eancia, mensagem ou intera\u00e7\u00e3o com contrato.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#creating-a-keyring-instance","title":"Criar uma inst\u00e2ncia de Keyring","text":"<p>Instancie a classe Keyring e defina o tipo padr\u00e3o de endere\u00e7o. O padr\u00e3o \u00e9 <code>sr25519</code>, mas para redes Tanssi compat\u00edveis com EVM use <code>ethereum</code>.</p> <pre><code>// Importe o keyring conforme necess\u00e1rio\nimport Keyring from '@polkadot/keyring';\n\n// Crie uma inst\u00e2ncia de keyring (ECDSA)\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\n\n// Crie uma inst\u00e2ncia de keyring (SR25519)\nconst keyring = new Keyring({ type: 'sr25519' });\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#adding-accounts","title":"Adicionar uma conta ao Keyring","text":"<p>H\u00e1 v\u00e1rias formas de adicionar contas, incluindo frase mnem\u00f4nica e chave privada curta. Exemplos:</p> Mnemonic (ECDSA)Chave privada (ECDSA)Mnemonic (SR25519) <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { u8aToHex } from '@polkadot/util';\nimport { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';\n\n// Import Ethereum account from mnemonic\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst mnemonic = 'INSERT_MNEMONIC';\n\n// Define index of the derivation path and the derivation path\nconst index = 0;\nconst ethDerPath = \"m/44'/60'/0'/0/\" + index;\nconsole.log(`Mnemonic: ${mnemonic}`);\nconsole.log(`--------------------------\\n`);\n\n// Extract Ethereum address from mnemonic\nconst newPairEth = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);\nconsole.log(`Ethereum Derivation Path: ${ethDerPath}`);\nconsole.log(`Derived Ethereum Address from Mnemonic: ${newPairEth.address}`);\n\n// Extract private key from mnemonic\nconst privateKey = u8aToHex(\n  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)\n    .secretKey\n);\nconsole.log(`Derived Private Key from Mnemonic: ${privateKey}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\n\n// Import Ethereum account from private key\nconst keyringECDSA = new Keyring({ type: 'ethereum' });\nconst privateKeyInput = 'INSERT_PK';\n\n// Extract address from private key\nconst otherPair = keyringECDSA.addFromUri(privateKeyInput);\nconsole.log(`Derived Address from provided Private Key: ${otherPair.address}`);\n</code></pre> <pre><code>// Import the required packages\nimport Keyring from '@polkadot/keyring';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst main = async () =&gt; {\n  await cryptoWaitReady();\n\n  // Import SR25519 account from mnemonic\n  const keyring = new Keyring({ type: 'sr25519' });\n  const mnemonic = 'INSERT_MNEMONIC';\n\n  // Extract SR25519 address from mnemonic\n  const newPair = keyring.addFromUri(`${mnemonic}`);\n  console.log(`Derived SR25519 Address from Mnemonic: ${newPair.address}`);\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#transactions","title":"Enviando transa\u00e7\u00f5es","text":"<p>Endpoints de transa\u00e7\u00e3o t\u00eam a forma <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>, decorados via metadata. Eles permitem enviar transa\u00e7\u00f5es para inclus\u00e3o em blocos \u2014 transfer\u00eancias, intera\u00e7\u00f5es com pallets, ou qualquer coisa suportada. Liste endpoints via:</p> <pre><code>console.log(api.tx);\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#sending-basic-transactions","title":"Enviar uma transa\u00e7\u00e3o b\u00e1sica","text":"<p>A Polkadot.js API pode enviar transa\u00e7\u00f5es. Supondo que voc\u00ea tenha inicializado a API e um keyring, use:</p> <pre><code>// Inicializar pares de chaves da carteira\nconst alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n// Montar a transa\u00e7\u00e3o\nconst tx = await api.tx.balances.transferAllowDeath(\n  'INSERT_BOBS_ADDRESS',\n  BigInt(INSERT_VALUE)\n);\n\n// Obter o calldata codificado da transa\u00e7\u00e3o\nconst encodedCallData = tx.method.toHex()\nconsole.log(`Encoded calldata: ${encodedCallData}`);\n\n// Assinar e enviar a transa\u00e7\u00e3o\nconst txHash = await tx.signAndSend(alice);\n\n// Exibir o hash da transa\u00e7\u00e3o\nconsole.log(`Submitted with hash ${txHash}`);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Form the transaction\n  const tx = await api.tx.balances.transferAllowDeath(\n    'INSERT_BOBS_ADDRESS',\n    BigInt(INSERT_VALUE)\n  );\n\n  // Retrieve the encoded calldata of the transaction\n  const encodedCalldata = tx.method.toHex();\n  console.log(`Encoded calldata: ${encodedCalldata}`);\n\n  // Sign and send the transaction\n  const txHash = await tx.signAndSend(alice);\n\n  // Show the transaction hash\n  console.log(`Submitted with hash ${txHash}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre> <p>Observe que <code>signAndSend</code> aceita par\u00e2metros opcionais, como <code>nonce</code>, por exemplo <code>signAndSend(alice, { nonce: aliceNonce })</code>. Voc\u00ea pode usar o c\u00f3digo da se\u00e7\u00e3o Consultas de estado para obter o nonce correto, incluindo transa\u00e7\u00f5es no mempool.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#fees","title":"Informa\u00e7\u00f5es de taxa","text":"<p>Os endpoints de transa\u00e7\u00e3o tamb\u00e9m oferecem um m\u00e9todo para obter o peso de um <code>api.tx.&lt;module&gt;.&lt;method&gt;</code>. Use <code>paymentInfo</code> ap\u00f3s montar a transa\u00e7\u00e3o com o m\u00f3dulo e m\u00e9todo espec\u00edficos.</p> <p><code>paymentInfo</code> retorna informa\u00e7\u00f5es de peso em <code>refTime</code> e <code>proofSize</code>, que podem ser usadas para determinar a taxa da transa\u00e7\u00e3o \u2014 \u00fatil ao criar execu\u00e7\u00f5es remotas via XCM.</p> <p>Exemplo, ap\u00f3s inicializar a API, para obter peso de uma transfer\u00eancia simples:</p> <pre><code>// Transa\u00e7\u00e3o para obter informa\u00e7\u00f5es de peso\nconst tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n// Obter informa\u00e7\u00f5es de peso\nconst { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\nconsole.log(`Transaction weight: ${weight}`);\nconsole.log(`Transaction fee: ${partialFee.toHuman()}`);\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Transaction to get weight information\n  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));\n\n  // Get weight info\n  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');\n\n  console.log(`Transaction weight: ${weight}`);\n  console.log(`Transaction fee: ${partialFee.toHuman()}`);\n\n  // Disconnect the API\n  await api.disconnect();\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#transaction-events","title":"Eventos de transa\u00e7\u00e3o","text":"<p>Qualquer transa\u00e7\u00e3o emite eventos; no m\u00ednimo, haver\u00e1 <code>system.ExtrinsicSuccess</code> ou <code>system.ExtrinsicFailed</code>, indicando sucesso ou falha na execu\u00e7\u00e3o. Dependendo da transa\u00e7\u00e3o, outros eventos podem ser emitidos, por exemplo <code>balances.Transfer</code> em uma transfer\u00eancia.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#batching-transactions","title":"Agrupar transa\u00e7\u00f5es","text":"<p>A Polkadot.js API permite processar transa\u00e7\u00f5es em lote via <code>api.tx.utility.batch</code>. As transa\u00e7\u00f5es s\u00e3o processadas sequencialmente de um \u00fanico remetente. A taxa pode ser estimada com <code>paymentInfo</code>.</p> <p>Assumindo que voc\u00ea tenha inicializado a API, um keyring e adicionado uma conta, o exemplo abaixo faz duas transfer\u00eancias em uma transa\u00e7\u00e3o:</p> <pre><code>// Construir lista de transa\u00e7\u00f5es para o batch\nconst txs = [\n  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n];\n\n// Estime as taxas como RuntimeDispatchInfo usando o assinante\n// (endere\u00e7o ou par de chaves bloqueado/desbloqueado)\nconst info = await api.tx.utility\n  .batch(txs)\n  .paymentInfo(alice);\n\nconsole.log(`Estimated fees: ${info}`);\n\n// Construir o batch e enviar as transa\u00e7\u00f5es\nawait api.tx.utility\n  .batch(txs)\n  .signAndSend(alice, ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`included in ${status.asInBlock}`);\n\n      // Desconecte a API aqui!\n    }\n  });\n</code></pre> Veja o script completo <pre><code>import { ApiPromise, WsProvider } from '@polkadot/api';\nimport Keyring from '@polkadot/keyring';\n\nconst main = async () =&gt; {\n  // Construct API provider\n  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Create a keyring instance (ECDSA)\n  const keyring = new Keyring({ type: 'ethereum' });\n\n  // Initialize wallet key pairs\n  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');\n\n  // Construct a list of transactions to batch\n  const txs = [\n    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),\n    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),\n  ];\n\n  // Estimate the fees as RuntimeDispatchInfo, using the signer (either\n  // address or locked/unlocked keypair)\n  const info = await api.tx.utility.batch(txs).paymentInfo(alice);\n\n  console.log(`Estimated fees: ${info}`);\n\n  // Construct the batch and send the transactions\n  await api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) =&gt; {\n    if (status.isInBlock) {\n      console.log(`Included in ${status.asInBlock}`);\n\n      // Disconnect the API\n      await api.disconnect();\n    }\n  });\n};\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#sample-code-for-monitoring-native-token-transfers","title":"C\u00f3digo de exemplo para monitorar transfer\u00eancias do token nativo","text":"<p>Os c\u00f3digos a seguir mostram como escutar transfer\u00eancias do token nativo, enviadas via Substrate ou Ethereum API, usando a biblioteca Polkadot.js ou o Substrate API Sidecar. Os snippets s\u00e3o para demonstra\u00e7\u00e3o e precisam de ajustes e testes antes de produ\u00e7\u00e3o.</p> <p>O snippet abaixo usa <code>subscribeFinalizedHeads</code> para assinar cabe\u00e7alhos de blocos finalizados, percorre as extr\u00ednsecas do bloco e recupera eventos de cada extr\u00ednseca. Se encontrar um evento <code>balances.Transfer</code>, extrai <code>from</code>, <code>to</code>, <code>amount</code> e o <code>tx hash</code> e mostra no console. O <code>amount</code> aparece na menor unidade (Wei). Veja a documenta\u00e7\u00e3o oficial para detalhes da API Polkadot.js e do JSON RPC do Substrate.</p> <pre><code>import '@polkadot/api-augment';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// This script will listen to all Native token transfers (Substrate &amp; Ethereum) and extract the tx hash\n// It can be adapted for any Tanssi-powered network\n\nconst main = async () =&gt; {\n  // Define the provider\n  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');\n  // Create the provider\n  const polkadotApi = await ApiPromise.create({\n    provider: wsProvider,\n  });\n\n  // Subscribe to finalized blocks\n  await polkadotApi.rpc.chain.subscribeFinalizedHeads(\n    async (lastFinalizedHeader) =&gt; {\n      const [{ block }, records] = await Promise.all([\n        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),\n        (await polkadotApi.at(lastFinalizedHeader.hash)).query.system.events(),\n      ]);\n\n      block.extrinsics.forEach((extrinsic, index) =&gt; {\n        const {\n          method: { args, method, section },\n        } = extrinsic;\n\n        const isEthereum = section == 'ethereum' &amp;&amp; method == 'transact';\n\n        // Gets the transaction object\n        const tx = args[0] as any;\n\n        // Convert to the correct Ethereum Transaction format\n        const ethereumTx =\n          isEthereum &amp;&amp;\n          ((tx.isLegacy &amp;&amp; tx.asLegacy) ||\n            (tx.isEip1559 &amp;&amp; tx.asEip1559) ||\n            (tx.isEip2930 &amp;&amp; tx.asEip2930));\n\n        // Check if the transaction is a transfer\n        const isEthereumTransfer =\n          ethereumTx &amp;&amp;\n          ethereumTx.input.length === 0 &amp;&amp;\n          ethereumTx.action.isCall;\n\n        // Retrieve all events for this extrinsic\n        const events = records.filter(\n          ({ phase }) =&gt;\n            phase.isApplyExtrinsic &amp;&amp; phase.asApplyExtrinsic.eq(index)\n        );\n\n        // This hash will only exist if the transaction was executed through Ethereum.\n        let ethereumHash = '';\n\n        if (isEthereum) {\n          // Search for Ethereum execution\n          events.forEach(({ event }) =&gt; {\n            if (event.section == 'ethereum' &amp;&amp; event.method == 'Executed') {\n              ethereumHash = event.data[2].toString();\n            }\n          });\n        }\n\n        // Search if it is a transfer\n        events.forEach(({ event }) =&gt; {\n          if (event.section == 'balances' &amp;&amp; event.method == 'Transfer') {\n            const from = event.data[0].toString();\n            const to = event.data[1].toString();\n            const balance = (event.data[2] as any).toBigInt();\n\n            const substrateHash = extrinsic.hash.toString();\n\n            console.log(\n              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`\n            );\n            console.log(`  - Triggered by extrinsic: ${substrateHash}`);\n            if (isEthereum) {\n              console.log(\n                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`\n              );\n            }\n          }\n        });\n      });\n    }\n  );\n};\n\nmain();\n</code></pre> <p>H\u00e1 mais exemplos de transfer\u00eancias neste gist.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/#utilities","title":"Fun\u00e7\u00f5es utilit\u00e1rias","text":"<p>A API Polkadot.js inclui utilit\u00e1rios para primitivas criptogr\u00e1ficas e fun\u00e7\u00f5es de hash.</p> <p>O exemplo a seguir calcula o hash determin\u00edstico de uma transa\u00e7\u00e3o Ethereum legacy crua: primeiro gera a codifica\u00e7\u00e3o RLP (Recursive Length Prefix) e depois aplica keccak256.</p> <pre><code>import { encode } from '@polkadot/util-rlp';\nimport { keccakAsHex } from '@polkadot/util-crypto';\nimport { numberToHex } from '@polkadot/util';\n\n// Defina o tipo da chave como string\ntype txType = {\n  [key: string]: any;\n};\n\n// Defina a transa\u00e7\u00e3o assinada bruta\nconst txData: txType = {\n  nonce: numberToHex(1),\n  gasPrice: numberToHex(21000000000),\n  gasLimit: numberToHex(21000),\n  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',\n  value: numberToHex(1000000000000000000),\n  data: '',\n  v: '0507',\n  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',\n  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',\n};\n\n// Extraia os valores para um array\nvar txDataArray = Object.keys(txData).map(function (key) {\n  return txData[key];\n});\n\n// Calcule a transa\u00e7\u00e3o codificada em RLP\nvar encoded_tx = encode(txDataArray);\n\n// Fa\u00e7a o hash da transa\u00e7\u00e3o codificada usando keccak256\nconsole.log(keccakAsHex(encoded_tx));\n</code></pre> <p>Consulte o reposit\u00f3rio NPM para a lista de m\u00e9todos dispon\u00edveis em <code>@polkadot/util-crypto</code> e suas descri\u00e7\u00f5es.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/","title":"Usando o Substrate API Sidecar","text":""},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O Substrate API Sidecar permite que aplica\u00e7\u00f5es acessem blocos, saldos de contas e outras informa\u00e7\u00f5es de blockchains baseadas em Substrate por meio de uma API REST. Isso \u00e9 \u00fatil para exchanges, carteiras ou outras aplica\u00e7\u00f5es que precisam acompanhar saldos e mudan\u00e7as de estado em uma rede com Tanssi. Esta p\u00e1gina descreve como instalar e executar o Sidecar para uma rede Tanssi e os endpoints mais usados.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#installing-and-running-substrate-api-sidecar","title":"Instalando e executando o Substrate API Sidecar","text":"<p>H\u00e1 v\u00e1rias formas de instalar e executar o Sidecar. Aqui usamos a instala\u00e7\u00e3o local via NPM. Para uso com Docker, ou build a partir do c\u00f3digo\u2011fonte, consulte o reposit\u00f3rio oficial.</p> <p>Note</p> <p>Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necess\u00e1rio.</p> <p>Verifique tamb\u00e9m se voc\u00ea tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a documenta\u00e7\u00e3o oficial.</p> <p>Al\u00e9m disso, certifique-se de ter inicializado um arquivo <code>package.json</code> para m\u00f3dulos ES6. Voc\u00ea pode criar um <code>package.json</code> padr\u00e3o com npm executando <code>npm init --yes</code>.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#installing-the-substrate-api-sidecar","title":"Instalando o Substrate API Sidecar","text":"<p>Para instalar o servi\u00e7o localmente no diret\u00f3rio atual, execute:</p> <pre><code>npm install @substrate/api-sidecar@20.2.2\n</code></pre> <p>Nota</p> <p>Se a pasta n\u00e3o tiver um projeto Node.js, crie manualmente <code>node_modules</code> com <code>mkdir node_modules</code>.</p> <p>A vers\u00e3o est\u00e1vel v20.2.2 foi testada com redes Tanssi. Verifique a instala\u00e7\u00e3o a partir da raiz do diret\u00f3rio:</p> <pre><code>node_modules/.bin/substrate-api-sidecar --version\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#setting-up-the-substrate-api-sidecar","title":"Configurando o Substrate API Sidecar","text":"<p>No terminal em que o Sidecar rodar\u00e1, exporte a vari\u00e1vel de ambiente com o endpoint WSS da rede que deseja usar:</p> Tanssi MainNetDancelight TestNetDemo EVM NetworkSua rede <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-mainnet.network/tanssi\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=wss://services.tanssi-testnet.network/dancelight-2001/\n</code></pre> <pre><code>export SAS_SUBSTRATE_URL=INSIRA_ENDPOINT_WSS_DA_REDE\n</code></pre> <p>Ap\u00f3s definir, confirme com:</p> <pre><code>echo $SAS_SUBSTRATE_URL\n</code></pre> <p>Ele deve exibir o endpoint configurado.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#running-substrate-api-sidecar","title":"Executando o Substrate API Sidecar","text":"<p>Com a vari\u00e1vel de ambiente definida, a partir da raiz da instala\u00e7\u00e3o, execute:</p> <pre><code>node_modules/.bin/substrate-api-sidecar\n</code></pre> <p>Se a instala\u00e7\u00e3o e configura\u00e7\u00e3o estiverem corretas, ver\u00e1 uma sa\u00edda semelhante a:</p> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-sidecar-endpoints","title":"Endpoints do Substrate API Sidecar","text":"<p>Alguns endpoints comuns:</p> <ul> <li>GET /blocks/head \u2014 bloco finalizado mais recente. O par\u00e2metro opcional <code>finalized=false</code> retorna o bloco mais novo, possivelmente n\u00e3o finalizado</li> <li>GET /blocks/head/header \u2014 cabe\u00e7alho do \u00faltimo bloco. <code>finalized=false</code> opcional</li> <li>GET /blocks/{blockId} \u2014 bloco por altura ou hash</li> <li>GET /accounts/{accountId}/balance-info \u2014 saldo e info da conta</li> <li>GET /node/version \u2014 implementa\u00e7\u00e3o e vers\u00e3o do n\u00f3</li> <li>GET /runtime/metadata \u2014 metadata do runtime em JSON decodificado</li> </ul> <p>Para a lista completa, consulte a documenta\u00e7\u00e3o oficial.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#fields-mapping-in-block-json-object","title":"Mapeamento de campos em blocos","text":"<p>O Sidecar retorna blocos em JSON. Parte do objeto \u00e9 a estrutura aninhada das extr\u00ednsecas processadas:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"MODULE_NAME\"\n                |--method: \"METHOD_NAME\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"MODULE_NAME\"\n                        |--method: \"METHOD_EVENT_NAME\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Assim, saber o m\u00f3dulo e m\u00e9todo chamados permite extrair informa\u00e7\u00f5es espec\u00edficas (por exemplo, transfer\u00eancias de saldo).</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#evm-fields-mapping-in-block-json-object","title":"Mapeamento EVM em blocos","text":"<p>Para redes EVM do Tanssi, as execu\u00e7\u00f5es EVM s\u00e3o identificadas por:</p> <pre><code>{extrinsic_number}.method.pallet = \"ethereum\"\n{extrinsic_number}.method.method = \"transact\"\n</code></pre> <p>Estrutura aninhada:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature\n            |--nonce\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"ethereum\"\n                        |--method: \"Executed\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n                        |--3\n    ...\n</code></pre> <p>Para transa\u00e7\u00f5es Substrate, campos como \u201cNonce\u201d e \u201cSignature\u201d ficam em:</p> <pre><code>extrinsics[extrinsic_number]\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-types-and-payload","title":"Tipos de transa\u00e7\u00e3o EVM e payload","text":"<p>As redes EVM do Tanssi suportam <code>legacy</code>, <code>eip1559</code> e <code>eip2930</code>. Cada tipo cont\u00e9m o seguinte payload:</p> EIP1559LegacyEIP2930 <pre><code>    ...\n    |--eip1559\n        |--chainId\n        |--nonce\n        |--maxPriorityFeePerGas\n        |--maxFeePerGas\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <pre><code>    ...\n    |--legacy\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--signature\n    ...\n</code></pre> <pre><code>    ...\n    |--eip2930\n        |--chainId\n        |--nonce\n        |--gasPrice\n        |--gasLimit\n        |--action\n        |--value\n        |--input\n        |--accessList\n        |--oddYParity\n        |--r\n        |--s\n    ...\n</code></pre> <p>Para mais detalhes sobre EIP1559 e EIP2930, consulte as especifica\u00e7\u00f5es oficiais.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-field-mappings","title":"Mapeamento de campos da transa\u00e7\u00e3o","text":"<p>Para obter remetente, destinat\u00e1rio e hash EVM de qualquer transa\u00e7\u00e3o, verifique o evento com:</p> <pre><code>{event_number}.method.pallet: \"ethereum\"\n{event_number}.method.method: \"Executed\"\n</code></pre> <p>Mapeamentos:</p> EIP1559LegacyEIP2930 Campo EVM Campo JSON do bloco Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip1559.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip1559.nonce</code> Max priority fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Max fee per gas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip1559.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s</code> Endere\u00e7o remetente <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Endere\u00e7o destinat\u00e1rio <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status da execu\u00e7\u00e3o EVM <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> Campo EVM Campo JSON do bloco Nonce <code>extrinsics[extrinsic_number].args.transaction.legacy.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.legacy.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.legacy.value</code> Signature <code>extrinsics[extrinsic_number].args.transaction.legacy.signature</code> Endere\u00e7o remetente <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Endere\u00e7o destinat\u00e1rio <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status execu\u00e7\u00e3o <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> Campo EVM Campo JSON do bloco Chain ID <code>extrinsics[extrinsic_number].args.transaction.eip2930.chainId</code> Nonce <code>extrinsics[extrinsic_number].args.transaction.eip2930.nonce</code> Gas price <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code> Gas limit <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit</code> Value <code>extrinsics[extrinsic_number].args.transaction.eip2930.value</code> Access list <code>extrinsics[extrinsic_number].args.transaction.eip2930.accessList</code> Signature <code>extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s</code> Endere\u00e7o remetente <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Endere\u00e7o destinat\u00e1rio <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Hash EVM <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> Status execu\u00e7\u00e3o <code>extrinsics[extrinsic_number].events[event_number].data[3]</code> <p>Para transa\u00e7\u00f5es EVM, \u201cNonce\u201d e \u201cSignature\u201d ficam em:</p> <pre><code>extrinsics[extrinsic_number].args.transaction[transaction_type]\n</code></pre> <p>Logo, os campos \u201cNonce\u201d e \u201cSignature\u201d no n\u00edvel Substrate (<code>extrinsics[extrinsic_number]</code>) ficam como <code>null</code>.</p> <p>Uma transa\u00e7\u00e3o EVM bem-sucedida retorna <code>succeed: \"Stopped\"</code> ou <code>succeed: \"Returned\"</code> no campo de status de execu\u00e7\u00e3o.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#monitor-transfers","title":"Monitorar transfer\u00eancias de saldo","text":"<p>Os exemplos a seguir mostram como ouvir transfer\u00eancias do token nativo (enviadas via Substrate ou Ethereum API) e transfer\u00eancias de tokens ERC-20 via Ethereum API usando o Sidecar. Transfer\u00eancias via Ethereum API se aplicam apenas \u00e0s redes EVM do Tanssi.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#native-token-transfers","title":"Transfer\u00eancias de token nativo","text":"<p>Redes Tanssi EVM e n\u00e3o\u2011EVM podem fazer transfer\u00eancias nativas via Substrate. O snippet abaixo usa Axios para consultar <code>/blocks/head</code> e decodifica <code>from</code>, <code>to</code>, <code>value</code>, <code>tx hash</code> e <code>status</code> de transfer\u00eancias nativas tanto no n\u00edvel EVM quanto Substrate:</p> <pre><code>import axios from 'axios';\n\n// This script will decode all native token transfers (Substrate &amp; Ethereum)\n// in a given Sidecar block, and extract the tx hash. It can be adapted for\n// any Tanssi-powered network.\n\n// Endpoint to retrieve the latest block\nconst endpoint = 'http://127.0.0.1:8080/blocks/head';\n\nasync function main() {\n  try {\n    // Retrieve the block from the Sidecar endpoint\n    const response = await axios.get(endpoint);\n    // Retrieve the block height of the current block\n    console.log('Block Height: ' + response.data.number);\n\n    // Iterate through all extrinsics in the block\n    response.data.extrinsics.forEach((extrinsic) =&gt; {\n      // Retrieve Ethereum Transfers\n      if (\n        extrinsic.method.pallet === 'ethereum' &amp;&amp;\n        extrinsic.method.method === 'transact'\n      ) {\n        // Get the value for any of the three EIP transaction standards supported\n        const value =\n          (extrinsic.args.transaction.legacy &amp;&amp;\n            extrinsic.args.transaction.legacy.value) ||\n          (extrinsic.args.transaction.eip1559 &amp;&amp;\n            extrinsic.args.transaction.eip1559.value) ||\n          (extrinsic.args.transaction.eip2930 &amp;&amp;\n            extrinsic.args.transaction.eip2930.value);\n\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'ethereum' &amp;&amp;\n            event.method.method === 'Executed'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + event.data[2]);\n            console.log('Value: ' + value);\n            // Check the execution status\n            if (event.data[3].succeed) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n\n      // Retrieve Substrate Transfers\n      if (\n        extrinsic.method.pallet === 'balances' &amp;&amp;\n        (extrinsic.method.method === 'transferKeepAlive' ||\n          extrinsic.method.method === 'transfer')\n      ) {\n        // Iterate through the events to get transaction details\n        extrinsic.events.forEach((event) =&gt; {\n          if (\n            event.method.pallet === 'balances' &amp;&amp;\n            event.method.method === 'Transfer'\n          ) {\n            console.log('From: ' + event.data[0]);\n            console.log('To: ' + event.data[1]);\n            console.log('Tx Hash: ' + extrinsic.hash);\n            console.log('Value: ' + event.data[2]);\n            // Check the execution status\n            if (extrinsic.success) {\n              console.log('Status: Success');\n            } else {\n              console.log('Status: Failed');\n            }\n          }\n        });\n      }\n    });\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#erc-20-token-transfers","title":"Transfer\u00eancias de tokens ERC-20","text":"<p>Eventos emitidos por contratos ERC-20 em redes EVM do Tanssi podem ser decodificados do JSON de bloco. Estrutura:</p> <pre><code>RESPONSE JSON Block Object:\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n                |--pallet: \"ethereum\"\n                |--method: \"transact\"\n            |--signature:\n            |--nonce:\n            |--args\n                |--transaction\n                    |--{transaction_type}\n            |--hash\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"evm\"\n                        |--method: \"Log\"\n                    |--data\n                        |--0\n                            |-- address\n                            |-- topics\n                                |--0\n                                |--1\n                                |--2\n                            |-- data\n            ...\n    ...\n</code></pre> <p>Transfer\u00eancias ERC-20 emitem o evento <code>Transfer</code>, mapeado como:</p> Informa\u00e7\u00e3o da Tx Campo JSON Contrato ERC-20 <code>extrinsics[extrinsic_number].events[event_number].data[0].address</code> Assinatura do evento <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[0]</code> Remetente <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[1]</code> Destinat\u00e1rio <code>extrinsics[extrinsic_number].events[event_number].data[0].topics[2]</code> Valor <code>extrinsics[extrinsic_number].events[event_number].data[0].data</code> <p>Outros eventos EVM podem ser decodificados de forma semelhante; t\u00f3picos e dados variam conforme o evento.</p> <p>Nota</p> <p>O valor transferido considera decimais e est\u00e1 em formato hexadecimal.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#substrate-api-transaction-fees","title":"Taxas de transa\u00e7\u00e3o (Substrate)","text":"<p>Para redes Tanssi EVM e n\u00e3o\u2011EVM, informa\u00e7\u00f5es de taxa de transa\u00e7\u00f5es enviadas via Substrate API podem ser extra\u00eddas de:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>Os endpoints de bloco retornam dados relevantes para um ou mais blocos; veja mais na documenta\u00e7\u00e3o do Sidecar.</p> <p>Como JSON, para <code>pallet</code> e <code>method</code> espec\u00edficos, a taxa \u00e9 fornecida por um evento:</p> <pre><code>{event_number}.method.pallet: \"transactionPayment\"\n{event_number}.method.method: \"TransactionFeePaid\"\n</code></pre> <p>Estrutura relevante:</p> <pre><code>RESPONSE JSON Block Object:\n    ...\n    |--number\n    |--extrinsics\n        |--{extrinsic_number}\n            |--method\n            |--signature\n            |--nonce\n            |--args\n            |--tip\n            |--hash\n            |--info\n            |--era\n            |--events\n                |--{event_number}\n                    |--method\n                        |--pallet: \"transactionPayment\"\n                        |--method: \"TransactionFeePaid\"\n                    |--data\n                        |--0\n                        |--1\n                        |--2\n    ...\n</code></pre> <p>Mapeamento:</p> Informa\u00e7\u00e3o da Tx Campo JSON Conta que paga <code>extrinsics[extrinsic_number].events[event_number].data[0]</code> Taxa total paga <code>extrinsics[extrinsic_number].events[event_number].data[1]</code> Gorjeta <code>extrinsics[extrinsic_number].events[event_number].data[2]</code> <p>A taxa total para a extr\u00ednseca est\u00e1 em:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[1]\n</code></pre>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#ethereum-api-transaction-fees","title":"Taxas de transa\u00e7\u00e3o (API Ethereum)","text":"<p>Em redes EVM do Tanssi, usu\u00e1rios podem enviar transa\u00e7\u00f5es via API Ethereum. As taxas podem ser calculadas assim:</p> EIP-1559LegacyEIP-2930 <pre><code>GasPrice = BaseFee + MaxPriorityFeePerGas &lt; MaxFeePerGas ?\n            BaseFee + MaxPriorityFeePerGas :\n            MaxFeePerGas;\nTransaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <pre><code>Transaction Fee = (GasPrice * TransactionWeight) / 25000\n</code></pre> <p>As se\u00e7\u00f5es a seguir detalham cada componente.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#base-fee","title":"Base Fee","text":"<p>A <code>BaseFee</code> \u00e9 o valor m\u00ednimo cobrado para enviar uma transa\u00e7\u00e3o, introduzida pela EIP-1559. Redes EVM do Tanssi ajustam a base fee dinamicamente, de forma semelhante ao mecanismo da EIP-1559, conforme congestionamento do bloco. No template EVM do Tanssi, a gas price m\u00ednima \u00e9 <code>1 GWei</code>.</p> <p>A <code>BaseFee</code> pode ser obtida em <code>baseFeePerGas</code> do m\u00f3dulo <code>baseFee</code>:</p> <pre><code>GET /pallets/baseFee/storage/baseFeePerGas?at={blockId}\n</code></pre> <p>Estrutura relevante:</p> <pre><code>RESPONSE JSON Storage Object:\n    |--at\n        |--hash\n        |--height\n    |--pallet\n    |--palletIndex\n    |--storageItem\n    |--keys\n    |--value\n</code></pre> <p>O valor est\u00e1 em <code>value</code> (fixed point); divida pelas casas decimais para obter o valor real.</p>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#gasprice-maxfeepergas-maxpriorityfeepergas","title":"GasPrice, MaxFeePerGas e MaxPriorityFeePerGas","text":"<p><code>GasPrice</code> especifica o gas price em transa\u00e7\u00f5es legacy (pr\u00e9\u2011EIP-1559). <code>MaxFeePerGas</code> e <code>MaxPriorityFeePerGas</code> foram introduzidos com a EIP-1559 juntamente com a <code>BaseFee</code>. <code>MaxFeePerGas</code> define a taxa m\u00e1xima por unidade de gas (soma de BaseFee + MaxPriorityFeePerGas). <code>MaxPriorityFeePerGas</code> \u00e9 a gorjeta m\u00e1xima configurada para priorizar a transa\u00e7\u00e3o.</p> <p>Embora redes EVM do Tanssi sejam compat\u00edveis com Ethereum, s\u00e3o cadeias Substrate, e prioridades funcionam de forma diferente: no Substrate as transa\u00e7\u00f5es n\u00e3o s\u00e3o priorizadas por gas price. O Tanssi usa um sistema de prioriza\u00e7\u00e3o ajustado que reordena transa\u00e7\u00f5es Substrate com base na taxa por gas (derivada de tip e weight). Para transa\u00e7\u00f5es Ethereum, a prioridade \u00e9 definida pela priority fee.</p> <p>Nota: prioridade n\u00e3o \u00e9 o \u00fanico fator para ordenar transa\u00e7\u00f5es; longevidade tamb\u00e9m influencia.</p> <p>Os valores de <code>GasPrice</code>, <code>MaxFeePerGas</code> e <code>MaxPriorityFeePerGas</code> podem ser lidos do JSON do bloco conforme a estrutura descrita em Mapeamento EVM.</p> <p>Os dados de uma transa\u00e7\u00e3o Ethereum em um bloco podem ser obtidos de:</p> <pre><code>GET /blocks/{blockId}\n</code></pre> <p>Trajetos relevantes:</p> EIP1559LegacyEIP2930 Campo EVM Campo JSON MaxFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas</code> MaxPriorityFeePerGas <code>extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas</code> Campo EVM Campo JSON GasPrice <code>extrinsics[extrinsic_number].args.transaction.legacy.gasPrice</code> Campo EVM Campo JSON GasPrice <code>extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice</code>"},{"location":"pt/builders/toolkit/substrate-api/libraries/sidecar-api/#transaction-weight","title":"Transaction Weight","text":"<p><code>TransactionWeight</code> mede o tempo de execu\u00e7\u00e3o de uma transa\u00e7\u00e3o no bloco. Para todos os tipos, pode ser obtido no evento da extr\u00ednseca onde:</p> <pre><code>pallet: \"system\", method: \"ExtrinsicSuccess\"\n</code></pre> <p>E ent\u00e3o o <code>TransactionWeight</code> est\u00e1 em:</p> <pre><code>extrinsics[extrinsic_number].events[event_number].data[0].weight\n</code></pre>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/wallets/","title":"Carteiras","text":"<p>Carteiras s\u00e3o ferramentas digitais que permitem aos usu\u00e1rios armazenar, gerenciar e transacionar com seguran\u00e7a seus ativos digitais. Elas armazenam as chaves criptogr\u00e1ficas necess\u00e1rias para acessar ativos digitais e permitem que se executem transa\u00e7\u00f5es em redes blockchain.</p> <p>as p\u00e1ginas desta se\u00e7\u00e3o fornecem uma vis\u00e3o geral de como come\u00e7ar a usar v\u00e1rios provedores de carteira. Ela aborda como criar e importar contas, conectar-se \u00e0 sua rede e come\u00e7ar a interagir com ela.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/ledger/","title":"Interagindo com as Tanssi Chains do Substrate usando Ledger","text":""},{"location":"pt/builders/toolkit/substrate-api/wallets/ledger/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de redes Substrate, como a rede Tanssi ou appchains Substrate n\u00e3o-EVM alimentadas pela Tanssi, t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. Em rela\u00e7\u00e3o \u00e0s carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, Ledger \u00e9 uma das op\u00e7\u00f5es mais populares. Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.</p> <p>Os dispositivos Ledger s\u00e3o carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles s\u00e3o usados para verificar e assinar as transa\u00e7\u00f5es, mas ainda precisam de uma camada de software para fornecer a interface do usu\u00e1rio que interage com as redes, constr\u00f3i as transa\u00e7\u00f5es e envia as transa\u00e7\u00f5es assinadas de volta para a rede assim que o usu\u00e1rio as verifica.</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias para usar seu dispositivo Ledger com as Tanssi Chains do Substrate.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/ledger/#setting-up-ledger-device","title":"Configurando seu dispositivo Ledger","text":"<p>Se voc\u00ea tiver um dispositivo Ledger novo, consulte o site oficial para obter um guia sobre como inici\u00e1-lo com a configura\u00e7\u00e3o inicial.</p> <p>Agora, com seu Ledger j\u00e1 iniciado, instale o aplicativo Polkadot seguindo estas etapas:</p> <ol> <li>Abra o aplicativo Ledger Live no seu computador.</li> <li>V\u00e1 para My Ledger.</li> <li>Conecte e desbloqueie o dispositivo.</li> </ol> <p>Por fim, procure o aplicativo Polkadot (DOT) no Ledger Live e instale-o em seu dispositivo.</p> <p>Nota</p> <p>Por que Polkadot? Tanssi \u00e9 constru\u00eddo usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptogr\u00e1fica. Isso significa que o aplicativo Ledger chamado Polkadot (DOT) \u00e9 totalmente compat\u00edvel com Tanssi.</p> <p></p> <p>E \u00e9 isso. Seu dispositivo agora possui uma conta Substrate e \u00e9 capaz de assinar transa\u00e7\u00f5es na Tanssi e em qualquer appchain n\u00e3o-EVM alimentada pela Tanssi.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/ledger/#adding-Ledger-hot-wallet","title":"Adicionando o Ledger a uma carteira quente","text":"<p>Conforme apresentado na introdu\u00e7\u00e3o, uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usu\u00e1rios verifiquem e assinem transa\u00e7\u00f5es. No entanto, por design, ele n\u00e3o pode interagir com blockchains ou dApps por si s\u00f3, nem oferece uma interface do usu\u00e1rio para gerenciar ativos. Para complementar o dispositivo, uma carteira quente \u00e9 necess\u00e1ria. O usu\u00e1rio pode escolher qualquer carteira Substrate, como Talisman ou SubWallet.</p> <p>Para fins de demonstra\u00e7\u00e3o, mostraremos como configurar o Talisman para funcionar com sua carteira de hardware, mas essas etapas s\u00e3o geralmente aplic\u00e1veis a qualquer outra carteira habilitada para Substrate que suporte Ledger. Para acompanhar as etapas, certifique-se de ter o Talisman instalado no seu navegador, em seguida, abra a extens\u00e3o e:</p> <ol> <li>Pressione o \u00edcone + (Adicionar conta).</li> <li>Clique na guia Conectar.</li> <li>Selecione Conectar Ledger.</li> </ol> <p></p> <p>Na tela seguinte, siga estas etapas:</p> <ol> <li>Selecione Polkadot. Outras op\u00e7\u00f5es ser\u00e3o apresentadas abaixo.</li> <li>Selecione Polkadot no menu suspenso.</li> <li>Selecione Aplicativo Polkadot na caixa. Voc\u00ea ser\u00e1 solicitado a conectar seu ledger e abrir o aplicativo Polkadot.</li> <li>Certifique-se de que seu ledger est\u00e1 conectado com sucesso.</li> <li>Clique em Continuar.</li> </ol> <p></p> <p>Na pr\u00f3xima etapa, voc\u00ea ser\u00e1 apresentado a uma lista de contas derivadas. Selecione aquela que voc\u00ea deseja importar, clique em Continuar, e pronto! Sua carteira Talisman agora pode assinar transa\u00e7\u00f5es usando seu dispositivo Ledger.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/","title":"Interagindo com Sua Rede Tanssi Substrate Usando SubWallet","text":""},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de redes Substrate com tecnologia Tanssi t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. SubWallet \u00e9 uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Substrate, mas voc\u00ea pode consultar um tutorial semelhante para interagir com SubWallet usando a API Ethereum.</p> <p>A extens\u00e3o de navegador da carteira SubWallet pode ser baixada para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. SubWallet tamb\u00e9m possui um aplicativo m\u00f3vel para iOS e Android, mas isso est\u00e1 al\u00e9m do escopo deste guia. Um painel de ativos online completo \u00e9 acess\u00edvel em web.subwallet.app.</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias, desde a instala\u00e7\u00e3o do SubWallet at\u00e9 a configura\u00e7\u00e3o de uma carteira, conectando-a \u00e0 sua rede Tanssi Substrate e enviando fundos.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#creating-your-first-substrate-account","title":"Criando Sua Primeira Conta Substrate","text":"<p>Primeiro, baixe e instale a extens\u00e3o SubWallet. Criar uma nova conta gerar\u00e1 uma frase semente que pode derivar v\u00e1rias contas Ethereum e Substrate. Por padr\u00e3o, SubWallet gerar\u00e1 uma \u00fanica conta Ethereum e uma \u00fanica conta Substrate, mas voc\u00ea pode facilmente derivar mais da mesma frase semente. Clique em Criar uma nova conta para come\u00e7ar.</p> <p></p> <p>Na tela seguinte, voc\u00ea ser\u00e1 solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a fazer backup de sua frase semente. Esta \u00e9 uma etapa importante, especialmente porque voc\u00ea tem a op\u00e7\u00e3o de derivar posteriormente contas adicionais desta frase semente.</p> <p></p> <p>Nota</p> <p>Voc\u00ea nunca deve compartilhar sua frase semente (mnem\u00f4nico) ou chave privada com ningu\u00e9m. Isso lhes d\u00e1 acesso direto aos seus fundos. Este guia \u00e9 apenas para fins educacionais.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#importing-an-existing-substrate-account","title":"Importando uma Conta Substrate Existente","text":"<p>\u00c9 claro que voc\u00ea pode importar uma conta Substrate existente para o SubWallet. Para come\u00e7ar, siga estas etapas:</p> <ol> <li>Pressione o bot\u00e3o Todas as contas na parte superior</li> <li>Pressione o \u00edcone Importar conta</li> </ol> <p></p> <p>Na tela seguinte, selecione o m\u00e9todo pelo qual voc\u00ea gostaria de importar a conta existente. Se voc\u00ea estiver importando uma conta Substrate, pode escolher entre as op\u00e7\u00f5es de frase semente, Polkadot.js (JSON) ou c\u00f3digo QR.</p> <p></p> <p>Na tela seguinte, voc\u00ea poder\u00e1 fornecer a frase semente relevante, o arquivo JSON ou o c\u00f3digo QR, e poder\u00e1 come\u00e7ar a usar sua nova conta imediatamente.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-dancelight","title":"Conectando SubWallet ao Dancelight","text":"<p>O SubWallet vem pr\u00e9-configurado com suporte para Dancelight, a Tanssi TestNet, mas pode n\u00e3o estar habilitado por padr\u00e3o. Voc\u00ea s\u00f3 precisa ir para a p\u00e1gina Gerenciar redes para ativ\u00e1-lo. Lembre-se de que Dancelight em si \u00e9 a rede baseada em Substrate que orquestra e gerencia o lan\u00e7amento de redes com tecnologia Tanssi. Para configurar seu SubWallet para funcionar com Dancelight, pressione o \u00edcone Mais op\u00e7\u00f5es no canto superior esquerdo. Em seguida, clique em Gerenciar redes e siga estas etapas:</p> <ol> <li>Procure por Dancelight</li> <li>Ative o controle deslizante para habilitar o suporte para Dancelight</li> </ol> <p></p> <p>Se voc\u00ea tiver um saldo de tokens Dancelight, ver\u00e1 o saldo da sua conta na p\u00e1gina inicial da carteira SubWallet. Por padr\u00e3o, todos os saldos s\u00e3o ocultos no SubWallet, mas se voc\u00ea pressionar o \u00edcone de olho, poder\u00e1 alternar a visibilidade do saldo.</p> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#connecting-Subwallet-to-your-substrate-network","title":"Conectando SubWallet \u00e0 Sua Rede Substrate","text":"<p>Para configurar o SubWallet para sua rede Substrate, pressione o \u00edcone Mais op\u00e7\u00f5es no canto superior esquerdo. Em seguida, clique em Gerenciar redes. Pressione o \u00edcone +. Na p\u00e1gina seguinte, voc\u00ea ser\u00e1 solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstra\u00e7\u00e3o, o Dancelight \u00e9 usado aqui; no entanto, voc\u00ea pode substituir esses detalhes por sua pr\u00f3pria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:</p> <ol> <li>Cole a URL WSS da sua rede Tanssi. Outros par\u00e2metros, como a ID da parachain e as casas decimais dos tokens, podem ser preenchidos automaticamente</li> <li>Forne\u00e7a um nome para sua rede Tanssi</li> <li>Pressione Salvar</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#connecting-to-polkadotjs","title":"Conectando ao Polkadot.js","text":"<p>Para conectar sua rede Tanssi Substrate ao Polkadot.js Apps, primeiro v\u00e1 para Polkadot.js Apps. Neste exemplo, Polkadot.js Apps est\u00e1 conectado ao Dancelight, mas voc\u00ea pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo endpoint personalizado.</p> <p></p> <p>A extens\u00e3o SubWallet solicitar\u00e1 que voc\u00ea selecione as contas que deseja usar com o Polkadot.js Apps. Se ele n\u00e3o aparecer automaticamente, voc\u00ea pode abrir a extens\u00e3o SubWallet e clicar no \u00edcone Conectado ao lado da sua conta na parte superior. Para configurar o SubWallet para interagir corretamente com sua rede Tanssi no Polkadot.js Apps, voc\u00ea deve seguir estas etapas:</p> <ol> <li>Selecione as contas Substrate que voc\u00ea gostaria de usar com o Polkadot.js Apps</li> <li>Pressione Conectar</li> </ol> <p></p> <p>Sua carteira SubWallet agora est\u00e1 conectada ao Polkadot.js Apps. Ap\u00f3s atualizar o Polkadot.js Apps, voc\u00ea dever\u00e1 ver sua conta SubWallet na [p\u00e1gina Contas do Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=\\_blank} sob o cabe\u00e7alho extens\u00e3o.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/subwallet/#sending-a-transaction","title":"Enviando uma Transa\u00e7\u00e3o","text":"<p>Para enviar uma transa\u00e7\u00e3o por meio da API Substrate, clique em Enviar ao lado da sua conta no Polkadot.js Apps. Em seguida, siga estas etapas:</p> <ol> <li>Insira o enviar para endere\u00e7o</li> <li>Insira o valor</li> <li>Pressione Fazer Transfer\u00eancia e confirme a transa\u00e7\u00e3o no pop-up do Polkadot.js resultante</li> <li>Pressione Ver Detalhes se voc\u00ea quiser inspecionar o conte\u00fado da transa\u00e7\u00e3o</li> <li>Pressione Aprovar para enviar a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Voc\u00ea tamb\u00e9m pode enviar uma transa\u00e7\u00e3o por meio da API Substrate diretamente da extens\u00e3o SubWallet sem usar o Polkadot.js Apps. Para fazer isso, pressione o \u00edcone Enviar e siga estas etapas:</p> <ol> <li>Especifique o ativo a ser enviado</li> <li>Especifique a cadeia de destino (neste caso, a mesma cadeia de onde voc\u00ea est\u00e1 enviando)</li> <li>Insira o endere\u00e7o de destino</li> <li>Insira o n\u00famero de tokens a serem enviados</li> <li>Analise os detalhes da transa\u00e7\u00e3o e, em seguida, pressione Transferir e, em seguida, Aprovar</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configura\u00e7\u00e3o do SubWallet para funcionar com sua rede Tanssi Substrate, mas o SubWallet tamb\u00e9m \u00e9 uma carteira completa para contas EVM. Na se\u00e7\u00e3o da API Ethereum, voc\u00ea encontrar\u00e1 um guia semelhante para configurar o SubWallet para uso com sua rede Tanssi EVM.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/","title":"Interagindo com Tanssi ou sua Appchain Substrate usando Talisman","text":""},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Desenvolvedores e usu\u00e1rios de redes Substrate, como a rede Tanssi ou appchains Substrate com tecnologia Tanssi, t\u00eam uma variedade de op\u00e7\u00f5es quando se trata de carteiras. Talisman \u00e9 uma \u00f3tima op\u00e7\u00e3o, pois oferece suporte nativo total para contas Substrate e Ethereum. Este guia se concentra na API Substrate. Voc\u00ea tamb\u00e9m pode conferir um guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM.</p> <p>Talisman \u00e9 uma carteira Web3 que suporta nativamente contas Substrate e Ethereum. A extens\u00e3o do navegador da carteira Talisman est\u00e1 dispon\u00edvel no Google Chrome, Brave e outros navegadores baseados em Chromium, bem como no Firefox. Um painel de ativos \u00e9 acess\u00edvel em app.talisman.xyz</p> <p>Este guia leva voc\u00ea por todas as etapas necess\u00e1rias, desde a instala\u00e7\u00e3o do Talisman at\u00e9 a configura\u00e7\u00e3o de uma carteira, conectando-a \u00e0 sua rede Substrate Tanssi e enviando fundos.</p> <p>Nota do Editor (Atualiza\u00e7\u00e3o de 2025)</p> <p>Este guia faz refer\u00eancia a op\u00e7\u00f5es como Polkadot.js Apps ou tipo de conta Polkadot porque esses s\u00e3o os r\u00f3tulos usados em ferramentas Substrate comuns. A pr\u00f3pria Tanssi \u00e9 independente \u2014 constru\u00edda com Substrate e alinhada com a seguran\u00e7a apoiada pela Ethereum.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#setting-up-talisman","title":"Configurando o Talisman","text":"<p>Primeiro, baixe e instale a extens\u00e3o Talisman. Este guia primeiro abordar\u00e1 a cria\u00e7\u00e3o de uma nova carteira e, mais tarde, tratar\u00e1 da importa\u00e7\u00e3o de uma existente. Revise os termos e condi\u00e7\u00f5es e, em seguida, pressione Come\u00e7ar.</p> <p></p> <p>Na tela seguinte, voc\u00ea ser\u00e1 solicitado a criar uma senha para proteger sua nova carteira.</p> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#create-a-substrate-account","title":"Criar uma Conta Substrate","text":"<p>Para criar sua primeira conta Substrate no Talisman, siga as seguintes etapas:</p> <ol> <li>Selecione a op\u00e7\u00e3o Polkadot.</li> <li>D\u00ea um nome para sua conta.</li> <li>Pressione Criar.</li> </ol> <p>Nota</p> <p>Por que Polkadot? Tanssi e appchains com tecnologia Tanssi s\u00e3o constru\u00eddos usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptogr\u00e1fica.</p> <p></p> <p>Ap\u00f3s criar sua primeira conta, voc\u00ea ser\u00e1 solicitado a fazer backup de sua frase semente. Esta \u00e9 uma etapa importante, especialmente porque voc\u00ea tem a op\u00e7\u00e3o de, mais tarde, derivar contas adicionais dessa frase semente.</p> <p></p> <p>Nota</p> <p>Voc\u00ea nunca deve compartilhar sua frase semente (mnem\u00f4nico) ou chave privada com ningu\u00e9m. Isso lhes d\u00e1 acesso direto aos seus fundos. Este guia \u00e9 apenas para fins educacionais.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#importing-an-existing-substrate-account","title":"Importando uma Conta Substrate Existente","text":"<p>\u00c9 claro que voc\u00ea pode importar uma conta Substrate existente para o Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Pressione Adicionar Conta.</li> <li>Pressione Importar.</li> <li>Selecione Importar via Frase de Recupera\u00e7\u00e3o.</li> </ol> <p></p> <p>Na tela seguinte, siga as seguintes etapas:</p> <ol> <li>Selecione o tipo de conta Polkadot.</li> <li>Forne\u00e7a um nome para sua conta.</li> <li>Cole sua semente.</li> <li>Selecione quais contas voc\u00ea gostaria de importar.</li> <li>Pressione Importar.</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-the-tanssi-network","title":"Conectando o Talisman \u00e0 Rede Tanssi","text":"<p>Talisman j\u00e1 vem pr\u00e9-configurado com suporte para Tanssi MainNet e Dancelight. Para se conectar ao Dancelight, voc\u00ea primeiro precisa garantir que ativou o suporte para TestNets no Talisman. Para fazer isso, siga as seguintes etapas:</p> <ol> <li>Abra a extens\u00e3o Talisman e clique no logotipo do Talisman.</li> <li>Selecione Configura\u00e7\u00f5es.</li> <li>Certifique-se de que Habilitar testnets esteja marcado.</li> </ol> <p></p> <p>Se voc\u00ea tiver um saldo de tokens Tanssi MainNet ou Dancelight, ver\u00e1 o saldo da sua conta na p\u00e1gina inicial da carteira Talisman. Quando voc\u00ea n\u00e3o tem um saldo, a rede \u00e9 omitida da sua lista de ativos.</p> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-talisman-to-your-substrate-network","title":"Conectando o Talisman \u00e0 sua Rede Substrate","text":"<p>Para configurar o Talisman para sua rede Substrate com tecnologia Tanssi, abra a extens\u00e3o Talisman e clique na guia Mais Op\u00e7\u00f5es. Clique em Configura\u00e7\u00f5es &gt; Redes e Tokens &gt; Gerenciar Redes.</p> <ol> <li>Deslize o controle deslizante da rede para Polkadot.</li> <li>Marque a caixa Habilitar testnets.</li> <li>Pressione Adicionar Rede.</li> </ol> <p></p> <p>Na p\u00e1gina seguinte, voc\u00ea ser\u00e1 solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstra\u00e7\u00e3o, o Dancelight \u00e9 usado aqui, mas voc\u00ea pode substituir esses detalhes pela sua pr\u00f3pria rede Tanssi. Para adicionar sua rede Tanssi ao Talisman, siga as seguintes etapas:</p> <ol> <li>Cole a URL RPC da sua rede Tanssi. Outros par\u00e2metros ser\u00e3o preenchidos automaticamente.</li> <li>Opcionalmente, insira a URL do explorador de blocos da sua rede Tanssi, se aplic\u00e1vel.</li> <li>Marque a caixa Esta \u00e9 uma testnet, se aplic\u00e1vel.</li> <li>Pressione Adicionar Rede.</li> </ol> <p></p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs","title":"Conectando ao Polkadot.js","text":"<p>Para conectar sua rede Substrate Tanssi aos Polkadot.js Apps, primeiro acesse [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=_blank}. Neste exemplo, os Polkadot.js Apps est\u00e3o conectados ao Dancelight, mas voc\u00ea pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo de endpoint personalizado.</p> <p></p> <p>A extens\u00e3o Talisman solicitar\u00e1 que voc\u00ea selecione as contas que deseja usar com os Polkadot.js Apps. Se ela n\u00e3o aparecer automaticamente, voc\u00ea pode abrir a extens\u00e3o Talisman e clicar no t\u00edtulo polkadot.js.org na parte superior. Para configurar o Talisman para interagir corretamente com sua rede Tanssi nos Polkadot.js Apps, voc\u00ea deve seguir as seguintes etapas:</p> <ol> <li>Selecione a(s) conta(s) Substrate que voc\u00ea deseja usar com os Polkadot.js Apps</li> <li>Pressione Conectar 1. O valor mudar\u00e1 dependendo do n\u00famero de contas que voc\u00ea est\u00e1 conectando</li> </ol> <p></p> <p>Sua carteira Talisman agora est\u00e1 conectada aos Polkadot.js Apps. Ap\u00f3s atualizar os Polkadot.js Apps, voc\u00ea deve ver sua conta Talisman na [p\u00e1gina Contas dos Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/accounts){target=_blank} abaixo do t\u00edtulo extens\u00e3o.</p>"},{"location":"pt/builders/toolkit/substrate-api/wallets/talisman/#sending-a-transaction","title":"Enviando uma Transa\u00e7\u00e3o","text":"<p>Para enviar uma transa\u00e7\u00e3o por meio da API Substrate, clique em Enviar pr\u00f3ximo \u00e0 sua conta nos Polkadot.js Apps. Em seguida, siga as seguintes etapas:</p> <ol> <li>Insira o endere\u00e7o para enviar.</li> <li>Insira o valor.</li> <li>Pressione Fazer Transfer\u00eancia e confirme a transa\u00e7\u00e3o no pop-up Polkadot.js resultante.</li> <li>Pressione Ver Detalhes se voc\u00ea quiser inspecionar o conte\u00fado da transa\u00e7\u00e3o.</li> <li>Pressione Aprovar para enviar a transa\u00e7\u00e3o.</li> </ol> <p></p> <p>Este guia se concentrou especificamente na configura\u00e7\u00e3o do Talisman para funcionar com sua rede Substrate Tanssi, mas o Talisman tamb\u00e9m \u00e9 uma carteira completa para contas EVM. Na se\u00e7\u00e3o da API Ethereum, voc\u00ea encontrar\u00e1 um guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/learn/","title":"Aprenda","text":"<p>Lan\u00e7ar uma rede descentralizada tem sido tradicionalmente um processo desafiador e demorado, exigindo experi\u00eancia em infraestrutura, seguran\u00e7a e configura\u00e7\u00e3o operacional. Tanssi simplifica essa jornada, removendo as complexidades e tornando a implanta\u00e7\u00e3o de rede r\u00e1pida e acess\u00edvel.</p> <p>Esta se\u00e7\u00e3o explora os elementos centrais que definem Tanssi como uma solu\u00e7\u00e3o l\u00edder para o desenvolvimento de redes. Se voc\u00ea est\u00e1 come\u00e7ando sua jornada em redes descentralizadas ou aprofundando sua compreens\u00e3o das capacidades \u00fanicas do Tanssi, estes documentos fornecem tudo que voc\u00ea precisa para entender como o Tanssi estabelece um novo padr\u00e3o para a infraestrutura de rede.</p>"},{"location":"pt/learn/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/#comece-a-construir-agora","title":"Comece a Construir AgoraConstrua Sua Rede","text":"<p>Comece sua jornada Tanssi aqui se voc\u00ea preferir aprender fazendo.</p> <p>Aprenda a projetar e personalizar sua rede com modelos e ferramentas prontos para uso, adaptados \u00e0s suas necessidades t\u00e9cnicas.</p>"},{"location":"pt/learn/decentralized-networks/","title":"Redes Tanssi-Powered","text":"<p>Desenvolver uma blockchain que equilibre escalabilidade, efici\u00eancia e personaliza\u00e7\u00e3o \u00e9 uma tarefa complexa. As Redes Tanssi-Powered abordam estes desafios atrav\u00e9s da sua integra\u00e7\u00e3o na infraestrutura modular da Tanssi. Esta sec\u00e7\u00e3o explica a estrutura, funcionalidade e caracter\u00edsticas \u00fanicas das redes no ecossistema Tanssi.</p> <p>Principais funcionalidades das redes Tanssi-powered:</p> <ul> <li>Personaliza\u00e7\u00e3o de tempo de execu\u00e7\u00e3o - adapte os tipos de transac\u00e7\u00f5es, a l\u00f3gica de execu\u00e7\u00e3o e as transi\u00e7\u00f5es de estado para se adequar aos requisitos espec\u00edficos da sua rede</li> <li>Efici\u00eancia de transac\u00e7\u00f5es - otimize as taxas de transac\u00e7\u00f5es para escalabilidade e sustentabilidade econ\u00f3mica</li> <li>Escalabilidade no seu n\u00facleo - construa redes preparadas para crescer juntamente com o seu ecossistema</li> </ul>"},{"location":"pt/learn/decentralized-networks/#explore-esta-seccao","title":"Explore Esta Sec\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/decentralized-networks/included-templates/","title":"Modelos de Rede Inclu\u00eddos no Tanssi","text":""},{"location":"pt/learn/decentralized-networks/included-templates/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A constru\u00e7\u00e3o de uma nova rede do zero pode ser uma tarefa assustadora. Felizmente, gra\u00e7as ao framework de desenvolvimento de rede usado pelo Tanssi e sua arquitetura orientada a m\u00f3dulos, os desenvolvedores podem aproveitar alguns modelos de rede pr\u00e9-empacotados que os ajudam a dar o pontap\u00e9 inicial no processo e se beneficiar em alguns aspectos, como:</p> <ul> <li> <p>Head Start - Os modelos de rede Tanssi fornecem um ponto de partida para seu projeto, economizando tempo e esfor\u00e7o significativos, fornecendo uma estrutura b\u00e1sica e um conjunto de funcionalidades testadas e prontas para uso. Ele permite que os desenvolvedores acelerem a constru\u00e7\u00e3o de prot\u00f3tipos ou produtos minimamente vi\u00e1veis (MVPs) e reduzam o tempo de lan\u00e7amento</p> </li> <li> <p>Consist\u00eancia - os modelos de rede Tanssi inclu\u00eddos seguem padr\u00f5es de design estabelecidos, padr\u00f5es de codifica\u00e7\u00e3o e melhores pr\u00e1ticas amplamente aceitos entre a comunidade de desenvolvedores. Eles tamb\u00e9m fornecem um conjunto padr\u00e3o de defini\u00e7\u00f5es de arquitetura para otimizar o desenvolvimento de blockchain</p> </li> <li> <p>UX - Os modelos de rede Tanssi cobrem os casos de uso mais exigidos, como o suporte EVM para uma rede compat\u00edvel com Ethereum</p> </li> <li> <p>Customiza\u00e7\u00e3o - Os modelos de rede Tanssi s\u00e3o um \u00f3timo ponto de partida e s\u00e3o totalmente personaliz\u00e1veis. As funcionalidades e configura\u00e7\u00f5es padr\u00e3o que eles incluem podem ser modificadas, substitu\u00eddas ou estendidas para atender aos requisitos espec\u00edficos do caso de uso</p> </li> <li> <p>Atualiza\u00e7\u00f5es e Compatibilidade - Tanssi \u00e9 constru\u00eddo sobre um framework em evolu\u00e7\u00e3o, com novos recursos, aprimoramentos e corre\u00e7\u00f5es de bugs sendo introduzidos regularmente. Os modelos de rede Tanssi fornecidos s\u00e3o mantidos atualizados com essas atualiza\u00e7\u00f5es</p> </li> </ul>"},{"location":"pt/learn/decentralized-networks/included-templates/#start-building","title":"Comece a Construir uma Rede","text":"<p>Para come\u00e7ar a construir uma rede descentralizada para implanta\u00e7\u00e3o em Tanssi, alguns modelos de rede Tanssi \u00fateis para iniciar o processo de desenvolvimento s\u00e3o fornecidos no reposit\u00f3rio oficial.</p> <p>O processo \u00e9 t\u00e3o simples quanto:</p> <ol> <li>Selecione um dos modelos</li> <li>Adicione a l\u00f3gica espec\u00edfica para adaptar o tempo de execu\u00e7\u00e3o aos requisitos do caso de uso</li> <li>Implante no Tanssi</li> </ol> <p></p> <p>Os dois modelos inclu\u00eddos s\u00e3o o modelo de rede de linha de base e o modelo EVM de linha de base, que s\u00e3o apresentados nas se\u00e7\u00f5es a seguir.</p>"},{"location":"pt/learn/decentralized-networks/included-templates/#baseline-network-template","title":"Baseline Network Template","text":"<p>Conforme apresentado no artigo Vis\u00e3o geral, as redes implantadas por meio do Tanssi s\u00e3o blockchains totalmente soberanas e personaliz\u00e1veis.</p> <p>Como parte do ecossistema Tanssi, as redes devem incluir os componentes essenciais para implementar o mecanismo de consenso e ser capazes de interagir e sincronizar com o provedor de seguran\u00e7a de sua escolha (por exemplo, Symbiotic no Ethereum). O modelo de rede Tanssi de linha de base inclui toda a funcionalidade necess\u00e1ria para a l\u00f3gica de sequenciadores, p2p, banco de dados e camadas de sincroniza\u00e7\u00e3o entre a rede e o provedor de seguran\u00e7a, permitindo que os desenvolvedores se concentrem exclusivamente na personaliza\u00e7\u00e3o de seu produto.</p> <p>Este modelo tamb\u00e9m inclui o m\u00f3dulo Author Noting do Tanssi, que implementa a l\u00f3gica para recuperar e validar o conjunto de sequenciadores atribu\u00eddos para fornecer servi\u00e7os de produ\u00e7\u00e3o de blocos \u00e0 rede. Ele tamb\u00e9m inclui a l\u00f3gica que permite que um sequenciador assine o bloco quando o mecanismo de consenso determina que \u00e9 a vez do sequenciador produzir o bloco (e, portanto, ser recompensado de acordo).</p> <p>O c\u00f3digo fonte para este modelo \u00e9 p\u00fablico e acess\u00edvel no reposit\u00f3rio Tanssi GitHub.</p>"},{"location":"pt/learn/decentralized-networks/included-templates/#baseline-evm-template","title":"Baseline EVM (Ethereum Virtual Machine) Template","text":"<p>Estendendo o modelo de rede Tanssi de linha de base, este modelo fornece n\u00e3o apenas suporte ao protocolo Tanssi, mas tamb\u00e9m um EVM e compatibilidade total com Ethereum.</p> <p>Aproveitando um conjunto de m\u00f3dulos espec\u00edficos para EVM, este modelo inclui uma camada de compatibilidade com Ethereum para que as redes possam executar dApps Ethereum n\u00e3o modificadas.</p> <p>Usando este modelo, as redes suportam a implanta\u00e7\u00e3o e execu\u00e7\u00e3o de qualquer contrato inteligente existente escrito em Solidity ou Vyper, sem altera\u00e7\u00f5es. Ao emular a produ\u00e7\u00e3o de blocos Ethereum e expor a interface RPC esperada, os desenvolvedores tamb\u00e9m podem continuar usando as mesmas ferramentas como Metamask, Hardhat, Remix, Foundry, e muitos mais prontos para uso, sem adaptadores extras.</p> <p>Com este modelo EVM, os desenvolvedores podem implantar uma rede semelhante a Moonbeam em nenhum momento e adicionar sua l\u00f3gica e recursos personalizados, espec\u00edficos para seu caso de uso.</p> <p>O c\u00f3digo fonte para este modelo \u00e9 p\u00fablico e acess\u00edvel no reposit\u00f3rio Tanssi GitHub.</p>"},{"location":"pt/learn/decentralized-networks/overview/","title":"Vis\u00e3o Geral das Redes Tanssi","text":""},{"location":"pt/learn/decentralized-networks/overview/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As redes implementadas atrav\u00e9s do Tanssi recebem muitos benef\u00edcios, como produ\u00e7\u00e3o de blocos como um servi\u00e7o, recuperabilidade de dados como um servi\u00e7o e seguran\u00e7a atrav\u00e9s de provedores de seguran\u00e7a externos, como o Symbiotic no Ethereum.</p> <p>Al\u00e9m disso, como as redes com tecnologia Tanssi s\u00e3o baseadas em uma pilha de tecnologia modular, elas se beneficiam de vantagens exclusivas quando as personaliza\u00e7\u00f5es s\u00e3o necess\u00e1rias em um n\u00edvel de tempo de execu\u00e7\u00e3o. Esta modularidade permite que os desenvolvedores adicionem funcionalidades diretamente no tempo de execu\u00e7\u00e3o ou estendam as capacidades da pr\u00f3pria EVM atrav\u00e9s de contratos pr\u00e9-compilados.</p> <p>Por exemplo, o Tanssi fornece um modelo pronto para uso que inclui m\u00f3dulos Frontier, permitindo a implementa\u00e7\u00e3o sem esfor\u00e7o de redes compat\u00edveis com EVM, semelhante ao Moonbeam. Esta se\u00e7\u00e3o aborda os fundamentos de uma rede Tanssi, sua arquitetura, seus m\u00f3dulos e funcionalidades principais e o mecanismo de taxas de transa\u00e7\u00e3o.</p>"},{"location":"pt/learn/decentralized-networks/overview/#general-architecture","title":"Arquitetura Geral","text":"<p>Como discutido anteriormente, as redes implementadas atrav\u00e9s do Tanssi s\u00e3o blockchains personaliz\u00e1veis que, entre outros recursos, recebem a produ\u00e7\u00e3o de blocos como um servi\u00e7o e herdam a seguran\u00e7a com finalidade de bloco determin\u00edstica em segundos de um provedor de seguran\u00e7a externo.</p> <p>As redes com tecnologia Tanssi s\u00e3o redes totalmente descentralizadas. A natureza descentralizada das redes aumenta consideravelmente sua resili\u00eancia e toler\u00e2ncia a falhas, pois n\u00e3o dependem de uma \u00fanica autoridade ou entidade para garantir sua atividade, seguran\u00e7a e desempenho, mas em protocolos descentralizados e sem confian\u00e7a. Por exemplo, elas recebem servi\u00e7os de produ\u00e7\u00e3o de blocos de um conjunto descentralizado e incentivado de sequenciadores gerenciados pelo Tanssi.</p> <p>O protocolo Tanssi funciona com um provedor de seguran\u00e7a externo, que possui um conjunto de operadores (tamb\u00e9m chamados de validadores) com ativos em jogo, validando as transa\u00e7\u00f5es da pr\u00f3pria rede Tanssi e de todas as redes implementadas atrav\u00e9s do Tanssi. Dessa forma, todas as redes com tecnologia Tanssi herdam a seguran\u00e7a econ\u00f4mica derivada do protocolo Tanssi e, indiretamente, dos operadores, que verificam cada transa\u00e7\u00e3o de cada rede. As redes Tanssi n\u00e3o precisam executar seu pr\u00f3prio conjunto de operadores nem inicializar a liquidez para proteger seu protocolo.</p> <p>As redes Tanssi tamb\u00e9m se beneficiam de um conjunto de Preservadores de Dados, com n\u00f3s de arquivamento completos, garantindo a disponibilidade da camada de disponibilidade de dados. Esses preservadores de dados s\u00e3o incentivados atrav\u00e9s dos servi\u00e7os de recupera\u00e7\u00e3o de dados do Tanssi e tamb\u00e9m fornecem a infraestrutura RPC para aplicativos e usu\u00e1rios que interagem com as redes Tanssi.</p> <pre><code>flowchart TB\n    networks[\"Redes Tanssi&lt;br/&gt;(Redes Descentralizadas)\"]\n\n    subgraph tanssi[\"Protocolo Tanssi\"]\n        direction TB\n        sequencers[\"Conjunto de Sequenciadores Descentralizados\"]\n        node[\"N\u00f3s de Arquivamento Completo com&lt;br/&gt;Servi\u00e7os RPC\"]\n    end\n\n    security[\"Provedor de Seguran\u00e7a Externo&lt;br/&gt;Operadores\"]\n\n    networks&lt;--Produ\u00e7\u00e3o de Blocos--&gt;tanssi\n    networks&lt;--Modelo de Seguran\u00e7a Compartilhada--&gt;tanssi\n    networks&lt;--Disponibilidade de Dados&lt;br/&gt;Endpoints RPC--&gt;tanssi\n    tanssi&lt;--Transa\u00e7\u00f5es&lt;br/&gt;Valida\u00e7\u00e3o e Finalidade--&gt;security</code></pre>"},{"location":"pt/learn/decentralized-networks/overview/#network-transaction-flow","title":"Fluxo de Transa\u00e7\u00e3o de Rede","text":"<p>Uma transa\u00e7\u00e3o enviada a uma rede com tecnologia Tanssi segue um caminho complexo, mas cont\u00ednuo, desde o envio at\u00e9 a inclus\u00e3o e finaliza\u00e7\u00e3o do bloco. A infraestrutura de rede, Tanssi e o provedor de seguran\u00e7a escolhidos trabalham juntos em diferentes n\u00edveis para garantir que o processo ocorra o mais r\u00e1pido poss\u00edvel, geralmente levando cerca de 30 segundos. Lembre-se de que uma transa\u00e7\u00e3o em uma rede Tanssi atinge a finalidade determin\u00edstica. Consequentemente, uma vez que a transa\u00e7\u00e3o \u00e9 final, ela se torna irrevers\u00edvel e imut\u00e1vel, e a transi\u00e7\u00e3o de estado resultante da execu\u00e7\u00e3o daquela transa\u00e7\u00e3o \u00e9 final.</p> <p>Por exemplo, um usu\u00e1rio inicia uma transa\u00e7\u00e3o ao interagir por meio de um aplicativo implantado em uma rede com tecnologia Tanssi. O provedor RPC compartilhar\u00e1 a transa\u00e7\u00e3o, que fica no pool de transa\u00e7\u00f5es da cadeia, com todos os participantes da rede. Um sequenciador atribu\u00eddo pelo Tanssi a essa rede eventualmente pegar\u00e1 a transa\u00e7\u00e3o e a incluir\u00e1 no pr\u00f3ximo bloco da rede.</p> <p>Ent\u00e3o, o sequenciador compartilhar\u00e1 com os operadores do provedor de seguran\u00e7a:</p> <ul> <li>O pr\u00f3prio bloco com as transi\u00e7\u00f5es de estado</li> <li>Os componentes de armazenamento no banco de dados da rede Tanssi que o bloco est\u00e1 modificando</li> <li>Os hashes necess\u00e1rios dos pontos n\u00e3o afetados na \u00e1rvore Merkle do armazenamento</li> </ul> <p>Esses componentes constituem a prova de validade (PoV).</p> <p>Em seguida, o PoV \u00e9 verificado pelos operadores do provedor de seguran\u00e7a. Observe que os operadores n\u00e3o verificam se o armazenamento da rede Tanssi \u00e9 v\u00e1lido, mas sim que as transi\u00e7\u00f5es de estado que o afetam s\u00e3o. Um resumo dessa verifica\u00e7\u00e3o \u00e9 ent\u00e3o divulgado para outros operadores para que eles possam verific\u00e1-lo e inclu\u00ed-lo no pr\u00f3ximo bloco Tanssi. Por fim, esse bloco Tanssi com todas as verifica\u00e7\u00f5es das redes \u00e9 finalizado.</p> <p>O processo de fluxo de transa\u00e7\u00e3o \u00e9 resumido no diagrama a seguir:</p> <p></p>"},{"location":"pt/learn/decentralized-networks/runtime-features/","title":"Funcionalidades Principais do Runtime","text":""},{"location":"pt/learn/decentralized-networks/runtime-features/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As redes implantadas via Tanssi t\u00eam muitos benef\u00edcios gra\u00e7as \u00e0 sua arquitetura \u00fanica.</p> <p>Al\u00e9m disso, as redes com tecnologia Tanssi tamb\u00e9m s\u00e3o especiais por causa do framework (Substrate) sobre o qual s\u00e3o constru\u00eddas, que oferece caracter\u00edsticas que os desenvolvedores podem aproveitar para ajustar comportamentos espec\u00edficos no runtime.</p> <p>Esta se\u00e7\u00e3o aborda algumas dessas funcionalidades centrais: as diferentes origens que uma transa\u00e7\u00e3o pode ter, os tipos de transa\u00e7\u00f5es e como s\u00e3o executadas e inclu\u00eddas em um bloco, a conta especial SUDO e o recurso de atualiza\u00e7\u00f5es de runtime sem fork.</p>"},{"location":"pt/learn/decentralized-networks/runtime-features/#origins","title":"Origens","text":"<p>Em uma rede Tanssi, todas as chamadas t\u00eam uma origem, conceito an\u00e1logo ao msg.sender em EVM, por\u00e9m com mais flexibilidade e n\u00edveis de privil\u00e9gio:</p> <ul> <li>Root \u2013 origem de n\u00edvel de sistema, com o privil\u00e9gio mais alto; pode executar qualquer chamada.</li> <li>Signed \u2013 origem de uma transa\u00e7\u00e3o assinada pela chave privada de uma conta on-chain; inclui o endere\u00e7o como signat\u00e1rio.</li> <li>None \u2013 aus\u00eancia de origem, usada para a\u00e7\u00f5es acordadas no n\u00edvel de runtime (por exemplo, aplicar uma atualiza\u00e7\u00e3o pr\u00e9-autorizada sem taxa).</li> <li>Custom \u2013 origens personalizadas para casos espec\u00edficos (por exemplo, faixas de governan\u00e7a).</li> </ul>"},{"location":"pt/learn/decentralized-networks/runtime-features/#transaction-types","title":"Tipos de Transa\u00e7\u00e3o","text":"<ul> <li>Transa\u00e7\u00f5es assinadas \u2013 carga assinada solicitando uma chamada de runtime; normalmente cobram taxa da conta associada.</li> <li>Transa\u00e7\u00f5es n\u00e3o assinadas \u2013 sem conta associada; exigem regras no runtime para evitar spam ou repeti\u00e7\u00e3o (ex.: acionar uma atualiza\u00e7\u00e3o pr\u00e9-aprovada).</li> <li>Transa\u00e7\u00f5es inerentes \u2013 inseridas pelo sequenciador ao inicializar o bloco; n\u00e3o ficam no pool de transa\u00e7\u00f5es; usadas para dados como timestamp do bloco.</li> </ul>"},{"location":"pt/learn/decentralized-networks/runtime-features/#transaction-execution","title":"Execu\u00e7\u00e3o de Transa\u00e7\u00f5es","text":"<p>Transa\u00e7\u00f5es assinadas s\u00e3o validadas pelas regras do runtime e enfileiradas no pool. H\u00e1 duas filas: pronta (podem entrar no pr\u00f3ximo bloco) e futura (ainda n\u00e3o atendem aos crit\u00e9rios, como nonce futuro). Transa\u00e7\u00f5es inv\u00e1lidas s\u00e3o rejeitadas.</p> <p>Durante a constru\u00e7\u00e3o do bloco, um sequenciador usa um sistema de prioridade:</p> <ul> <li>Inicializa\u00e7\u00e3o (<code>on_initialize</code>) \u2013 l\u00f3gica executada antes das demais transa\u00e7\u00f5es (ex.: timestamp inerente). Depois, o m\u00f3dulo confere hash pai e raiz da trie.</li> <li>Execu\u00e7\u00e3o de transa\u00e7\u00f5es \u2013 executa cada transa\u00e7\u00e3o v\u00e1lida pela prioridade. Como o estado n\u00e3o \u00e9 armazenado em cache antes, uma falha no meio invalida o bloco; o runtime deve validar bem.</li> <li>Finaliza\u00e7\u00e3o (<code>on_idle</code>/<code>on_finalize</code>) \u2013 l\u00f3gica extra executada ao finalizar; ao fim, o m\u00f3dulo garante que digest e raiz de armazenamento correspondam ao esperado.</li> </ul>"},{"location":"pt/learn/decentralized-networks/runtime-features/#forkless-upgrades","title":"Atualiza\u00e7\u00f5es Sem Fork","text":"<p>Atualiza\u00e7\u00f5es sem fork permitem mudar a fun\u00e7\u00e3o de transi\u00e7\u00e3o de estado sem bifurcar a rede. O runtime (blob Wasm) fica on-chain tanto na rede Tanssi quanto na rede alimentada pelo Tanssi. Ap\u00f3s o per\u00edodo de atraso configurado, um sequenciador produz um bloco que referencia o novo runtime, e todos os operadores validam com a vers\u00e3o atualizada.</p> <p></p>"},{"location":"pt/learn/decentralized-networks/runtime-features/#sudo-account","title":"Conta SUDO","text":"<p>O m\u00f3dulo SUDO introduz uma conta SUDO capaz de executar chamadas com origem Root, como:</p> <ul> <li>Cunhar novos tokens nativos.</li> <li>Executar atualiza\u00e7\u00f5es de runtime sem fork.</li> <li>Enviar chamadas em nome de outros tipos de origens.</li> </ul> <p>SUDO \u00e9 \u00fatil em testnets para mudan\u00e7as r\u00e1pidas, mas traz riscos de centraliza\u00e7\u00e3o em produ\u00e7\u00e3o; recomenda-se guarda segura das chaves e uso de proxys. Avalie cuidadosamente antes de manter SUDO ativo em ambientes produtivos.</p>"},{"location":"pt/learn/decentralized-networks/tx-fees/","title":"Taxas de Transa\u00e7\u00e3o","text":""},{"location":"pt/learn/decentralized-networks/tx-fees/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As redes com tecnologia Tanssi s\u00e3o constru\u00eddas com uma estrutura modular chamada Substrate. Com esta estrutura, voc\u00ea pode construir maneiras exclusivas de lidar com as taxas de transa\u00e7\u00e3o. Por exemplo, a maioria das transa\u00e7\u00f5es usa um m\u00f3dulo espec\u00edfico chamado Transaction Payment. No entanto, as taxas de transa\u00e7\u00e3o em redes compat\u00edveis com EVM com tecnologia Tanssi podem ser cobradas em um n\u00edvel de execu\u00e7\u00e3o EVM, ignorando outros m\u00f3dulos relacionados a taxas.</p> <p>Por dentro, para tempo de execu\u00e7\u00e3o, em vez de trabalhar com um mecanismo baseado em g\u00e1s, todas as redes Tanssi trabalham com um mecanismo baseado em peso. Peso refere-se ao tempo (em picossegundos) que leva para validar um bloco. Em geral, para redes Tanssi EVM e n\u00e3o-EVM, todas as chamadas de fun\u00e7\u00e3o t\u00eam um peso associado a elas, que define limites de entrada/sa\u00edda de armazenamento e computa\u00e7\u00e3o. Para redes Tanssi EVM, existe um mapeamento de g\u00e1s para peso que est\u00e1 totalmente em conformidade com os requisitos de g\u00e1s esperados para ferramentas baseadas em API Ethereum.</p> <p>Um esquema de taxas de transa\u00e7\u00e3o \u00e9 aplicado sobre o mecanismo baseado em peso para garantir que os incentivos econ\u00f4micos estejam alinhados para limitar o tempo de execu\u00e7\u00e3o, a computa\u00e7\u00e3o e o n\u00famero de chamadas (leitura/grava\u00e7\u00e3o de banco de dados) para realizar opera\u00e7\u00f5es. As taxas de transa\u00e7\u00e3o s\u00e3o fundamentais para prevenir spam na rede, pois representam o custo de usar o servi\u00e7o de rede Tanssi. Consequentemente, um usu\u00e1rio que interage com a rede por meio de uma chamada de fun\u00e7\u00e3o espec\u00edfica pagar\u00e1 uma taxa de transa\u00e7\u00e3o determinada por um algoritmo de taxa de base.</p> <p>Esta p\u00e1gina aborda os fundamentos das taxas de transa\u00e7\u00e3o para as redes Tanssi. Primeiro, ela aborda a arquitetura subjacente das taxas de transa\u00e7\u00e3o e como ela \u00e9 adaptada a um modelo totalmente compat\u00edvel com EIP-1559 para as redes Tanssi EVM.</p>"},{"location":"pt/learn/decentralized-networks/tx-fees/#baseline-fees","title":"C\u00e1lculo de Taxas de Base","text":"<p>Cada a\u00e7\u00e3o que altera o estado de uma rede Tanssi incorre em uma taxa de transa\u00e7\u00e3o. Essa taxa \u00e9 essencial para a opera\u00e7\u00e3o da rede, cobrindo os recursos computacionais necess\u00e1rios para processar transa\u00e7\u00f5es, semelhante aos par\u00e2metros de g\u00e1s e pre\u00e7o do g\u00e1s em cadeias compat\u00edveis com EVM, como o Ethereum.</p> <p>A estrutura modular das redes Tanssi usa um mecanismo de c\u00e1lculo de taxa baseado em peso para determinar as taxas de transa\u00e7\u00e3o. Essa abordagem considera v\u00e1rios fatores, incluindo recursos computacionais e opera\u00e7\u00f5es de armazenamento (entradas/sa\u00eddas), para refletir com precis\u00e3o o custo real das transa\u00e7\u00f5es. Ao contabilizar esses elementos, a rede garante uma aloca\u00e7\u00e3o de recursos justa e eficiente.</p> <p>Al\u00e9m disso, a modularidade das redes Tanssi garante que as redes compat\u00edveis com EVM suportem mecanismos de pre\u00e7os de transa\u00e7\u00e3o legados e compat\u00edveis com EIP-1559, garantindo total compatibilidade com os ambientes de desenvolvimento comumente usados no Ethereum.</p> <p>Esta se\u00e7\u00e3o descreve todos os diferentes conceitos associados \u00e0s taxas de transa\u00e7\u00e3o para as redes Tanssi.</p>"},{"location":"pt/learn/decentralized-networks/tx-fees/#baseline-weight","title":"Peso","text":"<p>De modo geral, o peso se refere ao tempo de execu\u00e7\u00e3o necess\u00e1rio para validar um bloco, medido em picossegundos. O peso \u00e9 dividido em duas vari\u00e1veis separadas:</p> <ul> <li><code>refTime</code> - corresponde ao peso associado ao tempo de computa\u00e7\u00e3o e \u00e0s leituras/grava\u00e7\u00f5es do banco de dados</li> <li><code>proofSize</code> - corresponde ao peso associado ao tamanho da Prova de Validade (ou PoV, em resumo). A PoV est\u00e1 associada ao estado relevante de uma transa\u00e7\u00e3o e \u00e9 o que o sequenciador da rede Tanssi compartilha com os operadores do provedor de seguran\u00e7a para obter um bloco validado e finalizado como parte do fluxo de transa\u00e7\u00f5es da rede</li> </ul> <p>Para encontrar os pesos para todas as chamadas de fun\u00e7\u00e3o, elas s\u00e3o benchmarkadas em um sistema com hardware de refer\u00eancia e os valores aproximados de <code>refTime</code> e <code>proofSize</code> s\u00e3o definidos. Esse processo \u00e9 repetido para todas as chamadas de fun\u00e7\u00e3o que consomem espa\u00e7o de bloco e afetam a PoV.</p> <p>Para transa\u00e7\u00f5es em que as taxas s\u00e3o tratadas pelo m\u00f3dulo transaction payment, todos os par\u00e2metros baseados em peso s\u00e3o ent\u00e3o passados por um algoritmo peso para taxa que converte tudo em um valor final, deduzido da conta do remetente ao executar a chamada de fun\u00e7\u00e3o. O algoritmo pode ser personalizado, mas as redes Tanssi t\u00eam um valor constante definido.</p> <p>Para transa\u00e7\u00f5es EVM, g\u00e1s \u00e9 convertido em peso por meio de um algoritmo de g\u00e1s para peso para que todas as chamadas EVM possam ser mapeadas para o tempo de execu\u00e7\u00e3o do bloco. No entanto, as taxas s\u00e3o tratadas em um n\u00edvel de execu\u00e7\u00e3o EVM.</p>"},{"location":"pt/learn/decentralized-networks/tx-fees/#baseline-transaction-fees","title":"Taxas de transa\u00e7\u00e3o base","text":"<p>Com todas as chamadas de fun\u00e7\u00e3o benchmarkadas, a taxa de transa\u00e7\u00e3o para cada chamada espec\u00edfica pode ser obtida. As taxas de transa\u00e7\u00e3o s\u00e3o normalmente compostas pelos seguintes elementos:</p> <ul> <li><code>BaseFee</code> - custo base para uma transa\u00e7\u00e3o ser inclu\u00edda. Ele contabiliza a sobrecarga de inclus\u00e3o da transa\u00e7\u00e3o, como a verifica\u00e7\u00e3o da assinatura. A taxa \u00e9 definida por dois par\u00e2metros separados:</li> <li><code>ExtrinsicBaseWeight</code> - um valor constante que representa o peso da sobrecarga de inclus\u00e3o da transa\u00e7\u00e3o</li> <li><code>WeightToFee</code> - uma fun\u00e7\u00e3o polinomial que converte peso em taxa</li> <li><code>WeightFee</code> - taxa definida por dois par\u00e2metros separados:</li> <li><code>BenchmarkedWeight</code> - peso que contabiliza a complexidade (tempo de execu\u00e7\u00e3o) de uma chamada espec\u00edfica</li> <li><code>CongestionMultiplier</code> - uma fun\u00e7\u00e3o que converte peso em taxa e pode ser ajustada para contabilizar o congestionamento da rede (peso consumido no bloco anterior). A estrat\u00e9gia padr\u00e3o para redes Tanssi \u00e9 <code>SlowAdjustingFeeUpdate</code>, que ajusta esse multiplicador lentamente ao longo do tempo, acompanhando a carga da rede</li> <li><code>LengthFee</code> - uma taxa correlacionada ao comprimento em bytes da chamada de fun\u00e7\u00e3o. A taxa \u00e9 definida por dois par\u00e2metros separados:</li> <li><code>ByteLengthFunctionCall</code> - comprimento em bytes da chamada que est\u00e1 sendo executada</li> <li><code>LengthToFee</code> - uma fun\u00e7\u00e3o que define o algoritmo de taxa por byte. Para redes Tanssi, este \u00e9 um valor constante</li> <li><code>Tip</code> - um valor opcional que aumenta a taxa geral, aumentando a prioridade da transa\u00e7\u00e3o, incentivando os sequenciadores a inclu\u00ed-la no pr\u00f3ximo bloco</li> </ul> <p>Portanto, em termos gerais, a taxa de transa\u00e7\u00e3o pode ser calculada com a seguinte equa\u00e7\u00e3o:</p> <pre><code>BaseFee = ExtrinsicBaseWeight * WeightToFee\nWeightFee = BenchmarkedWeight  * CongestionMultiplier\nLengthFee = ByteLengthFunctionCall * LengthToFee\n\nInclusionFee = BaseFee + WeightFee + LengthFee\nFinalFee = InclusionFee + Tip\n</code></pre> <p>Todas as chamadas de fun\u00e7\u00e3o n\u00e3o EVM dispon\u00edveis para desenvolvedores usam esses c\u00e1lculos b\u00e1sicos para taxas de transa\u00e7\u00e3o. As redes Tanssi EVM t\u00eam uma camada extra para traduzir este esquema de taxas em um esquema semelhante ao Ethereum, a partir de uma perspectiva JSON-RPC e EVM do Ethereum.</p>"},{"location":"pt/learn/decentralized-networks/tx-fees/#evm-transaction-fees","title":"Taxas de transa\u00e7\u00e3o EVM","text":"<p>A Tanssi oferece modelos para redes totalmente compat\u00edveis com Tanssi EVM. Tais redes fornecem um ambiente semelhante ao Ethereum para desenvolvedores, onde eles podem usar bibliotecas espec\u00edficas do Eth, como Ethers.js, Hardhat e Foundry.</p> <p>Al\u00e9m disso, todas as redes compat\u00edveis com Tanssi EVM t\u00eam um mecanismo de pre\u00e7os de transa\u00e7\u00e3o compat\u00edvel com EIP-1559 para transa\u00e7\u00f5es EVM. Mas elas suportam ambos os tipos de transa\u00e7\u00e3o EVM comumente usados:</p> <ul> <li>Tipo 0 (Legacy) - a taxa de transa\u00e7\u00e3o \u00e9 calculada por meio de um \u00fanico valor de pre\u00e7o de g\u00e1s que \u00e9 inclu\u00eddo no blob de transa\u00e7\u00e3o assinado. Como as redes compat\u00edveis com Tanssi EVM possuem um mecanismo de pre\u00e7os din\u00e2micos, o pre\u00e7o do g\u00e1s deve ser maior que o <code>baseFee</code> do bloco atual para que uma transa\u00e7\u00e3o seja considerada v\u00e1lida</li> <li>Tipo 2 (EIP-1559) - a taxa de transa\u00e7\u00e3o \u00e9 calculada com uma combina\u00e7\u00e3o de <code>maxFeePerGas</code> e <code>maxPriorityFeePerGas</code> do blob de transa\u00e7\u00e3o assinado e o <code>baseFee</code> da rede muda dinamicamente com base no congestionamento do bloco</li> </ul> <p>Independentemente do tipo de transa\u00e7\u00e3o, o resultado de todas as transa\u00e7\u00f5es EVM \u00e9 que existe um custo associado em tokens nativos que a rede deve cobrar.</p> <p>Por padr\u00e3o, as redes compat\u00edveis com Tanssi EVM s\u00e3o configuradas com os seguintes par\u00e2metros:</p> <ul> <li>BaseFee M\u00ednima - o pre\u00e7o m\u00ednimo do g\u00e1s da rede caso n\u00e3o haja transa\u00e7\u00f5es por longos per\u00edodos. O valor padr\u00e3o \u00e9 definido como 1 GWei</li> <li>Meta de preenchimento de bloco (Elasticidade) - o g\u00e1s usado como meta em um bloco, de modo que o <code>baseFee</code> permane\u00e7a o mesmo. EIP-1559 define esse valor como uma constante definida como 2, o que significa que o uso-alvo \u00e9 50% do limite de g\u00e1s do bloco. Todas as redes compat\u00edveis com Tanssi EVM s\u00e3o configuradas com a mesma meta</li> <li>Aumento m\u00e1ximo da BaseFee - a quantidade m\u00e1xima que o <code>baseFee</code> pode aumentar ou diminuir, em pontos percentuais, com base no uso-alvo do bloco anterior. EIP-1559 define esse valor como uma constante definida como 12,5%. Consequentemente, se o bloco estiver cheio/vazio, o <code>baseFee</code> aumentar\u00e1/diminuir\u00e1 em 12,5%, e quaisquer valores intermedi\u00e1rios ser\u00e3o ajustados linearmente. Os desenvolvedores podem configurar esse valor para redes compat\u00edveis com Tanssi EVM, mas o valor padr\u00e3o \u00e9 12,5%</li> </ul> <p>Nota</p> <p>Uma diferen\u00e7a importante na implementa\u00e7\u00e3o do EIP-1559 nas redes compat\u00edveis com Tanssi EVM \u00e9 que as taxas de transa\u00e7\u00e3o s\u00e3o calculadas usando o <code>baseFee</code> do bloco anterior.</p> <p>O custo da taxa de transa\u00e7\u00e3o EVM associado a todas as redes compat\u00edveis com Tanssi EVM \u00e9 capturado em um n\u00edvel de execu\u00e7\u00e3o EVM. No entanto, as transa\u00e7\u00f5es EVM consomem tempo de execu\u00e7\u00e3o do bloco. Portanto, um algoritmo de g\u00e1s para peso \u00e9 necess\u00e1rio para contabilizar o peso consumido por uma chamada espec\u00edfica em rela\u00e7\u00e3o ao g\u00e1s que ela est\u00e1 consumindo.</p> <p>Em \u00faltima an\u00e1lise, a taxa de transa\u00e7\u00e3o e o peso associados a uma chamada EVM em uma rede compat\u00edvel com Tanssi EVM podem ser calculados com a seguinte f\u00f3rmula:</p> EIP-1559Legacy <pre><code>Gas Price = baseFee + maxPriorityFeePerGas &lt; maxFeePerGas ? \n           baseFee + maxPriorityFeePerGas : \n           maxFeePerGas;\nTransaction Fee = Gas Price * Gas Used\nTransaction Weight = Gas Used * GasToWeight\n</code></pre> <pre><code>Transaction Fee = GasPrice * GasUsed\nTransaction Weight = GasUsed * GasToWeight\n</code></pre> <p><code>GasToWeight</code> \u00e9 um valor constante definido como <code>25000</code>.</p>"},{"location":"pt/learn/framework/","title":"Network Development Framework","text":"<p>A constru\u00e7\u00e3o de uma blockchain do zero \u00e9 um processo intrincado que exige um profundo conhecimento de algoritmos de consenso, criptografia, estruturas de dados, governan\u00e7a e muito mais. Tanssi simplifica esse processo, aproveitando o Substrate, um poderoso framework de desenvolvimento de blockchain que fornece todos os componentes essenciais para a cria\u00e7\u00e3o de blockchains personalizadas.</p> <p>Com a arquitetura modular do Substrate, voc\u00ea pode modificar as caracter\u00edsticas do tempo de execu\u00e7\u00e3o, integrar m\u00f3dulos pr\u00e9-constru\u00eddos ou desenvolver novos com base nas necessidades espec\u00edficas da sua rede. Tanssi fornece a base que voc\u00ea precisa para dar vida \u00e0 sua vis\u00e3o de blockchain.</p> <p>Principais recursos do framework:</p> <ul> <li>Arquitetura central do Substrate - dividida em core client, que gerencia as comunica\u00e7\u00f5es externas e as responsabilidades internas, como armazenamento, e o runtime, que executa transa\u00e7\u00f5es e gerencia as transi\u00e7\u00f5es de estado com l\u00f3gica personaliz\u00e1vel</li> <li>Simplicidade para o usu\u00e1rio final - o funcionamento interno do framework \u00e9 abstra\u00eddo para os usu\u00e1rios finais, garantindo uma intera\u00e7\u00e3o perfeita por meio de dApps ou via endpoints RPC, como os usados \u200b\u200bpor carteiras</li> <li>Design de sistema modular - incorpore m\u00f3dulos pr\u00e9-constru\u00eddos ou crie m\u00f3dulos personalizados para atender \u00e0s necessidades espec\u00edficas</li> <li>Flexibilidade centrada no desenvolvedor - concentre-se nas caracter\u00edsticas de tempo de execu\u00e7\u00e3o e nas especificidades dos casos de uso, permitindo que voc\u00ea crie um blockchain adaptado \u00e0 sua vis\u00e3o sem complexidade desnecess\u00e1ria</li> </ul>"},{"location":"pt/learn/framework/architecture/","title":"Arquitetura do Framework","text":""},{"location":"pt/learn/framework/architecture/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Substrate \u00e9 um kit de desenvolvimento de software (SDK) para a constru\u00e7\u00e3o de blockchains. Este framework \u00e9 a base e o motor que impulsionam muitos projetos em todo o ecossistema Web3, incluindo a pr\u00f3pria rede Tanssi e as redes implantadas atrav\u00e9s do Tanssi.</p> <p>Escrito na linguagem Rust e projetado com uma arquitetura modular, o Substrate \u00e9 extremamente perform\u00e1tico, flex\u00edvel e altamente personaliz\u00e1vel, tornando-o a melhor op\u00e7\u00e3o para o desenvolvimento de blockchains.</p> <p>Neste artigo, a arquitetura de um n\u00f3 Substrate \u00e9 abordada.</p>"},{"location":"pt/learn/framework/architecture/#architecture","title":"Arquitetura","text":"<p>O framework Substrate \u00e9 projetado para m\u00e1xima personaliza\u00e7\u00e3o, fornecendo uma implementa\u00e7\u00e3o totalmente funcional para todos os aspectos internos importantes de uma blockchain. Ele permite que os desenvolvedores se concentrem nos detalhes do caso de uso e nas caracter\u00edsticas do runtime, e oferece a capacidade de alterar qualquer um dos recursos padr\u00e3o (se necess\u00e1rio).</p> <p>A arquitetura de um n\u00f3 Substrate cont\u00e9m dois componentes principais:</p> <ul> <li>Cliente Core - lida com a comunica\u00e7\u00e3o com o mundo exterior (outros n\u00f3s, dApps, usu\u00e1rios finais, entre outros), e muitas outras responsabilidades internas, como armazenamento e comunica\u00e7\u00e3o</li> <li>Runtime - implementa a l\u00f3gica personalizada da rede Tanssi, executa transa\u00e7\u00f5es e gerencia as transi\u00e7\u00f5es de estado</li> </ul> <p>Da perspectiva do usu\u00e1rio final, toda a intera\u00e7\u00e3o com a rede Tanssi \u00e9 geralmente feita atrav\u00e9s de dApps ou diretamente atrav\u00e9s dos endpoints RPC do n\u00f3, por exemplo, usando uma carteira. Quando um usu\u00e1rio aciona uma solicita\u00e7\u00e3o para buscar dados ou envia transa\u00e7\u00f5es para um n\u00f3, o cliente core \u00e9 respons\u00e1vel por responder ou enfileirar as transa\u00e7\u00f5es at\u00e9 a execu\u00e7\u00e3o no runtime. Ainda assim, todos esses aspectos internos do design do n\u00f3 s\u00e3o mantidos transparentes para o usu\u00e1rio.</p> <p></p>"},{"location":"pt/learn/framework/architecture/#core-client","title":"O Cliente Core","text":"<p>O cliente core compreende componentes respons\u00e1veis por tudo na opera\u00e7\u00e3o de um n\u00f3 na rede, exceto pelo que acontece no runtime.</p> <p>Alguns dos principais componentes s\u00e3o:</p> <ul> <li>Networking - este componente lida com a comunica\u00e7\u00e3o com os pares na rede (sincroniza\u00e7\u00e3o de blocos, propaga\u00e7\u00e3o de transa\u00e7\u00f5es e assim por diante) e exp\u00f5e os endpoints que permitem que os dApps se integrem e interajam com a rede Tanssi</li> <li>Storage - este componente gerencia o armazenamento de estado da rede Tanssi em um banco de dados chave-valor altamente eficiente</li> <li>Consenso - este componente garante que todos os participantes da rede concordem com o estado da blockchain, validando transa\u00e7\u00f5es, transi\u00e7\u00f5es de estado e os blocos resultantes</li> </ul> <p>A configura\u00e7\u00e3o padr\u00e3o de um n\u00f3 Substrate e as implementa\u00e7\u00f5es embutidas dos componentes s\u00e3o geralmente a melhor escolha para a maioria dos casos de uso. Ainda assim, as equipes s\u00e3o bem-vindas para inovar e alterar ou substituir qualquer parte do n\u00f3 ou at\u00e9 mesmo escrever uma implementa\u00e7\u00e3o completamente diferente do cliente core, como Kagome (implementa\u00e7\u00e3o C++) e Gossamer (implementa\u00e7\u00e3o Golang).</p>"},{"location":"pt/learn/framework/architecture/#runtime","title":"O Runtime","text":"<p>O runtime desempenha um papel crucial na opera\u00e7\u00e3o da rede Tanssi. Ele cont\u00e9m a l\u00f3gica e as regras principais para atender aos requisitos do caso de uso que os desenvolvedores est\u00e3o construindo e, portanto, \u00e9 respons\u00e1vel por validar as transa\u00e7\u00f5es e executar as transi\u00e7\u00f5es de estado.</p> <p>Sendo o elemento central em uma rede Tanssi, projetar a arquitetura Substrate uma decis\u00e3o importante foi tomada em rela\u00e7\u00e3o ao formato para o runtime: ele \u00e9 compilado para c\u00f3digo de bytes WebAssembly (Wasm).</p> <p>O formato Wasm oferece muitas vantagens para uma rede Tanssi implantada, incluindo:</p> <ul> <li>Portabilidade - o formato Wasm \u00e9 independente de plataforma, o que significa que o mesmo bin\u00e1rio pode ser distribu\u00eddo e executado em diferentes n\u00f3s usando diferentes arquiteturas de hardware e sistemas operacionais</li> <li>Execu\u00e7\u00e3o Determin\u00edstica - o formato Wasm garante a execu\u00e7\u00e3o determin\u00edstica do c\u00f3digo, o que significa que a mesma entrada sempre produzir\u00e1 a mesma sa\u00edda. A determin\u00e2ncia \u00e9 um aspecto cr\u00edtico em blockchains para obter as mesmas transi\u00e7\u00f5es de estado em todos os n\u00f3s da rede e alcan\u00e7ar um consenso</li> <li>Atualiza\u00e7\u00e3o sem fork - Substrate armazena o blob Wasm do runtime on-chain, o que significa que o pr\u00f3prio runtime se torna parte do estado. Este projeto permite a atualiza\u00e7\u00e3o da l\u00f3gica do runtime de forma sem fork usando uma transa\u00e7\u00e3o</li> </ul> <p>Al\u00e9m do formato, internamente, um runtime Substrate \u00e9 constru\u00eddo compondo diferentes m\u00f3dulos, fornecidos e prontos para uso pelo Substrate ou feitos sob medida. Cada um desses m\u00f3dulos define, entre outras coisas, as transa\u00e7\u00f5es que exp\u00f5em, a l\u00f3gica por tr\u00e1s delas, o que precisa ser armazenado no estado da cadeia, o melhor formato para faz\u00ea-lo e como eles cooperam com outros m\u00f3dulos para compor a funcionalidade. Mais detalhes sobre a constru\u00e7\u00e3o de um runtime ser\u00e3o abordados na se\u00e7\u00e3o m\u00f3dulos.</p>"},{"location":"pt/learn/framework/architecture/#client-runtime-communication","title":"Comunica\u00e7\u00e3o Cliente-Runtime","text":"<p>Como descrito anteriormente, os dois principais componentes de um n\u00f3 Substrate (o cliente core e o runtime) t\u00eam uma clara separa\u00e7\u00e3o de preocupa\u00e7\u00f5es. Al\u00e9m das responsabilidades funcionais, em um n\u00edvel inferior, sua representa\u00e7\u00e3o bin\u00e1ria e ambientes de execu\u00e7\u00e3o s\u00e3o diferentes. Embora o n\u00f3 seja compilado para ser instalado e executado em uma plataforma espec\u00edfica (seja Linux x64 ou qualquer outra), o runtime da rede Tanssi \u00e9 compilado para um formato Wasm que \u00e9 agn\u00f3stico \u00e0 plataforma e \u00e9 executado em um ambiente de execu\u00e7\u00e3o isolado.</p> <p>Tendo em mente os ambientes de execu\u00e7\u00e3o separados, toda a comunica\u00e7\u00e3o entre o cliente do n\u00f3 e o runtime ocorre por meio de uma interface limitada e bem definida, permitindo as opera\u00e7\u00f5es necess\u00e1rias, como:</p> <ul> <li>Executar Transa\u00e7\u00f5es - quando um usu\u00e1rio envia uma transa\u00e7\u00e3o para o n\u00f3 cliente, o n\u00f3 passa essa transa\u00e7\u00e3o para o runtime atrav\u00e9s da API definida para sua execu\u00e7\u00e3o</li> <li>Consultas de Estado - o n\u00f3 cliente pode consultar o estado atual da blockchain para recuperar informa\u00e7\u00f5es como saldos de contas e quaisquer outros dados espec\u00edficos do dom\u00ednio</li> <li>Consenso e Finalidade - o n\u00f3 cliente coordena o consenso e a finaliza\u00e7\u00e3o dos blocos, mas \u00e9 responsabilidade do runtime determinar a validade de novos blocos, validar transa\u00e7\u00f5es e garantir que as regras de consenso sejam seguidas</li> <li>Notifica\u00e7\u00f5es de Eventos - o runtime emite eventos ao executar transa\u00e7\u00f5es que o n\u00f3 cliente pode usar para manter os usu\u00e1rios externos atualizados sobre a\u00e7\u00f5es ou altera\u00e7\u00f5es espec\u00edficas no estado</li> </ul>"},{"location":"pt/learn/framework/modules/","title":"M\u00f3dulos de Framework de Rede","text":""},{"location":"pt/learn/framework/modules/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O framework Substrate fornece implementa\u00e7\u00f5es completas e prontas para uso das fun\u00e7\u00f5es principais que uma rede Tanssi precisa para funcionar corretamente, incluindo criptografia, consenso, governan\u00e7a e assim por diante. Estas implementa\u00e7\u00f5es s\u00e3o totalmente personaliz\u00e1veis e podem ser substitu\u00eddas por l\u00f3gica personalizada, se necess\u00e1rio.</p> <p>Ao criar o Tempo de Execu\u00e7\u00e3o, que define as regras de transi\u00e7\u00e3o de estado entre dois blocos aplicados a um conjunto de transa\u00e7\u00f5es, o comportamento e as funcionalidades pretendidas da blockchain precisam de ser definidos ao determinar as regras da transi\u00e7\u00e3o de estado.</p> <p>Para construir o Tempo de Execu\u00e7\u00e3o, o Substrate fornece muitos m\u00f3dulos integrados (tamb\u00e9m conhecidos como pallets) que podem ser livremente usados como blocos de constru\u00e7\u00e3o para compor e interagir com quaisquer outros m\u00f3dulos feitos sob medida, permitindo que as equipas criem comportamentos \u00fanicos de acordo com os requisitos espec\u00edficos da sua rede Tanssi.</p> <p></p>"},{"location":"pt/learn/framework/modules/#built-in-modules","title":"M\u00f3dulos Integrados","text":"<p>Ao projetar e escrever as regras de uma rede Tanssi, o conjunto dispon\u00edvel de m\u00f3dulos funcionais traz uma solu\u00e7\u00e3o para muitos dos requisitos de codifica\u00e7\u00e3o que, caso contr\u00e1rio, precisariam ser constru\u00eddos do zero.</p> <p>Aqui est\u00e1 uma lista de alguns dos m\u00f3dulos mais populares:</p> <ul> <li>Balances - fornece fun\u00e7\u00f5es para lidar com contas e saldos para a moeda nativa da rede Tanssi</li> <li>Assets - fornece fun\u00e7\u00f5es para lidar com qualquer tipo de token fung\u00edvel</li> <li>NFTs - fornece fun\u00e7\u00f5es para lidar com tokens n\u00e3o fung\u00edveis</li> <li>Democracy - fornece fun\u00e7\u00f5es para gerir e administrar a vota\u00e7\u00e3o geral dos stakeholders</li> <li>Multisig - fornece fun\u00e7\u00f5es para envio de multi-assinaturas</li> <li>Recovery - fornece fun\u00e7\u00f5es para permitir que os utilizadores recuperem o acesso \u00e0s suas contas quando a chave privada \u00e9 perdida. Isto funciona ao conceder a outras contas o direito de assinar transa\u00e7\u00f5es em nome da conta perdida (observe que \u00e9 necess\u00e1rio ter escolhido previamente as contas autorizadas)</li> <li>Staking - fornece fun\u00e7\u00f5es para administrar tokens apostados, apoiar recompensas, cortes, dep\u00f3sito, levantamento, e assim por diante</li> </ul> <p>Al\u00e9m daqueles j\u00e1 listados, outros m\u00f3dulos como identity, smart contracts, vesting, e muitos outros que est\u00e3o livremente dispon\u00edveis podem acelerar o desenvolvimento da rede Tanssi e, consequentemente, o tempo de lan\u00e7amento.</p> <p>Nota</p> <p>O framework tamb\u00e9m inclui outros m\u00f3dulos que fornecem funcionalidades essenciais de protocolo, como consenso e codifica\u00e7\u00e3o de dados de baixo n\u00edvel.</p>"},{"location":"pt/learn/framework/modules/#custom-modules","title":"M\u00f3dulos Feitos sob Medida","text":"<p>Os desenvolvedores que criam novos m\u00f3dulos desfrutam de total liberdade para expressar qualquer comportamento desejado na l\u00f3gica principal da blockchain, como expor novas transa\u00e7\u00f5es, armazenar informa\u00e7\u00f5es sens\u00edveis e validar e impor l\u00f3gica de neg\u00f3cios.</p> <p>Como explicado no artigo Arquitetura, um m\u00f3dulo precisa ser capaz de se comunicar com o cliente principal, expondo e integrando com uma API muito espec\u00edfica que permite que o tempo de execu\u00e7\u00e3o exponha transa\u00e7\u00f5es, acesse o armazenamento e code e decodifique informa\u00e7\u00f5es armazenadas na cadeia. Tamb\u00e9m precisa incluir muitos outros c\u00f3digos de liga\u00e7\u00e3o necess\u00e1rios que fazem o m\u00f3dulo funcionar no n\u00f3.</p> <p>Para melhorar a experi\u00eancia do desenvolvedor ao escrever m\u00f3dulos, o Substrate depende muito de macros Rust. As macros s\u00e3o instru\u00e7\u00f5es especiais que se expandem automaticamente para o c\u00f3digo Rust pouco antes do tempo de compila\u00e7\u00e3o, permitindo que os m\u00f3dulos mantenham at\u00e9 sete vezes a quantidade de c\u00f3digo fora da vista dos desenvolvedores. Isto permite que os desenvolvedores se concentrem nos requisitos funcionais espec\u00edficos ao escrever m\u00f3dulos, em vez de lidar com tecnicidades e o c\u00f3digo de suporte necess\u00e1rio.</p> <p>Todos os m\u00f3dulos no Substrate, incluindo os feitos sob medida, implementam estas macros de atributo, das quais as tr\u00eas primeiras s\u00e3o obrigat\u00f3rias:</p> <ul> <li><code>#[frame_support::pallet]</code> - atributo de entrada que marca o m\u00f3dulo como utiliz\u00e1vel no runtime</li> <li><code>#[pallet::pallet]</code> - aplicado a uma estrutura usada para recuperar informa\u00e7\u00f5es do m\u00f3dulo com facilidade</li> <li><code>#[pallet::config]</code> - atributo obrigat\u00f3rio para definir a configura\u00e7\u00e3o dos tipos de dados do m\u00f3dulo</li> <li><code>#[pallet::call]</code> - macro usada para definir fun\u00e7\u00f5es expostas como transa\u00e7\u00f5es, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transa\u00e7\u00f5es e l\u00f3gica personalizadas</li> <li><code>#[pallet::error]</code> - como transa\u00e7\u00f5es podem falhar (por exemplo, fundos insuficientes) e, por seguran\u00e7a, um m\u00f3dulo n\u00e3o deve gerar exce\u00e7\u00f5es, todos os poss\u00edveis erros devem ser identificados e listados em um enum para serem retornados em uma execu\u00e7\u00e3o malsucedida</li> <li><code>#[pallet::event]</code> - eventos podem ser definidos e usados para fornecer mais informa\u00e7\u00f5es ao usu\u00e1rio</li> <li><code>#[pallet::storage]</code> - macro usada para definir elementos que ser\u00e3o persistidos em storage; como recursos s\u00e3o escassos em uma blockchain, deve ser usada com parcim\u00f4nia para armazenar apenas informa\u00e7\u00f5es essenciais</li> </ul> <p>Todas estas macros atuam como atributos que devem ser aplicados ao c\u00f3digo logo acima dos m\u00f3dulos, fun\u00e7\u00f5es, estruturas, enums, tipos, etc., Rust, permitindo que o m\u00f3dulo seja constru\u00eddo e adicionado ao tempo de execu\u00e7\u00e3o, que, com o tempo, ir\u00e1 expor a l\u00f3gica personalizada ao mundo exterior, conforme exposto na se\u00e7\u00e3o seguinte.</p>"},{"location":"pt/learn/framework/modules/#custom-module-example","title":"Exemplo de M\u00f3dulo Personalizado","text":"<p>Como exemplo de um m\u00f3dulo personalizado, o seguinte c\u00f3digo (n\u00e3o destinado a uso em produ\u00e7\u00e3o) demonstra o uso das macros mencionadas anteriormente, apresentando uma loteria simples com funcionalidade m\u00ednima, expondo duas transa\u00e7\u00f5es:</p> <ul> <li> <p>buy_ticket - esta transa\u00e7\u00e3o verifica se o utilizador que est\u00e1 a assinar o pedido ainda n\u00e3o comprou um bilhete e tem fundos suficientes para pagar. Se tudo estiver bem, o m\u00f3dulo transfere o pre\u00e7o do bilhete para uma conta especial e regista o utilizador como participante do pr\u00e9mio</p> </li> <li> <p>award_prize - esta transa\u00e7\u00e3o gera um n\u00famero aleat\u00f3rio para escolher o vencedor da lista de participantes. O vencedor recebe a quantia total dos fundos transferidos para a conta especial do m\u00f3dulo</p> </li> </ul> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre> <p>Para mais informa\u00e7\u00f5es sobre o processo passo a passo de cria\u00e7\u00e3o de um m\u00f3dulo feito sob medida para o tempo de execu\u00e7\u00e3o, consulte Adicionar um m\u00f3dulo personalizado na sec\u00e7\u00e3o de Construtor.</p>"},{"location":"pt/learn/framework/overview/","title":"Vis\u00e3o Geral da Estrutura de Desenvolvimento de Rede","text":""},{"location":"pt/learn/framework/overview/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A constru\u00e7\u00e3o de uma rede do zero \u00e9 uma tarefa muito complexa que exige profundo conhecimento em uma ampla gama de \u00e1reas, incluindo (mas n\u00e3o se limitando a):</p> <ul> <li> <p>Algoritmos de Consenso - o consenso garante que todos os participantes da rede blockchain concordem com a validade das transa\u00e7\u00f5es. Alguns mecanismos de consenso populares incluem Prova de Trabalho (PoW) e Prova de Participa\u00e7\u00e3o (PoS)</p> </li> <li> <p>Criptografia - a criptografia desempenha um papel crucial na seguran\u00e7a da blockchain. Voc\u00ea precisar\u00e1 de algoritmos criptogr\u00e1ficos para tarefas como criar assinaturas digitais, verificar transa\u00e7\u00f5es e criptografar dados</p> </li> <li> <p>Rede Distribu\u00edda - uma arquitetura de rede para permitir que os n\u00f3s se comuniquem, validem transa\u00e7\u00f5es e sincronizem os dados da blockchain \u00e9 fundamental para manter um livro-raz\u00e3o compartilhado em uma rede descentralizada</p> </li> <li> <p>Estruturas de Dados - al\u00e9m da lista de blocos, onde cada bloco cont\u00e9m um conjunto de transa\u00e7\u00f5es junto com uma refer\u00eancia ao bloco anterior, \u00e9 necess\u00e1ria uma estrat\u00e9gia otimizada e de alto desempenho para armazenar o estado da rede</p> </li> <li> <p>Governan\u00e7a - se a rede for projetada para ser sem permiss\u00e3o, um mecanismo de vota\u00e7\u00e3o \u00e9 importante para mant\u00ea-la evoluindo e refletindo a vontade da comunidade</p> </li> <li> <p>Atualiza\u00e7\u00e3o - \u00e9 necess\u00e1rio definir claramente como atualizar, como as modifica\u00e7\u00f5es s\u00e3o implementadas e como os conflitos s\u00e3o resolvidos dentro da rede</p> </li> </ul> <p>Felizmente, n\u00e3o h\u00e1 necessidade de construir esses componentes de blockchain do zero, gra\u00e7as a uma excelente estrutura de c\u00f3digo aberto chamada Substrate. A pr\u00f3pria Tanssi \u00e9 constru\u00edda com essa estrutura, aproveitando suas implementa\u00e7\u00f5es de base abrangentes, modularidade e flexibilidade para alcan\u00e7ar um alto n\u00edvel de personaliza\u00e7\u00e3o.</p>"},{"location":"pt/learn/framework/overview/#substrate-framework","title":"Estrutura Substrate","text":"<p>Substrate \u00e9 uma estrutura extremamente perform\u00e1tica, flex\u00edvel, modular e altamente personaliz\u00e1vel para construir blockchains. Essa estrutura \u00e9 a base e o motor que impulsionam muitos projetos no ecossistema Web3, incluindo a pr\u00f3pria rede Tanssi e as redes implantadas por meio da Tanssi.</p> <p>Muitos de seus \u00f3timos recursos, como desempenho, facilidade de uso e modularidade, resultam da linguagem de programa\u00e7\u00e3o escolhida para seu desenvolvimento. \u00c9 aqui que a Linguagem de Programa\u00e7\u00e3o Rust se destaca: ela \u00e9 r\u00e1pida, port\u00e1til e fornece um modelo maravilhoso para lidar com a mem\u00f3ria, entre outros motivos detalhados na pr\u00f3xima se\u00e7\u00e3o.</p> <p>Ao desenvolver uma rede, Substrate representa uma grande vantagem ao fornecer um conjunto de implementa\u00e7\u00f5es prontas para uso dos principais blocos de constru\u00e7\u00e3o que um projeto precisa:</p> <ul> <li> <p>Algoritmos de Consenso - existem v\u00e1rios mecanismos de consenso integrados, como Aura (Prova de Autoridade), Babe (Prova de Participa\u00e7\u00e3o) e Grandpa (finalidade de bloco), mas devido ao alto grau de personaliza\u00e7\u00e3o que Substrate oferece, as equipes podem sempre optar por desenvolver seu consenso espec\u00edfico para se adaptar \u00e0s necessidades do caso de uso, como a equipe Moonbeam fez com a Estrutura de Consenso Nimbus Parachain</p> </li> <li> <p>M\u00f3dulos de Tempo de Execu\u00e7\u00e3o - muitos m\u00f3dulos integrados (explicados em detalhes na se\u00e7\u00e3o modules) podem ser selecionados e configurados em sua rede, como contas, saldos, staking, governan\u00e7a, identidade e muito mais</p> </li> <li> <p>Rede - protocolos e bibliotecas integradas para estabelecer conex\u00f5es, propagar transa\u00e7\u00f5es e blocos, sincronizar o estado da blockchain e gerenciar intera\u00e7\u00f5es de rede</p> </li> <li> <p>Armazenamento - mecanismos de armazenamento integrados para armazenamento e recupera\u00e7\u00e3o de dados eficientes</p> </li> <li> <p>Fila de Transa\u00e7\u00f5es - sistema de fila de transa\u00e7\u00f5es integrado que gerencia a valida\u00e7\u00e3o, prioriza\u00e7\u00e3o e inclus\u00e3o de transa\u00e7\u00f5es em blocos, garantindo a consist\u00eancia e integridade do estado da rede</p> </li> <li> <p>APIs RPC - Substrate fornece APIs de Chamada de Procedimento Remoto (RPC) que permitem que aplicativos externos interajam com a rede, consultando dados da blockchain, enviando transa\u00e7\u00f5es e acessando v\u00e1rias funcionalidades expostas pelo tempo de execu\u00e7\u00e3o</p> </li> </ul> <p>Cada recurso que o Substrate oferece pode ser usado como est\u00e1, estendido, personalizado ou substitu\u00eddo para atender aos requisitos espec\u00edficos do caso de uso da rede.</p> <p>Substrate agiliza e acelera o processo de desenvolvimento de novas redes. Quando usado em conjunto com Tanssi, que ajuda a lidar com a infraestrutura e supervisionar a implanta\u00e7\u00e3o, a tarefa de lan\u00e7ar uma nova rede se torna significativamente mais simples!</p>"},{"location":"pt/learn/framework/overview/#rust-programming-language","title":"Linguagem de Programa\u00e7\u00e3o Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o com recursos que os desenvolvedores classificam consistentemente em pesquisas como a pesquisa anual de desenvolvedores do Stack Overflow.</p> <p>Al\u00e9m de fornecer uma \u00f3tima experi\u00eancia para os desenvolvedores, o Rust se destaca em muitas \u00e1reas:</p> <ul> <li> <p>Seguran\u00e7a da mem\u00f3ria - O compilador Rust imp\u00f5e verifica\u00e7\u00f5es estritas em tempo de compila\u00e7\u00e3o para evitar erros de programa\u00e7\u00e3o comuns, como desrefer\u00eancias de ponteiros nulos, estouros de buffer e condi\u00e7\u00f5es de corrida de dados. Al\u00e9m disso, a mem\u00f3ria \u00e9 gerenciada por meio de um novo sistema de propriedade (verificado pelo compilador), que elimina a necessidade de um coletor de lixo</p> </li> <li> <p>Desempenho - Rust atinge um desempenho compar\u00e1vel ao de C e C++, fornecendo controle de baixo n\u00edvel sobre os recursos do sistema e minimizando a sobrecarga de tempo de execu\u00e7\u00e3o. Ele tem um princ\u00edpio de abstra\u00e7\u00e3o de custo zero, semelhante a \"o que voc\u00ea n\u00e3o usa, voc\u00ea n\u00e3o paga\" de C++, o que significa que as abstra\u00e7\u00f5es n\u00e3o t\u00eam sobrecarga extra</p> </li> <li> <p>Concorr\u00eancia - Rust possui recursos integrados que facilitam a escrita de c\u00f3digo concorrente e paralelo sem introduzir condi\u00e7\u00f5es de corrida de dados. Ele fornece threads leves (tarefas) e um modelo de propriedade poderoso que garante o compartilhamento seguro de dados entre threads</p> </li> <li> <p>Abstra\u00e7\u00f5es expressivas e seguras - Rust oferece um rico conjunto de recursos de linguagem modernos, como correspond\u00eancia de padr\u00f5es, tipos de dados alg\u00e9bricos, closures e infer\u00eancia de tipos, permitindo que os desenvolvedores escrevam e leiam c\u00f3digo expressivo e conciso. O compilador Rust imp\u00f5e o forte sistema de tipos, evitando muitos erros em tempo de execu\u00e7\u00e3o em tempo de compila\u00e7\u00e3o</p> </li> <li> <p>Compatibilidade entre plataformas - Rust foi projetado para funcionar bem em uma variedade de plataformas e arquiteturas. Ele suporta os principais sistemas operacionais como Windows, macOS e Linux, bem como sistemas embarcados e WebAssembly. Essa versatilidade permite que os desenvolvedores escrevam c\u00f3digo que pode ser implantado em diferentes ambientes</p> </li> <li> <p>Ecossistema em crescimento - Rust tem um ecossistema em r\u00e1pido crescimento com uma comunidade vibrante e uma rica cole\u00e7\u00e3o de bibliotecas e ferramentas. O gerenciador de pacotes oficial, Cargo, simplifica o gerenciamento de depend\u00eancias, constru\u00e7\u00e3o e teste</p> </li> <li> <p>Interoperabilidade - Rust fornece interoperabilidade perfeita com bases de c\u00f3digo existentes escritas em C e C++. Ele tem uma Interface de Fun\u00e7\u00e3o Estrangeira (FFI) que permite que o c\u00f3digo Rust se interface com o c\u00f3digo escrito em outras linguagens, permitindo que os desenvolvedores introduzam gradualmente Rust em projetos existentes, como o kernel Linux</p> </li> </ul>"},{"location":"pt/learn/framework/xcm/","title":"Comunica\u00e7\u00e3o Nativa Cross-Chain","text":""},{"location":"pt/learn/framework/xcm/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Todas as redes alimentadas por Tanssi t\u00eam uma capacidade inerente de se comunicar e interagir com qualquer outra rede no ecossistema. Esse recurso de comunica\u00e7\u00e3o cross-chain nativo \u00e9 poss\u00edvel gra\u00e7as \u00e0 infraestrutura exclusiva sobre a qual as redes s\u00e3o constru\u00eddas, alavancando o formato de Mensagem Cross-Consensus (XCM para abreviar), que facilita a comunica\u00e7\u00e3o entre diferentes sistemas de consenso.</p> <p>XCM \u00e9 uma linguagem de mensagens projetada para ser gen\u00e9rica. Ela n\u00e3o faz nenhuma suposi\u00e7\u00e3o sobre a cadeia de destino e pode comunicar diferentes inten\u00e7\u00f5es entre sistemas de consenso soberanos.</p> <p>A mensagem XCM \u00e9 um programa que cont\u00e9m uma ou mais instru\u00e7\u00f5es que ser\u00e3o retransmitidas para execu\u00e7\u00e3o na cadeia de destino. Por si s\u00f3, cada instru\u00e7\u00e3o XCM \u00e9 sem sentido, mas a combina\u00e7\u00e3o de um conjunto espec\u00edfico de instru\u00e7\u00f5es pode resultar em uma a\u00e7\u00e3o desejada quando a mensagem XCM \u00e9 executada na cadeia de destino.</p> <p>Neste artigo, abordamos os conceitos b\u00e1sicos do mecanismo de comunica\u00e7\u00e3o cross-chain nativo que permite pontes r\u00e1pidas e seguras dentro do ecossistema.</p>"},{"location":"pt/learn/framework/xcm/#design-principles","title":"Princ\u00edpios de Design","text":"<p>Concebido com uma mentalidade abstrata, o XCM n\u00e3o foi projetado para estar em conformidade com um caso de uso espec\u00edfico ou configura\u00e7\u00e3o de rede de destino espec\u00edfica, minimizando assim o efeito de acoplamento. Seus princ\u00edpios b\u00e1sicos de design s\u00e3o:</p> <ul> <li>Ass\u00edncrono - semelhante ao envio de um cart\u00e3o postal - mas muito mais r\u00e1pido - o remetente continuar\u00e1 a realizar suas tarefas como de costume, sem se bloquear ou aguardar uma resposta do destino</li> <li>Absoluto - as mensagens t\u00eam garantia de serem entregues ao destino pretendido, em ordem e em tempo h\u00e1bil</li> <li>Assim\u00e9trico - as mensagens enviadas n\u00e3o t\u00eam contrapartida de resposta. Quaisquer valores de retorno, se necess\u00e1rios, devem ser enviados de volta do destino para o remetente com outra mensagem</li> <li>Agn\u00f3stico - n\u00e3o h\u00e1 qualquer suposi\u00e7\u00e3o sobre a configura\u00e7\u00e3o ou propriedades de duas redes de comunica\u00e7\u00e3o. As redes podem diferir em todos os aspectos, exceto na capacidade de entender o XCM. Por exemplo, uma cadeia pode ser compat\u00edvel com EVM e a outra n\u00e3o, uma cadeia pode ser uma rede DeFi e a outra uma rede de jogos, e assim por diante.</li> </ul>"},{"location":"pt/learn/framework/xcm/#fees","title":"Taxas","text":"<p>Um usu\u00e1rio que executa uma transa\u00e7\u00e3o em uma rede deve pagar as taxas derivadas do esfor\u00e7o computacional associado \u00e0 tarefa, e a execu\u00e7\u00e3o cross-chain n\u00e3o \u00e9 exce\u00e7\u00e3o a essa regra. Na comunica\u00e7\u00e3o cross-chain, uma mensagem requer execu\u00e7\u00e3o em pelo menos duas cadeias diferentes, e o usu\u00e1rio precisa pagar as taxas associadas ao esfor\u00e7o computacional feito por cada cadeia envolvida. Al\u00e9m dos custos relacionados \u00e0 execu\u00e7\u00e3o, as redes Tanssi incluem uma taxa de entrega padr\u00e3o para evitar spam XCM.</p> <p>Por exemplo, se um usu\u00e1rio na rede A deseja chamar um contrato inteligente na rede B, o usu\u00e1rio deve ter fundos suficientes para pagar a entrega da mensagem e incluir instru\u00e7\u00f5es na mensagem XCM para fornecer um ativo que a rede B aceite como pagamento por seus servi\u00e7os para cobrir as taxas associadas. Uma vez que esse ativo \u00e9 fornecido, a execu\u00e7\u00e3o agora pode ser comprada na cadeia de destino.</p> <p>Nota</p> <p>Como as redes s\u00e3o soberanas, elas decidem quais tokens s\u00e3o v\u00e1lidos para pagar suas taxas de execu\u00e7\u00e3o XCM. Por exemplo, se a rede B aceitar tokens da rede A para pagamentos de taxas, qualquer usu\u00e1rio na rede A pode pagar por uma mensagem XCM destinada \u00e0 rede B usando apenas tokens da rede A.</p>"},{"location":"pt/learn/framework/xcm/#common-use-cases","title":"Casos de Uso Comuns","text":"<p>Muitos casos de uso podem ser abordados, beneficiando-se do terreno comum e da versatilidade que o XCM oferece. Dois dos mais recorrentes s\u00e3o transfer\u00eancias de ativos e execu\u00e7\u00e3o remota.</p>"},{"location":"pt/learn/framework/xcm/#asset-transfer","title":"Transfer\u00eancias de Ativos","text":"<p>Mover ativos digitais de uma rede para outra \u00e9 essencial para criar um ecossistema blockchain mais din\u00e2mico, eficiente e interconectado. O recurso cross-chain nativo permite duas estrat\u00e9gias principais para transferir ativos de uma cadeia para outra:</p> <ul> <li>Teleporte - teletransportar um ativo \u00e9 um mecanismo simples e eficiente, mas tem uma grande ressalva: requer confian\u00e7a entre as partes. Essencialmente, quando a rede A deseja enviar X quantidade de ativos para a rede B, ela queima X quantidade de ativos e envia uma mensagem para a rede B instruindo-a a cunhar exatamente X quantidade de ativos, preservando o saldo geral de ativos e concluindo a a\u00e7\u00e3o de teletransporte. Nesse processo, a rede A confia na rede B para n\u00e3o cunhar mais tokens do que o transferido, e a rede B confia na rede A para queimar os tokens que foram transferidos</li> <li>Transfer\u00eancia de reserva - Uma transfer\u00eancia de reserva envolve a cadeia de reserva de um ativo, que \u00e9 a cadeia onde o ativo \u00e9 nativo (por exemplo, Moonbeam \u00e9 a cadeia de reserva para o token GLMR). Al\u00e9m disso, as redes n\u00e3o reservadas mant\u00eam uma conta soberana na cadeia de reserva, uma conta sem chave gerenciada pelo respectivo governador da rede. Assim, quando a rede de reserva A deseja enviar X quantidade de um ativo para a rede n\u00e3o reservada B, ela transfere localmente os ativos para a conta soberana da rede B e, na mesma a\u00e7\u00e3o at\u00f4mica, envia uma mensagem XCM para a rede B com instru\u00e7\u00f5es para cunhar X quantidade de uma forma derivada do ativo transferido. Por outro lado, se a rede n\u00e3o reservada B deseja enviar X quantidade de um ativo para a rede de reserva A, as etapas s\u00e3o: a rede B queima a forma derivada do ativo localmente e envia uma mensagem XCM para a rede A, com instru\u00e7\u00f5es para transferir os ativos da conta soberana da rede B para a conta de destino da rede A. Mesmo que a rede n\u00e3o reservada cunhe tokens derivados em excesso (ou n\u00e3o queime tokens ao transferir), esses tokens n\u00e3o ter\u00e3o valor real porque n\u00e3o s\u00e3o apoiados um a um na cadeia de reserva</li> </ul> <p>As taxas associadas \u00e0 execu\u00e7\u00e3o de transfer\u00eancias s\u00e3o tipicamente deduzidas do valor transferido, para que o destinat\u00e1rio receba a quantia pretendida menos as taxas.</p>"},{"location":"pt/learn/framework/xcm/#remote-execution","title":"Execu\u00e7\u00e3o Remota","text":"<p>A interoperabilidade nativa que o XCM fornece permite que uma rede envie uma mensagem a outra, acionando alguma a\u00e7\u00e3o. Por exemplo, se a cadeia de destino for compat\u00edvel com EVM, a rede A poder\u00e1 chamar um contrato inteligente implantado na rede B.</p> <p>Conforme mencionado na se\u00e7\u00e3o de taxas, para que qualquer solicita\u00e7\u00e3o na cadeia seja executada, \u00e9 necess\u00e1rio cobrir suas taxas associadas. No XCM, a execu\u00e7\u00e3o remota pode ser comprada com duas etapas:</p> <ol> <li>Reservar alguns ativos usando a instru\u00e7\u00e3o <code>WithdrawAsset</code> XCM, que retira fundos da origem da chamada e os coloca em um registro de reten\u00e7\u00e3o</li> <li>Pagar pela execu\u00e7\u00e3o na cadeia, usando a instru\u00e7\u00e3o <code>BuyExecution</code> XCM, que usa os ativos previamente retirados</li> </ol> <p>Nota</p> <p>Quando uma rede envia uma mensagem XCM, sua fonte padr\u00e3o no lado receptor \u00e9 a conta soberana da rede de origem. A rede remetente pode adicionar uma instru\u00e7\u00e3o XCM chamada <code>DescendOrigin</code> \u00e0 mensagem, alterando a conta de origem para corresponder \u00e0 conta do usu\u00e1rio que assina, garantindo que a execu\u00e7\u00e3o ocorra em nome da mesma entidade que inicia a mensagem XCM na cadeia de origem e evitando um cen\u00e1rio potencialmente inseguro.</p> <p>Finalmente, a execu\u00e7\u00e3o ocorre na cadeia de destino, chamando um contrato inteligente ou qualquer outra transa\u00e7\u00e3o usando a instru\u00e7\u00e3o XCM chamada <code>Transact</code>.</p> <p>O fluxo geral para execu\u00e7\u00e3o remota \u00e9 representado no seguinte diagrama:</p> <p></p>"},{"location":"pt/learn/framework/xcm/#channel-registration","title":"Estabelecendo Comunica\u00e7\u00e3o Cross-Chain","text":"<p>Antes que duas cadeias possam se comunicar, um canal de mensagens deve ser estabelecido. Os canais s\u00e3o unidirecionais, o que significa que canais separados s\u00e3o necess\u00e1rios para enviar mensagens da cadeia A para a cadeia B e da B para a A.</p> <p>Para que a cadeia A se comunique com a cadeia B, a cadeia A deve enviar uma transa\u00e7\u00e3o de canal aberto para a cadeia de retransmiss\u00e3o solicitando que um canal seja aberto com a cadeia B. A cadeia B deve ent\u00e3o aceitar a solicita\u00e7\u00e3o enviando uma mensagem XCM correspondente para a cadeia de retransmiss\u00e3o. Somente quando ambas as cadeias concordam \u00e9 que o canal \u00e9 aberto na pr\u00f3xima \u00e9poca. O mesmo processo \u00e9 necess\u00e1rio para estabelecer um canal da cadeia B para a cadeia A.</p> <p>\u00c9 importante notar que um canal entre uma rede e a cadeia de retransmiss\u00e3o \u00e9 aberto automaticamente mediante registro e integra\u00e7\u00e3o da rede.</p> <p></p> <p>Depois que o canal \u00e9 estabelecido, as mensagens cross-chain podem ser enviadas entre as redes. Para transfer\u00eancias de ativos, os ativos tamb\u00e9m precisar\u00e3o ser registrados antes de serem transferidos.</p> <p>Nota</p> <p>XCM \u00e9 uma linguagem versionada e em constante evolu\u00e7\u00e3o. Quando duas redes de comunica\u00e7\u00e3o usam vers\u00f5es diferentes do XCM, elas devem usar a vers\u00e3o mais recente com suporte do lado menos atualizado. Para descobrir a vers\u00e3o XCM mais recente com a qual uma rede pode trabalhar, outras redes podem consult\u00e1-la e assinar atualiza\u00e7\u00f5es sempre que isso mudar.</p>"},{"location":"pt/learn/framework/xcm/#message-destinations","title":"Destinos de Mensagens","text":"<p>Para compor mensagens significativas em um ambiente multichain, \u00e9 necess\u00e1rio ter uma maneira precisa e abstrata de referenciar recursos localizados em diferentes sistemas de consenso. Um conceito chamado multilocaliza\u00e7\u00e3o \u00e9 usado para servir a esse prop\u00f3sito e direcionar uma cadeia espec\u00edfica ou qualquer um de seus elementos internos, como uma conta, um ativo ou um contrato inteligente.</p> <p>Os elementos de destino do XCM s\u00e3o organizados em uma arquitetura hier\u00e1rquica, onde os elementos est\u00e3o contidos em outros componentes. Por exemplo, um contrato inteligente \u00e9 um elemento contido em uma rede, e o mesmo pode ser dito para uma conta ou um ativo ERC20. As redes est\u00e3o contidas pela cadeia de retransmiss\u00e3o, que desempenha um papel crucial no processo de mensagens cross-chain, retransmitindo mensagens de uma rede para outra.</p> <p>Multilocaliza\u00e7\u00f5es n\u00e3o s\u00e3o um localizador de recursos universal. Eles se referem a elementos da perspectiva do remetente e s\u00e3o compostos por dois componentes: <code>pais</code> e <code>interior</code>. Pais \u00e9 uma propriedade que indica se a rota deve \"subir\" na hierarquia, ou seja, de uma rede para a cadeia de retransmiss\u00e3o. Interior \u00e9 uma lista de jun\u00e7\u00f5es que definem como localizar o destino. Aqui est\u00e3o alguns exemplos de multilocaliza\u00e7\u00f5es:</p> <ul> <li>Rede A referencia um contrato inteligente na rede B - do ponto de vista da rede A, para alcan\u00e7ar um contrato inteligente na rede B, \u00e9 necess\u00e1rio subir na hierarquia (para a cadeia de retransmiss\u00e3o) e, em seguida, descer para a rede B para, uma vez l\u00e1, referenciar o endere\u00e7o do contrato inteligente. A multiloca\u00e7\u00e3o \u00e9, portanto, definida com um valor de <code>pais</code> definido como <code>1</code>, que sobe, e duas jun\u00e7\u00f5es, uma que define qual rede deve receber a mensagem e a outra que define o endere\u00e7o H160 do contrato inteligente que ser\u00e1 chamado</li> </ul> <p></p> <ul> <li>Rede A referencia uma conta na cadeia de retransmiss\u00e3o - do ponto de vista da rede A, para referenciar uma conta na cadeia de retransmiss\u00e3o, \u00e9 necess\u00e1rio subir e, em seguida, referenciar a conta. A multiloca\u00e7\u00e3o \u00e9 definida com um valor de <code>pais</code> definido como <code>1</code>, que sobe para a cadeia de retransmiss\u00e3o, e uma jun\u00e7\u00e3o que referencia o endere\u00e7o de destino do tipo substrato</li> </ul> <p></p>"},{"location":"pt/learn/tanssi/","title":"Saiba Mais Sobre Tanssi","text":"<p>Com Tanssi, os desenvolvedores podem contar com a produ\u00e7\u00e3o cont\u00ednua de blocos, integra\u00e7\u00e3o com ferramentas essenciais e a flexibilidade de escolher provedores de seguran\u00e7a que melhor se adequem ao seu ambiente de blockchain, capacitando-os a se concentrar na inova\u00e7\u00e3o, e n\u00e3o nos obst\u00e1culos t\u00e9cnicos.</p> <p>A estrutura modular, a personaliza\u00e7\u00e3o de tempo de execu\u00e7\u00e3o, o gerenciamento de transa\u00e7\u00f5es e a interoperabilidade da Tanssi transformam o desenvolvimento de rede em um processo acess\u00edvel e eficiente, reduzindo drasticamente o tempo de lan\u00e7amento no mercado, garantindo, ao mesmo tempo, alto desempenho e escalabilidade.</p> <p>Esta se\u00e7\u00e3o inclui uma vis\u00e3o geral dos principais recursos da Tanssi que suportam o desenvolvimento da rede, cobrindo tudo, desde infraestrutura e seguran\u00e7a at\u00e9 integra\u00e7\u00f5es essenciais.</p>"},{"location":"pt/learn/tanssi/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/tanssi/account-types/","title":"Contas no Protocolo Tanssi","text":""},{"location":"pt/learn/tanssi/account-types/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A tecnologia blockchain baseia-se na criptografia de chaves p\u00fablico-privadas para propriedade segura de ativos e verifica\u00e7\u00e3o de transa\u00e7\u00f5es. Chaves privadas autorizam transa\u00e7\u00f5es, enquanto chaves p\u00fablicas servem como endere\u00e7os para verifica\u00e7\u00e3o. Devido \u00e0 natureza h\u00edbrida Substrate e Ethereum do protocolo Tanssi, entender os diferentes tipos de conta \u00e9 crucial para usu\u00e1rios e operadores.</p>"},{"location":"pt/learn/tanssi/account-types/#key-types-in-tanssi-protocol","title":"Tipos de Conta no Protocolo Tanssi","text":"Tipo de Conta Algoritmo Subjacente Uso Principal no Tanssi Sr25519 Assinaturas Schnorr no grupo Ristretto Esquema padr\u00e3o de assinatura para transa\u00e7\u00f5es baseadas em Substrate e identidade de operador. Ed25519 EdDSA usando Curve25519 Usado para fun\u00e7\u00f5es espec\u00edficas de consenso (ex.: produ\u00e7\u00e3o de blocos, finalidade) no Substrate. ECDSA Algoritmo de Assinatura Digital de Curva El\u00edptica Recebimento de recompensas via protocolo Symbiotic baseado em Ethereum para operadores."},{"location":"pt/learn/tanssi/account-types/#identity-and-operations","title":"Identidade e Opera\u00e7\u00f5es","text":"<p>A Tanssi, constru\u00edda com o framework Substrate, utiliza esquemas criptogr\u00e1ficos distintos para fun\u00e7\u00f5es diferentes, principalmente Sr25519 e Ed25519. Esses tipos de conta s\u00e3o essenciais para interagir com os componentes Substrate do protocolo, assinando transa\u00e7\u00f5es.</p> <p>Sr25519 (Schnorrkel/Ristretto x25519) \u2013 \u00e9 o tipo de conta principal usado na maioria das opera\u00e7\u00f5es voltadas ao usu\u00e1rio dentro da Tanssi. Seus pontos fortes s\u00e3o seguran\u00e7a e efici\u00eancia. Contas Sr25519 servem como sua identidade on-chain, usadas para manter tokens, participar de governan\u00e7a, pagar taxas de transa\u00e7\u00e3o e outras intera\u00e7\u00f5es gerais com a rede.</p> <p>Ed25519 (Algoritmo de Assinatura Digital de Curva Edwards) \u2013 enquanto Sr25519 cuida da identidade e transa\u00e7\u00f5es gerais, Ed25519 \u00e9 usado por seu alto desempenho em assinatura criptogr\u00e1fica, ideal para opera\u00e7\u00f5es de consenso. Na Tanssi, contas Ed25519 s\u00e3o usadas por operadores de n\u00f3 para mecanismos cr\u00edticos, como produ\u00e7\u00e3o de blocos e finalidade. Usu\u00e1rios comuns normalmente n\u00e3o criam ou usam diretamente contas Ed25519, mas elas s\u00e3o fundamentais para a seguran\u00e7a e opera\u00e7\u00e3o da rede.</p> <p>Operadores de n\u00f3 na Tanssi precisam de uma conta Substrate para registrar suas atividades, incluindo validadores que protegem a rede e sequenciadores que produzem blocos. Esta conta tamb\u00e9m rastreia recompensas, com chaves de sess\u00e3o mapeadas para ela para maior seguran\u00e7a.</p>"},{"location":"pt/learn/tanssi/account-types/#security-and-rewards-on-ethereum","title":"Seguran\u00e7a e Recompensas no Ethereum","text":"<p>O Algoritmo de Assinatura Digital de Curva El\u00edptica (ECDSA) \u00e9 fundamental para o Ethereum e \u00e9 usado pela Tanssi para integrar-se \u00e0 rede Ethereum via Symbiotic. Essa parceria alavanca a seguran\u00e7a do Ethereum para redes com tecnologia Tanssi.</p> <p>Operadores Tanssi precisam de uma conta ECDSA para receber recompensas distribu\u00eddas no Ethereum, geralmente via protocolo Symbiotic. A necessidade de contas Substrate e ECDSA destaca o design h\u00edbrido da Tanssi, em que as opera\u00e7\u00f5es s\u00e3o baseadas em Substrate, e a seguran\u00e7a e as recompensas est\u00e3o vinculadas ao Ethereum.</p>"},{"location":"pt/learn/tanssi/account-types/#account-mappings-in-tanssi","title":"Mapeamentos de Conta na Tanssi","text":""},{"location":"pt/learn/tanssi/account-types/#vinculacao-interna-de-chaves-sr25519-e-ed25519","title":"Vincula\u00e7\u00e3o Interna de Chaves (Sr25519 e Ed25519)","text":"<p>Dentro do protocolo Substrate da Tanssi, a identidade Sr25519 prim\u00e1ria de um operador se vincula a chaves Ed25519 espec\u00edficas usadas para tarefas de consenso (como produ\u00e7\u00e3o de blocos). Os operadores criam essa vincula\u00e7\u00e3o com uma transa\u00e7\u00e3o on-chain, mapeando suas chaves p\u00fablicas internas (\u201cchaves de sess\u00e3o\u201d) para a conta de stash. Esse registro on-chain garante que a rede atribua corretamente todas as a\u00e7\u00f5es das chaves de sess\u00e3o \u00e0 identidade prim\u00e1ria do operador.</p>"},{"location":"pt/learn/tanssi/account-types/#mapeamento-de-recompensas-entre-ecossistemas-sr25519-e-ecdsa","title":"Mapeamento de Recompensas entre Ecossistemas (Sr25519 e ECDSA)","text":"<p>Para recompensas no Ethereum (por exemplo, via Symbiotic), a identidade Sr25519 do operador \u00e9 mapeada para um endere\u00e7o ECDSA no Ethereum. As duas contas s\u00e3o vinculadas pelo middleware da Tanssi, garantindo que as recompensas do trabalho do operador na rede Tanssi sejam roteadas para a conta Ethereum designada.</p>"},{"location":"pt/learn/tanssi/glossary/","title":"Gloss\u00e1rio","text":""},{"location":"pt/learn/tanssi/glossary/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O protocolo Tanssi oferece uma ampla gama de recursos e arquitetura em camadas, tornando-o rico e complexo. H\u00e1 uma grande quantidade de terminologia espec\u00edfica para Tanssi, Appchains, Symbiotic e o espa\u00e7o web3 em geral. Compilamos uma lista de termos que voc\u00ea vai querer conhecer ao revisar a documenta\u00e7\u00e3o do Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#appchain","title":"Appchain","text":"<p>Um blockchain personaliz\u00e1vel espec\u00edfico para aplica\u00e7\u00f5es implantado atrav\u00e9s do Tanssi que entra em opera\u00e7\u00e3o em minutos, beneficiando-se da seguran\u00e7a compartilhada, servi\u00e7os de produ\u00e7\u00e3o de blocos, bridging integrado e outros servi\u00e7os.</p>"},{"location":"pt/learn/tanssi/glossary/#beefy","title":"BEEFY","text":"<p>BEEFY significa Bridge Efficiency Enabling Finality Yielder. \u00c9 um protocolo de consenso que o Tanssi utiliza para bridging eficiente e sem confian\u00e7a para o Ethereum.</p>"},{"location":"pt/learn/tanssi/glossary/#bridge","title":"Bridge","text":"<p>Uma bridge no contexto web3 conecta dois blockchains soberanos diferentes. Tanssi oferece uma bridge integrada baseada no Snowbridge, conectando a rede Tanssi ao Ethereum de forma descentralizada e sem confian\u00e7a.</p>"},{"location":"pt/learn/tanssi/glossary/#dancelight","title":"Dancelight","text":"<p>A TestNet oficial do Tanssi para implanta\u00e7\u00e3o e experimenta\u00e7\u00e3o r\u00e1pida de redes.</p>"},{"location":"pt/learn/tanssi/glossary/#data-preservers","title":"Data Preservers","text":"<p>N\u00f3s de arquivamento completo que garantem a disponibilidade de dados e fornecem infraestrutura RPC para as redes Tanssi e com tecnologia Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#ecdsa","title":"ECDSA","text":"<p>ECDSA significa Elliptic Curve Digital Signature Algorithm, que \u00e9 o esquema criptogr\u00e1fico usado para contas Ethereum.</p>"},{"location":"pt/learn/tanssi/glossary/#ed25519","title":"Ed25519","text":"<p>\u00c9 o esquema criptogr\u00e1fico para produzir assinaturas digitais usado por operadores de n\u00f3s para mecanismos de consenso como produ\u00e7\u00e3o de blocos.</p>"},{"location":"pt/learn/tanssi/glossary/#gateway","title":"Gateway Contract","text":"<p>Um dos componentes da bridge Tanssi-Ethereum. Ele serve como o ponto central de mensagens do Ethereum que recebe e valida mensagens do Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#light-client","title":"Light Client","text":"<p>Um dos componentes da bridge Tanssi-Ethereum. Serve como um verificador on-chain para a legitimidade dos dados em uma rede.</p> <p>Um cliente leve \u00e9 um software que permite interagir com um blockchain sem ter que baixar todos os dados. Ele utiliza um subconjunto de informa\u00e7\u00f5es (como cabe\u00e7alhos de blocos) e usa ferramentas como provas de Merkle para verificar a autenticidade de transa\u00e7\u00f5es e dados. Isso torna os clientes leves mais eficientes em termos de recursos do que os n\u00f3s completos.</p>"},{"location":"pt/learn/tanssi/glossary/#merkle-root","title":"Merkle Root","text":"<p>Um \u00fanico hash criptogr\u00e1fico que permite a verifica\u00e7\u00e3o de um conjunto inteiro de dados, como todas as transa\u00e7\u00f5es em um bloco.</p>"},{"location":"pt/learn/tanssi/glossary/#operator","title":"Operator","text":"<p>Um n\u00f3 que valida transa\u00e7\u00f5es, fornecendo seguran\u00e7a atrav\u00e9s de um protocolo de restaking para Tanssi e todas as appchains movidas a Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#relayer","title":"Relayer","text":"<p>Um componente sem estado que transporta mensagens e provas entre diferentes redes blockchain, como Tanssi e Ethereum.</p>"},{"location":"pt/learn/tanssi/glossary/#restaking","title":"Restaking","text":"<p>A pr\u00e1tica de usar tokens j\u00e1 apostados para proteger protocolos ou servi\u00e7os adicionais.</p>"},{"location":"pt/learn/tanssi/glossary/#sequencer","title":"Sequencer","text":"<p>Um n\u00f3 respons\u00e1vel por executar transa\u00e7\u00f5es e produzir blocos para appchains movidas a Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#session","title":"Session","text":"<p>Um per\u00edodo de tempo durante o qual o mesmo conjunto de autoridades (sequencers ou validadores) est\u00e1 ativo.</p>"},{"location":"pt/learn/tanssi/glossary/#sr25519","title":"Sr25519","text":"<p>O principal esquema de assinatura que \u00e9 usado para a maioria das opera\u00e7\u00f5es voltadas para o usu\u00e1rio dentro da rede Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#substrate","title":"Substrate","text":"<p>Uma estrutura de desenvolvimento de blockchain modular e de alto desempenho usada para construir Tanssi e appchains Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#symbiotic","title":"Symbiotic","text":"<p>Um protocolo de restaking baseado em Ethereum, fornecendo servi\u00e7os de restaking e seguran\u00e7a econ\u00f4mica para Tanssi e appchains com tecnologia Tanssi.</p>"},{"location":"pt/learn/tanssi/glossary/#tanssi-substrate","title":"$TANSSI(Substrate)","text":"<p>O token de utilidade nativo do protocolo Tanssi. \u00c9 usado para staking, governan\u00e7a, opera\u00e7\u00f5es de rede e muito mais.</p>"},{"location":"pt/learn/tanssi/glossary/#tanssi-erc20","title":"$TANSSI(ERC20)","text":"<p>A representa\u00e7\u00e3o ERC20 Ethereum do token Tanssi. \u00c9 usado para pagar recompensas aos operadores e muito mais.</p>"},{"location":"pt/learn/tanssi/glossary/#trustless","title":"Trustless","text":"<p>Assim como uma bridge sem confian\u00e7a, ela permite a opera\u00e7\u00e3o sem exigir confian\u00e7a em intermedi\u00e1rios centralizados, contando, em vez disso, com provas criptogr\u00e1ficas.</p>"},{"location":"pt/learn/tanssi/glossary/#vault","title":"Vault","text":"<p>Um componente Symbiotic que recebe e gerencia colaterais em restaking, delegando aos operadores e fornecendo seguran\u00e7a econ\u00f4mica \u00e0s redes.</p>"},{"location":"pt/learn/tanssi/glossary/#verifier","title":"Verifier","text":"<p>O componente que valida provas criptogr\u00e1ficas.</p>"},{"location":"pt/learn/tanssi/overview/","title":"O que \u00e9 Tanssi?","text":"<p>Tanssi \u00e9 um protocolo de infraestrutura de appchain descentralizado que permite que os desenvolvedores lancem sua appchain em minutos. Em outras palavras, Tanssi reduz o processo de configura\u00e7\u00e3o de seis a doze meses normalmente necess\u00e1rio para qualquer equipe entrar em funcionamento com uma nova cadeia para minutos.</p> <p>Pode-se pensar em Tanssi como AWS para appchains. Em vez de lidar com toda a infraestrutura de rede voc\u00ea mesmo, Tanssi lida com todos os obst\u00e1culos, permitindo que voc\u00ea se concentre na cria\u00e7\u00e3o da l\u00f3gica do seu aplicativo, no crescimento de sua comunidade e em outras tarefas essenciais para o sucesso do seu produto.</p> <p>A seguran\u00e7a \u00e9 outro obst\u00e1culo significativo que os desenvolvedores devem enfrentar, assumindo a responsabilidade de atrair ativos em stake para garantir a seguran\u00e7a do consenso e inicializar um conjunto de validadores, o que pode ser particularmente desafiador para projetos em seus est\u00e1gios iniciais. Todas as appchains com tecnologia Tanssi se beneficiam da seguran\u00e7a de n\u00edvel Ethereum desde o in\u00edcio e, ao aproveitar o design descentralizado do Tanssi, as appchains n\u00e3o est\u00e3o expostas a pontos \u00fanicos de falha.</p> <p>As appchains com tecnologia Tanssi tamb\u00e9m se beneficiam de uma pilha de tecnologia modular, fornecendo controle m\u00e1ximo sobre a l\u00f3gica que alimenta o tempo de execu\u00e7\u00e3o do blockchain, oferecendo uma excelente maneira de os projetos escalarem e constru\u00edrem solu\u00e7\u00f5es otimizadas para seus produtos. Esse controle completo sobre a l\u00f3gica da appchain e o mecanismo de governan\u00e7a se adequa perfeitamente a uma ampla gama de casos de uso, incluindo protocolos DeFi, Ativos do Mundo Real (RWA), plataformas de jogos e outros.</p>"},{"location":"pt/learn/tanssi/overview/#the-problem-with-appchains","title":"O Problema com Appchains","text":"<p>Os desenvolvedores que buscam construir appchains descentralizadas geralmente t\u00eam que lidar com os seguintes problemas:</p> <ul> <li> <p>Gerenciamento de Infraestrutura Complexo: As implanta\u00e7\u00f5es de appchain normalmente exigem o manuseio de numerosos componentes de infraestrutura, incluindo bootstrapping de sequenciadores, operadores (tamb\u00e9m conhecidos como validadores), carteiras, exploradores de blocos, or\u00e1culos, indexadores, endpoints RPC e muito mais. O gerenciamento adequado desses componentes consome tempo e recursos.</p> </li> <li> <p>Seguran\u00e7a Fraca e Ineficiente: As appchains geralmente sofrem por ter um pequeno conjunto de operadores ou seguran\u00e7a econ\u00f4mica fraca. Projetos em est\u00e1gio inicial geralmente carecem de apoio econ\u00f4mico suficiente para oferecer suporte a um mecanismo de consenso robusto. Al\u00e9m disso, os desenvolvedores geralmente t\u00eam que pagar pela valida\u00e7\u00e3o total da capacidade do blockchain, mesmo quando podem n\u00e3o ter alcan\u00e7ado o ajuste produto-mercado, e os blocos podem estar quase vazios. Isso essencialmente significa que os operadores est\u00e3o sendo super pagos, e h\u00e1 um custo de oportunidade significativo, pois esses recursos poderiam ser usados em outros lugares para desenvolver o protocolo.</p> </li> <li> <p>Cross-Chain e Interoperabilidade: As appchains inerentemente carecem de recursos cross-chain, o que as impede de se conectar a outros ecossistemas de blockchain. Al\u00e9m disso, o desenvolvimento de solu\u00e7\u00f5es de interoperabilidade requer expertise especializada e implementa\u00e7\u00e3o meticulosa.</p> </li> <li> <p>Tempo para o mercado lento: As complexidades da infraestrutura da appchain desviam o foco dos desenvolvedores da l\u00f3gica do aplicativo, que \u00e9 o principal impulsionador de interfaces intuitivas e uma experi\u00eancia do usu\u00e1rio perfeita, cr\u00edtica para a ado\u00e7\u00e3o.</p> </li> </ul>"},{"location":"pt/learn/tanssi/overview/#what-tanssi-provides","title":"O que Tanssi Fornece","text":"<p>Tanssi aborda os pontos problem\u00e1ticos mais comuns da appchain:</p> <ul> <li> <p>Sequenciamento como Servi\u00e7o: As appchains constru\u00eddas com Tanssi t\u00eam seus blocos produzidos pelos trabalhadores incentivados do Tanssi. Tanssi garante a atividade cont\u00ednua da appchain, orquestrando um conjunto descentralizado de sequenciadores.</p> </li> <li> <p>Seguran\u00e7a Econ\u00f4mica por Meio de Provedores Externos: As appchains implantadas por meio do Tanssi aproveitam a seguran\u00e7a de um provedor de escolha (por exemplo, Symbiotic para Ethereum). O protocolo foi projetado para finalizar as transa\u00e7\u00f5es de forma determin\u00edstica em segundos por meio de um conjunto descentralizado de operadores.</p> </li> <li> <p>Tanssi/Ethereum Bridge: Mova a liquidez de e para o Ethereum usando a ponte integrada com base no Snowbridge.</p> </li> <li> <p>Integra\u00e7\u00f5es Chave: As appchains constru\u00eddas com Tanssi podem acessar componentes de infraestrutura importantes, juntamente com a produ\u00e7\u00e3o de blocos, de forma totalmente automatizada e padronizada. As appchains com tecnologia Tanssi v\u00eam com suporte integrado para ferramentas essenciais, incluindo carteiras, exploradores de blocos, indexadores, provedores RPC e muito mais, economizando o esfor\u00e7o dos desenvolvedores de integrar esses componentes.</p> </li> <li> <p>Estrutura Modular de Blockchain: As appchains constru\u00eddas com Tanssi podem usar uma estrutura de blockchain modular chamada Substrate, que permite que os desenvolvedores criem de forma r\u00e1pida e f\u00e1cil blockchains otimizadas e personaliz\u00e1veis para qualquer caso de uso. Tanssi lida com a maioria das complexidades de infraestrutura, permitindo que os desenvolvedores se concentrem na l\u00f3gica personalizada de sua appchain.</p> </li> </ul> <p>Em resumo, as appchains implantadas por meio do Tanssi s\u00e3o solu\u00e7\u00f5es soberanas de Camada 1 projetadas para serem altamente modulares e interconectadas, com foco na simplifica\u00e7\u00e3o do processo de implanta\u00e7\u00e3o e no desenvolvimento da personaliza\u00e7\u00e3o da pr\u00f3pria appchain. Isso capacita os desenvolvedores a levar seus aplicativos blockchain ao mercado mais r\u00e1pido, com seguran\u00e7a e com maior potencial de integra\u00e7\u00e3o e intera\u00e7\u00e3o nos ecossistemas blockchain mais amplos.</p>"},{"location":"pt/learn/tanssi/overview/#tanssi-key-aspects","title":"Principais aspectos do Tanssi","text":"<p>A tabela a seguir resume os principais benef\u00edcios que Tanssi traz para seu projeto:</p> Aspecto A solu\u00e7\u00e3o Tanssi Tempo de implanta\u00e7\u00e3o - Minutos para implantar - Tempo mais r\u00e1pido de lan\u00e7amento no mercado Produ\u00e7\u00e3o de bloco - Sequenciamento como servi\u00e7o- Conjunto descentralizado de sequenciadores por projeto Seguran\u00e7a - Seguran\u00e7a de n\u00edvel Ethereum desde o in\u00edcio Finalidade/Liquida\u00e7\u00e3o - Determin\u00edstico- Finalidade em segundos Custo - T\u00edtulo de registro + modelo de pagamento conforme o uso Personaliza\u00e7\u00e3o - Escolha o mecanismo de governan\u00e7a que melhor se adapta ao seu projeto - Estrutura modular- Personaliza\u00e7\u00e3o completa do tempo de execu\u00e7\u00e3o Integra\u00e7\u00f5es e ferramentas - Ferramentas essenciais dispon\u00edveis desde o in\u00edcio"},{"location":"pt/learn/tanssi/overview/#tanssi-architecture","title":"Arquitetura Geral do Tanssi e Appchains com tecnologia Tanssi","text":"<p>Como discutido anteriormente, as appchains implantadas por meio do Tanssi s\u00e3o blockchains soberanas e personaliz\u00e1veis que, entre outros recursos, aproveitam o sequenciamento como servi\u00e7o e herdam a finalidade do bloco de um provedor de seguran\u00e7a externo.</p> <p>Uma vis\u00e3o geral de alto n\u00edvel da arquitetura \u00e9 apresentada abaixo, apresentando Symbiotic como o provedor de seguran\u00e7a.</p> <p></p> <p>O protocolo Tanssi gerencia e orquestra um conjunto descentralizado de sequenciadores atribu\u00eddos a fornecer servi\u00e7os de produ\u00e7\u00e3o de blocos para appchains com tecnologia Tanssi. Os sequenciadores executam transa\u00e7\u00f5es e as incluem em blocos, que os operadores do provedor de seguran\u00e7a prosseguem para validar. O protocolo de restaking da Symbiotic permite que seus operadores ofere\u00e7am seguran\u00e7a econ\u00f4mica de n\u00edvel Ethereum. O mecanismo de como isso funciona \u00e9 explicado em dois artigos separados: Servi\u00e7os de Produ\u00e7\u00e3o de Blocos e Ethereum com Symbiotic.</p> <p>Embora os sequenciadores que fornecem servi\u00e7os de produ\u00e7\u00e3o de blocos sejam rotacionados e realocados para uma appchain diferente a cada mudan\u00e7a de sess\u00e3o, cada appchain ter\u00e1 seu pr\u00f3prio conjunto de Preservadores de Dados executando n\u00f3s de arquivo completos, garantindo a disponibilidade de dados. Esses Preservadores de Dados fornecer\u00e3o a infraestrutura RPC para aplicativos e usu\u00e1rios que interagem com appchains com tecnologia Tanssi.</p> <p></p>"},{"location":"pt/learn/tanssi/overview/#whats-next","title":"O que vem a seguir?","text":"<ul> <li>V\u00e1 para o Tanssi dApp e lance sua appchain.</li> <li>Interaja com uma appchain com tecnologia Tanssi ao vivo: a Tanssi Demo EVM appchain.</li> </ul>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/","title":"Ponte Tanssi-Ethereum","text":""},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Blockchains tradicionais frequentemente criam silos, limitando a interoperabilidade de ativos e funcionalidades. A ponte Tanssi-Ethereum supera essas limita\u00e7\u00f5es ao permitir opera\u00e7\u00f5es entre cadeias que beneficiam ambos os ecossistemas.</p> <p>A ponte \u00e9 mais do que uma troca de ativos. \u00c9 um protocolo seguro e padronizado para intera\u00e7\u00e3o direta entre cadeias sem intermedi\u00e1rios centralizados. Seu design sem confian\u00e7a evita riscos de pontos \u00fanicos de falha.</p> <p>Este artigo apresenta a ponte Tanssi-Ethereum como uma camada-chave de interoperabilidade entre as duas redes. Voc\u00ea ver\u00e1 como ela funciona, incluindo arquitetura, gerenciamento de operadores, modelo econ\u00f4mico, mecanismos de corte e transfer\u00eancias de ativos.</p> <p>Tamb\u00e9m ver\u00e1 as camadas de consenso que protegem a comunica\u00e7\u00e3o (BEEFY no Tanssi e a Ethereum Beacon Chain), e os pap\u00e9is de provadores, verificadores e relayers, oferecendo uma vis\u00e3o clara de como ativos e mensagens circulam com seguran\u00e7a entre Tanssi e Ethereum.</p>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#core-functions","title":"Fun\u00e7\u00f5es Principais","text":"<p>A ponte facilita opera\u00e7\u00f5es cr\u00edticas entre Tanssi e Ethereum:</p> <ul> <li>Gerenciamento de Operadores - mant\u00e9m informa\u00e7\u00f5es de stake no Ethereum via Symbiotic, fornecendo dados para o Tanssi selecionar operadores ativos e alinhados economicamente em cada era</li> <li>Opera\u00e7\u00f5es Econ\u00f4micas - distribui recompensas do Tanssi para stakers e operadores no Ethereum</li> <li>Corte (Slashing) - processa pedidos de corte do Tanssi para o Ethereum quando operadores violam regras</li> <li>Transfer\u00eancia de Ativos - permite transfer\u00eancias bilaterais e sem confian\u00e7a entre Tanssi e Ethereum, aumentando a liquidez</li> </ul> <p>Essa interoperabilidade amplia o potencial de dApps e melhora significativamente a liquidez e usabilidade de ativos.</p>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#bridge-architecture","title":"A Arquitetura da Ponte","text":"<p>Entender a funcionalidade de consenso da ponte exige olhar para provadores, verificadores e relayers. Provadores geram provas criptogr\u00e1ficas, verificadores as validam e relayers movem dados entre cadeias.</p> <p>Os provadores incluem o m\u00f3dulo BEEFY do Tanssi e o consenso da Ethereum Beacon Chain. Eles produzem dados de consenso transmitidos por relayers especializados.</p> <p>Cada cadeia executa um cliente leve da outra, atuando como verificador on-chain da legitimidade dos dados. Por exemplo, quando o Tanssi envia uma mensagem para o Ethereum, gera provas compactas de eventos ou mudan\u00e7as de estado; o cliente leve do Ethereum as verifica antes de agir.</p>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-consensus","title":"Consenso Tanssi \u2192 Ethereum","text":"<p>BEEFY (Bridge Efficiency Enabling Finality Yielder) \u00e9 o protocolo de consenso do Tanssi e atua como provador. Ele foi projetado para ponte eficiente e sem confian\u00e7a com cadeias como Ethereum.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_Pallet as Tanssi &lt;br/&gt; BEEFY Pallet (prover)\n    participant Beefy_Relayer as Relayer &lt;br/&gt; (Beefy)\n    participant Eth_BeefyClient as Ethereum &lt;br/&gt; BEEFY Client (verifier)\n\n    Tanssi_Pallet-&gt;&gt;Beefy_Relayer: Gerar compromisso BEEFY\n    activate Beefy_Relayer\n    Beefy_Relayer-&gt;&gt;Eth_BeefyClient: Enviar compromisso/prova\n    deactivate Beefy_Relayer\n\n    activate Eth_BeefyClient\n    Eth_BeefyClient-&gt;&gt;Eth_BeefyClient: Verificar compromisso\n    deactivate Eth_BeefyClient</code></pre>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-consensus","title":"Consenso Ethereum \u2192 Tanssi","text":"<p>Para a ponte Ethereum\u2192Tanssi, o consenso da Ethereum Beacon Chain \u00e9 o provador. Ele fornece ao cliente leve on-chain do Tanssi prova do estado finalizado do Ethereum, incluindo eventos ou mensagens destinados ao Tanssi.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_BeaconCons as Ethereum &lt;br/&gt; Beacon Chain Consensus (prover)\n    participant Beacon_Relayer as Relayer &lt;br/&gt; (Beacon)\n    participant Tanssi_EthClient as Tanssi &lt;br/&gt; Ethereum Light Client (verifier)\n\n    Eth_BeaconCons-&gt;&gt;Beacon_Relayer: Atualiza\u00e7\u00e3o da Beacon (Header/Prova)\n    activate Beacon_Relayer\n    Beacon_Relayer-&gt;&gt;Tanssi_EthClient: Enviar atualiza\u00e7\u00e3o/prova\n    deactivate Beacon_Relayer\n\n    activate Tanssi_EthClient\n    Tanssi_EthClient-&gt;&gt;Tanssi_EthClient: Verificar atualiza\u00e7\u00e3o/prova\n    deactivate Tanssi_EthClient</code></pre> <p>Do ponto de vista das mensagens, a ponte usa essa camada de verifica\u00e7\u00e3o de consenso para comunica\u00e7\u00e3o segura. Relayers dedicados transportam mensagens: o Execution Relay para Ethereum\u2192Tanssi e o Tanssi Relay para Tanssi\u2192Ethereum.</p> <p>Relayers s\u00e3o sem estado e apenas submetem provas. Eles n\u00e3o podem forjar mensagens ou roubar fundos, pois o consenso revalida cada prova on-chain. V\u00e1rios relayers paralelos melhoram a responsividade sem centralizar poder.</p> <p>O contrato <code>Gateway</code> no Ethereum \u00e9 o ponto central de mensagens. Ele recebe mensagens do Tanssi via relayers, valida com provas de consenso e executa opera\u00e7\u00f5es como cunhagem/desbloqueio de tokens ou chamadas de contratos.</p>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#ethereum-tanssi-messages","title":"Mensagens de Entrada Ethereum \u2192 Tanssi","text":"<p>Mensagens do Ethereum para o Tanssi usam o consenso da Beacon Chain para provas e um Execution/Beacon Relay.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Gateway Contract\n    participant Exec_Relay as Relayer &lt;br/&gt; (Execution Relay)\n    participant Tanssi_InQueue as Tanssi &lt;br/&gt; Inbound Queue\n\n    Note over Eth_Gateway: Mensagem pronta / Evento ocorre\n    Eth_Gateway-&gt;&gt;Exec_Relay: Mensagem + Prova\n    activate Exec_Relay\n    Exec_Relay-&gt;&gt;Tanssi_InQueue: Enviar Mensagem/Prova\n    deactivate Exec_Relay\n\n    activate Tanssi_InQueue\n    Tanssi_InQueue-&gt;&gt;Tanssi_InQueue: Processar mensagem de entrada\n    deactivate Tanssi_InQueue</code></pre>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#tanssi-ethereum-messages","title":"Mensagens de Sa\u00edda Tanssi \u2192 Ethereum","text":"<p>Mensagens do Tanssi para Ethereum usam o consenso BEEFY para provar o estado do Tanssi e um Tanssi Relay para transmiss\u00e3o.</p> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Tanssi_OutQueue as Tanssi &lt;br/&gt; Outbound Queue\n    participant Para_Relay as Relayer &lt;br/&gt; (Tanssi Relay)\n    participant Eth_Gateway as Ethereum &lt;br/&gt; Gateway Contract\n\n    Note over Tanssi_OutQueue: Mensagem pronta / Prova confirmada\n    Tanssi_OutQueue-&gt;&gt;Para_Relay: Mensagem + Prova\n    activate Para_Relay\n    Para_Relay-&gt;&gt;Eth_Gateway: Enviar Mensagem/Prova\n    deactivate Para_Relay\n\n    activate Eth_Gateway\n    Eth_Gateway-&gt;&gt;Eth_Gateway: Processar mensagem de sa\u00edda\n    deactivate Eth_Gateway</code></pre> <p>O <code>Gateway</code> gerencia comunica\u00e7\u00f5es de sa\u00edda no Ethereum. Para transfer\u00eancias entre cadeias, registra um evento, bloqueia tokens (se necess\u00e1rio) e empacota dados para retransmiss\u00e3o ao Tanssi. O Tanssi usa duas filas para processar mensagens com efici\u00eancia.</p> <p>A <code>Outbound Queue</code> lida com mensagens para o Ethereum, agrupando-as e adicionando uma raiz Merkle a cada cabe\u00e7alho de bloco. Isso permite que o cliente leve do Ethereum verifique a inclus\u00e3o com provas de consenso.</p> <p>A <code>Inbound Queue</code> processa mensagens do Ethereum, recebendo e verificando provas via cliente leve Ethereum on-chain do Tanssi. Eventos verificados tornam-se instru\u00e7\u00f5es internas no Tanssi. Essa arquitetura em camadas, protegida por consenso, garante intera\u00e7\u00f5es sem confian\u00e7a entre cadeias.</p>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#token-transfers-flow","title":"Fluxo de Transfer\u00eancias de Tokens","text":"<p>O fluxo de ativos envolve bloquear/cunhar em uma cadeia e a a\u00e7\u00e3o complementar na outra, protegida por provas verificadas:</p> <ol> <li>Inicia\u00e7\u00e3o (cadeia de origem) - usu\u00e1rio inicia a transfer\u00eancia</li> <li>Prova via Relay - relayers off-chain captam o evento e enviam provas criptogr\u00e1ficas para a cadeia de destino</li> <li>Verifica\u00e7\u00e3o (cadeia de destino) - clientes leves on-chain verificam as provas enviadas</li> <li>Execu\u00e7\u00e3o - ap\u00f3s a verifica\u00e7\u00e3o, tokens s\u00e3o cunhados/desbloqueados na cadeia de destino</li> </ol>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#transferencia-de-ethereum-para-tanssi","title":"Transfer\u00eancia de Ethereum para Tanssi","text":"<ol> <li>Bloqueio no Ethereum - o usu\u00e1rio deposita ativos no contrato da Bridge no Ethereum; tokens s\u00e3o bloqueados e um evento de dep\u00f3sito \u00e9 emitido</li> <li>Relay para Tanssi - um relayer detecta o evento finalizado, cria um pacote de prova (cabe\u00e7alho do bloco + prova de Merkle) e envia para a <code>Inbound Queue</code> da Tanssi Bridge</li> <li>Verificar no Tanssi - o m\u00f3dulo <code>EthereumClient</code> (cliente leve on-chain) verifica a finalidade do cabe\u00e7alho do Ethereum e a prova de Merkle</li> <li>Cunhar no Tanssi - ap\u00f3s verifica\u00e7\u00e3o, a <code>Inbound Queue</code> cunha o ativo correspondente no Tanssi</li> </ol> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant User\n    participant EBridge as Ethereum Bridge Contract\n    participant Relayer\n    participant TBP as Tanssi Bridge&lt;br/&gt; (Inbound Queue + ETH Client)\n    participant TAH as Tanssi\n\n    User-&gt;&gt;EBridge: 1. Depositar ativo\n    activate EBridge\n    Note over EBridge: Bloquear tokens &amp; emitir evento\n    deactivate EBridge\n\n    Relayer-&gt;&gt;Relayer: Observar evento no Ethereum\n    Relayer-&gt;&gt;TBP: 2. Enviar cabe\u00e7alho + prova de Merkle\n    activate TBP\n    Note over TBP: Receber prova (Inbound Queue)\n    TBP-&gt;&gt;TBP: 3. Verificar prova (EthereumClient)\n    TBP-&gt;&gt;TAH: Enviar solicita\u00e7\u00e3o de cunhagem\n    deactivate TBP\n\n    activate TAH\n    TAH-&gt;&gt;TAH: 4. Cunhar ativo\n    TAH--&gt;&gt;User: Ativo aparece na conta\n    deactivate TAH</code></pre>"},{"location":"pt/learn/tanssi/tanssi-ethereum-bridge/#transferencia-de-tanssi-para-ethereum","title":"Transfer\u00eancia de Tanssi para Ethereum","text":"<ol> <li>Iniciar e confirmar no Tanssi - usu\u00e1rio inicia transfer\u00eancia; mensagem vai para a <code>Outbound Queue</code>, que agrupa a carga \u00fatil e confirma a raiz Merkle no cabe\u00e7alho do Tanssi</li> <li>Relay para Ethereum - relayer off-chain busca prova: compromisso BEEFY + prova de Merkle da carga \u00fatil</li> <li>Enviar compromisso no Ethereum - relayer envia compromisso BEEFY e prova de Merkle ao contrato <code>Gateway</code></li> <li>Verificar no Ethereum - contrato Beefy Client verifica o compromisso</li> <li>Validar carga \u00fatil - <code>Gateway</code> valida a prova de Merkle</li> <li>Executar no Ethereum - <code>Gateway</code> executa a a\u00e7\u00e3o (desbloqueio de ativos ou chamada de contrato)</li> </ol> <pre><code>sequenceDiagram\n    %%{init: {'sequence': {'mirrorActors': false}}}%%\n    participant Relayer\n    participant EGateway as Ethereum Gateway Contract\n    participant EBeefy as Ethereum Beefy Client Contract\n    participant EBridge as Ethereum Bridge Contract\n    participant User\n\n    Relayer-&gt;&gt;EGateway: 3. Enviar compromisso BEEFY + prova de Merkle\n    activate EGateway\n    EGateway-&gt;&gt;EBeefy: 4. Verificar compromisso BEEFY\n    activate EBeefy\n    EBeefy--&gt;&gt;EGateway: Verifica\u00e7\u00e3o OK\n    deactivate EBeefy\n\n    EGateway-&gt;&gt;EGateway: 5. Verificar prova de Merkle\n    Note over EGateway: Prova validada\n\n    EGateway-&gt;&gt;EBridge: 6. Executar: desbloquear tokens / chamar contrato\n    activate EBridge\n    Note over EBridge: Ativos transferidos ou chamada executada\n    EBridge--&gt;&gt;User: Tokens recebidos / chamada conclu\u00edda\n    deactivate EBridge\n    deactivate EGateway</code></pre>"},{"location":"pt/learn/tanssi/external-security-providers/","title":"Provedores de Seguran\u00e7a Externos","text":"<p>A Tanssi integra provedores de seguran\u00e7a externos para fortalecer a flexibilidade e resili\u00eancia de seu ecossistema. Ao adotar modelos de seguran\u00e7a descentralizados, esses provedores oferecem solu\u00e7\u00f5es personalizadas que atendem \u00e0s diversas necessidades operacionais, garantindo maiores n\u00edveis de seguran\u00e7a e confian\u00e7a em todas as redes.</p> <p>Essa abordagem aborda desafios comuns que os desenvolvedores enfrentam, como garantir recursos econ\u00f4micos significativos ou negociar com operadores para manter os n\u00f3s. Por meio da estrutura de seguran\u00e7a colaborativa do Tanssi, os desenvolvedores podem contornar esses obst\u00e1culos e se concentrar na inova\u00e7\u00e3o, aproveitando uma infraestrutura segura e escal\u00e1vel para otimizar a implanta\u00e7\u00e3o de redes.</p>"},{"location":"pt/learn/tanssi/external-security-providers/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/","title":"Ethereum com Symbiotic","text":""},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O protocolo Tanssi cuida de componentes cr\u00edticos de infraestrutura, facilitando o lan\u00e7amento de redes em poucos minutos. Al\u00e9m de produ\u00e7\u00e3o de blocos, disponibilidade de dados e integra\u00e7\u00f5es com ferramentas essenciais (carteiras, endpoints RPC, exploradores de blocos etc.), uma tarefa chave \u00e9 prover seguran\u00e7a \u00e0 rede.</p> <p>A Tanssi foi projetada para oferecer um modelo de seguran\u00e7a compartilhada, evitando que desenvolvedores precisem buscar seguran\u00e7a econ\u00f4mica ou negociar com operadores para rodar n\u00f3s. Ao implantar redes via Tanssi e escolher a Symbiotic como provedor, os desenvolvedores se beneficiam de seguran\u00e7a de n\u00edvel Ethereum, alavancando o stake de ETH.</p> <p>As se\u00e7\u00f5es a seguir explicam como o protocolo Symbiotic funciona e como as redes Tanssi podem utiliz\u00e1-lo como mecanismo de consenso.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#symbiotic","title":"Seguran\u00e7a de N\u00edvel Ethereum com Symbiotic","text":"<p>Symbiotic \u00e9 um protocolo de seguran\u00e7a compartilhada permissionless, multi-ativo e agn\u00f3stico de rede. Ele promove efici\u00eancia de capital ao permitir que ativos em stake protejam outras redes.</p> <p>O protocolo fornece uma camada de coordena\u00e7\u00e3o para alinhar incentivos entre as partes, minimizando riscos da camada de execu\u00e7\u00e3o com contratos principais n\u00e3o atualiz\u00e1veis no Ethereum. O diagrama abaixo resume componentes e atores:</p> <pre><code>flowchart TD\n    %% Vaults subgraph\n    subgraph Ethereum[\"Ethereum/Symbiotic\"]\n        slash[/Eventos de Corte/]\n        Restakers -- Depositar Ativos --&gt; Vaults\n        manager[\"Gerenciadores de Vault\"] -- Gerenciar --&gt; Vaults\n        Resolvers -- Decidir Sobre --&gt; slash\n        slash -- Executa Em --&gt; Vaults\n    end\n\n    %% Operadores subgraph\n    subgraph Operators\n        direction BT\n        operators[\"Operadores (Validadores)\"]\n        node_operators[\"Operadores de N\u00f3s\"]\n        node_operators -- Executar --&gt; operators\n    end\n\n    %% Networks subgraph\n    subgraph Networks\n        direction BT\n        developers[\"Desenvolvedores\"]\n        networks[\"Redes Descentralizadas\"]\n        developers -- Lan\u00e7ar --&gt; networks\n    end\n\n    Vaults &lt;--&gt; Tanssi\n    Tanssi &lt;--&gt; Operators\n    Tanssi &lt;--&gt; Networks</code></pre> <p>O design flex\u00edvel da Symbiotic permite que cada parte ajuste sua configura\u00e7\u00e3o: vaults escolhem colaterais e estrat\u00e9gias, operadores decidem quais redes atender, e redes definem exig\u00eancias de seguran\u00e7a.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#vaults","title":"Vaults","text":"<p>Vaults s\u00e3o a espinha dorsal econ\u00f4mica: gerenciam liquidez e dep\u00f3sitos, conectam operadores e redes, e configuram delega\u00e7\u00e3o.</p> <p>Cada vault \u00e9 atrelado a um token ERC-20 aceito como garantia. Os fundos s\u00e3o representados como a\u00e7\u00f5es para rastrear propriedade e distribuir recompensas; o token de recompensa pode ser diferente do colateral.</p> <p>Tr\u00eas m\u00f3dulos comp\u00f5em um vault:</p> <ul> <li>Slasher \u2013 implementa a l\u00f3gica de corte.</li> <li>Delegator \u2013 define como os fundos s\u00e3o delegados entre operadores e redes; diferentes estrat\u00e9gias podem ser usadas.</li> <li>Accounting \u2013 lida com dep\u00f3sitos, saques, saldos e eventos de corte; a implementa\u00e7\u00e3o padr\u00e3o \u00e9 ERC-4626.</li> </ul> <p>Como o stake dos vaults pode ser cortado, operadores e redes precisam ser aprovados pelos gerentes de vault. Gerentes tamb\u00e9m indicam resolvers, que podem aprovar ou vetar eventos de corte em vaults com veto-slashing, como a rede Tanssi.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#operators","title":"Operadores","text":"<p>Operadores de n\u00f3s executam os n\u00f3s (operadores/validadores) que validam transa\u00e7\u00f5es. Eles optam por oferecer servi\u00e7o a redes (que devem aceit\u00e1-los) e a vaults (que tamb\u00e9m precisam aceit\u00e1-los). Uma vez aceitos por um vault e por uma rede, podem prestar valida\u00e7\u00e3o e receber recompensas.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#networks","title":"Redes","text":"<p>Redes s\u00e3o blockchains espec\u00edficas de aplicativo (games, DeFi, RWA etc.) com as quais usu\u00e1rios interagem via dApps. Como operadores optam por atend\u00ea-las e vaults precisam aprov\u00e1-las, cabe aos desenvolvedores definir como integrar, recompensar e cortar operadores.</p> <p>Nota</p> <p>Redes implantadas via Tanssi n\u00e3o precisam lidar diretamente com vaults e operadores, pois o protocolo Tanssi cuida dessas complexidades.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#tanssi-symbiotic","title":"Tanssi com Symbiotic","text":"<p>Redes lan\u00e7adas pela Tanssi contam com servi\u00e7os de produ\u00e7\u00e3o de blocos, disponibilidade de dados como servi\u00e7o e um modelo de seguran\u00e7a compartilhada herdado dos vaults que optam por suportar o protocolo Tanssi.</p> <p>Gerentes de vault podem oferecer colateral restakeado como seguran\u00e7a para a rede Tanssi; como a Tanssi gerencia as responsabilidades de rede, eles s\u00f3 precisam avaliar e optar pelo protocolo. Operadores que participam de um vault compat\u00edvel com Tanssi podem usar a mesma configura\u00e7\u00e3o para produzir blocos e validar tanto a rede Tanssi quanto todas as redes implantadas via Tanssi.</p> <p>Nota</p> <p>O protocolo Tanssi abstrai os detalhes do conjunto ativo de redes: particularidades das redes n\u00e3o exigem configura\u00e7\u00e3o extra dos operadores nem criam risco para os ativos dos vaults.</p> <pre><code>flowchart LR\n    subgraph Symbiotic\n        direction LR\n        Operators\n        Vaults\n    end\n    Symbiotic  -- Valida/Protege --&gt; tanssi[\"Rede Tanssi\"]\n    tanssi -- Servi\u00e7os de Produ\u00e7\u00e3o de Blocos--&gt; Redes\n    tanssi -- Seguran\u00e7a--&gt; Redes\n    tanssi -- Disponibilidade de Dados--&gt; Redes\n\n    class Symbiotic custom-container</code></pre>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#tanssi-ethereum-communication","title":"Comunica\u00e7\u00e3o Tanssi\u2013Ethereum","text":"<p>Tanssi e Ethereum trocam dados por uma ponte bidirecional. Tr\u00eas componentes-chave:</p> <ul> <li><code>Relayer</code> \u2013 monitora ambas as redes e transmite mensagens, garantindo entrega confi\u00e1vel.</li> <li><code>Gateway</code> \u2013 no lado Ethereum: recebe, verifica e roteia mensagens da Tanssi; aceita mensagens para a Tanssi; lida com funcionalidades de n\u00edvel mais alto, como transfer\u00eancias de tokens.</li> <li><code>Middleware</code> \u2013 implementa\u00e7\u00e3o da Tanssi para eventos e opera\u00e7\u00f5es de rede; liga o <code>Gateway</code> ao protocolo central, classifica operadores por stake, envia lista para Tanssi, registra operadores, distribui recompensas e processa cortes.</li> </ul>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#from-ethereum-tanssi","title":"Do Ethereum para Tanssi","text":"<p>O <code>Middleware</code> envia ao Tanssi o conjunto de operadores por \u00e9poca, ordenado por stake agregado nos vaults. A Tanssi usa isso para atribuir operadores \u00e0s pr\u00f3ximas sess\u00f5es, criando sele\u00e7\u00e3o ponderada por stake.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#from-tanssi-ethereum","title":"De Tanssi para Ethereum","text":"<p>A Tanssi envia de volta dados operacionais (recompensas, eventos de corte, cria\u00e7\u00e3o/registro de tokens) pelo mesmo canal, permitindo distribui\u00e7\u00e3o e penalidades no Ethereum.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#rewards","title":"Recompensas","text":"<p>Operadores e restakers recebem TANSSI. O fluxo envolve c\u00e1lculo na Tanssi, envio via Snowbridge, processamento por <code>Gateway</code>/<code>Middleware</code> e armazenamento em <code>OperatorRewards</code>, seguido de reivindica\u00e7\u00e3o por operadores e stakers (via <code>StakerRewards</code>). O compartilhamento atual \u00e9 20% operadores / 80% stakers.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#slashing","title":"Slashing","text":"<p>O protocolo aplica corte para punir mau comportamento. Tanssi envia solicita\u00e7\u00f5es de corte via ponte; o <code>Middleware</code> valida o operador, consulta stake ativo em cada vault e aplica corte conforme a implementa\u00e7\u00e3o do vault:</p> <ul> <li>Corte instant\u00e2neo \u2013 reduz o stake imediatamente.</li> <li>Veto slashing \u2013 requer aprova\u00e7\u00e3o de um resolver dentro de uma janela de veto; se n\u00e3o houver veto, o corte \u00e9 aplicado.</li> </ul> <p>Nota</p> <p>Eventos de corte s\u00f3 podem ser disparados por mau comportamento de operadores na rede Tanssi; redes atendidas s\u00e3o isoladas em sandbox.</p>"},{"location":"pt/learn/tanssi/external-security-providers/symbiotic/#burner","title":"Burner","text":"<p>O contrato <code>Burner</code> executa a\u00e7\u00f5es ap\u00f3s o corte (por exemplo, queimar o colateral cortado). Pode implementar queima direta, unwrapping antes de queimar, opera\u00e7\u00f5es cross-chain ou redistribui\u00e7\u00e3o, dependendo do design do vault.</p>"},{"location":"pt/learn/tanssi/network-features/","title":"Recursos da Rede","text":"<p>Os recursos da rede em Tanssi s\u00e3o projetados para fornecer os mecanismos fundamentais que apoiam a descentraliza\u00e7\u00e3o, a seguran\u00e7a e a escalabilidade. De proteger redes por meio de staking a capacidades futuras, esta se\u00e7\u00e3o descreve os elementos principais que capacitam a infraestrutura de rede da Tanssi.</p>"},{"location":"pt/learn/tanssi/network-features/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/tanssi/network-features/staking/","title":"Staking da Tanssi para Produ\u00e7\u00e3o de Blocos","text":""},{"location":"pt/learn/tanssi/network-features/staking/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Uma das propostas centrais da Tanssi \u00e9 simplificar a complexidade de infraestrutura das redes. Um componente crucial \u00e9 iniciar um conjunto descentralizado de sequenciadores, que a Tanssi oferece por sua arquitetura e mec\u00e2nica de staking.</p> <p>O staking da Tanssi garante que os sequenciadores das redes com tecnologia Tanssi sejam escolhidos de forma descentralizada e trustless, al\u00e9m de incentivar a comunidade a delegar para sequenciadores de melhor desempenho.</p> <p>Este conte\u00fado apresenta os conceitos fundamentais do staking da Tanssi e como ele mant\u00e9m um conjunto descentralizado de produ\u00e7\u00e3o de blocos que garante a disponibilidade das redes.</p>  Aprenda como Fazer Estacas -&gt;"},{"location":"pt/learn/tanssi/network-features/staking/#core-concepts","title":"Conceitos B\u00e1sicos","text":"<p>A mec\u00e2nica de staking da Tanssi se inspira no conceito de tokens de pool de liquidez (LP tokens) em AMMs como o Uniswap V2.</p> <p>Cada sequenciador tem quatro pools de liquidez pelos quais os delegadores passam ao realizar opera\u00e7\u00f5es de staking: entrando, recebendo recompensas manuais, recompensas com auto-compound e saindo. Diferentemente dos LP tokens tradicionais, os tokens de participa\u00e7\u00e3o nesses pools n\u00e3o s\u00e3o transfer\u00edveis.</p> <p>H\u00e1 quatro opera\u00e7\u00f5es simples para que o delegador alterne entre estados (pools): delegar (para recompensas manuais ou auto-compound), undelegar, trocar entre pools e executar opera\u00e7\u00f5es pendentes. Exemplo: ao delegar para um dos pools de recompensas, o usu\u00e1rio entra no Joining Pool; ap\u00f3s um atraso, qualquer pessoa pode executar a opera\u00e7\u00e3o pendente e mover os fundos para o pool escolhido. Depois disso, \u00e9 poss\u00edvel trocar entre pools de recompensas. Para sair, o usu\u00e1rio usa undelegate e, ap\u00f3s o atraso, executa a opera\u00e7\u00e3o pendente para resgatar tokens.</p> <p>Pools mant\u00eam um conjunto de shares (an\u00e1logas a LP tokens). As shares recebidas dependem do tipo de pool, quantidade delegada, total de shares e total delegado no pool.</p> <p>Recompensas s\u00e3o atribu\u00eddas aos pools de recompensas (Manual ou Auto-Compound) quando a Tanssi atesta que o slot de produ\u00e7\u00e3o de blocos do sequenciador foi cumprido com sucesso.</p> <p>Todas as recompensas ficam em uma conta do protocolo, mas o protocolo rastreia internamente o saldo de cada pool. A diferen\u00e7a entre os pools de recompensas \u00e9 como as recompensas s\u00e3o distribu\u00eddas: no Manual Rewards Pool o usu\u00e1rio precisa reivindicar; no Auto-Compound Rewards Pool as recompensas s\u00e3o reinvestidas automaticamente a cada bloco Tanssi.</p> <p>As chamadas de delegar e undelegar precisam ser enviadas pelo pr\u00f3prio delegador (sinalizam a inten\u00e7\u00e3o). Ap\u00f3s o atraso configurado em sess\u00f5es, qualquer pessoa pode executar a opera\u00e7\u00e3o pendente para efetivar a entrada/sa\u00edda do pool.</p> <p>O diagrama a seguir resume o fluxo de delegar e undelegar para um sequenciador; a\u00e7\u00f5es do usu\u00e1rio em ciano e pools em coral.</p> <p></p>"},{"location":"pt/learn/tanssi/network-features/staking/#pallet-overview","title":"Vis\u00e3o Geral do M\u00f3dulo","text":"<p>O m\u00f3dulo de staking da Tanssi mant\u00e9m um invent\u00e1rio de sequenciadores, delegadores e permiss\u00f5es, al\u00e9m das pools de recompensas. As principais estruturas (em ingl\u00eas para corresponder ao c\u00f3digo) s\u00e3o:</p> <ul> <li><code>SequencerBalance</code>: registra stake do sequenciador, delegadores permitidos e pools do sequenciador.</li> <li><code>RewardPools</code>: mant\u00e9m recompensas dispon\u00edveis para o sequenciador, e rewards acumulados (pending) em cada pool.</li> <li><code>PoolData</code>: metadados de cada pool (shares, delegado total, contas do pool, epoch de entrada).</li> <li><code>JoiningPools</code>: opera\u00e7\u00f5es pendentes de entrada em um sequenciador; usu\u00e1rios movem fundos aqui antes de irem ao pool de destino.</li> <li><code>LeavingPool</code>: opera\u00e7\u00f5es pendentes de sa\u00edda; delegadores movem fundos para sair de todos os pools.</li> </ul> <p></p>"},{"location":"pt/learn/tanssi/network-features/staking/#delegator-in-and-out","title":"Fluxo de Entradas e Sa\u00eddas","text":"<p>O fluxo de delega\u00e7\u00e3o/sa\u00edda acontece em duas etapas:</p> <ul> <li>Sinalizar: o usu\u00e1rio envia delegate ou undelegate e os fundos entram no Joining Pool ou Leaving Pool. Nessa etapa o protocolo valida permiss\u00f5es (limites de delegadores por sequenciador, autodelega\u00e7\u00e3o etc.).</li> <li>Executar: ap\u00f3s o atraso configurado, qualquer pessoa pode chamar execute_pending_operation para mover os fundos para o pool de destino (manual ou auto-compound) ou completar a sa\u00edda para o delegador.</li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#reward-pools","title":"Pools de Recompensa","text":"<p>H\u00e1 tr\u00eas pools de recompensa por sequenciador:</p> <ul> <li>Joining Pool: est\u00e1gio intermedi\u00e1rio antes de alocar em Manual ou Auto-Compound.</li> <li>Manual Rewards Pool: recompensas precisam ser reivindicadas manualmente.</li> <li>Auto-Compound Rewards Pool: recompensas s\u00e3o automaticamente reinvestidas a cada bloco Tanssi.</li> </ul> <p></p>"},{"location":"pt/learn/tanssi/network-features/staking/#reward-distribution","title":"Distribui\u00e7\u00e3o de Recompensas","text":"<p>Ao final de cada sess\u00e3o, a Tanssi calcula recompensas do sequenciador e distribui para os pools Manual e Auto-Compound do sequenciador:</p> <ul> <li>Valor do pool manual:   <pre><code>reward\\_manual = (total\\_reward * weight\\_manual) / (weight\\_manual + weight\\_auto)\n</code></pre></li> <li>Valor do pool auto-compound:   <pre><code>reward\\_auto = total\\_reward - reward\\_manual\n</code></pre></li> <li>Rewards s\u00e3o somados a <code>available_rewards</code> de cada pool; depois, no block hook, <code>available_rewards</code> \u00e9 movido para <code>pending_rewards</code> e, em seguida, distribu\u00eddo proporcionalmente \u00e0s shares dos delegadores.</li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#shares-evolution","title":"Como as shares evoluem","text":"<ul> <li>Quando um delegador entra em um pool:   <pre><code>shares = (stake\\_amount * total\\_shares) / total\\_stake\\_in\\_pool\n</code></pre></li> <li>Quando rewards s\u00e3o adicionadas, o total de stake no pool aumenta, mas o total de shares n\u00e3o muda; isso faz o valor por share subir.</li> <li>Na sa\u00edda, o usu\u00e1rio recebe:   <pre><code>payout = (user\\_shares * total\\_stake\\_in\\_pool) / total\\_shares\n</code></pre></li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#auto-vs-manual","title":"Auto-Compound x Manual","text":"<ul> <li>Manual: usu\u00e1rio reivindica quando quiser; valor por share cresce apenas quando <code>pending_rewards</code> \u00e9 distribu\u00eddo.</li> <li>Auto-Compound: a cada bloco, <code>pending_rewards</code> \u00e9 reinvestido automaticamente no pool, aumentando o valor por share continuamente.</li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#user-actions","title":"Opera\u00e7\u00f5es de Usu\u00e1rio","text":"<ul> <li>delegate(sequencer_id, amount, autocompound?)</li> <li>Envia fundos para o Joining Pool do sequenciador (destino manual ou auto).</li> <li>Ap\u00f3s <code>join_delay</code>, executar opera\u00e7\u00e3o pendente move fundos para o pool de destino.</li> <li>execute_pending_operation(target_account?)</li> <li>Qualquer pessoa pode chamar; move opera\u00e7\u00f5es do Joining/Leaving Pool ap\u00f3s os atrasos.</li> <li>swap_pool(sequencer_id)</li> <li>Troca entre Manual e Auto-Compound; adiciona entrada no Joining Pool e sa\u00edda do pool atual; ap\u00f3s atraso, execu\u00e7\u00e3o pendente efetiva a troca.</li> <li>undelegate(sequencer_id)</li> <li>Move shares para o Leaving Pool; ap\u00f3s <code>leaving_delay</code>, execu\u00e7\u00e3o pendente devolve tokens ao delegador.</li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#parameters","title":"Par\u00e2metros Importantes","text":"<ul> <li>join_delay: n\u00famero de sess\u00f5es antes de entrar no pool de destino.</li> <li>leave_delay: n\u00famero de sess\u00f5es antes de concluir a sa\u00edda.</li> <li>max_delegators: limite de delegadores por sequenciador.</li> <li>weights de recompensa: definem quanto vai para Manual vs Auto-Compound.</li> </ul>"},{"location":"pt/learn/tanssi/network-features/staking/#summary","title":"Resumo","text":"<ul> <li>Delegadores interagem com pools por opera\u00e7\u00f5es em duas etapas (sinalizar, executar).</li> <li>Recompensas s\u00e3o alocadas entre pools Manual e Auto-Compound a cada sess\u00e3o; Auto-Compound reinveste automaticamente.</li> <li>Shares n\u00e3o s\u00e3o transfer\u00edveis e definem a fra\u00e7\u00e3o de cada pool; valor por share aumenta com recompensas.</li> </ul>"},{"location":"pt/learn/tanssi/network-services/","title":"Servi\u00e7os de Rede","text":"<p>Os servi\u00e7os de rede da Tanssi fornecem a infraestrutura essencial para opera\u00e7\u00f5es de blockchain seguras e eficientes. No cerne desses servi\u00e7os, o protocolo Tanssi oferece produ\u00e7\u00e3o de blocos como servi\u00e7o, garantindo o desempenho cont\u00ednuo e a escalabilidade de redes descentralizadas.</p>"},{"location":"pt/learn/tanssi/network-services/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/learn/tanssi/network-services/block-production/","title":"Servi\u00e7os de Produ\u00e7\u00e3o de Blocos","text":""},{"location":"pt/learn/tanssi/network-services/block-production/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Como apresentado no artigo Vis\u00e3o Geral, Tanssi \u00e9 um protocolo de infraestrutura que agiliza a implanta\u00e7\u00e3o de redes descentralizadas com l\u00f3gica personalizada que se adequa a uma ampla gama de casos de uso, incluindo DeFi, NFTs, Jogos e qualquer outro caso de uso que as equipes de desenvolvimento possam querer abordar.</p> <p>A infraestrutura representa um enorme desafio para os desenvolvedores, exigindo que eles inicializem sequenciadores, preservadores de dados e endpoints RPC, al\u00e9m de gerenciar integra\u00e7\u00f5es, interoperabilidade e seguran\u00e7a. Isso exige tempo e recursos valiosos, desviando o foco do que realmente importa: entregar valor aos seus usu\u00e1rios.</p> <p>Tanssi orquestra recursos, permitindo que os desenvolvedores implantem redes descentralizadas (tamb\u00e9m conhecidas como servi\u00e7os validados ativamente ou AVSs) que s\u00e3o totalmente adapt\u00e1veis a qualquer aplicativo ou caso de uso espec\u00edfico. Nesta analogia, a rede Tanssi se assemelha ao Kubernetes em seu papel como orquestrador, gerenciando recursos para garantir a atividade e o desempenho das redes.</p> <p>O protocolo tamb\u00e9m aborda a frente de seguran\u00e7a, permitindo que as redes selecionem e se conectem a provedores de seguran\u00e7a externos (como Symbiotic), garantindo seguran\u00e7a de n\u00edvel Ethereum desde o in\u00edcio.</p> <p>Este artigo aborda os aspectos necess\u00e1rios a serem considerados ao construir e implantar seu pr\u00f3prio blockchain modular, juntamente com os aspectos t\u00e9cnicos mais relevantes do protocolo Tanssi.</p>"},{"location":"pt/learn/tanssi/network-services/block-production/#block-production-as-a-service","title":"Produ\u00e7\u00e3o de Blocos como Servi\u00e7o","text":"<p>O protocolo Tanssi fornece produ\u00e7\u00e3o de blocos como servi\u00e7o, orquestrando um conjunto descentralizado e confi\u00e1vel de sequenciadores, garantindo a atividade das redes. Para fazer isso, o protocolo conecta ambas as extremidades:</p> <ul> <li>Operadores de n\u00f3s: Que executam sequenciadores, oferecendo seus servi\u00e7os de produ\u00e7\u00e3o de blocos para obter recompensas.</li> <li>Desenvolvedores: Que lan\u00e7am redes, que exigem sequenciadores.</li> </ul> <p>O protocolo atribui um subconjunto de sequenciadores para fornecer servi\u00e7os a cada rede, rotacionando-os ap\u00f3s um per\u00edodo de tempo. Os sequenciadores podem servir qualquer rede baseada em Tanssi, independentemente da l\u00f3gica personalizada que implementam. Por outro lado, as redes implantadas por meio do Tanssi podem personalizar seu tempo de execu\u00e7\u00e3o tanto quanto precisarem para se adequar ao seu caso de uso e atualizar a l\u00f3gica a qualquer momento de forma sem bifurca\u00e7\u00e3o, sem se preocupar com a configura\u00e7\u00e3o do sequenciador.</p> <p>O diagrama a seguir ilustra como o Tanssi atribui dois sequenciadores a cada rede ativa, selecionando-os de um conjunto descentralizado de sequenciadores.</p> <pre><code>flowchart TB\n    subgraph network1 [Rede 1]\n        s1bis[Sequenciador 1]\n        s2bis[Sequenciador 2]\n    end\n\n    subgraph network2 [Rede 2]\n        s3bis[Sequenciador 3]\n        s4bis[Sequenciador 4]\n    end\n\n    Tanssi[Rede Tanssi&lt;br/&gt;Orquestrador]\n\n    subgraph sequencers [Pool de Sequenciadores]\n        direction LR\n        s1[Sequenciador 1]\n        s2[Sequenciador 2]\n        s3[Sequenciador 3]\n        s4[Sequenciador 4]\n        sn[Sequenciador N]\n\n        s1 --- s2 --- s3 --- s4 --- sn\n    end\n\n    sequencers -- Gerenciado por --&gt; Tanssi\n    Tanssi -- Atribui Sequenciadores --&gt; network1\n    Tanssi -- Atribui Sequenciadores --&gt; network2</code></pre>"},{"location":"pt/learn/tanssi/network-services/block-production/#sequencer-selection-process","title":"Processo de Sele\u00e7\u00e3o do Sequenciador","text":"<p>A qualquer momento, todas as redes Tanssi exigem um certo n\u00famero de sequenciadores, dependendo do n\u00famero de redes ativas e da configura\u00e7\u00e3o atual de produ\u00e7\u00e3o de blocos definida no Tanssi. A configura\u00e7\u00e3o define o n\u00famero m\u00e1ximo de sequenciadores totais no conjunto e o n\u00famero de sequenciadores que cada rede deve ter atribu\u00eddo.</p> Tanssi MainNet Vari\u00e1vel Valor M\u00e1x. n\u00ba de Sequenciadores 100 n\u00ba de Sequenciadores (Redes) 5 Dancelight TestNet Vari\u00e1vel Valor M\u00e1x. n\u00ba de Sequenciadores 100 n\u00ba de Sequenciadores (Redes) 2 <p>Assim que o n\u00famero necess\u00e1rio de sequenciadores para uma determinada sess\u00e3o for conhecido, o Tanssi usa dois mecanismos para decidir o conjunto de sequenciadores distribu\u00eddos entre todas as redes.</p> <p>O primeiro mecanismo \u00e9 atrav\u00e9s do m\u00f3dulo Invulner\u00e1veis, que define uma lista de sequenciadores fixos priorizados pelo protocolo e garante a estabilidade da produ\u00e7\u00e3o de blocos em certos cen\u00e1rios, como TestNets.</p> <p>O segundo mecanismo \u00e9 atrav\u00e9s do m\u00f3dulo de staking do Tanssi. O m\u00f3dulo ajuda a criar um conjunto descentralizado de sequenciadores para todas as redes Tanssi, fornecendo ao protocolo uma lista de sequenciadores classificados por valor apostado. O Tanssi anexa a lista classificada por aposta de sequenciadores aos invulner\u00e1veis (se houver), em seguida, pega da lista apenas a quantidade exata de sequenciadores necess\u00e1ria, come\u00e7ando do topo, deixando de fora da pr\u00f3xima sess\u00e3o aqueles sequenciadores que t\u00eam menos valor apostado, para finalmente iniciar o processo de atribui\u00e7\u00e3o do sequenciador.</p>"},{"location":"pt/learn/tanssi/network-services/block-production/#block_producers-assignment","title":"Atribui\u00e7\u00e3o de Sequenciadores","text":"<p>Assim que o conjunto de sequenciadores que participar\u00e1 da pr\u00f3xima sess\u00e3o for conhecido, o Tanssi embaralha a lista e os atribui para fornecer servi\u00e7os de produ\u00e7\u00e3o de blocos \u00e0s redes Tanssi ativas.</p> <p>O algoritmo de atribui\u00e7\u00e3o come\u00e7ar\u00e1 a distribuir os sequenciadores que atendem \u00e0s redes pela data de registro em ordem de chegada. Depois que a atribui\u00e7\u00e3o for feita, ela ser\u00e1 mantida por pelo menos uma sess\u00e3o, representando um per\u00edodo medido em blocos com um conjunto constante de sequenciadores. No Tanssi MainNet, a dura\u00e7\u00e3o da sess\u00e3o padr\u00e3o \u00e9 definida como 3600 blocos, o que, com um tempo m\u00e9dio de bloco de seis segundos, se traduz em (aproximadamente) six horas.</p> <p>Cada nova atribui\u00e7\u00e3o funciona intencionalmente com um atraso de uma sess\u00e3o, para que os sequenciadores saibam com anteced\u00eancia a qual das redes eles est\u00e3o atribu\u00eddos. Os sequenciadores come\u00e7ar\u00e3o a sincronizar a nova rede que ter\u00e3o que servir na pr\u00f3xima sess\u00e3o com um mecanismo de sincroniza\u00e7\u00e3o especial chamado warp sync. O warp sync permite que os sequenciadores sincronizem rapidamente a nova rede sem atuar como um n\u00f3 de arquivo.</p> <p>Quando uma nova sess\u00e3o come\u00e7a, o protocolo Tanssi colocar\u00e1 a atribui\u00e7\u00e3o na fila em vigor. Os sequenciadores mudar\u00e3o automaticamente e come\u00e7ar\u00e3o a produzir blocos na nova rede Tanssi a que foram atribu\u00eddos, descartando o estado da cadeia da atribui\u00e7\u00e3o anterior. O Tanssi tamb\u00e9m calcular\u00e1 a nova atribui\u00e7\u00e3o, considerando as altera\u00e7\u00f5es nas redes Tanssi que podem ter sido ativadas ou desativadas e os sequenciadores que podem ter sido adicionados ou removidos do pool ou alterado o valor total apostado. Esta nova atribui\u00e7\u00e3o ser\u00e1 enfileirada para a pr\u00f3xima sess\u00e3o.</p> <p></p>"},{"location":"pt/learn/tanssi/network-services/block-production/#tanssi-newtwork","title":"O Papel da Rede Tanssi","text":"<p>Como discutido anteriormente, o protocolo Tanssi atribui sequenciadores \u00e0s redes Tanssi, e o resultado desta atribui\u00e7\u00e3o \u00e9 armazenado no estado da cadeia. Al\u00e9m de executar o n\u00f3 da rede, os sequenciadores tamb\u00e9m executam o Tanssi. Portanto, ao acessar os dados armazenados nos blocos finalizados da Rede Tanssi, eles podem aprender sua atribui\u00e7\u00e3o para a sess\u00e3o, e as redes Tanssi podem confirmar que um determinado grupo de sequenciadores foi atribu\u00eddo a elas.</p> <p>\u00c0 medida que as redes Tanssi produzem blocos, esses blocos precisam ser validados e finalizados por um provedor de seguran\u00e7a externo. Depois que um operador verifica um bloco, uma pequena prova de validade \u00e9 produzida e armazenada no Tanssi, mantendo o controle das provas para cada bloco de cada cadeia. Esta pequena representa\u00e7\u00e3o da prova de validade \u00e9 chamada de recibo de candidato e \u00e9 composta por um conjunto de valores, incluindo a raiz do estado, que pode ser usada para verificar provas de estado.</p> <p>Finalmente, o Tanssi pode verificar se o autor de um bloco de rede foi o esperado e recompens\u00e1-lo de acordo.</p> <p>O diagrama a seguir mostra um modelo simplificado dos dados que o Tanssi armazena em seu estado interno. Para cada rede ativa (neste exemplo, duas), o Tanssi armazena os sequenciadores atribu\u00eddos, que s\u00e3o os \u00fanicos autorizados a produzir blocos em nome da rede, prova de validade (recibos de candidatos) estendidos pelos operadores do provedor de seguran\u00e7a, a raiz do estado mais recente e o sequenciador mais recente.</p> <p></p>"},{"location":"pt/learn/tanssi/network-services/block-production/#network","title":"O Papel da Rede com Tecnologia Tanssi","text":"<p>Como um sequenciador atribu\u00eddo a uma rede com tecnologia Tanssi inclui funcionalidade de n\u00f3 Tanssi integrada, \u00e9 tecnicamente vi\u00e1vel ler o estado da Rede Tanssi.</p> <p>Aproveitando essa capacidade de acessar os estados, o sequenciador atual com a autoridade para produzir um bloco ler\u00e1 o estado do \u00faltimo bloco produzido na cadeia Tanssi. Ele prosseguir\u00e1 para incluir este estado no bloco da rede, o conjunto atual de sequenciadores atribu\u00eddos \u00e0 rede e sua assinatura p\u00fablica, permitindo que o Tanssi saiba quem produziu o bloco e recompense o operador do n\u00f3.</p> <p>Depois que o bloco for preenchido com as transa\u00e7\u00f5es da rede, ele ser\u00e1 proposto como candidato e entregue \u00e0 cadeia Tanssi, onde os operadores do provedor de seguran\u00e7a garantir\u00e3o que as provas de estado inclu\u00eddas correspondam \u00e0s provas de estado do \u00faltimo estado do Tanssi (impedindo a produ\u00e7\u00e3o n\u00e3o autorizada de blocos) e que as transa\u00e7\u00f5es produziram transi\u00e7\u00f5es de estado v\u00e1lidas. Tendo verificado o trabalho do sequenciador, os operadores finalizar\u00e3o o bloco proposto, incluindo seu recibo de candidato em um bloco de rede Tanssi.</p> <p></p>"},{"location":"pt/learn/tanssi/network-services/block-production/#block-production-fees","title":"Taxas de Produ\u00e7\u00e3o de Blocos","text":"<p>Como apresentado na Introdu\u00e7\u00e3o, Tanssi \u00e9 um protocolo de infraestrutura que aborda as complexidades e os altos custos associados \u00e0 configura\u00e7\u00e3o e manuten\u00e7\u00e3o da infraestrutura blockchain, agilizando a implanta\u00e7\u00e3o de redes. Este protocolo traz benef\u00edcios para ambos os participantes:</p> <ul> <li>Redes: As equipes podem se concentrar na l\u00f3gica principal de seu produto, na UX e na UI, sem lidar com os desafios da inicializa\u00e7\u00e3o da infraestrutura e seu gerenciamento.</li> <li>Sequenciadores: Assumindo a responsabilidade de manter sua configura\u00e7\u00e3o de hardware e software em \u00f3timas condi\u00e7\u00f5es, eles s\u00e3o incentivados a executar transa\u00e7\u00f5es e produzir blocos em nome das redes Tanssi.</li> </ul> <p>A produ\u00e7\u00e3o de blocos como servi\u00e7o acarreta custos associados que devem ser cobertos pelas redes que desejam alavancar o Tanssi para tal fim. As se\u00e7\u00f5es a seguir cobrem os aspectos gerais desses custos e pagamentos de servi\u00e7os associados.</p>"},{"location":"pt/learn/tanssi/network-services/block-production/#service-payments","title":"Pagamentos de Servi\u00e7os","text":"<p>Existem tr\u00eas custos principais associados \u00e0 produ\u00e7\u00e3o de blocos como servi\u00e7o que qualquer rede deve cobrir usando tokens Tanssi para implantar com sucesso e obter os servi\u00e7os de produ\u00e7\u00e3o de blocos:</p> <ul> <li>Dep\u00f3sito de registro: O dep\u00f3sito inicial que \u00e9 bloqueado da conta que assina a transa\u00e7\u00e3o de registro da rede.</li> <li>Dep\u00f3sito de armazenamento de registro: O dep\u00f3sito inicial que \u00e9 bloqueado da conta que assina a transa\u00e7\u00e3o de registro da rede. \u00c9 um valor vari\u00e1vel dependendo do tamanho do tempo de execu\u00e7\u00e3o da appchain.</li> <li>Atribui\u00e7\u00e3o de sequenciadores: Toda vez que o protocolo Tanssi atribui sequenciadores, o que acontece uma vez por sess\u00e3o, uma taxa fixa \u00e9 cobrada. Esta taxa d\u00e1 \u00e0s redes o direito de serem atribu\u00eddas sequenciadores e desencoraja redes cuja l\u00f3gica de tempo de execu\u00e7\u00e3o n\u00e3o consegue produzir transa\u00e7\u00f5es ou blocos v\u00e1lidos.</li> <li>Produ\u00e7\u00e3o de blocos: As redes devem pagar por cada bloco produzido em seu nome. Como o protocolo seleciona e atribui os sequenciadores por sess\u00e3o, as redes devem ter fundos suficientes para cobrir todos os blocos a serem produzidos em uma sess\u00e3o inteira para serem atendidos.</li> </ul> <p>A configura\u00e7\u00e3o atual \u00e9 definida da seguinte forma:</p> Tanssi MainNet Vari\u00e1vel Valor Dep\u00f3sito de registro 1000 TANSSI Dep\u00f3sito de armazenamento de registro 6.6666666 x 10<sup>-5</sup> TANSSI por byte de tempo de execu\u00e7\u00e3o da appchain Atribui\u00e7\u00e3o de sequenciadores 50 TANSSI por sess\u00e3o Produ\u00e7\u00e3o de blocos 0.03 TANSSI por bloco Dancelight TestNet Vari\u00e1vel Valor Dep\u00f3sito de registro 40 STAR Dep\u00f3sito de armazenamento de registro 6.6666666 x 10<sup>-5</sup> STAR por byte de tempo de execu\u00e7\u00e3o da appchain Atribui\u00e7\u00e3o de sequenciadores 100 x 10<sup>-6</sup> STAR por sess\u00e3o Produ\u00e7\u00e3o de blocos 1 x 10<sup>-6</sup> STAR por bloco <p>Para garantir a produ\u00e7\u00e3o de blocos na pr\u00f3xima sess\u00e3o, o saldo total deve ser pelo menos suficiente para cobrir o custo de atribui\u00e7\u00e3o de sequenciadores mais o custo de produ\u00e7\u00e3o dos 3600 blocos que comp\u00f5em uma sess\u00e3o inteira.</p> <p>Nota</p> <p>Embora os custos de atribui\u00e7\u00e3o de sequenciadores e produ\u00e7\u00e3o de blocos sejam atualmente fixos, \u00e0 medida que o desenvolvimento do protocolo progride, eles podem se tornar din\u00e2micos, variando em resposta \u00e0 carga de trabalho da rede.</p>"},{"location":"pt/learn/tanssi/network-services/block-production/#tipping","title":"Gorjetas","text":"<p>Em algumas ocasi\u00f5es, o Tanssi pode experimentar uma alta demanda por seus servi\u00e7os de produ\u00e7\u00e3o de blocos que n\u00e3o pode ser atendida com os recursos dispon\u00edveis. Por exemplo, se houver dez redes ativas para a pr\u00f3xima sess\u00e3o e o Tanssi s\u00f3 puder servir oito, duas redes ser\u00e3o paralisadas durante toda a dura\u00e7\u00e3o da sess\u00e3o.</p> <p>Para lidar com esses per\u00edodos de alta carga de trabalho, o protocolo Tanssi implementa um mecanismo de gorjeta que permite que as redes compitam por uma prioridade maior em rela\u00e7\u00e3o ao restante. Semelhante \u00e0s redes compat\u00edveis com Ethereum, onde uma taxa de prioridade pode ser definida para superar as transa\u00e7\u00f5es concorrentes e obter tratamento de execu\u00e7\u00e3o preferencial, as redes Tanssi ser\u00e3o atendidas de acordo com a prioridade dada pelas gorjetas que oferecem. Seguindo o exemplo anterior, se houver dez redes ativas para a pr\u00f3xima sess\u00e3o e o Tanssi s\u00f3 puder servir oito, apenas as oito redes com maior lance receber\u00e3o sequenciadores atribu\u00eddos.</p>"},{"location":"pt/node-operators/","title":"Operadores de N\u00f3s","text":"<p>A opera\u00e7\u00e3o de n\u00f3s \u00e9 uma parte crucial para manter um ecossistema de blockchain, e o Tanssi garante que esse processo seja o mais perfeito poss\u00edvel. Da execu\u00e7\u00e3o de n\u00f3s de rede e gerenciamento de sequenciadores \u00e0 integra\u00e7\u00e3o de operadores, esta se\u00e7\u00e3o fornece tudo o que voc\u00ea precisa para come\u00e7ar e operar com efici\u00eancia.</p> <p>Se voc\u00ea est\u00e1 configurando pela primeira vez, lidando com tarefas operacionais ou aposentando seu n\u00f3, esses guias oferecem instru\u00e7\u00f5es claras e concisas para ajud\u00e1-lo a manter opera\u00e7\u00f5es seguras e confi\u00e1veis.</p>"},{"location":"pt/node-operators/#tipos-de-nos-no-ecossistema-tanssi","title":"Tipos de N\u00f3s no Ecossistema Tanssi","text":"<p>A compreens\u00e3o dos pap\u00e9is de diferentes n\u00f3s na rede alimentada pelo Tanssi ajuda voc\u00ea a escolher o certo com base no seu n\u00edvel desejado de participa\u00e7\u00e3o no ecossistema Tanssi:</p> <ul> <li>N\u00f3s de Rede - fornecem endpoints RPC e servi\u00e7os de disponibilidade de dados para fluxo de dados e intera\u00e7\u00e3o suaves entre cadeias e usu\u00e1rios</li> <li>Sequenciadores - respons\u00e1veis pela produ\u00e7\u00e3o de blocos dentro do ecossistema Tanssi, os sequenciadores coletam transa\u00e7\u00f5es, as executam e as compilam em blocos, mantendo a vivacidade e a continuidade operacional para todas as redes alimentadas pelo Tanssi</li> <li>Operadores - tamb\u00e9m conhecidos como validadores de rede, os operadores s\u00e3o respons\u00e1veis por proteger o ecossistema. Eles verificam cada bloco produzido por sequenciadores dentro das redes alimentadas pelo Tanssi, verificando se as transa\u00e7\u00f5es inclu\u00eddas s\u00e3o v\u00e1lidas. Os operadores devem se registrar e apostar no provedor de seguran\u00e7a (por exemplo, Symbiotic). Eles tamb\u00e9m produzem blocos para a pr\u00f3pria rede Tanssi, mantendo sua vivacidade</li> </ul>"},{"location":"pt/node-operators/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/network-node/","title":"Executar um N\u00f3","text":"<p>A configura\u00e7\u00e3o de um n\u00f3 de rede \u00e9 essencial para interagir com a Tanssi ou sua rede alimentada por Tanssi, fornecendo um endpoint RPC seguro e dedicado. Esta se\u00e7\u00e3o oferece guias passo a passo para ajud\u00e1-lo a configurar e gerenciar diferentes tipos de n\u00f3s de forma eficaz.</p> <ul> <li>N\u00f3 Tanssi - um n\u00f3 Tanssi se conecta diretamente \u00e0 rede Tanssi, permitindo que voc\u00ea interaja via endpoint RPC</li> <li>N\u00f3 de Rede alimentado por Tanssi - execute um n\u00f3 para sua rede alimentada por Tanssi, permitindo que voc\u00ea mantenha seu pr\u00f3prio endpoint RPC</li> </ul>"},{"location":"pt/node-operators/network-node/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/network-node/tanssi/","title":"Executar um N\u00f3 Tanssi","text":"<p>A configura\u00e7\u00e3o de um N\u00f3 Tanssi \u00e9 um passo importante para interagir e consultar a rede Tanssi. Voc\u00ea tem duas op\u00e7\u00f5es de configura\u00e7\u00e3o: usar Docker ou Systemd. Seja qual for o caminho escolhido, oferecemos tutoriais passo a passo para orient\u00e1-lo durante o processo.</p>"},{"location":"pt/node-operators/network-node/tanssi/#requisitos-de-hardware","title":"Requisitos de Hardware","text":"<p>O hardware adequado \u00e9 essencial para executar um n\u00f3 Tanssi com sucesso. Uma configura\u00e7\u00e3o de alto desempenho garante um servi\u00e7o confi\u00e1vel e resposta r\u00e1pida \u00e0s consultas.</p> <p>Hardware recomendado:</p> <ul> <li>Configura\u00e7\u00e3o Recomendada - hardware bare metal executando Linux Debian ou Ubuntu</li> <li>CPUs Recomendados - Intel Ice Lake ou mais recente (Xeon ou s\u00e9rie Core), AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito n\u00facleos f\u00edsicos @ 3,4 GHz com hyperthreading desabilitado (SMT para processadores AMD)</li> <li>NVMe Recomendado - SSD NVMe de 500 GB</li> <li>RAM Recomendada - 32 GB de RAM ECC</li> <li>Rede Recomendada - conex\u00e3o de 1 Gbps</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>Manter o desempenho do seu N\u00f3 Tanssi, mant\u00ea-lo atualizado e garantir sua seguran\u00e7a s\u00e3o cruciais para uma opera\u00e7\u00e3o confi\u00e1vel.</p>"},{"location":"pt/node-operators/network-node/tanssi/#portas-de-rede-necessarias","title":"Portas de Rede Necess\u00e1rias","text":"<p>Para garantir a comunica\u00e7\u00e3o adequada com a rede Tanssi, certifique-se de que a seguinte porta esteja aberta para conex\u00f5es de entrada:</p> Rede Porta Tanssi Chain 30333 (TCP)"},{"location":"pt/node-operators/network-node/tanssi/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/","title":"Executar um N\u00f3 Tanssi Usando Docker","text":""},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Neste guia, voc\u00ea aprender\u00e1 como iniciar um n\u00f3 Tanssi usando a imagem oficial com Docker em sistemas Linux. Os n\u00f3s s\u00e3o cruciais para o ecossistema Tanssi, pois fornecem endpoints de API est\u00e1veis aos quais aplicativos e usu\u00e1rios podem se conectar para obter dados da cadeia e enviar transa\u00e7\u00f5es.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":""},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#installing-docker","title":"Instalando o Docker","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instala\u00e7\u00e3o:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execu\u00e7\u00e3o bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#pull-docker-image","title":"Puxar a Imagem Docker","text":"<p>Para cada vers\u00e3o, uma imagem Docker \u00e9 constru\u00edda e publicada. Ela cont\u00e9m todas as depend\u00eancias que um n\u00f3 Tanssi exige e o pr\u00f3prio bin\u00e1rio.</p> <p>A imagem combina o bin\u00e1rio da vers\u00e3o est\u00e1vel mais recente do n\u00f3 cliente com o arquivo de especifica\u00e7\u00f5es do orquestrador Tanssi.</p> <p>Execute o comando abaixo para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>O comando far\u00e1 download/extrair a imagem e exibir\u00e1 o status ap\u00f3s a execu\u00e7\u00e3o:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#set-up-data-directory","title":"Configure o diret\u00f3rio de dados","text":"<p>Executar um n\u00f3 requer sincronizar com a cadeia Tanssi e armazenar seu estado.</p> <p>Crie o diret\u00f3rio onde o n\u00f3 armazenar\u00e1 os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando a seguir se quiser rodar o n\u00f3 com o usu\u00e1rio atualmente logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diret\u00f3rio \u00e9 um par\u00e2metro no comando de inicializa\u00e7\u00e3o do Docker. Se decidir cri\u00e1-lo em outro lugar, ajuste o comando.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#generate-node-key","title":"Gerar a Chave do N\u00f3","text":"<p>Para gerar e armazenar em disco as chaves de sess\u00e3o referenciadas no comando de inicializa\u00e7\u00e3o, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#start-your-node","title":"Inicie Seu N\u00f3","text":"<p>Para iniciar seu n\u00f3, execute a imagem Docker com <code>docker run</code>.</p> <p>Substitua <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome leg\u00edvel e defina <code>INSERT_YOUR_IP_ADDRESS</code> com seu IP p\u00fablico.</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path /data \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#run-flags","title":"Executar Flags","text":"<p>As flags do <code>docker run</code> podem ser ajustadas conforme suas prefer\u00eancias e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mant\u00e9m todos os dados de estado (necess\u00e1rio para consultas hist\u00f3ricas)</li> <li>--blocks-pruning=archive - mant\u00e9m todos os blocos (necess\u00e1rio para dados hist\u00f3ricos de blocos)</li> <li>--database=paritydb - usa ParityDB como backend otimizado para desempenho de n\u00f3 RPC</li> <li>--unsafe-rpc-external - permite conex\u00f5es externas ao RPC; exige medidas adicionais de seguran\u00e7a em produ\u00e7\u00e3o (proxy reverso, autentica\u00e7\u00e3o, firewall)</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>A flag <code>--unsafe-rpc-external</code> exp\u00f5e seu n\u00f3 RPC externamente. Em produ\u00e7\u00e3o, proteja com firewall, proxy reverso, autentica\u00e7\u00e3o e limita\u00e7\u00e3o de taxa.</p> <p>Voc\u00ea pode visualizar todas as flags dispon\u00edveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#syncing-your-node","title":"Sincronizando Seu N\u00f3","text":"<p>Na primeira execu\u00e7\u00e3o, o processo de sincroniza\u00e7\u00e3o exibir\u00e1 muitos logs do n\u00f3 e da cadeia. Alguns erros iniciais s\u00e3o esperados e desaparecem quando a cadeia alcan\u00e7a o \u00faltimo bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-docker/#testing-your-rpc-node","title":"Testando Seu N\u00f3","text":"<p>Depois de sincronizado, teste o endpoint RPC com uma solicita\u00e7\u00e3o simples, por exemplo:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>Se estiver funcionando, voc\u00ea receber\u00e1 uma resposta JSON com o cabe\u00e7alho do bloco mais recente.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/","title":"Executar um N\u00f3 Tanssi Usando Systemd","text":""},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Neste guia, voc\u00ea aprender\u00e1 a iniciar um N\u00f3 Tanssi usando o bin\u00e1rio est\u00e1vel mais recente e gerenciar o servi\u00e7o com Systemd em sistemas Linux. Os n\u00f3s fornecem endpoints de API essenciais para que aplica\u00e7\u00f5es e usu\u00e1rios interajam com a rede Tanssi.</p> <p>O artigo segue a boa pr\u00e1tica de executar o servi\u00e7o com uma conta n\u00e3o-root e conceder a essa conta acesso de grava\u00e7\u00e3o a um diret\u00f3rio espec\u00edfico. Voc\u00ea pode adaptar as etapas \u00e0 sua configura\u00e7\u00e3o, prefer\u00eancias e pol\u00edticas de seguran\u00e7a.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de acesso a um computador executando Ubuntu Linux com Landlock habilitado e privil\u00e9gios de root. Voc\u00ea tamb\u00e9m precisar\u00e1 de:</p> <ul> <li>Arquivos bin\u00e1rios do N\u00f3 - um n\u00f3 requer tr\u00eas bin\u00e1rios: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code></li> </ul> <p>As instru\u00e7\u00f5es executam a vers\u00e3o est\u00e1vel mais recente. Voc\u00ea pode compilar seu pr\u00f3prio arquivo a partir do c\u00f3digo-fonte.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#check-landlock","title":"Verificar Suporte Landlock","text":"<p>Os n\u00f3s Tanssi usam o recurso Landlock do kernel Linux como medida de seguran\u00e7a para restringir acesso a recursos do sistema, limitando danos caso o aplicativo seja comprometido.</p> <p>Verifique o suporte Landlock executando:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>Sa\u00edda esperada:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>Se o Landlock estiver desabilitado, atualize o kernel para a vers\u00e3o 5.13 ou superior.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#download-latest-release","title":"Baixar a Vers\u00e3o Mais Recente","text":"<p>Baixe o bin\u00e1rio mais recente e torne-o execut\u00e1vel:</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#set-up-systemd-service","title":"Configure o servi\u00e7o Systemd","text":"<p>O Systemd \u00e9 um sistema de gerenciamento para Linux que controla servi\u00e7os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.</p> <p>Os comandos a seguir criam uma nova conta, o diret\u00f3rio e movem os arquivos previamente baixados para o local correto.</p> <ol> <li> <p>Crie uma nova conta para executar o servi\u00e7o:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Crie um diret\u00f3rio para armazenar os arquivos e dados necess\u00e1rios:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Defina a propriedade da pasta para a conta que executar\u00e1 o servi\u00e7o, garantindo permiss\u00e3o de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Mova os bin\u00e1rios para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dancelight-data\n</code></pre> </li> </ol>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#generate-node-key","title":"Gerar a chave do n\u00f3","text":"<p>Para gerar e armazenar em disco as chaves de sess\u00e3o que ser\u00e3o referenciadas no comando de inicializa\u00e7\u00e3o, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#create-systemd-configuration","title":"Criar o arquivo de configura\u00e7\u00e3o do Systemd","text":"<p>O pr\u00f3ximo passo \u00e9 criar o arquivo de configura\u00e7\u00e3o do Systemd.</p> <p>Crie o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configura\u00e7\u00e3o do servi\u00e7o, substituindo a tag <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome leg\u00edvel e <code>INSERT_YOUR_IP_ADDRESS</code> pelo seu endere\u00e7o IP p\u00fablico. Esse nome ajuda a relacionar entradas de log e m\u00e9tricas ao n\u00f3 que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd Dancelight\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=dancelight_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/dancelight-data/tanssi-relay --chain=dancelight \\\n--base-path /var/lib/tanssi-data/ \\\n--name INSERT_YOUR_TANSSI_NODE_NAME \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database paritydb \\\n--rpc-port 9944 \\\n--prometheus-port 9615 \\\n--prometheus-external \\\n--listen-addr /ip4/0.0.0.0/tcp/30333 \\\n--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning archive \\\n--blocks-pruning archive \\\n--rpc-cors=all \\\n--unsafe-rpc-external \\\n--rpc-methods=safe \\\n--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>As flags usadas no <code>ExecStart</code> podem ser ajustadas conforme suas prefer\u00eancias e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mant\u00e9m todos os dados de estado (necess\u00e1rio para consultas hist\u00f3ricas)</li> <li>--blocks-pruning=archive - mant\u00e9m todos os blocos (necess\u00e1rio para dados hist\u00f3ricos de blocos)</li> <li>--database=paritydb - usa ParityDB como back-end otimizado para desempenho de n\u00f3 RPC</li> <li>--unsafe-rpc-external - permite conex\u00f5es externas ao RPC; requer medidas adicionais de seguran\u00e7a em produ\u00e7\u00e3o (proxy reverso, autentica\u00e7\u00e3o, firewall)</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>A flag <code>--unsafe-rpc-external</code> exp\u00f5e o RPC externamente. Em produ\u00e7\u00e3o, proteja com firewall, proxy reverso, autentica\u00e7\u00e3o e limita\u00e7\u00e3o de taxa.</p> <p>Voc\u00ea pode visualizar todas as flags dispon\u00edveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#run-the-service","title":"Execute o servi\u00e7o","text":"<p>Por fim, habilite o servi\u00e7o e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Voc\u00ea pode verificar se o servi\u00e7o est\u00e1 ativo e rodando corretamente executando:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>Verifique os logs, se necess\u00e1rio, com o comando a seguir:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi/tanssi-node-systemd/#testing-your-rpc-node","title":"Testando Seu N\u00f3","text":"<p>Depois que seu n\u00f3 estiver totalmente sincronizado, voc\u00ea pode verificar se o endpoint RPC est\u00e1 funcionando corretamente fazendo uma solicita\u00e7\u00e3o simples. Use curl para testar:</p> <pre><code>curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\":\"chain_getHeader\", \"params\":[]}' http://localhost:9944\n</code></pre> <p>Se o endpoint RPC estiver funcionando, voc\u00ea receber\u00e1 uma resposta JSON contendo as informa\u00e7\u00f5es do cabe\u00e7alho do bloco mais recente.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/","title":"Executar um n\u00f3 em uma rede Tanssi-Powered","text":"<p>A configura\u00e7\u00e3o de um n\u00f3 de rede \u00e9 essencial para interagir com sua rede Tanssi-powered e fornecer um endpoint RPC seguro e dedicado. Esta se\u00e7\u00e3o oferece guias passo a passo para ajud\u00e1-lo a configurar e gerenciar seu n\u00f3 de forma eficaz. Explore duas abordagens diferentes para executar seu n\u00f3:</p> <ul> <li>Usando Docker - instru\u00e7\u00f5es para configurar seu n\u00f3 em um ambiente conteinerizado para f\u00e1cil implanta\u00e7\u00e3o e isolamento</li> <li>Usando Systemd - orienta\u00e7\u00e3o para configurar seu n\u00f3 como um servi\u00e7o, permitindo o gerenciamento automatizado e a integra\u00e7\u00e3o do sistema</li> </ul>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/","title":"Executar um N\u00f3 Appchain usando Docker","text":""},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Executar um n\u00f3 de appchain com Tanssi permite conectar e interagir com a appchain usando sua pr\u00f3pria infraestrutura via HTTP ou WebSocket.</p> <p>Os n\u00f3s armazenam dados de blocos e estado da rede. H\u00e1 diferentes tipos que os desenvolvedores podem operar:</p> <ul> <li>N\u00f3 Arquivo Completo - armazena todos os dados de blocos e estados da rede em todas as alturas. \u00datil para consultar dados hist\u00f3ricos, mas consome muito espa\u00e7o</li> <li>N\u00f3 Podado Completo - armazena dados de blocos e estado at\u00e9 um certo n\u00famero de blocos antes da altura atual. \u00datil para consultar dados recentes ou enviar transa\u00e7\u00f5es pela sua infraestrutura. Requer bem menos espa\u00e7o que um n\u00f3 arquival, mas n\u00e3o mant\u00e9m todo o estado da rede</li> </ul> <p>Neste guia, voc\u00ea aprender\u00e1 como iniciar rapidamente um n\u00f3 appchain Tanssi usando Docker em um computador Linux. Ele pode ser adaptado para outros sistemas operacionais.</p> <p>Nota</p> <p>N\u00e3o \u00e9 poss\u00edvel executar um n\u00f3 RPC para appchains de teste r\u00e1pidas, pois elas rodam em uma rede privada e, portanto, n\u00e3o est\u00e3o acess\u00edveis para sincroniza\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#checking-prerequisites","title":"Verifica\u00e7\u00e3o de Pr\u00e9-requisitos","text":""},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#installing-docker","title":"Instalando o Docker","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instala\u00e7\u00e3o:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execu\u00e7\u00e3o bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#getting-specifications-files","title":"Obtendo os arquivos de especifica\u00e7\u00e3o","text":"<p>Um n\u00f3 de appchain precisa de informa\u00e7\u00f5es sobre duas blockchains para funcionar corretamente: a pr\u00f3pria appchain e a cadeia de orquestra\u00e7\u00e3o do Tanssi.</p> <p>Essas informa\u00e7\u00f5es ficam em um arquivo de especifica\u00e7\u00f5es de cadeia, que inclui, entre outras coisas, o estado g\u00eanesis, permitindo que o n\u00f3 verifique e sincronize corretamente os blocos e estados recebidos de outros n\u00f3s.</p> <p>Para obter o arquivo de especifica\u00e7\u00e3o do Tanssi, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>Para obter o arquivo de especifica\u00e7\u00e3o da appchain, baixe-o no dashboard do dApp clicando no link Network Data.</p> <p></p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#setup-data-directory","title":"Configurar o diret\u00f3rio de dados","text":"<p>Executar um sequenciador ou um n\u00f3 de appchain exige sincronizar duas cadeias: a cadeia de orquestra\u00e7\u00e3o do Tanssi e a appchain para a qual ele trabalha.</p> <p>Crie o diret\u00f3rio onde o n\u00f3 armazenar\u00e1 os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando abaixo se quiser rodar o sequenciador com o usu\u00e1rio logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diret\u00f3rio \u00e9 um par\u00e2metro no comando de inicializa\u00e7\u00e3o do Docker. Se optar por criar o diret\u00f3rio em outro lugar, ajuste o comando.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-docker-image","title":"Extraindo a Imagem Docker","text":"<p>Duas imagens Docker s\u00e3o criadas e publicadas para cada vers\u00e3o: uma para appchains compat\u00edveis com EVM e outra para appchains Substrate.</p> <p>Essas imagens incluem todos os bin\u00e1rios necess\u00e1rios para executar a vers\u00e3o est\u00e1vel mais recente do n\u00f3 cliente.</p> <p>Puxe a imagem correspondente ao tipo de appchain que voc\u00ea deseja executar.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-evm-docker-image","title":"Appchains compat\u00edveis com EVM","text":"<p>Se a appchain foi registrada escolhendo o modelo EVM ou enviando uma especifica\u00e7\u00e3o personalizada compat\u00edvel com EVM, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-evm-template\n</code></pre> <p>O comando far\u00e1 download e extra\u00e7\u00e3o da imagem e exibir\u00e1 o status ap\u00f3s a execu\u00e7\u00e3o:</p> docker pull moondancelabs/container-chain-evm-template  Using default tag: latest      latest: Pulling from moondancelabs/container-chain-evm-template      31ad3619f756: Already exists       8f3d9759dcde: Pull complete       de5eaba9b289: Pull complete       Digest: sha256:4930d631a8ac7f7852754d4cf77bb3317229d768f44092a00295ba50641b2a33      Status: Downloaded newer image for moondancelabs/container-chain-evm-template      docker.io/moondancelabs/container-chain-evm-template:latest"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#pulling-substrate-docker-image","title":"Appchains Substrate Simples","text":"<p>Se a appchain foi registrada escolhendo o modelo Substrate b\u00e1sico ou enviando uma especifica\u00e7\u00e3o personalizada Substrate, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <pre><code>docker pull moondancelabs/container-chain-simple-template\n</code></pre> <p>O comando far\u00e1 download e extra\u00e7\u00e3o da imagem e exibir\u00e1 o status ap\u00f3s a execu\u00e7\u00e3o, semelhante ao exemplo anterior.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#start-up-command","title":"Comando de Inicializa\u00e7\u00e3o","text":"<p>Para iniciar seu n\u00f3, execute a imagem Docker com <code>docker run</code>. Altere conforme necess\u00e1rio:</p> <ul> <li><code>Arquivo de especifica\u00e7\u00f5es da appchain</code> - substitua <code>INSERT_YOUR_APPCHAIN_SPECS_FILE</code> pelo nome do arquivo de specs baixado na etapa de obten\u00e7\u00e3o das especifica\u00e7\u00f5es.</li> <li><code>Bootnode</code> - \u00e9 um n\u00f3 arquivo completo usado para sincronizar a rede do zero. Voc\u00ea precisar\u00e1 recuperar o bootnode da sua rede Tanssi e substituir <code>INSERT_YOUR_NETWORK_BOOTNODES</code> pela informa\u00e7\u00e3o real de bootnode.</li> </ul> Tanssi MainNetDancelight TestNet Appchain compat\u00edvel com EVMAppchain Substrate Simples <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n</code></pre> Appchain compat\u00edvel com EVMAppchain Substrate Simples <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-simple-template \\\n--chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \\\n--rpc-port=9944 \\\n--name=appchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--name=relay \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre> <p>Nota</p> <p>Por padr\u00e3o, apenas o estado hist\u00f3rico dos \u00faltimos 256 blocos finalizados \u00e9 mantido. Para executar um n\u00f3 de arquivo completo, defina a flag <code>--state-pruning archive</code>. Mais informa\u00e7\u00f5es na se\u00e7\u00e3o de sinalizadores.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#fetching-bootnode-information","title":"Obtendo informa\u00e7\u00f5es de bootnode","text":"<p>As informa\u00e7\u00f5es de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, voc\u00ea pode usar o portal do desenvolvedor para obter os bootnodes de uma rede espec\u00edfica no Dancelight.</p> <p>Para isso, siga estas etapas:</p> <ol> <li>Selecione dataPreservers como o m\u00f3dulo a consultar</li> <li>Defina a consulta de armazenamento como bootNodes</li> <li>Informe o ID da sua rede Tanssi</li> <li>Clique no sinal de +</li> </ol> <p></p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#example-demo-evm-appchain","title":"Exemplo de N\u00f3 Completo para Demo EVM Appchain","text":"<p>O exemplo abaixo inicia um n\u00f3 RPC de arquivo completo para a rede demo EVM implantada no Dancelight (ID <code>2001</code>). Assume que os arquivos de specs est\u00e3o na pasta de dados.</p> Demo EVM Appchain (Dancelight) <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/container-chain-evm-template \\\n--chain=/data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=demoAppchain \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#run-flags","title":"Executar Sinalizadores","text":"<p>As flags usadas no <code>docker run</code> podem ser ajustadas conforme suas prefer\u00eancias e hardware. Algumas das principais:</p> <ul> <li><code>--name INSERT_NAME</code> - nome leg\u00edvel para este n\u00f3</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o n\u00f3 ouve</li> <li><code>--unsafe-rpc-external</code> - exp\u00f5e o servi\u00e7o RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (n\u00f3 atua como completo mantendo todo o estado), <code>archive-canonical</code> (mant\u00e9m apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados ser\u00e3o mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (n\u00f3 completo mantendo todos os blocos), <code>archive-canonical</code> (mant\u00e9m apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita sa\u00edda detalhada de logs</li> </ul> <p>Warning</p> <p>O par\u00e2metro <code>--unsafe-rpc-external</code> permite acesso externo \u00e0 interface RPC do seu n\u00f3, tornando-a acess\u00edvel de qualquer endere\u00e7o IP. Certifique-se de que controles de seguran\u00e7a adequados estejam configurados.</p> <p>Para ver a lista completa de flags dispon\u00edveis, descri\u00e7\u00e3o e valores poss\u00edveis, execute:</p> Appchain compat\u00edvel com EVMAppchain Substrate Simples <pre><code>docker run -ti moondancelabs/container-chain-evm-template --help\n</code></pre> <pre><code>docker run -ti moondancelabs/container-chain-simple-template --help\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-docker/#syncing-your-node","title":"Sincronizando seu n\u00f3","text":"<p>Ap\u00f3s iniciar, o processo de sincroniza\u00e7\u00e3o exibir\u00e1 muitos logs do n\u00f3 e da appchain Tanssi. Alguns erros iniciais s\u00e3o esperados e desaparecem quando a cadeia alcan\u00e7a o \u00faltimo bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>Nota</p> <p>A dura\u00e7\u00e3o da sincroniza\u00e7\u00e3o \u00e9 proporcional ao tamanho da cadeia que est\u00e1 sendo sincronizada.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/","title":"Execute um N\u00f3 Appchain Usando Systemd","text":""},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Executar um n\u00f3 de appchain com Tanssi permite conectar e interagir com a appchain usando sua pr\u00f3pria infraestrutura via HTTP ou WebSocket.</p> <p>Os n\u00f3s armazenam dados de blocos e estado da rede. H\u00e1 diferentes tipos que os desenvolvedores podem operar:</p> <ul> <li>N\u00f3 Arquivo Completo - armazena todos os dados de blocos e estados da rede em todas as alturas. \u00datil para consultar dados hist\u00f3ricos, mas consome muito espa\u00e7o</li> <li>N\u00f3 Podado Completo - armazena dados de blocos e estado at\u00e9 um certo n\u00famero de blocos antes da altura atual. \u00datil para consultar dados recentes ou enviar transa\u00e7\u00f5es pela sua infraestrutura. Requer bem menos espa\u00e7o que um n\u00f3 arquival, mas n\u00e3o mant\u00e9m todo o estado da rede</li> </ul> <p>Neste guia, voc\u00ea aprender\u00e1 a iniciar um n\u00f3 appchain da Tanssi usando um bin\u00e1rio execut\u00e1vel e gerenciar o servi\u00e7o com Systemd em sistemas Linux.</p> <p>O artigo segue a boa pr\u00e1tica de executar o servi\u00e7o com uma conta n\u00e3o-root e conceder a essa conta acesso de grava\u00e7\u00e3o a um diret\u00f3rio espec\u00edfico. Voc\u00ea pode adaptar as etapas \u00e0 sua configura\u00e7\u00e3o, prefer\u00eancias e pol\u00edticas de seguran\u00e7a.</p> <p>Nota</p> <p>N\u00e3o \u00e9 poss\u00edvel executar um n\u00f3 RPC para appchains de teste r\u00e1pido, pois eles rodam em uma rede privada e, portanto, n\u00e3o est\u00e3o acess\u00edveis para sincroniza\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de acesso a um computador executando Ubuntu Linux com privil\u00e9gios de root. Voc\u00ea tamb\u00e9m precisar\u00e1 de:</p> <ul> <li>Arquivo bin\u00e1rio do n\u00f3 - as instru\u00e7\u00f5es executam a vers\u00e3o est\u00e1vel mais recente. Se quiser compilar e rodar o seu pr\u00f3prio arquivo, siga as instru\u00e7\u00f5es para construir seu n\u00f3 appchain.</li> <li>Arquivos de especifica\u00e7\u00f5es de cadeia - o n\u00f3 precisa de informa\u00e7\u00f5es sobre duas blockchains diferentes para sincronizar e executar corretamente. A se\u00e7\u00e3o a seguir mostra como obt\u00ea-los.</li> </ul>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#getting-specifications-files","title":"Obtendo os arquivos de especifica\u00e7\u00e3o","text":"<p>Um n\u00f3 de appchain precisa de informa\u00e7\u00f5es sobre duas blockchains para funcionar corretamente: a pr\u00f3pria appchain e a cadeia de orquestra\u00e7\u00e3o do Tanssi.</p> <p>Essas informa\u00e7\u00f5es ficam em um arquivo de especifica\u00e7\u00f5es de cadeia, que inclui, entre outras coisas, o estado g\u00eanesis, permitindo que o n\u00f3 verifique e sincronize corretamente os blocos e estados recebidos de outros n\u00f3s.</p> <p>Para obter o arquivo de especifica\u00e7\u00e3o do Tanssi, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre> <p>Para obter o arquivo de especifica\u00e7\u00e3o da appchain, baixe-o no dashboard do dApp clicando no link Network Data.</p> <p></p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#download-latest-release","title":"Baixe a Vers\u00e3o Mais Recente","text":"<p>Cada nova vers\u00e3o inclui dois bin\u00e1rios, um para redes compat\u00edveis com EVM e outro para redes Substrate. Para come\u00e7ar, execute o comando que corresponde ao seu tipo de rede e torne-o execut\u00e1vel:</p> Rede Compat\u00edvel com EVMRede Substrate <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-frontier-node &amp;&amp; \\\nchmod +x ./container-chain-frontier-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/container-chain-simple-node &amp;&amp; \\\nchmod +x ./container-chain-simple-node\n</code></pre> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#setup-systemd-service","title":"Configurar o servi\u00e7o Systemd","text":"<p>O Systemd \u00e9 um sistema de gerenciamento para Linux que controla servi\u00e7os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.</p> <p>Os comandos a seguir configuram uma nova conta, o diret\u00f3rio e movem os arquivos baixados para o local correto.</p> <p>Crie uma nova conta para executar o servi\u00e7o:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Crie um diret\u00f3rio para armazenar os arquivos e dados necess\u00e1rios:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Defina a propriedade da pasta para a conta que executar\u00e1 o servi\u00e7o, garantindo permiss\u00e3o de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Mova o arquivo de especifica\u00e7\u00e3o da cadeia para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Mova tamb\u00e9m o bin\u00e1rio do n\u00f3:</p> Tanssi MainNetDancelight TestNet Appchain compat\u00edvel com EVMRede Substrate <pre><code>mv ./container-chain-frontier-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/tanssi-data\n</code></pre> Appchain compat\u00edvel com EVMRede Substrate <pre><code>mv ./container-chain-frontier-node /var/lib/dancelight-data\n</code></pre> <pre><code>mv ./container-chain-simple-node /var/lib/dancelight-data\n</code></pre> <p>Por fim, mova o arquivo de especifica\u00e7\u00f5es do seu appchain para a mesma pasta.</p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#create-systemd-configuration","title":"Crie o Arquivo de Configura\u00e7\u00e3o do Servi\u00e7o Systemd","text":"<p>A pr\u00f3xima etapa \u00e9 criar o arquivo de configura\u00e7\u00e3o do Systemd.</p> <p>Voc\u00ea pode criar o arquivo executando:</p> <pre><code>sudo touch /etc/systemd/system/appchain.service\n</code></pre> <p>Em seguida, abra o arquivo no seu editor favorito e adicione a configura\u00e7\u00e3o do servi\u00e7o.</p> <p>Note que o comando <code>ExecStart</code> tem par\u00e2metros que precisam ser ajustados para sua rede:</p> <ul> <li> <p><code>Arquivo de especifica\u00e7\u00e3o</code> - substitua <code>INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME</code> pelo nome do arquivo do seu appchain. Para um appchain MainNet, o caminho ser\u00e1 parecido com <code>/var/lib/tanssi-data/SEU_ARQUIVO.json</code>.</p> </li> <li> <p><code>Bootnode</code> - \u00e9 um n\u00f3 arquivo completo usado para sincronizar a rede do zero. Voc\u00ea precisar\u00e1 recuperar o bootnode da sua rede Tanssi e substituir <code>INSERT_YOUR_NETWORK_BOOTNODES</code> pela informa\u00e7\u00e3o real de bootnode.</p> </li> </ul> Tanssi MainNetDancelight TestNet Appchain compat\u00edvel com EVMRede Substrate <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-frontier-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/container-chain-simple-node \\\n--chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/tanssi-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> Rede Compat\u00edvel com EVMRede Substrate <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-simple-node \\\n--chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \\\n--rpc-port=9944 \\\n--name=para \\\n--base-path=/var/lib/dancelight-data \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#fetching-bootnode-information","title":"Obtendo informa\u00e7\u00f5es de bootnode","text":"<p>As informa\u00e7\u00f5es de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, voc\u00ea pode usar o portal do desenvolvedor para obter os bootnodes de uma rede espec\u00edfica no Dancelight.</p> <p>Para isso, siga estas etapas:</p> <ol> <li>Selecione dataPreservers como o m\u00f3dulo a consultar</li> <li>Defina a consulta de armazenamento como bootNodes</li> <li>Informe o ID da sua rede Tanssi</li> <li>Clique no sinal de +</li> </ol> <p></p>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#example-demo-evm-network","title":"Exemplo de Configura\u00e7\u00e3o Completa para a Rede EVM de Demonstra\u00e7\u00e3o","text":"<p>O exemplo a seguir implanta um n\u00f3 de arquivo completo e funcional para a rede EVM de demonstra\u00e7\u00e3o implantada no Dancelight com ID <code>2001</code>.</p> <p>O arquivo de especifica\u00e7\u00e3o de cadeia bruta \u00e9 necess\u00e1rio para executar o n\u00f3 e pode ser baixado deste reposit\u00f3rio p\u00fablico no GitHub. Baixe o arquivo e coloque-o em <code>/var/lib/dancelight-data/</code>.</p> Demo EVM Appchain (Dancelight) <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd do Appchain\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=network\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/container-chain-frontier-node \\\n--chain=/var/lib/dancelight-data/container-2001-raw-specs.json \\\n--rpc-port=9944 \\\n--name=para \\\n--state-pruning=archive \\\n--blocks-pruning=archive \\\n--base-path=/var/lib/dancelight-data \\\n--database=paritydb \\\n--unsafe-rpc-external \\\n--bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \\\n--bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--rpc-port=9945 \\\n--name=relay \\\n--sync=fast \\\n--database=paritydb \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>As flags usadas no comando <code>ExecStart</code> podem ser ajustadas conforme suas prefer\u00eancias e configura\u00e7\u00e3o de hardware. Algumas das mais importantes:</p> <ul> <li><code>--name INSERT_NAME</code> - nome leg\u00edvel para este n\u00f3</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o n\u00f3 ouve</li> <li><code>--unsafe-rpc-external</code> - exp\u00f5e o servi\u00e7o RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (n\u00f3 atua como completo mantendo todo o estado), <code>archive-canonical</code> (mant\u00e9m apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados ser\u00e3o mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (n\u00f3 completo mantendo todos os blocos), <code>archive-canonical</code> (mant\u00e9m apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita sa\u00edda detalhada de logs</li> </ul> <p>Warning</p> <p>O par\u00e2metro <code>--unsafe-rpc-external</code> permite acesso externo \u00e0 interface RPC do seu n\u00f3, tornando-a acess\u00edvel de qualquer endere\u00e7o IP. Certifique-se de que controles de seguran\u00e7a adequados estejam configurados.</p> <p>Para ver a lista completa de flags dispon\u00edveis, descri\u00e7\u00e3o e valores poss\u00edveis, execute:</p> Rede compat\u00edvel com EVMRede Substrate Simples <pre><code>/var/lib/dancelight-data/container-chain-frontier-node --help\n</code></pre> <pre><code>/var/lib/dancelight-data/container-chain-simple-node --help\n</code></pre>"},{"location":"pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/#run-the-service","title":"Execute o Servi\u00e7o","text":"<p>Finalmente, habilite o servi\u00e7o e inicie-o pela primeira vez:</p> <pre><code>systemctl enable appchain.service &amp;&amp; \\\nsystemctl start appchain.service\n</code></pre> <p>Verifique se o servi\u00e7o est\u00e1 funcionando corretamente executando:</p> <pre><code>systemctl status appchain.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>E verifique os logs, se necess\u00e1rio:</p> <pre><code>journalctl -f -u appchain.service\n</code></pre> journalctl -f -u network.service  Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 Parachain Collator Template      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \u270c\ufe0f  version 0.1.0-3b1fbbfdfe7      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \u2764\ufe0f  by Moondance Labs,      2020-2024      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udccb Chain specification: Frontier Container 2001      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83c\udff7  Node name: para      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udc64 Role: FULL      Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 \ud83d\udcbe Database: RocksDb at /var/lib/network-data/chains/frontier_container_2001/db/full      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain id: Id(2001)      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain Account: 5Ec4AhPQLGvfWywVhJZwufTDvknLT3BVPQcbV977JmBDUsHP      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V0: 0x000000000000000000000000000000000000000000000000000000000000000000e1324cc53e66      Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V1: 0x000000000000000000000000000000000000000000000000000000000000000000327cfde8482b"},{"location":"pt/node-operators/operators/","title":"Operadores Tanssi","text":"<p>Os operadores (tamb\u00e9m conhecidos como validadores) s\u00e3o respons\u00e1veis por manter a seguran\u00e7a em todas as redes com tecnologia Tanssi, verificando a integridade e a validade de suas transa\u00e7\u00f5es. Eles participam de um mecanismo de consenso DPoS (Delegated Proof-of-Stake), que melhora a descentraliza\u00e7\u00e3o e promove um bom comportamento por meio de incentivos econ\u00f4micos.</p> <p>Esta se\u00e7\u00e3o fornece tudo o que voc\u00ea precisa para come\u00e7ar, desde a configura\u00e7\u00e3o inicial at\u00e9 as melhores pr\u00e1ticas operacionais e o gerenciamento de contas.</p>"},{"location":"pt/node-operators/operators/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/offboarding/","title":"Desativando um Operador do Tanssi","text":"<p>Deixar de ser um operador requer seguir os procedimentos adequados para garantir uma transi\u00e7\u00e3o tranquila. Esta se\u00e7\u00e3o fornece instru\u00e7\u00f5es claras sobre como desativar seu operador da rede Tanssi.</p> <p>Pr\u00e9-requisitos</p> <p>Antes de iniciar o offboarding do seu n\u00f3 Tanssi, verifique os pr\u00e9-requisitos.</p> <p>Opt-out da Tanssi (Obrigat\u00f3rio)</p> <p>Fa\u00e7a opt-out da rede Tanssi na Ethereum.</p> <p>Opt-out do Vault (Opcional)</p> <p>Esta etapa \u00e9 opcional e s\u00f3 \u00e9 necess\u00e1ria se voc\u00ea quiser remover totalmente sua associa\u00e7\u00e3o com o cofre. Ignor\u00e1-la n\u00e3o afeta sua capacidade de voltar \u00e0 rede no futuro.</p> <p>Retornando como Operador</p> <p>Se voc\u00ea decidir retornar como um validador Tanssi no futuro, poder\u00e1 facilmente se cadastrar novamente seguindo as etapas descritas no guia Onboarding.</p>"},{"location":"pt/node-operators/operators/offboarding/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/","title":"Cancelar a participa\u00e7\u00e3o na Tanssi","text":""},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A capacidade de gerenciar a participa\u00e7\u00e3o dos operadores de n\u00f3s no ecossistema Tanssi \u00e9 crucial. Este guia aborda a etapa inicial do processo de cancelamento: cancelar a participa\u00e7\u00e3o na rede Tanssi. Essa a\u00e7\u00e3o sinaliza sua inten\u00e7\u00e3o de retirada e permite que o protocolo Tanssi verifique sua identidade como o operador leg\u00edtimo.</p> <p>Durante o processo de integra\u00e7\u00e3o, uma etapa foi a participa\u00e7\u00e3o na rede Tanssi para se tornar um operador. Este guia ir\u00e1 gui\u00e1-lo pelo processo de cancelamento. Existem v\u00e1rias maneiras de interagir com os contratos inteligentes envolvidos. Consulte o artigo de pr\u00e9-requisitos para avaliar qual alternativa \u00e9 a mais adequada para voc\u00ea.</p> <p>Valida\u00e7\u00e3o de identidade</p> <p>Ao cancelar a participa\u00e7\u00e3o, voc\u00ea assina a transa\u00e7\u00e3o usando a chave privada ou o dispositivo Ledger associado \u00e0 sua conta de operador. Essa assinatura serve como prova criptogr\u00e1fica de que voc\u00ea \u00e9 o propriet\u00e1rio leg\u00edtimo da conta do operador, garantindo que apenas operadores autorizados possam iniciar o processo de cancelamento.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#methods-for-opting-out","title":"M\u00e9todos para cancelar a participa\u00e7\u00e3o de uma rede Tanssi","text":"<p>Para cancelar a participa\u00e7\u00e3o na rede Tanssi, voc\u00ea deve interagir com um contrato inteligente. Abaixo est\u00e3o os diferentes m\u00e9todos dispon\u00edveis para realizar essa a\u00e7\u00e3o. Escolha aquele que melhor se adapta \u00e0 sua configura\u00e7\u00e3o e prefer\u00eancias de seguran\u00e7a.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-cli","title":"Usando a CLI Symbiotic","text":"<p>A CLI Symbiotic fornece uma maneira direta de cancelar a participa\u00e7\u00e3o da rede. Escolha o comando apropriado com base em sua rede e m\u00e9todo de assinatura.</p> <p>Usando um dispositivo Ledger:</p> MainNet <pre><code>```bash\npython3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3  --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n```\n</code></pre> TestNet (Sepolia) <pre><code>```bash\npython3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n```\n</code></pre> <p>Para assinar com uma chave privada:</p> MainNet <pre><code>```bash\npython3 symb.py opt-out-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY\n```\n</code></pre> TestNet (Sepolia) <pre><code>```bash\npython3 symb.py --chain sepolia opt-out-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY\n```\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Observe que este m\u00e9todo exige que voc\u00ea exponha sua chave privada; portanto, n\u00e3o \u00e9 recomendado.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-etherscan","title":"Usando Etherscan","text":"<p>Voc\u00ea pode interagir diretamente com o contrato inteligente atrav\u00e9s do Etherscan usando uma carteira de navegador como MetaMask.</p> MainNet <pre><code>[Endere\u00e7o do contrato: 0x7133415b33B438843D581013f98A08704316633c](https://etherscan.io/address/0x7133415b33B438843D581013f98A08704316633c#writeContract){target=\\\\_blank}\n</code></pre> TestNet (Sepolia) <pre><code>[Endere\u00e7o do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401](https://sepolia.etherscan.io/address/0x58973d16FFA900D11fC22e5e2B6840d9f7e13401#writeContract){target=\\\\_blank}\n</code></pre> <p>Certifique-se de selecionar Contrato e Escrever Contrato, depois clique em Conectar ao Web3 e selecione sua carteira preferida (por exemplo, MetaMask): </p> <ol> <li>Expanda a fun\u00e7\u00e3o optOut</li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Se voc\u00ea estiver cancelando a participa\u00e7\u00e3o da Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Escrever e assine a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Aten\u00e7\u00e3o</p> <p>Ap\u00f3s enviar sua transa\u00e7\u00e3o de cancelamento, salve o hash da transa\u00e7\u00e3o. Voc\u00ea precisar\u00e1 desse hash mais tarde para verifica\u00e7\u00e3o no formul\u00e1rio de cancelamento de opera\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#opt-out-network-with-safe","title":"Usando Safe para configura\u00e7\u00f5es Multisig","text":"<p>Para contas Safe, use o Construtor de transa\u00e7\u00f5es com estes endere\u00e7os:</p> MainNet <pre><code>0x7133415b33B438843D581013f98A08704316633c\n</code></pre> TestNet (Sepolia) <pre><code>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401\n</code></pre> <p>Finalmente, escolha a fun\u00e7\u00e3o optOut, insira o <code>TANSSI_NETWORK_ADDRESS</code> no qual seu n\u00f3 est\u00e1 atualmente registrado (<code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code> para Tanssi MainNet e <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> para TestNet) e assine a transa\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-status","title":"Verificando seu status de cancelamento","text":"<p>Ap\u00f3s enviar a transa\u00e7\u00e3o de cancelamento, \u00e9 importante confirmar se a a\u00e7\u00e3o foi bem-sucedida e se seu operador n\u00e3o est\u00e1 mais inscrito na rede. Voc\u00ea pode verificar esse status usando os m\u00e9todos descritos abaixo.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-etherscan","title":"Usando Etherscan para verificar","text":"<p>Voc\u00ea pode verificar seu status de cancelamento no Etherscan consultando o contrato inteligente:</p> MainNet <pre><code>[Endere\u00e7o do contrato: 0x7133415b33B438843D581013f98A08704316633c](https://etherscan.io/address/0x7133415b33B438843D581013f98A08704316633c#readContract){target=\\\\_blank}\n</code></pre> TestNet (Sepolia) <pre><code>[Endere\u00e7o do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401](https://sepolia.etherscan.io/address/0x58973d16FFA900D11fC22e5e2B6840d9f7e13401#readContract){target=\\\\_blank}\n</code></pre> <p>Na p\u00e1gina do contrato:</p> <ol> <li>Certifique-se de selecionar a guia Ler contrato</li> <li>Localize e expanda a fun\u00e7\u00e3o isOptedIn</li> <li>Cole o endere\u00e7o da conta do seu operador no campo who.</li> <li>Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Se voc\u00ea estiver cancelando a participa\u00e7\u00e3o da Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code></li> <li>Clique em Consultar</li> </ol> <p></p> <p>Voc\u00ea obter\u00e1 um resultado <code>false</code> se seu operador tiver cancelado a participa\u00e7\u00e3o com sucesso e <code>true</code> se ele ainda estiver participando.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#verify-opt-out-cli","title":"Usando a CLI Symbiotic para verificar","text":"<p>Voc\u00ea tamb\u00e9m pode verificar seu status de cancelamento usando a CLI Symbiotic:</p> MainNet <pre><code>```bash\npython3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3\n```\n</code></pre> TestNet (Sepolia) <pre><code>```bash\npython3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4\n```\n</code></pre> <p>A sa\u00edda mostrar\u00e1 <code>false</code> se voc\u00ea tiver cancelado a participa\u00e7\u00e3o com sucesso e <code>true</code> se voc\u00ea ainda estiver participando.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#contact-tanssi-team","title":"Entre em contato com a equipe Tanssi","text":"<p>Ap\u00f3s o cancelamento da rede, a pr\u00f3xima etapa do cancelamento do seu operador Tanssi envolve a notifica\u00e7\u00e3o formal da equipe Tanssi. Esta p\u00e1gina o orienta sobre como enviar o formul\u00e1rio de cancelamento necess\u00e1rio e explicar o que esperar durante o processo de remo\u00e7\u00e3o final.</p> <p>Ap\u00f3s cancelar a participa\u00e7\u00e3o da rede, notifique a equipe Tanssi sobre sua inten\u00e7\u00e3o de parar de executar um operador. Para fazer isso, preencha o formul\u00e1rio de cancelamento do operador e aguarde a confirma\u00e7\u00e3o da conclus\u00e3o da solicita\u00e7\u00e3o da equipe Tanssi.</p> <p>Ap\u00f3s receber sua solicita\u00e7\u00e3o, a remo\u00e7\u00e3o do seu operador ser\u00e1 agendada. Esta etapa \u00e9 semiautom\u00e1tica e pode levar algum tempo para ser conclu\u00edda. Voc\u00ea ser\u00e1 notificado por e-mail quando for seguro desativar o n\u00f3. Por favor, n\u00e3o desative seu n\u00f3 at\u00e9 receber essa notifica\u00e7\u00e3o.</p> <p>Fornecer feedback</p> <p>Considere fornecer feedback no formul\u00e1rio de cancelamento sobre sua experi\u00eancia para ajudar a melhorar a rede Tanssi.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#pause-operations","title":"Pausar opera\u00e7\u00f5es (opcional)","text":"<p>Assim que receber a confirma\u00e7\u00e3o da remo\u00e7\u00e3o do seu operador pela equipe Tanssi, voc\u00ea poder\u00e1 parar com seguran\u00e7a quaisquer servi\u00e7os em execu\u00e7\u00e3o relacionados ao seu operador. Se necess\u00e1rio, fa\u00e7a backup de arquivos de configura\u00e7\u00e3o importantes, logs ou quaisquer dados relevantes antes de exclu\u00ed-los. Em seguida, voc\u00ea pode reaproveitar, encerrar ou desligar toda a sua infraestrutura.</p>"},{"location":"pt/node-operators/operators/offboarding/opt-out-from-tanssi/#next-steps-vault-opt-out","title":"Pr\u00f3ximas etapas (opcional)","text":"<p>Depois de cancelar a participa\u00e7\u00e3o da rede e informar a equipe Tanssi enviando o formul\u00e1rio de cancelamento, voc\u00ea pode realizar uma etapa opcional adicional e cancelar a participa\u00e7\u00e3o de quaisquer cofres espec\u00edficos com os quais seu operador possa estar associado.</p>"},{"location":"pt/node-operators/operators/offboarding/prerequisites/","title":"Pr\u00e9-requisitos para Offboarding","text":""},{"location":"pt/node-operators/operators/offboarding/prerequisites/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>O offboarding de operador \u00e9 o processo formal pelo qual os operadores de n\u00f3s saem do protocolo Tanssi de forma segura e transparente. Ele garante a integridade, seguran\u00e7a e estabilidade da rede, fornecendo etapas claras para os operadores que desejam deixar de participar.</p> <p>Os operadores desempenham um papel cr\u00edtico no consenso e nas opera\u00e7\u00f5es da rede. Desligar abruptamente um n\u00f3 sem seguir os procedimentos adequados pode impactar negativamente os operadores, potencialmente resultando em slashing.</p> <p>Este guia descreve os pr\u00e9-requisitos para o offboarding, e guias subsequentes o guiar\u00e3o pelo processo.</p> <p>Se voc\u00ea tiver d\u00favidas durante qualquer parte do processo de offboarding, a equipe da Tanssi pode te ajudar no Discord.</p>"},{"location":"pt/node-operators/operators/offboarding/prerequisites/#prerequisites","title":"Pr\u00e9-requisitos","text":"<p>Antes de iniciar o processo de offboarding, certifique-se de ter o seguinte:</p> <ul> <li>Acesso \u00e0 carteira Ethereum (EVM) que controla sua conta de operador</li> <li>ETH suficiente em sua carteira para cobrir as taxas de g\u00e1s para as transa\u00e7\u00f5es</li> </ul>"},{"location":"pt/node-operators/operators/offboarding/prerequisites/#why-smart-contracts","title":"Por que a intera\u00e7\u00e3o com contratos inteligentes \u00e9 necess\u00e1ria","text":"<p>Como muitos sistemas descentralizados, o protocolo Tanssi utiliza contratos inteligentes na blockchain Ethereum para gerenciar opera\u00e7\u00f5es cr\u00edticas, incluindo registro e staking de operador. Quando um operador decide sair, ele muda seu status e relacionamento com esses contratos principais do protocolo. As principais etapas de offboarding, como sinalizar sua inten\u00e7\u00e3o de sair ou cancelar formalmente o registro, envolvem transa\u00e7\u00f5es que atualizam o estado registrado nesses contratos inteligentes.</p>"},{"location":"pt/node-operators/operators/offboarding/prerequisites/#metodos-de-interacao","title":"M\u00e9todos de intera\u00e7\u00e3o","text":"<p>Existem v\u00e1rias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configura\u00e7\u00f5es multisig</li> </ul> <p>Em todos os casos, voc\u00ea precisar\u00e1 assinar a transa\u00e7\u00e3o com a conta que pretende usar para o n\u00f3. Voc\u00ea pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (n\u00e3o recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A se\u00e7\u00e3o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua op\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/offboarding/prerequisites/#set-up-the-cli","title":"Configurar o Symbiotic CLI","text":"<p>O Symbiotic CLI \u00e9 uma ferramenta para interagir com os contratos principais do Symbiotic. Ele \u00e9 escrito em Python, portanto voc\u00ea precisar\u00e1 instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas depend\u00eancias:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instala\u00e7\u00e3o foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos dispon\u00edveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/","title":"Exclus\u00e3o Volunt\u00e1ria de Vault (Opcional)","text":""},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Esta p\u00e1gina detalha a etapa final opcional no processo de desativa\u00e7\u00e3o de Tanssi: a exclus\u00e3o volunt\u00e1ria de um vault espec\u00edfico. Embora n\u00e3o seja obrigat\u00f3ria, esta a\u00e7\u00e3o permite que os operadores desassocie as suas contas de vaults individuais. Antes de prosseguir com esta etapa, certifique-se de ter cumprido todas as condi\u00e7\u00f5es descritas no nosso guia de pr\u00e9-requisitos.</p> <p>Este guia fornece instru\u00e7\u00f5es sobre como cancelar a inscri\u00e7\u00e3o usando um dos v\u00e1rios m\u00e9todos dispon\u00edveis e como verificar a conclus\u00e3o bem-sucedida desta a\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#opting-out-of-a-vault","title":"Cancelamento de inscri\u00e7\u00e3o num Vault","text":"<p>Para prosseguir com a exclus\u00e3o de um vault, pode usar um dos m\u00e9todos detalhados nas se\u00e7\u00f5es a seguir.</p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-cli","title":"Usando a CLI Symbiotic","text":"<p>Usando um dispositivo Ledger:</p> MainNet <pre><code>    ```bash\n\npython3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n\n    ```\n</code></pre> TestNet (Sepolia) <p>```bash</p> <p>````</p> <pre><code>```\n</code></pre> <p>python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS <code>````  Para assinar com uma chave privada:</code>bash </p> MainNet <p>```</p> <p><code>```bash python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY     ```bash</code>     ``` </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia opt-out-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY  ```</code> </p> <p>Aten\u00e7\u00e3o</p> <p>Observe que este m\u00e9todo requer que voc\u00ea exponha sua chave privada; portanto, n\u00e3o \u00e9 recomendado. </p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-etherscan","title":"Usando o Etherscan","text":"<p>Acesse o contrato atrav\u00e9s do Etherscan: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891](https://etherscan.io/address/0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891#writeContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p><code>[Endere\u00e7o do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351](https://sepolia.etherscan.io/address/0x95CC0a052ae33941877c9619835A233D21D57351#writeContract){target=\\_blank}</code>  Certifique-se de selecionar Contrato e Escrever Contrato, depois clique em Conectar \u00e0 Web3 e selecione sua carteira preferida (por exemplo, MetaMask):   1. Expanda a fun\u00e7\u00e3o optOut 2. Insira o <code>VAULT_ADDRESS</code> no campo where (por exemplo, <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet) 3. Clique em Escrever e assine a transa\u00e7\u00e3o   </p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#opt-out-vault-with-safe","title":"Usando o Safe","text":"<p>Para contas Safe, use estes endere\u00e7os de contrato no Transaction Builder: </p> MainNet <p><code>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</code> </p> TestNet (Sepolia) <p><code>0x95CC0a052ae33941877c9619835A233D21D57351</code>  Finalmente, escolha a fun\u00e7\u00e3o optOut, insira o <code>VAULT_ADDRESS</code> ao qual o seu n\u00f3 est\u00e1 atualmente registrado (por exemplo, <code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet) e assine a transa\u00e7\u00e3o. </p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#verify-vault-opt-out-status","title":"Verificar o Status de Exclus\u00e3o de Vault","text":"<p>Depois de enviar a transa\u00e7\u00e3o de exclus\u00e3o de vault, pode verificar o seu status de exclus\u00e3o usando um dos m\u00e9todos nas se\u00e7\u00f5es a seguir. </p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#usando-o-etherscan","title":"Usando o Etherscan","text":"<p>Pode verificar o status de exclus\u00e3o do seu vault no Etherscan: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891](https://etherscan.io/address/0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891#readContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p><code>[Endere\u00e7o do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351](https://sepolia.etherscan.io/address/0x95CC0a052ae33941877c9619835A233D21D57351#readContract){target=\\_blank}</code> <code>bash</code>  1. Selecione a fun\u00e7\u00e3o isOptedIn 2. Cole a conta do seu operador no campo who <code>bash 3. Clique em **Consultar**</code>  Voc\u00ea obter\u00e1 um resultado <code>false</code> se o seu operador tiver cancelado com sucesso o vault e <code>true</code> se ainda estiver inscrito.   </p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#usando-a-cli-symbiotic","title":"Usando a CLI Symbiotic","text":"<p>Pode tamb\u00e9m verificar o status de exclus\u00e3o do seu vault usando a CLI Symbiotic: </p> MainNet <p><code>```bash  python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS  ```</code> </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482  ```</code></p> <p>A sa\u00edda mostrar\u00e1 <code>false</code> se voc\u00ea tiver cancelado com sucesso o vault e <code>true</code> se ainda estiver inscrito.</p>"},{"location":"pt/node-operators/operators/offboarding/vault-opt-out/#proximos-passos","title":"Pr\u00f3ximos passos","text":"<p>Depois de concluir o processo de desativa\u00e7\u00e3o, se pretende voltar no futuro, pode seguir o processo de ativa\u00e7\u00e3o novamente.</p>"},{"location":"pt/node-operators/operators/onboarding/","title":"Onboarding","text":"<p>Um dos principais pilares da Tanssi para construtores \u00e9 que ela fornece seguran\u00e7a econ\u00f4mica de n\u00edvel Ethereum para cada rede com tecnologia Tanssi, independentemente de seu TVL, base de usu\u00e1rios ou detalhes do caso de uso. O design da Tanssi oferece aos desenvolvedores um modelo de seguran\u00e7a compartilhado, livrando-os de ter que obter seguran\u00e7a econ\u00f4mica suficiente ou negociar com operadores para executar n\u00f3s optando por suas redes.</p> <p>O protocolo Tanssi consegue isso integrando-se a provedores de seguran\u00e7a externos, como o Symbiotic. Nesse modelo, diferentes cofres associados \u00e0 Tanssi fornecem seguran\u00e7a econ\u00f4mica, e operadores confi\u00e1veis fornecem servi\u00e7os de valida\u00e7\u00e3o \u00e0 rede Tanssi.</p> <p>Siga estas etapas para configurar seu n\u00f3 e preparar sua conta para participa\u00e7\u00e3o ativa no protocolo Tanssi.</p> <p>Execute um n\u00f3 operador</p> <p>Configure o n\u00f3 usando Systemd ou Docker.</p> <p>Registrar no Symbiotic</p> <p>Adicione sua conta ao registro de operadores do Symbiotic. Esse registro \u00e9 o ponto central para identificar operadores dentro do ecossistema Symbiotic.</p> <p>Fazer opt-in na Tanssi Network</p> <p>Adicione sua conta ao registro de operadores da rede Tanssi. Esse registro \u00e9 o ponto central para identificar operadores que participam do protocolo Tanssi.</p> <p>Fazer opt-in em um cofre habilitado para Tanssi</p> <p>Adicione sua conta a um cofre habilitado para Tanssi. Operadores devem fazer opt-in (e serem admitidos) em um cofre que gerencia e delega os ativos em stake aos operadores.</p> <p>Preencha o formul\u00e1rio de inscri\u00e7\u00e3o</p> <p>Preencha o formul\u00e1rio para se candidatar como operador. Como esta etapa n\u00e3o \u00e9 totalmente automatizada, o processamento pode levar at\u00e9 uma semana.</p> <p>Configure sua conta</p> <p>Associe sua conta ao seu n\u00f3 para come\u00e7ar a validar no protocolo Tanssi.</p> <p>Configure uma identidade on-chain</p> <p>Defina uma identidade para melhorar a visibilidade e o reconhecimento da conta Substrate do seu operador.</p> <p>Depois de totalmente integrado, confira as tarefas operacionais relacionadas \u00e0 manuten\u00e7\u00e3o do seu n\u00f3.</p>"},{"location":"pt/node-operators/operators/onboarding/#explore-esta-secao","title":"Explore Esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/onboarding/account-setup/","title":"Configure sua Conta para Proteger o Ecossistema Tanssi","text":""},{"location":"pt/node-operators/operators/onboarding/account-setup/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Como apresentado na se\u00e7\u00e3o de integra\u00e7\u00e3o, assim que voc\u00ea optar com sucesso para um cofre habilitado para Tanssi, optar para a rede Tanssi, e preencher o formul\u00e1rio de inscri\u00e7\u00e3o, esta \u00e9 a sexta etapa do processo. Ap\u00f3s esta etapa, seu n\u00f3 estar\u00e1 apto a participar do protocolo Tanssi.</p> <p>Nesta etapa, voc\u00ea mapear\u00e1 sua conta de stash do Substrate (a que acompanha suas recompensas) para as chaves de sess\u00e3o do seu n\u00f3 (aquelas utilizadas para comunica\u00e7\u00e3o e consenso), permitindo que o protocolo inclua seu n\u00f3 no conjunto ativo.</p> <p>Este guia te orienta na gera\u00e7\u00e3o de chaves de sess\u00e3o para o seu n\u00f3, mapeando-as para sua conta atrav\u00e9s do portal do desenvolvedor Tanssi e verificando se a associa\u00e7\u00e3o foi estabelecida corretamente.</p>"},{"location":"pt/node-operators/operators/onboarding/account-setup/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Antes de configurar sua conta, certifique-se de que:</p> <ul> <li>Voc\u00ea tem um n\u00f3 corretamente configurado e em execu\u00e7\u00e3o</li> <li>Voc\u00ea se registrou como operador no registro Symbiotic</li> <li>Voc\u00ea optou pela Rede Tanssi e um cofre habilitado para Tanssi</li> </ul>"},{"location":"pt/node-operators/operators/onboarding/account-setup/#map-account","title":"Mapear uma Conta para Seu N\u00f3","text":"<p>A primeira etapa \u00e9 um processo de duas etapas que gera e mapeia as chaves de sess\u00e3o para sua conta. Chaves de sess\u00e3o podem ser comparadas ao ID do n\u00f3, e s\u00e3o usadas para executar opera\u00e7\u00f5es na rede, como assinar provas de validade, enquanto sua conta acompanha seu trabalho e recompensas relacionadas, e pode ter uma identidade na cadeia.</p> <p>Voc\u00ea precisar\u00e1 criar chaves de sess\u00e3o para seus servidores principal e de backup. Cada servidor deve ter suas pr\u00f3prias chaves exclusivas. Como as chaves nunca saem de seus servidores, voc\u00ea pode consider\u00e1-las um ID exclusivo para aquele servidor.</p>"},{"location":"pt/node-operators/operators/onboarding/account-setup/#generate-session-keys","title":"Gerar Chaves de Sess\u00e3o","text":"<p>Para gerar chaves de sess\u00e3o, envie uma chamada RPC usando o m\u00e9todo <code>author_rotateKeys</code> para o endpoint HTTP do seu n\u00f3. Para refer\u00eancia, se o endpoint HTTP do seu n\u00f3 estiver na porta <code>9944</code>, a chamada JSON-RPC pode ser assim:</p> <pre><code>\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{  \n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Suas chaves de sess\u00e3o codificadas em hexadecimal ser\u00e3o impressas no terminal no campo <code>\"result\"</code>.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":    \"0xca17757962a065eeebec2c6e0d2dc7fb24b56967fd9003e4d22bf4981da86fd4ac7cd701462730a76ab539d5a48f4fd2821acf07743335e56eef84d1544686480ada0ff0f38dfccee43515e619e03b0de95a08c74fcbb2da26af55ad144d5f54829a57d7d77bb9333cf9301eaa5d20c384f67388f36b402e33a03b949148325e80b812699fb22d9e4b4976e1d0e9964034489cb0b5b6b70c37d227fb54ffe50b444434b488361038b8b6949c36f0073c6bd52f2907c0991e32257d96bb946c590320539c343fc1f2e1dd1951a0ff38c6c9ea2f93a263e81ee95da1de0697e47e32\"} <p>Nota</p> <p>Certifique-se de anotar suas chaves de sess\u00e3o. Na pr\u00f3xima se\u00e7\u00e3o, voc\u00ea precisar\u00e1 mape\u00e1-las para sua conta.</p>"},{"location":"pt/node-operators/operators/onboarding/account-setup/#map-session-keys","title":"Mapear Chaves de Sess\u00e3o","text":"<p>Para executar a etapa seguinte e mapear suas chaves de sess\u00e3o para sua conta, abra o portal do desenvolvedor e v\u00e1 para a aba Desenvolvedor, se\u00e7\u00e3o Extrinsics. O seguinte link o levar\u00e1 diretamente para l\u00e1:</p> Tanssi MainNet <pre><code>[Portal do desenvolvedor da Mainnet](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-mainnet.network/tanssi#/extrinsics){target=\\_blank}\n</code></pre> Dancelight TestNet <pre><code>[Portal do desenvolvedor da TestNet](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/extrinsics){target=\\_blank}\n</code></pre> <p>Agora, siga estas etapas:</p> <ol> <li>Selecione sua conta, que deve ser a mesma conta que voc\u00ea registrou com a Tanssi anteriormente</li> <li>Selecione o m\u00f3dulo session e a extr\u00ednseca setKeys</li> <li>Para keys, insira suas chaves de sess\u00e3o</li> <li>Para proof, insira <code>0x</code></li> <li>Clique em Enviar Transa\u00e7\u00e3o e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p>"},{"location":"pt/node-operators/operators/onboarding/account-setup/#verify-keys-mapping","title":"Verifique o Mapeamento das Chaves","text":"<p>Usar o m\u00e9todo <code>session.keyOwner</code> permite verificar se suas chaves de sess\u00e3o foram mapeadas para sua conta conforme o esperado. Este m\u00e9todo \u00e9 acess\u00edvel atrav\u00e9s do portal do desenvolvedor, na aba Desenvolvedor, se\u00e7\u00e3o Chain state. O link a seguir o levar\u00e1 direto para l\u00e1:</p> Tanssi MainNet <pre><code>[Portal do desenvolvedor da Mainnet](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-mainnet.network/tanssi#/chainstate){target=\\_blank}\n</code></pre> Dancelight TestNet <pre><code>[Portal do desenvolvedor da TestNet](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\\_blank}\n</code></pre> <p>Agora, siga estas etapas:</p> <ol> <li>Selecione o m\u00f3dulo session e o query keyOwner</li> <li>Insira <code>gran</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira os primeiros sessenta e seis caracteres codificados em hexadecimal de suas chaves de sess\u00e3o (por exemplo, <code>0x00a12170e0925a9bf98f31bbdd7988550c1bf587766a2d2735e969aa5b4291dc</code>)</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A conta associada \u00e0s chaves de sess\u00e3o, que deve ser sua conta, ser\u00e1 exibida na parte inferior da p\u00e1gina</li> </ol> <p></p> <p>E \u00e9 isso! Voc\u00ea mapeou sua conta com sucesso, e seu n\u00f3 agora est\u00e1 qualificado para participar do protocolo.</p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/","title":"Optar para Tanssi","text":""},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Ap\u00f3s registrar com sucesso seu n\u00f3 no protocolo Symbiotic, as etapas seguintes s\u00e3o optar tanto pelos cofres habilitados para Tanssi quanto pela pr\u00f3pria rede Tanssi. Como apresentado na se\u00e7\u00e3o de integra\u00e7\u00e3o, estas s\u00e3o a terceira e a quarta etapas.</p> <p>Este guia ir\u00e1 orient\u00e1-lo pelas etapas para optar com sucesso por um cofre habilitado para Tanssi e pela rede Tanssi, permitindo que voc\u00ea escolha entre v\u00e1rios m\u00e9todos, incluindo o uso do Symbiotic CLI, a intera\u00e7\u00e3o direta com contratos inteligentes por meio do Etherscan ou a utiliza\u00e7\u00e3o do Safe para configura\u00e7\u00f5es multisig.</p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Antes de optar por um cofre habilitado para Tanssi e pela rede Tanssi, certifique-se de que:</p> <ul> <li>Voc\u00ea tem um n\u00f3 corretamente configurado e em execu\u00e7\u00e3o</li> <li>Voc\u00ea se registrou como operador no registro Symbiotic</li> </ul> <p>Para seguir este guia, voc\u00ea deve interagir com contratos inteligentes, um do protocolo central da Symbiotic e o outro da integra\u00e7\u00e3o da Tanssi com a Symbiotic.</p> <p>Existem v\u00e1rias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configura\u00e7\u00f5es multisig</li> </ul> <p>Em todos os casos, voc\u00ea precisar\u00e1 assinar a transa\u00e7\u00e3o com a conta que pretende usar para o n\u00f3. Voc\u00ea pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (n\u00e3o recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A se\u00e7\u00e3o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua op\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#set-up-the-cli","title":"Configurar o Symbiotic CLI","text":"<p>O Symbiotic CLI \u00e9 uma ferramenta para interagir com os contratos principais do Symbiotic. Ele \u00e9 escrito em Python, portanto voc\u00ea precisar\u00e1 instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas depend\u00eancias:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instala\u00e7\u00e3o foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos dispon\u00edveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults","title":"Optar por Cofres Habilitados para Tanssi","text":"<p>Antes de habilitar seu operador para estar ativo dentro da rede Tanssi, voc\u00ea deve optar por pelo menos um dos cofres habilitados para Tanssi. As se\u00e7\u00f5es a seguir descrevem v\u00e1rias maneiras de optar pelos cofres.</p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-cli","title":"Optar Usando a Symbiotic CLI","text":"<p>Se voc\u00ea instalou corretamente o Symbiotic CLI e deseja assinar a transa\u00e7\u00e3o usando um dispositivo Ledger, execute o seguinte comando, substituindo <code>INSERT_VAULT_ADDRESS</code> pelo endere\u00e7o espec\u00edfico que voc\u00ea deseja ingressar e <code>INSERT_OPERATOR_ADDRESS</code> pela sua conta:</p> MainNet <pre><code>    ```bash\n\npython3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n\n    ```\n</code></pre> TestNet (Sepolia) <p>```bash</p> <p>````</p> <pre><code>```\n</code></pre> <p>python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --ledger --ledger-account INSERT_OPERATOR_ADDRESS <code>````  Se voc\u00ea deseja assinar a transa\u00e7\u00e3o diretamente usando a chave privada da conta do operador, execute o seguinte comando, substituindo o par\u00e2metro `INSERT_PRIVATE_KEY`:</code>bash </p> MainNet <p>```</p> <p><code>```bash python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY     ```bash</code>     ``` </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia opt-in-vault 0xB94f8852443FB4faB18363D22a45cA64a8CF4482 --private-key INSERT_PRIVATE_KEY  ```</code> </p> <p>Aten\u00e7\u00e3o</p> <p>Observe que este m\u00e9todo exige que voc\u00ea exponha sua chave privada; portanto, n\u00e3o \u00e9 recomendado. </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-etherscan","title":"Optar Usando o Etherscan","text":"<p>Voc\u00ea pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transa\u00e7\u00e3o usando uma carteira de navegador (MetaMask, por exemplo).  Para abrir a p\u00e1gina do contrato, abra o link: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891](https://etherscan.io/address/0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891#writeContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p><code>[Endere\u00e7o do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351](https://sepolia.etherscan.io/address/0x95CC0a052ae33941877c9619835A233D21D57351#writeContract){target=\\_blank}</code>  Clique em Conectar ao Web3 e selecione sua carteira preferida (por exemplo, MetaMask):   </p> <p>Nota</p> <p>Voc\u00ea pode configurar o MetaMask para usar uma carteira fria. </p> <p>Ap\u00f3s a conex\u00e3o:  1. Expanda a fun\u00e7\u00e3o <code>optin</code> 2. Insira o <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet) 3. Clique em Escrever e assine a transa\u00e7\u00e3o   </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults-with-safe","title":"Optar Usando o Safe para Configura\u00e7\u00f5es Multisig","text":"<p>Se voc\u00ea tiver uma conta Safe, abra o Construtor de transa\u00e7\u00f5es e insira o seguinte endere\u00e7o do contrato: </p> MainNet <p><code>0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891</code> </p> TestNet (Sepolia) <p><code>0x95CC0a052ae33941877c9619835A233D21D57351</code>  Finalmente, escolha a fun\u00e7\u00e3o <code>optin</code>, insira o <code>VAULT_ADDRESS</code> (<code>0xB94f8852443FB4faB18363D22a45cA64a8CF4482</code> no Sepolia TestNet) e assine a transa\u00e7\u00e3o. </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#check-vault-registration","title":"Verificar o Status do Registro","text":"<p>Voc\u00ea pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891](https://etherscan.io/address/0xb361894bC06cbBA7Ea8098BF0e32EB1906A5F891#readContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p>```bash</p> <p>Endere\u00e7o do contrato: 0x95CC0a052ae33941877c9619835A233D21D57351 <code>Na p\u00e1gina do contrato:</code>bash 1. Cole a conta do seu operador no campo who <code>``  2. Clique em **Pesquisar**  Voc\u00ea obter\u00e1 um resultado</code>true<code>se seu operador foi registrado corretamente e</code>false<code>caso contr\u00e1rio.  ![Verificar o status do registro](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-3.webp)  Voc\u00ea tamb\u00e9m pode verificar o status do seu registro usando o Symbiotic CLI executando o seguinte comando, que imprime</code>true<code>ou</code>false` para qualquer endere\u00e7o de operador em um cofre habilitado para Tanssi: </p> MainNet <p><code>```bash  python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS  ```</code> </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS 0xB94f8852443FB4faB18363D22a45cA64a8CF4482  ```</code> <code>bash E a sa\u00edda se parece com:</code> python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS Connected to chain ID 1 <code>bash     &lt;br&gt;</code>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi","title":"Optar para a Rede Tanssi","text":"<p>Antes de habilitar seu operador para estar ativo na rede Tanssi, voc\u00ea deve optar pela rede e ser aprovado pela equipe Tanssi. As se\u00e7\u00f5es a seguir descrevem v\u00e1rias maneiras de optar pela rede.      <code>bash O endere\u00e7o da Rede Tanssi MainNet ser\u00e1 divulgado no lan\u00e7amento.</code> </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-cli","title":"Optar Usando a Symbiotic CLI","text":"<p>Se voc\u00ea instalou corretamente o Symbiotic CLI e deseja assinar a transa\u00e7\u00e3o usando um dispositivo Ledger, execute o seguinte comando, substituindo <code>INSERT_OPERATOR_ADDRESS</code>:      ```bash</p> MainNet <p>``` </p> <p><code>```bash  python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --ledger --ledger-account INSERT_OPERATOR_ADDRESS  ```</code> </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --ledger --ledger-account INSERT_OPERATOR_ADDRESS  ```</code>  Se voc\u00ea deseja assinar a transa\u00e7\u00e3o diretamente usando a chave privada da conta do operador, execute o seguinte comando, substituindo o par\u00e2metro <code>INSERT_PRIVATE_KEY</code>: </p> MainNet <p><code>```bash  python3 symb.py opt-in-network 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3 --private-key INSERT_PRIVATE_KEY  ```</code> </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia opt-in-network 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 --private-key INSERT_PRIVATE_KEY  ```</code> </p> <p>Aten\u00e7\u00e3o</p> <p>Observe que este m\u00e9todo exige que voc\u00ea exponha sua chave privada; portanto, n\u00e3o \u00e9 recomendado. </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-etherscan","title":"Optar Usando o Etherscan","text":"<p>Voc\u00ea pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transa\u00e7\u00e3o usando uma carteira de navegador (MetaMask, por exemplo). V\u00e1 para a p\u00e1gina do contrato abrindo o link: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0x7133415b33B438843D581013f98A08704316633c](https://etherscan.io/address/0x7133415b33B438843D581013f98A08704316633c#writeContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p><code>[Endere\u00e7o do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401](https://sepolia.etherscan.io/address/0x58973d16FFA900D11fC22e5e2B6840d9f7e13401#writeContract){target=\\_blank}</code>  Clique em Conectar ao Web3 e selecione sua carteira preferida (por exemplo, MetaMask):   </p> <p>Nota</p> <p>Voc\u00ea pode configurar o MetaMask para usar uma carteira fria. </p> <p>Ap\u00f3s a conex\u00e3o:  1. Expanda a fun\u00e7\u00e3o <code>optin</code> 2. Insira o <code>TANSSI_NETWORK_ADDRESS</code>. Se voc\u00ea estiver optando pela Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> 3. Clique em Escrever e assine a transa\u00e7\u00e3o   </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-with-safe","title":"Optar Usando o Safe para Configura\u00e7\u00f5es Multisig","text":"<p>Se voc\u00ea tiver uma conta Safe, abra o Construtor de transa\u00e7\u00f5es e insira o seguinte endere\u00e7o do contrato: </p> MainNet <p>```bash</p> <p>0x7133415b33B438843D581013f98A08704316633c     ``` </p> TestNet (Sepolia) <p>```bash</p> <p>0x58973d16FFA900D11fC22e5e2B6840d9f7e13401     <code>``  Finalmente, escolha a fun\u00e7\u00e3o **</code>optin<code>**, insira o endere\u00e7o da Rede Tanssi (</code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3<code>para Tanssi MainNet e</code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4` para TestNet) e assine a transa\u00e7\u00e3o. </p>"},{"location":"pt/node-operators/operators/onboarding/opt-in-to-tanssi/#check-tanssi-registration","title":"Verificar o Status do Registro","text":"<p>Voc\u00ea pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link: </p> MainNet <p><code>[Endere\u00e7o do contrato: 0x7133415b33B438843D581013f98A08704316633c](https://etherscan.io/address/0x7133415b33B438843D581013f98A08704316633c#readContract){target=\\_blank}</code> </p> TestNet (Sepolia) <p><code>[Endere\u00e7o do contrato: 0x58973d16FFA900D11fC22e5e2B6840d9f7e13401](https://sepolia.etherscan.io/address/0x58973d16FFA900D11fC22e5e2B6840d9f7e13401#readContract){target=\\_blank}</code>  Na p\u00e1gina do contrato:  1. Selecione a fun\u00e7\u00e3o <code>isOptedIn</code> 2. Cole a conta do seu operador no campo who 3. Insira o <code>TANSSI_NETWORK_ADDRESS</code> no campo where. Se voc\u00ea estiver optando pela Tanssi MainNet, use <code>0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3</code>. Para TestNet, use <code>0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4</code> 4. Clique em Pesquisar  Voc\u00ea obter\u00e1 um resultado <code>true</code> se seu operador foi registrado corretamente e <code>false</code> caso contr\u00e1rio.    Voc\u00ea tamb\u00e9m pode verificar o status do seu registro usando o Symbiotic CLI executando o seguinte comando, que imprime <code>true</code> ou <code>false</code> para qualquer endere\u00e7o de operador na Rede Tanssi: </p> MainNet <p><code>```bash  python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0x8c1a46D032B7b30D9AB4F30e51D8139CC3E85Ce3  ```</code> </p> TestNet (Sepolia) <p><code>```bash  python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4   ```</code></p> <p>E a sa\u00edda se parece com:</p> python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS 0xdaD051447C4452e15B35B7F831ceE8DEb890f1a4 Connected to chain ID 1 True <p>Nota</p> <p>Optar pelas Redes Tanssi requer aprova\u00e7\u00e3o da equipe Tanssi. Os pedidos para participar podem levar at\u00e9 uma semana.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/","title":"Registrar no Symbiotic","text":""},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Como apresentado na se\u00e7\u00e3o de integra\u00e7\u00e3o, registrar no Symbiotic \u00e9 o segundo passo do processo. Voc\u00ea j\u00e1 deve ter o n\u00f3 sincronizado e em execu\u00e7\u00e3o, seja usando Docker ou Systemd.</p> <p>O protocolo Tanssi fornece \u00e0s suas appchains seguran\u00e7a de n\u00edvel Ethereum desde o in\u00edcio, confiando em provedores externos como o Symbiotic. Para participar como operador no ecossistema Tanssi, voc\u00ea deve primeiro registrar seu n\u00f3 no protocolo Symbiotic. O processo de registro estabelece seu n\u00f3 como operador reconhecido.</p> <p>Este guia mostra as etapas para registrar seu n\u00f3 como operador Symbiotic, permitindo escolher entre v\u00e1rios m\u00e9todos: CLI Symbiotic, intera\u00e7\u00e3o direta via Etherscan ou uso do Safe para configura\u00e7\u00f5es multisig.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Antes de se registrar, certifique-se de j\u00e1 ter configurado o n\u00f3 e que ele esteja em execu\u00e7\u00e3o.</p> <p>Para seguir este guia, voc\u00ea dever\u00e1 interagir com contratos inteligentes. Existem v\u00e1rias formas de interagir com os contratos inteligentes:</p> <ul> <li>Usando o Symbiotic CLI</li> <li>Usando o Etherscan</li> <li>Usando o Safe para configura\u00e7\u00f5es multisig</li> </ul> <p>Em todos os casos, voc\u00ea precisar\u00e1 assinar a transa\u00e7\u00e3o com a conta que pretende usar para o n\u00f3. Voc\u00ea pode fazer isso de diferentes maneiras:</p> <ul> <li>Usando a chave privada da conta diretamente (n\u00e3o recomendado)</li> <li>Usando uma hot wallet, como o MetaMask</li> <li>Usando uma cold wallet, como o Ledger</li> </ul> <p>A se\u00e7\u00e3o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua op\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#set-up-the-cli","title":"Configurar o Symbiotic CLI","text":"<p>O Symbiotic CLI \u00e9 uma ferramenta para interagir com os contratos principais do Symbiotic. Ele \u00e9 escrito em Python, portanto voc\u00ea precisar\u00e1 instalar o interpretador Python e o pip, o instalador de pacotes do Python:</p> Linux (Ubuntu/Debian)MacOS <pre><code> sudo apt-get install python3 &amp;&amp; \\\n sudo apt install python3-pip\n</code></pre> <pre><code>brew install python3\n</code></pre> <p>Agora, com o Python instalado, baixe o Symbiotic CLI e suas depend\u00eancias:</p> <pre><code>git clone https://github.com/symbioticfi/cli.git &amp;&amp; \\\ncd cli &amp;&amp; \\\npip3 install -r requirements.txt\n</code></pre> <p>Execute o comando abaixo para verificar se a instala\u00e7\u00e3o foi bem-sucedida:</p> <pre><code>python3 symb.py --help\n</code></pre> <p>O terminal deve mostrar uma lista grande dos comandos dispon\u00edveis do CLI:</p> python3 symb.py --help Usage: symb.py [OPTIONS] COMMAND [ARGS]... Options: \u2003--chain CHAIN    Chain ID to use.  [default: mainnet] \u2003--provider TEXT  Ethereum provider URL [http(s)]. \u2003--help           Show this message and exit. Commands: \u2003active-balance-of\u2003\u2003\u2003\u2003\u2003\u2003\u2003Get an active balance of a given account... \u2003check-opt-in-network\u2003\u2003\u2002 Check if operator is opted in to a network. \u2003check-opt-in-vault\u2003\u2003\u2003\u2003\u2003\u2003Check if operator is opted in to a vault. \u2003claim\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Claim a withdrawal for some epoch at the... \u2003deposit\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Deposit to the vault. \u2003.......\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003.........."},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#registering-operator","title":"Registrar como Operador","text":"<p>O protocolo Symbiotic mant\u00e9m um registro de todos os operadores. Antes de proteger redes Tanssi, registre-se usando um dos m\u00e9todos abaixo.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#register-with-cli","title":"Registrar usando a CLI Symbiotic","text":"<p>Se voc\u00ea instalou a CLI Symbiotic e quer assinar com um dispositivo Ledger, execute o comando abaixo, substituindo <code>INSERT_OPERATOR_ADDRESS</code> pela sua conta:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS\n</code></pre> <p>Se preferir assinar diretamente com a chave privada da conta, execute (substitua <code>INSERT_PRIVATE_KEY</code>):</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <pre><code>python3 symb.py --chain sepolia register-operator --private-key INSERT_PRIVATE_KEY\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Este m\u00e9todo exige expor sua chave privada; n\u00e3o \u00e9 recomendado.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#register-with-etherscan","title":"Registrar usando o Etherscan","text":"<p>Voc\u00ea pode interagir com os contratos do Symbiotic pelo Etherscan e assinar com uma carteira de navegador (MetaMask, por exemplo).</p> <p>Abra a p\u00e1gina do contrato:</p> MainNetTestNet (Sepolia) <p>Endere\u00e7o do contrato: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Endere\u00e7o do contrato: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Clique em Conectar ao Web3 e selecione sua carteira preferida (por exemplo, MetaMask):</p> <p></p> <p>Nota</p> <p>Voc\u00ea pode configurar o MetaMask para usar uma carteira fria.</p> <p>Depois de conectado:</p> <ol> <li>Expanda a fun\u00e7\u00e3o <code>registerOperator</code></li> <li>Clique em Write e assine a transa\u00e7\u00e3o</li> </ol> <p></p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#register-with-safe","title":"Registrar usando o Safe para Multisig","text":"<p>Se voc\u00ea tiver uma conta Safe, abra o Transaction builder e insira o seguinte endere\u00e7o do contrato:</p> MainNetTestNet (Sepolia) <p>0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Por fim, escolha a fun\u00e7\u00e3o <code>registerOperator</code> e assine a transa\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#check-registration","title":"Verificar o status do registro","text":"<p>Voc\u00ea pode verificar rapidamente seu status de registro no Etherscan. Abra:</p> MainNetTestNet (Sepolia) <p>Endere\u00e7o do contrato: 0xAd817a6Bc954F678451A71363f04150FDD81Af9F</p> <p>Endere\u00e7o do contrato: 0x6F75a4ffF97326A00e52662d82EA4FdE86a2C548</p> <p>Na p\u00e1gina do contrato:</p> <ol> <li>Selecione a fun\u00e7\u00e3o <code>isEntity</code></li> <li>Cole a conta do seu operador</li> <li>Clique em Query</li> </ol> <p>Se o operador foi registrado corretamente, o resultado ser\u00e1 <code>true</code>; caso contr\u00e1rio, <code>false</code>.</p> <p></p> <p>Voc\u00ea tamb\u00e9m pode verificar o status via CLI Symbiotic, executando:</p> MainNetTestNet (Sepolia) <pre><code>python3 symb.py isop INSERT_OPERATOR_ADDRESS\n</code></pre> <pre><code>python3 symb.py --chain sepolia isop INSERT_OPERATOR_ADDRESS\n</code></pre> <p>E a sa\u00edda se parece com:</p> python3 symb.py isop INSERT_OPERATOR_ADDRESS Connected to chain ID 1 True"},{"location":"pt/node-operators/operators/onboarding/register-in-symbiotic/#submitting-metadata","title":"Enviar metadados","text":"<p>Ap\u00f3s o registro, voc\u00ea pode adicionar metadados (por exemplo, logotipo) para melhorar a visibilidade no site Symbiotic.</p> <p>Para enviar os metadados do operador, acesse o reposit\u00f3rio de metadados Symbiotic:</p> MainNet <p>Reposit\u00f3rio MainNet</p> <p>Crie um fork do reposit\u00f3rio e, no diret\u00f3rio <code>operators</code>, crie uma pasta com o endere\u00e7o do seu operador. Dentro dela, adicione <code>logo.png</code> e um arquivo <code>info.json</code> com os campos abaixo (substitua pelos seus valores):</p> info.json<pre><code>{\n    \"name\": \"INSERIR_SEU_NOME_DO_OPERADOR\",\n    \"description\": \"INSERIR_SUA_DESCRI\u00c7\u00c3O_DO_OPERADOR\",\n    \"tags\": [\n        \"operador\"\n    ],\n    \"links\": [\n        {\n            \"type\": \"website\",\n            \"name\": \"Website\",\n            \"url\": \"https://INSERIR_SEU_URL_DO_SITE\"\n        },\n        {\n            \"type\": \"website\",\n            \"name\": \"X\",\n            \"url\": \"https://INSERIR_SEU_URL_X\"\n        }\n    ]\n}\n</code></pre> <p>Nota</p> <p>O par\u00e2metro <code>links</code> \u00e9 um array. Adicione quantos links forem necess\u00e1rios.</p> <p>Por fim, abra um pull request. A equipe Symbiotic revisar\u00e1 e far\u00e1 o merge.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/","title":"Executar um N\u00f3 Operador","text":"<p>A configura\u00e7\u00e3o de um n\u00f3 operador \u00e9 um passo importante para participar da rede Tanssi. Voc\u00ea tem duas op\u00e7\u00f5es de configura\u00e7\u00e3o: usar Docker ou Systemd. Qualquer que seja o caminho que voc\u00ea escolher, fornecemos tutoriais passo a passo para gui\u00e1-lo pelo processo e garantir que seu n\u00f3 atenda aos requisitos necess\u00e1rios para validar as transa\u00e7\u00f5es da rede Tanssi e fornecer seguran\u00e7a ao ecossistema.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/#requisitos-de-hardware","title":"Requisitos de Hardware","text":"<p>Para executar um n\u00f3 operador com sucesso, hardware de alto desempenho \u00e9 essencial. Configura\u00e7\u00f5es sub\u00f3timas podem levar a atrasos, indisponibilidade e, por fim, perdas de recompensas e/ou penalidades. Como o processo de valida\u00e7\u00e3o depende muito do desempenho de um \u00fanico thread, \u00e9 recomend\u00e1vel priorizar CPUs com fortes capacidades de um \u00fanico thread em vez de contagens de n\u00facleos mais altas.</p> <p>Hardware recomendado:</p> <ul> <li>Configura\u00e7\u00e3o Recomendada - Hardware bare metal executando linux debian ou ubuntu</li> <li>CPUs Recomendadas - Intel Ice Lake ou mais recente (s\u00e9rie Xeon ou Core) ou AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito n\u00facleos f\u00edsicos @ 3,4 GHz com hyperthreading desativado (SMT para processadores AMD)</li> <li>NVMe Recomendado - SSD NVMe de 500 GB</li> <li>RAM Recomendada - 32 GB ECC RAM</li> <li>Rede Recomendada - Conex\u00e3o de 1 Gbps</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>Como operador, voc\u00ea \u00e9 respons\u00e1vel tanto pelo seu pr\u00f3prio stake quanto pelo de seus delegadores. Manter o desempenho do seu n\u00f3, mant\u00ea-lo atualizado e garantir sua seguran\u00e7a s\u00e3o cruciais para maximizar as recompensas e construir uma forte reputa\u00e7\u00e3o na rede Tanssi.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/#portas-de-rede-necessarias","title":"Portas de Rede Necess\u00e1rias","text":"<p>Um operador de sucesso deve ser capaz de sincronizar e interagir com uma rede ponto a ponto (P2P). Para garantir a comunica\u00e7\u00e3o adequada dentro do ecossistema Tanssi, certifique-se de que a seguinte porta esteja aberta para entrada:</p> Rede Porta Tanssi Chain 30333 (TCP)"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/","title":"Executar um N\u00f3 Operador Usando Docker","text":""},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Os operadores s\u00e3o fundamentais no ecossistema Tanssi, fornecendo seguran\u00e7a e valida\u00e7\u00e3o para redes baseadas em Tanssi. Como operador, voc\u00ea participa do consenso que protege a rede e ganha recompensas.</p> <p>Conforme apresentado na se\u00e7\u00e3o de integra\u00e7\u00e3o, executar o n\u00f3 \u00e9 o primeiro passo da sua participa\u00e7\u00e3o ativa no protocolo.</p> <p>Este guia mostra como iniciar um operador Tanssi usando a imagem oficial com Docker em sistemas Linux.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#checking-prerequisites","title":"Verificando Pr\u00e9-Requisitos","text":""},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#installing-docker","title":"Instalando o Docker","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instala\u00e7\u00e3o:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execu\u00e7\u00e3o bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#pull-docker-image","title":"Puxar a Imagem Docker","text":"<p>Uma imagem Docker \u00e9 constru\u00edda e publicada em cada vers\u00e3o, contendo todas as depend\u00eancias necess\u00e1rias e o bin\u00e1rio do operador.</p> <p>A imagem combina o bin\u00e1rio est\u00e1vel mais recente do n\u00f3 cliente com o arquivo de especifica\u00e7\u00e3o do orquestrador Tanssi.</p> <p>Execute o comando a seguir para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/starlight\n</code></pre> <pre><code>docker pull moondancelabs/starlight\n</code></pre> <p>O comando far\u00e1 download/extrair a imagem e exibir\u00e1 o status ap\u00f3s a execu\u00e7\u00e3o:</p> docker pull moondancelabs/starlight  Using default tag: latest      latest: Pulling from moondancelabs/starlight      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/starlight      docker.io/moondancelabs/starlight"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#set-up-data-directory","title":"Configure o diret\u00f3rio de dados","text":"<p>Executar um n\u00f3 requer sincronizar com a cadeia Tanssi e armazenar seu estado.</p> <p>Crie o diret\u00f3rio onde o n\u00f3 armazenar\u00e1 os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando a seguir se quiser rodar o n\u00f3 com o usu\u00e1rio atualmente logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diret\u00f3rio \u00e9 um par\u00e2metro no comando de inicializa\u00e7\u00e3o do Docker. Se decidir cri\u00e1-lo em outro lugar, ajuste o comando.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#generate-node-key","title":"Gerar a Chave do N\u00f3","text":"<p>Para gerar e armazenar as chaves de sess\u00e3o em disco (referenciadas no comando de inicializa\u00e7\u00e3o), execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#start-your-node","title":"Inicie Seu N\u00f3","text":"<p>Para iniciar seu n\u00f3, execute a imagem Docker com <code>docker run</code>.</p> <p>Substitua <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome leg\u00edvel e <code>INSERT_YOUR_IP_ADDRESS</code> pelo IP p\u00fablico.</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>As flags do <code>docker run</code> podem ser ajustadas conforme prefer\u00eancias e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mant\u00e9m todos os dados de estado (necess\u00e1rio para consultas hist\u00f3ricas)</li> <li>--blocks-pruning=archive - mant\u00e9m todos os blocos (necess\u00e1rio para dados hist\u00f3ricos de blocos)</li> <li>--database=paritydb - usa ParityDB como backend otimizado para desempenho do n\u00f3 RPC</li> <li>--unsafe-rpc-external - permite conex\u00f5es externas ao RPC; requer medidas adicionais de seguran\u00e7a (proxy reverso, autentica\u00e7\u00e3o, firewall)</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>A flag <code>--unsafe-rpc-external</code> exp\u00f5e seu n\u00f3 RPC externamente. Em produ\u00e7\u00e3o, proteja com firewall, proxy reverso, autentica\u00e7\u00e3o e limita\u00e7\u00e3o de taxa.</p> <p>Voc\u00ea pode visualizar todas as flags dispon\u00edveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre> <pre><code>docker run -ti moondancelabs/starlight --help\n</code></pre>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-docker/#syncing-your-node","title":"Sincronizando Seu N\u00f3","text":"<p>Na primeira execu\u00e7\u00e3o, o processo de sincroniza\u00e7\u00e3o exibir\u00e1 muitos logs do n\u00f3 e da cadeia sendo sincronizada. Alguns erros iniciais s\u00e3o esperados e desaparecem quando a cadeia alcan\u00e7a o \u00faltimo bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>Quando a sincroniza\u00e7\u00e3o terminar, seu n\u00f3 estar\u00e1 pronto para as pr\u00f3ximas etapas.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/","title":"Executar um N\u00f3 Operador Usando Systemd","text":""},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Os operadores s\u00e3o cruciais no ecossistema Tanssi, fornecendo seguran\u00e7a e valida\u00e7\u00e3o para redes baseadas em Tanssi. Como operador, voc\u00ea participa do consenso que protege a rede e ganha recompensas.</p> <p>Conforme apresentado na se\u00e7\u00e3o de integra\u00e7\u00e3o, executar o n\u00f3 \u00e9 o primeiro passo da sua participa\u00e7\u00e3o ativa no protocolo.</p> <p>Neste guia, voc\u00ea aprender\u00e1 a iniciar um operador Tanssi usando o bin\u00e1rio est\u00e1vel mais recente e gerenciar o servi\u00e7o com Systemd em sistemas Linux.</p> <p>O artigo segue a boa pr\u00e1tica de executar o servi\u00e7o com uma conta n\u00e3o-root e conceder a essa conta acesso de grava\u00e7\u00e3o a um diret\u00f3rio espec\u00edfico. Adapte as etapas conforme sua configura\u00e7\u00e3o e pol\u00edticas de seguran\u00e7a.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Voc\u00ea precisar\u00e1 de acesso a um computador Ubuntu Linux com Landlock habilitado e privil\u00e9gios de root. Tamb\u00e9m precisar\u00e1 de:</p> <ul> <li>Arquivos bin\u00e1rios do n\u00f3 - o operador precisa de tr\u00eas bin\u00e1rios: <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code>.</li> </ul> <p>As instru\u00e7\u00f5es usam a vers\u00e3o est\u00e1vel mais recente. Voc\u00ea pode compilar seu pr\u00f3prio arquivo a partir do c\u00f3digo fonte.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#check-landlock","title":"Verificar Suporte Landlock","text":"<p>Os operadores Tanssi usam o recurso Landlock do kernel Linux como medida de seguran\u00e7a para restringir o acesso a recursos do sistema.</p> <p>Verifique o suporte Landlock executando:</p> <pre><code>sudo dmesg | grep landlock || journalctl -kg landlock\n</code></pre> <p>A sa\u00edda esperada \u00e9 similar a:</p> sudo dmesg | grep landlock || journalctl -kg landlock [    0.240344] landlock: Up and running. <p>Se o Landlock estiver desabilitado, atualize o kernel para a vers\u00e3o 5.13 ou superior.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#download-latest-release","title":"Baixar a Vers\u00e3o Mais Recente","text":"<p>Baixe os bin\u00e1rios mais recentes e torne-os execut\u00e1veis:</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#set-up-systemd-service","title":"Configure o servi\u00e7o Systemd","text":"<p>O Systemd \u00e9 um sistema de gerenciamento para Linux que controla servi\u00e7os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.</p> <p>Os comandos a seguir criam uma nova conta, o diret\u00f3rio e movem os arquivos previamente baixados para o local correto.</p> <ol> <li> <p>Crie uma nova conta para executar o servi\u00e7o:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> </li> <li> <p>Crie um diret\u00f3rio para armazenar os arquivos e dados necess\u00e1rios:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Defina a propriedade da pasta para a conta que executar\u00e1 o servi\u00e7o, garantindo permiss\u00e3o de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>chown -R tanssi_service /var/lib/dancelight-data\n</code></pre> </li> <li> <p>Mova os bin\u00e1rios para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-relay* /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-relay* /var/lib/dancelight-data\n</code></pre> </li> </ol>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#generate-node-key","title":"Gerar a chave do n\u00f3","text":"<p>Para gerar e armazenar em disco as chaves de sess\u00e3o que ser\u00e3o referenciadas no comando de inicializa\u00e7\u00e3o, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#create-systemd-configuration","title":"Criar o arquivo de configura\u00e7\u00e3o do Systemd","text":"<p>O pr\u00f3ximo passo \u00e9 criar o arquivo de configura\u00e7\u00e3o do Systemd.</p> <p>Crie o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configura\u00e7\u00e3o do servi\u00e7o, substituindo a tag <code>INSERT_YOUR_TANSSI_NODE_NAME</code> por um nome leg\u00edvel e <code>INSERT_YOUR_IP_ADDRESS</code> pelo seu endere\u00e7o IP p\u00fablico. Esse nome ajuda a relacionar entradas de log e m\u00e9tricas ao n\u00f3 que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Servi\u00e7o systemd Tanssi\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nUser=tanssi_service\nType=simple\nRestart=always\nRestartSec=10\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nLimitNOFILE=100000\nExecStart=/var/lib/tanssi-data/tanssi-relay --chain=dancelight \\\n--base-path=/var/lib/tanssi-data/ \\\n--node-key-file /var/lib/tanssi-data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>As flags usadas no <code>ExecStart</code> podem ser ajustadas conforme prefer\u00eancias e hardware. Algumas das principais:</p> <ul> <li>--state-pruning=archive - mant\u00e9m todos os dados de estado (necess\u00e1rio para consultas hist\u00f3ricas)</li> <li>--blocks-pruning=archive - mant\u00e9m todos os blocos (necess\u00e1rio para dados hist\u00f3ricos de blocos)</li> <li>--database=paritydb - usa ParityDB como backend otimizado para desempenho de n\u00f3 RPC</li> <li>--unsafe-rpc-external - permite conex\u00f5es externas ao RPC; requer medidas adicionais de seguran\u00e7a (proxy reverso, autentica\u00e7\u00e3o, firewall)</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>A flag <code>--unsafe-rpc-external</code> exp\u00f5e o n\u00f3 RPC externamente. Em produ\u00e7\u00e3o, proteja com firewall, proxy reverso, autentica\u00e7\u00e3o e limita\u00e7\u00e3o de taxa.</p> <p>Voc\u00ea pode visualizar todas as flags dispon\u00edveis executando:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-relay --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-relay --help\n</code></pre>"},{"location":"pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/#run-the-service","title":"Execute o servi\u00e7o","text":"<p>Por fim, habilite o servi\u00e7o e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Voc\u00ea pode verificar se o servi\u00e7o est\u00e1 ativo e rodando corretamente executando:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> systemctl status network.service  \u25cf network.service - \"Network systemd service\"     \u00a0\u00a0\u00a0Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)     \u00a0\u00a0\u00a0Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago     \u00a0\u00a0Main PID: 4045278 (container-chain)     \u00a0\u00a0\u00a0\u00a0Tasks: 44 (limit: 9462)     \u00a0\u00a0\u00a0Memory: 6.5G     \u00a0\u00a0\u00a0CGroup: /system.slice/network.service     \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2514\u25004045278 4045278 /var/lib/network-data/container-chain- ...    <p>Verifique os logs, se necess\u00e1rio, com o comando a seguir:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"pt/node-operators/operators/operational-tasks/","title":"Tarefas Operacionais","text":"<p>A manuten\u00e7\u00e3o do seu operador exige manuten\u00e7\u00e3o regular para garantir desempenho consistente e gerenciamento seguro da conta. Atualiza\u00e7\u00f5es regulares s\u00e3o essenciais para manter seu n\u00f3 compat\u00edvel com as \u00faltimas altera\u00e7\u00f5es no protocolo Tanssi. Ao mesmo tempo, ferramentas como contas proxy fornecem uma camada extra de seguran\u00e7a, permitindo que voc\u00ea delegue tarefas espec\u00edficas sem expor as credenciais da sua conta principal. Esta se\u00e7\u00e3o fornece as etapas para manter suas opera\u00e7\u00f5es suaves, confi\u00e1veis e seguras.</p>"},{"location":"pt/node-operators/operators/operational-tasks/#explore-esta-secao","title":"Explore esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/","title":"Configurar uma Conta Proxy de Operador","text":""},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>As contas proxy podem ser configuradas para realizar um n\u00famero limitado de a\u00e7\u00f5es em nome das contas prim\u00e1rias e ajudar a mant\u00ea-las seguras. Como operador na Tanssi, \u00e9 ben\u00e9fico usar contas proxy para interagir com a rede em vez da sua conta principal.</p> <p>O tipo de proxy <code>SessionKeyManagement</code> permite que a conta gire as chaves de sess\u00e3o em nome da conta prim\u00e1ria. Ele a transforma em uma \u201ccarteira quente\u201d que executa tarefas regulares de manuten\u00e7\u00e3o em nome da sua conta de operador \u201ccarteira fria\u201d. Para maior seguran\u00e7a, voc\u00ea pode girar regularmente a sua conta proxy.</p> <p>As contas proxy tamb\u00e9m ajudam a implementar o princ\u00edpio do privil\u00e9gio m\u00ednimo para controle de acesso. Por exemplo, se voc\u00ea tiver v\u00e1rios membros na equipe, pode conceder o acesso m\u00ednimo necess\u00e1rio para realizarem suas tarefas por meio de uma conta proxy espec\u00edfica.</p> <p>Este tutorial mostra como configurar uma conta proxy <code>SessionKeyManagement</code> em Dancelight especificamente para a\u00e7\u00f5es relacionadas ao operador e como girar suas novas chaves usando o proxy.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para acompanhar este tutorial, voc\u00ea precisar\u00e1:</p> <ul> <li>Abrir o portal do desenvolvedor</li> </ul> <p>=== \"Tanssi MainNet\"</p> <p>Portal do desenvolvedor da Mainnet</p> <p>=== \"Dancelight TestNet\"</p> <p>Portal do desenvolvedor da TestNet</p> <ul> <li>Criar ou ter duas contas acess\u00edveis no portal do desenvolvedor</li> <li>Ambas as contas precisam estar financiadas com tokens</li> </ul> <p>Se precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia Conectando-se ao Portal do Desenvolvedor.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#create-a-proxy-account","title":"Criar uma Conta Proxy","text":"<p>Voc\u00ea pode criar contas proxy no portal do desenvolvedor pela p\u00e1gina Extrinsics ou pela p\u00e1gina Accounts. No entanto, a cria\u00e7\u00e3o de um proxy com atraso (time-delayed) deve ser feita via Extrinsics, pois o atraso adiciona uma camada extra de seguran\u00e7a, permitindo que a conta prim\u00e1ria revise ou cancele a transa\u00e7\u00e3o antes da execu\u00e7\u00e3o.</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel criar um proxy do tipo <code>Any</code>, que concede controle total sobre a conta prim\u00e1ria. O exemplo a seguir usa <code>SessionKeyManagement</code>, mais restritivo, limitando-se a a\u00e7\u00f5es de mapeamento de chaves de sess\u00e3o.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-extrinsics","title":"Usando a Se\u00e7\u00e3o Extrinsics","text":"<p>Para criar sua conta proxy na aba Developer \u2192 Extrinsics:</p> <ol> <li>Selecione a conta prim\u00e1ria.</li> <li>No menu submit the following extrinsic, escolha proxy.</li> <li>Selecione o extr\u00ednseco addProxy.</li> <li>Em AccountIdLookupOf, escolha Id.</li> <li>Selecione a conta delegate que ser\u00e1 o proxy.</li> <li>Em proxyType, escolha SessionKeyManagement.</li> <li>Opcionalmente, defina um atraso (n\u00famero de blocos) para revis\u00e3o/cancelamento antes da execu\u00e7\u00e3o.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Autorize e assine a transa\u00e7\u00e3o (Sign and Submit). Ap\u00f3s o envio bem-sucedido, voc\u00ea ver\u00e1 notifica\u00e7\u00f5es de confirma\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#creating-proxy-account-using-accounts","title":"Usando a Se\u00e7\u00e3o Accounts","text":"<p>Para criar um proxy via Accounts:</p> <ol> <li>Na p\u00e1gina Accounts, clique nos tr\u00eas pontos verticais ao lado da conta prim\u00e1ria.</li> <li>Selecione Add proxy.</li> </ol> <p></p> <p>Nota</p> <p>Se a conta j\u00e1 tiver um proxy, a op\u00e7\u00e3o exibida ser\u00e1 Manage proxies.</p> <p>Em seguida, preencha os dados:</p> <ol> <li>Escolha a conta que ser\u00e1 o proxy.</li> <li>Selecione o tipo de proxy.</li> <li>Clique em Submit e assine a transa\u00e7\u00e3o.</li> </ol> <p></p> <p>Na pr\u00f3xima se\u00e7\u00e3o, voc\u00ea ver\u00e1 como verificar se o proxy foi configurado.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#verify-your-proxy-account","title":"Verificar sua Conta Proxy","text":"<p>Voc\u00ea pode verificar as contas proxy pela p\u00e1gina Accounts ou pela p\u00e1gina Chain state.</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-chain-state","title":"Usando a Se\u00e7\u00e3o Chain State","text":"<ol> <li>Em selected state query, selecione proxy.</li> <li>Escolha proxies.</li> <li>Selecione ou cole sua conta prim\u00e1ria/proxy.</li> <li>Clique em + para enviar a consulta.</li> </ol> <p>O resultado mostrar\u00e1 conta delegada, tipo de proxy, atraso (se houver) e valor total em garantia (Planck).</p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#verifying-your-proxy-account-accounts-section","title":"Usando a Se\u00e7\u00e3o Accounts","text":"<ol> <li>Na p\u00e1gina Accounts, clique nos tr\u00eas pontos verticais ao lado da conta prim\u00e1ria.</li> <li>Selecione Manage proxy.</li> </ol> <p>Nota</p> <p>Um \u00edcone de proxy aparece ao lado da conta prim\u00e1ria; passe o cursor e clique em Manage proxies.</p> <p></p> <p>Uma janela exibir\u00e1 uma vis\u00e3o geral das contas proxy.</p> <p></p>"},{"location":"pt/node-operators/operators/operational-tasks/proxy-accounts/#execute-a-proxy-transaction","title":"Executar uma Transa\u00e7\u00e3o via Proxy","text":"<p>Com o proxy configurado e verificado, voc\u00ea pode executar uma transa\u00e7\u00e3o em nome da conta prim\u00e1ria. O exemplo a seguir define chaves para um n\u00f3.</p> <ol> <li>Volte \u00e0 p\u00e1gina Extrinsics.</li> <li>Em using the select account, escolha a conta proxy.</li> <li>Em submit the following extrinsic, selecione proxy.</li> <li>Escolha o extr\u00ednseco proxy.</li> <li>Em AccountIdLookupOf, selecione Id.</li> <li>Em real, selecione a conta prim\u00e1ria.</li> <li>Selecione a chamada Session.</li> <li>Escolha a entrada setKeys.</li> <li>Insira as chaves do n\u00f3 a mapear para a conta do operador.</li> <li>Em proof, insira <code>0x</code>.</li> <li>Clique em Submit Transaction.</li> </ol> <p></p> <p>Autorize e assine (Sign and Submit). Pronto! Voc\u00ea executou uma transa\u00e7\u00e3o usando uma conta proxy em nome da conta de operador prim\u00e1ria.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/","title":"Atualizar um N\u00f3 Operador","text":"<p>Manter seu n\u00f3 atualizado \u00e9 fundamental para manter a compatibilidade com as \u00faltimas altera\u00e7\u00f5es do protocolo Tanssi e garantir o desempenho ideal. N\u00f3s desatualizados podem levar \u00e0 dessincroniza\u00e7\u00e3o, redu\u00e7\u00e3o de efici\u00eancia ou at\u00e9 mesmo \u00e0 incapacidade de participar do protocolo. Ao se manter atualizado com os lan\u00e7amentos de clientes, voc\u00ea pode garantir que seu n\u00f3 opere com seguran\u00e7a e confiabilidade dentro da rede.</p> <p>--8\\&lt;-- 'text/pt/node-operators/github-release-notifications.md'</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/#explore-o-que-esta-secao-aborda","title":"Explore o que esta se\u00e7\u00e3o aborda","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/","title":"Atualize seu N\u00f3 em Execu\u00e7\u00e3o via Docker","text":""},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A manuten\u00e7\u00e3o do seu n\u00f3 atualizado \u00e9 uma parte importante de ser um operador Tanssi. Isso n\u00e3o apenas ajuda a garantir que seu n\u00f3 permane\u00e7a em bom estado, mas tamb\u00e9m contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualiza\u00e7\u00e3o do seu n\u00f3 operador Tanssi que foi configurado usando o Docker. Ele pressup\u00f5e que voc\u00ea j\u00e1 configurou sua conta e lan\u00e7ou um n\u00f3 operador usando o Systemd.</p> <p>Assine as notifica\u00e7\u00f5es de lan\u00e7amento</p> <p>Ficar informado sobre novas vers\u00f5es do cliente \u00e9 essencial para manter o n\u00f3 atualizado. Os mantenedores do n\u00f3 podem assinar as notifica\u00e7\u00f5es do GitHub para serem alertados sobre novas vers\u00f5es.</p> <p>Para assinar, acesse o reposit\u00f3rio Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a op\u00e7\u00e3o Releases.</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes","title":"Atualizando N\u00f3s Docker","text":"<p>A atualiza\u00e7\u00e3o do seu n\u00f3 \u00e9 t\u00e3o simples quanto parar o cont\u00eainer em execu\u00e7\u00e3o e reinici\u00e1-lo com a nova tag de vers\u00e3o.</p> <p>Primeiro, obtenha o ID do cont\u00eainer do seu n\u00f3 operador Tanssi com o seguinte comando:</p> <pre><code>docker ps -a\n</code></pre> <p>O ID do cont\u00eainer \u00e9 a primeira coluna e, se voc\u00ea estiver executando v\u00e1rios cont\u00eaineres Docker, poder\u00e1 identific\u00e1-lo pelo nome da imagem <code>moondancelabs/starlight</code>. Voc\u00ea pode executar o comando de parada da seguinte forma:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>A sua intera\u00e7\u00e3o com o terminal se assemelhar\u00e1 ao seguinte:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/dancelight-chain:2 \"/chain-network/tans\u2026\" 56 seconds ago  Up 56 seconds             determined_darwin      docker stop aa751703d6aa  aa751703d6aa    <p>Para reiniciar o n\u00f3, use o mesmo comando que usou ao inici\u00e1-lo pela primeira vez. O comando far\u00e1 o pull da imagem e o n\u00f3 retomar\u00e1 a sincroniza\u00e7\u00e3o de blocos de onde parou quando o processo Docker foi interrompido.</p> Tanssi MainNetDancelight TestNet Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=tanssi \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-skylake\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi-relay/tanssi-relay-znver3\" \\\nmoondancelabs/starlight \\\n--chain=dancelight \\\n--base-path=/data/ \\\n--node-key-file /data/node-key \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--validator\n</code></pre> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag","title":"Especifique uma Tag de Vers\u00e3o","text":"<p>Para usar uma tag de vers\u00e3o espec\u00edfica, anexe-a ao nome da imagem. Por exemplo, para obter a vers\u00e3o marcada como <code>latest</code> (que \u00e9 o padr\u00e3o), anexe <code>:latest</code> a <code>moondancelabs/starlight</code>.</p> <p>E \u00e9 s\u00f3 isso! Voc\u00ea atualizou com sucesso seu n\u00f3 Tanssi.</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/","title":"Atualize seu N\u00f3 em Execu\u00e7\u00e3o via Systemd","text":""},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>A manuten\u00e7\u00e3o do seu n\u00f3 atualizado \u00e9 uma parte importante de ser um operador Tanssi. Isso n\u00e3o s\u00f3 ajuda a garantir que seu n\u00f3 permane\u00e7a saud\u00e1vel, mas tamb\u00e9m contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualiza\u00e7\u00e3o do seu n\u00f3 operador Tanssi que foi configurado usando o Systemd. Ele pressup\u00f5e que voc\u00ea j\u00e1 configurou sua conta e iniciou um n\u00f3 operador usando Systemd.</p> <p>Assine as notifica\u00e7\u00f5es de lan\u00e7amento</p> <p>Ficar informado sobre novas vers\u00f5es do cliente \u00e9 essencial para manter o n\u00f3 atualizado. Os mantenedores do n\u00f3 podem assinar as notifica\u00e7\u00f5es do GitHub para serem alertados sobre novas vers\u00f5es.</p> <p>Para assinar, acesse o reposit\u00f3rio Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a op\u00e7\u00e3o Releases.</p>"},{"location":"pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node","title":"Atualizando Seu N\u00f3 Systemd","text":"<p>Se voc\u00ea estiver executando seu operador via o servi\u00e7o Systemd, voc\u00ea deve tomar medidas para atualizar seu n\u00f3 corretamente. Em resumo, voc\u00ea precisar\u00e1 parar o servi\u00e7o, substituir o bin\u00e1rio Tanssi pela vers\u00e3o atualizada e reiniciar o servi\u00e7o.</p> <p>Voc\u00ea pode parar seu servi\u00e7o Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Em seguida, navegue at\u00e9 o diret\u00f3rio onde seus bin\u00e1rios Tanssi s\u00e3o armazenados e remova-os.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>Se voc\u00ea n\u00e3o alterou os nomes de arquivo bin\u00e1rios Tanssi, eles ser\u00e3o nomeados <code>tanssi-relay</code>, <code>tanssi-relay-execute-worker</code> e <code>tanssi-relay-prepare-worker</code>. Caso contr\u00e1rio, voc\u00ea pode substituir <code>tanssi-relay*</code> no comando abaixo pelos nomes corretos de seus arquivos bin\u00e1rios Tanssi.</p> <pre><code>rm tanssi-relay*\n</code></pre> <p>Para baixar a vers\u00e3o mais recente e alterar as permiss\u00f5es para que o servi\u00e7o Tanssi possa us\u00e1-la, execute o comando correspondente ao seu ambiente:</p> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-skylake -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-znver3 -O tanssi-relay &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker &amp;&amp; \\\nwget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker &amp;&amp; \\\nchmod +x ./tanssi-relay*\n</code></pre> <p>Voc\u00ea pode reiniciar seu servi\u00e7o Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>O n\u00f3 retomar\u00e1 a sincroniza\u00e7\u00e3o de blocos de onde parou quando o servi\u00e7o Systemd foi interrompido. Para verificar se est\u00e1 funcionando corretamente, voc\u00ea pode usar o seguinte comando para verificar os logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>E \u00e9 isso! Voc\u00ea atualizou com sucesso seu n\u00f3 Tanssi.</p>"},{"location":"pt/node-operators/sequencers/","title":"Sequenciadores Tanssi","text":"<p>Os sequenciadores desempenham um papel fundamental na manuten\u00e7\u00e3o da atividade e do desempenho do ecossistema Tanssi. Eles s\u00e3o respons\u00e1veis por produzir blocos, executar transa\u00e7\u00f5es e garantir o bom funcionamento da rede. Esta se\u00e7\u00e3o fornece tudo o que voc\u00ea precisa para come\u00e7ar, desde a configura\u00e7\u00e3o inicial at\u00e9 as melhores pr\u00e1ticas operacionais e o gerenciamento de contas.</p>"},{"location":"pt/node-operators/sequencers/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/offboarding/","title":"Desativa\u00e7\u00e3o","text":"<p>A desativa\u00e7\u00e3o como sequenciador requer que os procedimentos adequados sejam seguidos para garantir uma transi\u00e7\u00e3o tranquila. Esta se\u00e7\u00e3o fornece instru\u00e7\u00f5es claras para remover suas chaves de sess\u00e3o e cancelar a delega\u00e7\u00e3o de sua participa\u00e7\u00e3o auto-vinculada, permitindo que voc\u00ea recupere seus fundos com seguran\u00e7a e desconecte sua conta da rede.</p> <p>O que voc\u00ea aprender\u00e1:</p> <ul> <li>Removendo sua autodelega\u00e7\u00e3o - etapas para remover sua participa\u00e7\u00e3o auto-vinculada e garantir que seu sequenciador n\u00e3o seja mais listado como um participante eleg\u00edvel</li> <li>Removendo as chaves de sess\u00e3o - como remover suas chaves de sess\u00e3o, interrompendo adequadamente a conex\u00e3o entre seu n\u00f3 e sua conta</li> </ul> <p>Retornando como um Sequenciador</p> <p>Se voc\u00ea decidir retornar como um sequenciador Tanssi no futuro, poder\u00e1 embarcar novamente facilmente seguindo as etapas descritas no guia Onboarding.</p>"},{"location":"pt/node-operators/sequencers/offboarding/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/offboarding/account/","title":"Sair como um Sequenciador Tanssi","text":""},{"location":"pt/node-operators/sequencers/offboarding/account/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Aos sequenciadores, pode chegar o momento de sair graciosamente da rede. A desativa\u00e7\u00e3o da sua conta envolve um processo de duas etapas para garantir que seu n\u00f3 seja devidamente dissociado da sua conta e que voc\u00ea receba sua garantia de volta.</p> <p>Este guia mostrar\u00e1 como encerrar suas opera\u00e7\u00f5es como um sequenciador Tanssi corretamente. Isso inclui a n\u00e3o delega\u00e7\u00e3o de sua autodelega\u00e7\u00e3o para reaver sua garantia e o desmapeamento de suas chaves de sess\u00e3o para cortar a conex\u00e3o entre seu n\u00f3 e sua conta. Naturalmente, este guia assume que voc\u00ea \u00e9 um sequenciador Tanssi existente com um n\u00f3 sequenciador e chaves de sess\u00e3o mapeadas{target=_blank}.</p>"},{"location":"pt/node-operators/sequencers/offboarding/account/#request-undelegation","title":"Solicitar a n\u00e3o delega\u00e7\u00e3o","text":"<p>Ao configurar seu sequenciador Tanssi, voc\u00ea precisou enviar uma garantia de delega\u00e7\u00e3o (pelo menos <code>10000</code> TANSSI para Tanssi MainNet). Para receb\u00ea-la de volta e remover seu sequenciador da lista de candidatos eleg\u00edveis, voc\u00ea precisar\u00e1 seguir etapas semelhantes \u00e0s do processo de integra\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/sequencers/offboarding/account/#viewing-existing-stake","title":"Visualizar a participa\u00e7\u00e3o existente","text":"<p>Antes de n\u00e3o delegar, \u00e9 \u00fatil primeiro ver quanto voc\u00ea apostou, pois precisar\u00e1 fornecer esse valor mais tarde. Para fazer isso, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=_blank}, clique na aba Desenvolvedor, selecione Estado da Cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o m\u00f3dulo pooledStaking</li> <li>Selecione a consulta pools</li> <li>Insira sua conta de sequenciador</li> <li>Certifique-se de que o controle deslizante include option esteja ativado</li> <li>No campo option, voc\u00ea seleciona JoiningShares</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco </li> </ol> <p>Observe que JoiningShares retorna apenas o valor inicial que voc\u00ea delegou ao configurar seu sequenciador. Para obter o valor total apostado, voc\u00ea precisar\u00e1 repetir as etapas acima para ManualRewardShares ou ManualRewardSharesHeldStake se voc\u00ea n\u00e3o selecionou Autocompounding, e AutoCompoundingShares ou AutoCompoundingSharesHeldStake se voc\u00ea configurou Autocompounding. Em seguida, adicione seu valor de a\u00e7\u00f5es de autocompounding ou manuais ao JoiningShares para obter sua delega\u00e7\u00e3o total pendente.</p> <p>Como exemplo, a participa\u00e7\u00e3o total de um sequenciador de autocompounding pode ser calculada adicionando JoiningShares a AutoCompoundingShares. Observe esse valor, pois voc\u00ea precisar\u00e1 dele na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/sequencers/offboarding/account/#submit-undelegation-request","title":"Enviar solicita\u00e7\u00e3o de n\u00e3o delega\u00e7\u00e3o","text":"<p>Acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Extr\u00ednsecos no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione a conta de onde voc\u00ea deseja enviar a transa\u00e7\u00e3o. Esta conta deve ser sua conta de sequenciador existente que voc\u00ea inicialmente delegou</li> <li>Selecione o m\u00f3dulo pooledStaking</li> <li>Selecione o extr\u00ednseco requestUndelegate</li> <li>Insira sua conta, que \u00e9, novamente, a mesma conta da qual voc\u00ea est\u00e1 enviando o extr\u00ednseco e a conta que voc\u00ea deseja desativar como um sequenciador</li> <li>Escolha o pool de destino que voc\u00ea usou originalmente ao configurar sua delega\u00e7\u00e3o ( Autocompounding ou Manual)</li> <li>Selecione Stake ou Shares no menu suspenso</li> <li>Insira a quantia a ser removida da aposta. Se voc\u00ea selecionou Shares, basta inserir o n\u00famero de Shares. Se voc\u00ea selecionou Stake, precisar\u00e1 enviar o valor, incluindo as doze casas decimais usadas pela Rede Tanssi. Como lembrete, o valor m\u00ednimo da aposta \u00e9 <code>10000</code> TANSSI. Se voc\u00ea delegou o valor m\u00ednimo e n\u00e3o acumulou recompensas adicionais, precisar\u00e1 inserir <code>10000000000000000</code></li> <li>Clique em Enviar Transa\u00e7\u00e3o e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p>"},{"location":"pt/node-operators/sequencers/offboarding/account/#execute-pending-request","title":"Executar a solicita\u00e7\u00e3o pendente","text":"<p>Voc\u00ea precisar\u00e1 esperar antes de executar a solicita\u00e7\u00e3o pendente. No caso do Tanssi MainNet, o per\u00edodo de espera \u00e9 configurado para pelo menos two sess\u00f5es. Cada sess\u00e3o \u00e9 composta por <code>3600</code> blocos e se traduz em cerca de 6 hora por sess\u00e3o. Portanto, two sess\u00f5es correspondem a aproximadamente twelve horas.</p> <p>Antes de executar a solicita\u00e7\u00e3o pendente, voc\u00ea precisar\u00e1 recuperar a sess\u00e3o na qual enviou a solicita\u00e7\u00e3o para delegar. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o m\u00f3dulo pooledStaking</li> <li>Selecione a consulta pendingOperations</li> <li>Insira sua conta de sequenciador</li> <li>Desative o controle deslizante include option</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A solicita\u00e7\u00e3o pendente ser\u00e1 exibida na parte inferior da p\u00e1gina </li> </ol> <p>No exemplo na imagem acima, a solicita\u00e7\u00e3o de n\u00e3o delega\u00e7\u00e3o para sair do pool de autocompounding foi enviada durante a sess\u00e3o <code>5.037</code>. Portanto, a solicita\u00e7\u00e3o pode ser executada a partir da sess\u00e3o <code>5.039</code>. Anote a opera\u00e7\u00e3o e o \u00edndice da sess\u00e3o em que voc\u00ea enviou a solicita\u00e7\u00e3o, pois voc\u00ea precisar\u00e1 de ambos os valores para executar a solicita\u00e7\u00e3o pendente.</p> <p>Voc\u00ea pode executar outra consulta na p\u00e1gina Estado da cadeia para verificar a sess\u00e3o atual. Para fazer isso, voc\u00ea pode:</p> <ol> <li>Selecione o m\u00f3dulo session</li> <li>Selecione a consulta currentIndex</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A sess\u00e3o atual ser\u00e1 exibida na parte inferior da p\u00e1gina</li> </ol> <p></p> <p>Se pelo menos duas sess\u00f5es se passaram desde a sess\u00e3o em que voc\u00ea enviou o extr\u00ednseco, a solicita\u00e7\u00e3o estar\u00e1 pronta para ser executada. Para fazer isso, selecione Extr\u00ednsecos no menu suspenso Desenvolvedor e siga estas etapas:</p> <ol> <li>Selecione a conta da qual voc\u00ea deseja enviar o extr\u00ednseco</li> <li>Selecione o m\u00f3dulo pooledStaking</li> <li>Selecione o extr\u00ednseco executePendingOperations</li> <li>Para delegator, insira sua conta, que \u00e9 a mesma conta da qual voc\u00ea enviou a solicita\u00e7\u00e3o de autodelega\u00e7\u00e3o</li> <li>Para operation, selecione Leaving</li> <li>Para candidate, insira a mesma conta que voc\u00ea fez no campo delegator</li> <li>Para at, insira o \u00edndice da sess\u00e3o em que voc\u00ea enviou a solicita\u00e7\u00e3o de delegado</li> <li>Clique em Enviar Transa\u00e7\u00e3o e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p>"},{"location":"pt/node-operators/sequencers/offboarding/account/#verify","title":"Verifique se sua conta n\u00e3o est\u00e1 na lista de candidatos eleg\u00edveis","text":"<p>Se voc\u00ea quiser, pode verificar se seu sequenciador n\u00e3o est\u00e1 mais na lista de candidatos eleg\u00edveis. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o m\u00f3dulo pooledStaking e a consulta sortedEligibleCandidates</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>Uma lista dos candidatos eleg\u00edveis e suas apostas ser\u00e1 exibida na parte inferior da p\u00e1gina. Voc\u00ea pode pesquisar seu endere\u00e7o para garantir que ele n\u00e3o exista na lista </li> </ol>"},{"location":"pt/node-operators/sequencers/offboarding/account/#unmap-session-keys","title":"Desmapear chaves de sess\u00e3o","text":"<p>As chaves de sess\u00e3o s\u00e3o usadas para realizar opera\u00e7\u00f5es de rede, como assinar blocos, enquanto sua conta de sequenciador mant\u00e9m os fundos apostados e tem uma identidade na cadeia. Ao desmapear a chave de sess\u00e3o para sua conta, voc\u00ea interrompe a associa\u00e7\u00e3o entre sua conta de sequenciador e seu n\u00f3 de sequenciador.</p> <p>A etapa de desmapeamento \u00e9 tomada apenas como parte do processo de desativa\u00e7\u00e3o. Se voc\u00ea precisar girar/alterar suas chaves de sess\u00e3o, precisar\u00e1 seguir a gera\u00e7\u00e3o e mapeamento de novas chaves de sess\u00e3o. Voc\u00ea n\u00e3o deve remover suas chaves durante o processo de rota\u00e7\u00e3o da chave de sess\u00e3o.</p> <p>Para desmapear suas chaves de sess\u00e3o, acesse o portal do desenvolvedor, clique na aba Desenvolvedor, selecione Extr\u00ednsecos no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione sua conta de sequenciador Tanssi</li> <li>Selecione o m\u00f3dulo session</li> <li>Selecione o extr\u00ednseco purgeKeys</li> <li>Clique em Enviar Transa\u00e7\u00e3o e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p> <p>Usando o m\u00e9todo <code>session.keyOwner</code>, voc\u00ea pode verificar se suas chaves de sess\u00e3o foram desmapeadas de sua conta conforme o esperado. Para fazer isso no portal do desenvolvedor, clique na aba Desenvolvedor, selecione Estado da cadeia no menu suspenso e siga estas etapas:</p> <ol> <li>Selecione o m\u00f3dulo session</li> <li>Selecione a consulta keyOwner</li> <li>Insira <code>nmbs</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira suas chaves de sess\u00e3o codificadas em hexadecimal</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A consulta n\u00e3o deve retornar nada </li> </ol> <p>E \u00e9 isso! Voc\u00ea desativou com sucesso um sequenciador Tanssi. Se mudar de ideia a qualquer momento e quiser se integrar novamente como um sequenciador Tanssi, voc\u00ea pode seguir as etapas no guia de integra\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/sequencers/onboarding/","title":"Onboarding","text":"<p>A sua jornada como um sequenciador come\u00e7a aqui. Siga estes passos para configurar o seu n\u00f3 e preparar a sua conta para a participa\u00e7\u00e3o ativa na rede Tanssi.</p> <p>Executar um sequenciador</p> <p>Configure o n\u00f3 usando Systemd ou Docker.</p> <p>Configurar sua conta</p> <p>Mapeie sua conta para as chaves de sess\u00e3o do seu n\u00f3.</p> <p>Autodelegar ativos</p> <p>Delegue ativos para a sua pr\u00f3pria conta para se tornar eleg\u00edvel a sequenciamento.</p> <p>Configurar uma identidade on-chain</p> <p>Crie uma identidade para melhorar a visibilidade e o reconhecimento do seu sequenciador.</p>"},{"location":"pt/node-operators/sequencers/onboarding/#explore-esta-secao","title":"Explore esta Se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/","title":"Configure sua conta para produzir blocos no Tanssi","text":""},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Antes de come\u00e7ar a produzir blocos em redes com tecnologia Tanssi, voc\u00ea precisar\u00e1 configurar sua conta e estabelecer sua elegibilidade.</p> <p>Voc\u00ea deve ter iniciado um n\u00f3 Sequenciador para realizar as etapas de configura\u00e7\u00e3o da conta neste guia.</p> <p>Voc\u00ea precisar\u00e1 configurar sua conta gerando chaves de sess\u00e3o e mapeando essas chaves de sess\u00e3o para sua conta. Esta conta \u00e9 aquela para a qual os delegadores escolher\u00e3o delegar e onde suas recompensas ser\u00e3o distribu\u00eddas. Opcionalmente, voc\u00ea pode configurar uma conta proxy para seguran\u00e7a adicional.</p> <p>Para estabelecer a elegibilidade, voc\u00ea deve se delegar como um sequenciador e atender aos requisitos m\u00ednimos de garantia.</p> <p>Seguindo as etapas descritas neste guia, voc\u00ea aprender\u00e1 tudo o que precisa saber para come\u00e7ar a produzir blocos no ecossistema Tanssi.</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#important-variables","title":"Vari\u00e1veis Importantes","text":"<p>Ao estabelecer a elegibilidade para produzir blocos, existem algumas vari\u00e1veis a serem observadas:</p> <ul> <li>Autodelega\u00e7\u00e3o m\u00ednima - h\u00e1 um valor m\u00ednimo que voc\u00ea deve autodelegar para ser considerado eleg\u00edvel</li> <li>Sess\u00e3o - um per\u00edodo que tem um conjunto constante de sequenciadores</li> <li>Sequenciadores de rede por sess\u00e3o - o n\u00famero de sequenciadores atribu\u00eddos a uma rede com tecnologia Tanssi por sess\u00e3o</li> </ul> Tanssi MainNet Vari\u00e1vel Valor Autodelega\u00e7\u00e3o m\u00ednima 10000 TANSSI Sess\u00e3o 3600 blocos Sequenciadores de rede por sess\u00e3o 5 sequenciadores Dancelight TestNet Vari\u00e1vel Valor Autodelega\u00e7\u00e3o m\u00ednima 10000 STAR Sess\u00e3o 3600 blocos Sequenciadores de rede por sess\u00e3o 2 sequenciadores"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#map-account","title":"Mapear uma conta para seu n\u00f3 Sequenciador","text":"<p>A primeira etapa \u00e9 um processo de duas etapas que gera chaves de sess\u00e3o e mapeia as chaves de sess\u00e3o para sua conta. As chaves de sess\u00e3o s\u00e3o usadas para realizar opera\u00e7\u00f5es de rede, como assinar blocos, enquanto sua conta mant\u00e9m os fundos apostados e tem uma identidade na cadeia. Ao mapear a chave de sess\u00e3o para sua conta, voc\u00ea cria uma associa\u00e7\u00e3o entre sua conta e seu sequenciador.</p> <p>Voc\u00ea precisar\u00e1 criar chaves de sess\u00e3o para seus servidores prim\u00e1rio e de backup. Cada um de seus servidores, seu prim\u00e1rio e de backup, deve ter suas pr\u00f3prias chaves exclusivas. Como as chaves nunca saem de seus servidores, voc\u00ea pode consider\u00e1-las um ID exclusivo para aquele servidor.</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#generate-session-keys","title":"Gerar chaves de sess\u00e3o","text":"<p>Antes de gerar chaves de sess\u00e3o, voc\u00ea deve estar executando um n\u00f3 sequenciador.</p> <p>Para gerar chaves de sess\u00e3o, voc\u00ea enviar\u00e1 uma chamada RPC, usando o m\u00e9todo <code>author_rotateKeys</code>, para o endpoint HTTP do seu n\u00f3. Como refer\u00eancia, se o endpoint HTTP do seu sequenciador estiver na porta <code>9945</code>, a chamada JSON-RPC pode ter esta apar\u00eancia:</p> <pre><code>\"Content-Type:application/json;charset=utf-8\" -d \\\n  '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n  }'\n</code></pre> <p>Suas chaves de sess\u00e3o codificadas em hexadecimal ser\u00e3o impressas no terminal no campo <code>\"result\"</code>.</p> curl http://127.0.0.1:9944 -H \\       \"Content-Type:application/json;charset=utf-8\" -d \\         '{             \"jsonrpc\":\"2.0\",             \"id\":1,             \"method\":\"author_rotateKeys\",             \"params\": []         }'    {\"jsonrpc\":\"2.0\",\"result\":    \"0x76afaf334bd33b82d0b8fbd6a2845cb3b9b785edf1dce4ccefd4973fa79fed2b\",\"id\":1} <p>Certifique-se de anotar suas chaves de sess\u00e3o; voc\u00ea precisar\u00e1 mapear suas chaves de sess\u00e3o para sua conta na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#map-session-keys","title":"Mapear chaves de sess\u00e3o","text":"<p>Para executar a pr\u00f3xima etapa e mapear suas chaves de sess\u00e3o para sua conta, acesse o portal do desenvolvedor, clique na aba Developer, selecione Extrinsics no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione sua conta, que deve ser a mesma conta que voc\u00ea autodelegou anteriormente</li> <li>Selecione o m\u00f3dulo session e o extr\u00ednseco setKeys</li> <li>Para keys, insira suas chaves de sess\u00e3o</li> <li>Para proof, insira <code>0x</code></li> <li>Clique em Submit Transaction e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p> <p>Usando o m\u00e9todo <code>session.keyOwner</code>, voc\u00ea pode verificar se suas chaves de sess\u00e3o foram mapeadas para sua conta conforme o esperado. Para fazer isso no portal do desenvolvedor, clique na aba Developer, selecione Chain state no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione o m\u00f3dulo session e a consulta keyOwner</li> <li>Insira <code>nmbs</code> no campo SpCoreCryptoKeyTypeId</li> <li>Para Bytes, insira suas chaves de sess\u00e3o codificadas em hexadecimal</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A conta associada \u00e0s chaves de sess\u00e3o, que deve ser sua conta, ser\u00e1 exibida na parte inferior da p\u00e1gina</li> </ol> <p></p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#submit-self-delegation","title":"Enviar Autodelega\u00e7\u00e3o","text":"<p>A pr\u00f3xima etapa para se tornar eleg\u00edvel para produzir blocos em redes com tecnologia Tanssi \u00e9 delegar \u00e0 sua pr\u00f3pria conta. Para fazer isso, voc\u00ea precisar\u00e1 enviar um m\u00ednimo de tokens, conforme listado na se\u00e7\u00e3o vari\u00e1veis importantes.</p> <p>Depois de enviar a solicita\u00e7\u00e3o para delegar, voc\u00ea precisar\u00e1 esperar um m\u00ednimo de sess\u00f5es antes de poder executar a solicita\u00e7\u00e3o pendente. No caso do Tanssi MainNet, o n\u00famero de sess\u00f5es \u00e9 configurado para two. Existem 3600 blocos em uma sess\u00e3o. Portanto, two sess\u00f5es s\u00e3o 7200 blocos, o que pode levar cerca de twelve horas.</p> <p>Os sequenciadores s\u00e3o atribu\u00eddos a cada sess\u00e3o. Os sequenciadores que participam da sess\u00e3o s\u00e3o escolhidos da lista de candidatos ordenada por participa\u00e7\u00e3o total at\u00e9 que o n\u00famero total de sequenciadores necess\u00e1rios seja coberto. Portanto, voc\u00ea precisar\u00e1 garantir que sua participa\u00e7\u00e3o total seja suficiente para preencher um dos slots, o que pode exigir mais do que a autodelega\u00e7\u00e3o m\u00ednima.</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#request-delegate","title":"Solicitar Delegado","text":"<p>Acesse o portal do desenvolvedor, clique na aba Developer, selecione Extrinsics no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione a conta da qual voc\u00ea deseja enviar a transa\u00e7\u00e3o. Esta conta deve ser a mesma conta para a qual voc\u00ea est\u00e1 delegando e \u00e9 a conta que voc\u00ea deseja se tornar um sequenciador</li> <li>Selecione o m\u00f3dulo pooledStaking e o extr\u00ednseco requestDelegate</li> <li>Insira sua conta, que \u00e9, novamente, a mesma conta da qual voc\u00ea est\u00e1 enviando a transa\u00e7\u00e3o e a conta que voc\u00ea deseja se tornar um sequenciador</li> <li>Escolha o pool de destino. O pool pode ser o pool de composi\u00e7\u00e3o autom\u00e1tica, que comp\u00f5e automaticamente as recompensas de delega\u00e7\u00e3o, ou o pool de recompensas manuais, no qual todas as a\u00e7\u00f5es relacionadas \u00e0s recompensas s\u00e3o manuais</li> <li>Insira o valor a ser apostado. Este valor deve atender ao m\u00ednimo, que \u00e9 10000 TANSSI tokens para Tanssi MainNet. A Tanssi Network usa doze casas decimais, portanto, ao enviar o valor, certifique-se de adicionar as casas decimais \u00e0 autodelega\u00e7\u00e3o. Para MainNet, o valor seria <code>10000000000000000</code></li> <li>Clique em Submit Transaction e assine e envie a transa\u00e7\u00e3o de sua carteira </li> </ol>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#execute-pending-request","title":"Executar a solicita\u00e7\u00e3o pendente","text":"<p>Antes de executar a solicita\u00e7\u00e3o pendente, voc\u00ea precisar\u00e1 recuperar a sess\u00e3o na qual voc\u00ea enviou a solicita\u00e7\u00e3o para delegar. Para fazer isso, acesse o portal do desenvolvedor, clique na aba Developer, selecione Chain state no menu suspenso e siga as etapas a seguir:</p> <ol> <li>Selecione o m\u00f3dulo pooledStaking e a consulta pendingOperations</li> <li>Insira sua conta</li> <li>Desative o controle deslizante include option</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A solicita\u00e7\u00e3o pendente ser\u00e1 exibida na parte inferior da p\u00e1gina</li> </ol> <p></p> <p>No exemplo da imagem acima, a solicita\u00e7\u00e3o de delega\u00e7\u00e3o para ingressar no pool de composi\u00e7\u00e3o autom\u00e1tica foi enviada durante a sess\u00e3o 4.829. Portanto, a solicita\u00e7\u00e3o pode ser executada a partir da sess\u00e3o 4.831.</p> <p>Anote a opera\u00e7\u00e3o e o n\u00famero da sess\u00e3o em que voc\u00ea enviou a solicita\u00e7\u00e3o, pois voc\u00ea precisar\u00e1 de ambos os valores para executar a solicita\u00e7\u00e3o pendente.</p> <p>Voc\u00ea pode executar outra consulta na p\u00e1gina Chain state para verificar a sess\u00e3o atual. Para fazer isso, voc\u00ea pode:</p> <ol> <li>Selecione o m\u00f3dulo session e a consulta currentIndex</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>A sess\u00e3o atual ser\u00e1 exibida na parte inferior da p\u00e1gina</li> </ol> <p></p> <p>Se a solicita\u00e7\u00e3o puder ser executada, selecione Extrinsics no menu suspenso Developer e siga as etapas a seguir:</p> <ol> <li>Selecione a conta da qual voc\u00ea deseja enviar a transa\u00e7\u00e3o</li> <li>Selecione o m\u00f3dulo pooledStaking e a transa\u00e7\u00e3o executePendingOperations</li> <li>Para delegator, insira sua conta, que \u00e9 a mesma conta da qual voc\u00ea enviou a solicita\u00e7\u00e3o de autodelega\u00e7\u00e3o</li> <li>Para operation, selecione o tipo de opera\u00e7\u00e3o a ser executada. Este deve ser JoiningAutoCompounding ou JoiningManualRewards, dependendo do pool de destino selecionado no momento do envio da solicita\u00e7\u00e3o de autodelega\u00e7\u00e3o</li> <li>Para candidate, insira a mesma conta que voc\u00ea fez no campo delegator</li> <li>Para at, insira o id da sess\u00e3o em que voc\u00ea enviou a solicita\u00e7\u00e3o de delega\u00e7\u00e3o</li> <li>Clique em Submit Transaction e assine e envie a transa\u00e7\u00e3o de sua carteira</li> </ol> <p></p> <p>Agora, voc\u00ea concluiu toda a configura\u00e7\u00e3o da conta necess\u00e1ria para ser eleg\u00edvel para produzir blocos!</p>"},{"location":"pt/node-operators/sequencers/onboarding/account-setup/#verify","title":"Verifique se sua conta est\u00e1 na lista de candidatos eleg\u00edveis","text":"<p>Se voc\u00ea seguiu todas as etapas deste guia e sincronizou totalmente seu sequenciador, agora voc\u00ea est\u00e1 eleg\u00edvel para produzir blocos. Para verificar se voc\u00ea est\u00e1 na lista de candidatos eleg\u00edveis, voc\u00ea pode acessar o portal do desenvolvedor, clicar na aba Developer, selecionar Chain state no menu suspenso e seguir as etapas a seguir:</p> <ol> <li>Selecione o m\u00f3dulo pooledStaking e a consulta sortedEligibleCandidates</li> <li>Clique no bot\u00e3o + ao lado do campo extr\u00ednseco</li> <li>Uma lista dos candidatos eleg\u00edveis e sua participa\u00e7\u00e3o ser\u00e1 exibida na parte inferior da p\u00e1gina. Voc\u00ea pode pesquisar seu endere\u00e7o para garantir que est\u00e1 qualificado para produzir blocos</li> </ol> <p></p> <p>Lembre-se que voc\u00ea precisar\u00e1 estar entre os principais candidatos por participa\u00e7\u00e3o total para produzir blocos, e isso se baseia no n\u00famero de sequenciadores necess\u00e1rios para cada rede e Tanssi.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/","title":"Executar um N\u00f3 Sequenciador","text":"<p>A configura\u00e7\u00e3o de um n\u00f3 sequenciador \u00e9 um passo importante para participar da rede Tanssi. Voc\u00ea tem duas op\u00e7\u00f5es: Docker ou Systemd. Seja qual for o caminho escolhido, fornecemos tutoriais passo a passo para orient\u00e1-lo durante o processo e garantir que seu n\u00f3 atenda aos requisitos necess\u00e1rios para produzir blocos e manter uma conex\u00e3o segura com a rede.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/#requisitos-de-hardware","title":"Requisitos de Hardware","text":"<p>Para executar um n\u00f3 sequenciador com sucesso, o uso de hardware de alto desempenho \u00e9 essencial. Configura\u00e7\u00f5es sub\u00f3timas podem levar a atrasos, rodadas de autoria perdidas e perda de recompensas. Como a produ\u00e7\u00e3o e o processo de importa\u00e7\u00e3o de blocos dependem fortemente do desempenho de um \u00fanico thread, recomenda-se priorizar CPUs com fortes capacidades de thread \u00fanico em vez de contagens de n\u00facleos mais altas.</p> <p>Hardware Recomendado:</p> <ul> <li>CPUs Recomendadas - Intel Xeon E-2386/2388 ou Ryzen 9 5950x/5900x</li> <li>NVMe Recomendado - 1 TB NVMe</li> <li>RAM Recomendada - 32 GB RAM</li> </ul> <p>Aten\u00e7\u00e3o</p> <p>Como um sequenciador, voc\u00ea \u00e9 respons\u00e1vel por sua pr\u00f3pria participa\u00e7\u00e3o e pela de seus delegadores. Manter o desempenho do seu n\u00f3, mant\u00ea-lo atualizado e garantir sua seguran\u00e7a s\u00e3o essenciais para maximizar as recompensas e construir uma forte reputa\u00e7\u00e3o na rede Tanssi.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/#portas-de-rede-necessarias","title":"Portas de Rede Necess\u00e1rias","text":"<p>Para produ\u00e7\u00e3o de blocos bem-sucedida, seu n\u00f3 deve sincronizar e interagir com duas redes peer-to-peer (P2P). Para garantir a comunica\u00e7\u00e3o adequada dentro do ecossistema Tanssi, certifique-se de que as seguintes portas estejam abertas para entrada:</p> Rede Porta Tanssi Chain 30334 (TCP) Rede Designada 30333 (TCP)"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/","title":"Executar um Sequenciador em Tanssi Usando Docker","text":""},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Uma das principais propostas do Tanssi \u00e9 oferecer produ\u00e7\u00e3o de blocos descentralizada e sem confian\u00e7a para suas redes. O runtime do Tanssi gerencia a atribui\u00e7\u00e3o de sequenciadores para todas as redes ativas no ecossistema.</p> <p>O algoritmo de atribui\u00e7\u00e3o distribui o conjunto dispon\u00edvel de sequenciadores a cada sess\u00e3o, designando-os para uma cadeia aleat\u00f3ria. Assim, eles produzem blocos para a mesma rede por um per\u00edodo relativamente curto, aumentando a seguran\u00e7a geral do ecossistema.</p> <p>Para isso, o bin\u00e1rio do Tanssi (software usado para rodar n\u00f3s) j\u00e1 possui um mecanismo embutido que alterna automaticamente a produ\u00e7\u00e3o de blocos para a cadeia designada sem exigir altera\u00e7\u00f5es do operador. O bin\u00e1rio inclui a l\u00f3gica para sincronizar a nova cadeia e produzir blocos quando a sess\u00e3o muda. Portanto, os sequenciadores precisam executar o bin\u00e1rio do Tanssi, e n\u00e3o o das redes individuais (como fazem os n\u00f3s completos).</p> <p>Neste guia, voc\u00ea aprender\u00e1 como iniciar um sequenciador Tanssi para fazer parte do pool compartilhado de sequenciadores usando Docker em um computador Linux. No entanto, ele pode ser adaptado a outros sistemas operacionais.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":""},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#installing-docker","title":"Instalando o Docker","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de um computador com Linux e instalar o Docker.</p> <p>Execute o comando a seguir para instalar o Docker em um Ubuntu:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>E o comando abaixo para verificar a instala\u00e7\u00e3o:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Uma execu\u00e7\u00e3o bem-sucedida no terminal se parece com isto:</p> sudo docker run hello-world  Hello from Docker!      This message shows that your installation appears to be working correctly.       To generate this message, Docker took the following steps:      1. The Docker client contacted the Docker daemon.      2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.          (amd64)      3. The Docker daemon created a new container from that image which runs the          executable that produces the output you are currently reading.      4. The Docker daemon streamed that output to the Docker client, which sent it          to your terminal.       To try something more ambitious, you can run an Ubuntu container with:      $ docker run -it ubuntu bash       Share images, automate workflows, and more with a free Docker ID:      https://hub.docker.com/       For more examples and ideas, visit:       https://docs.docker.com/get-started/"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#pulling-docker-image","title":"Puxando a Imagem Docker","text":"<p>Uma imagem Docker \u00e9 constru\u00edda e publicada em cada lan\u00e7amento, contendo todas as depend\u00eancias necess\u00e1rias que um sequenciador Tanssi precisa e o pr\u00f3prio arquivo bin\u00e1rio.</p> <p>Uma imagem Docker combina o bin\u00e1rio correspondente \u00e0 vers\u00e3o est\u00e1vel mais recente do n\u00f3 cliente, junto com o arquivo de especifica\u00e7\u00e3o do orquestrador Tanssi.</p> <p>O seguinte comando para puxar a imagem Docker:</p> Tanssi MainNetDancelight TestNet <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <pre><code>docker pull moondancelabs/tanssi\n</code></pre> <p>O comando far\u00e1 o download e extrair\u00e1 a imagem e mostrar\u00e1 o status ap\u00f3s a execu\u00e7\u00e3o:</p> docker pull moondancelabs/tanssi  Using default tag: latest      latest: Pulling from moondancelabs/tanssi      e1caac4eb9d2: Pull complete       1d4409959e6d: Pull complete       b8beed19c122: Pull complete       c0fab1f18601: Pull complete       d9dcf3cddfc5: Pull complete       Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c      Status: Downloaded newer image for moondancelabs/tanssi      docker.io/moondancelabs/tanssi"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#download-tanssi-specs","title":"Baixar o arquivo de especifica\u00e7\u00e3o da cadeia Tanssi","text":"<p>O bin\u00e1rio do n\u00f3 tamb\u00e9m inclui o c\u00f3digo necess\u00e1rio para executar um n\u00f3 da cadeia de orquestra\u00e7\u00e3o do Tanssi. Ao iniciar um sequenciador, \u00e9 necess\u00e1rio fornecer o arquivo de especifica\u00e7\u00e3o dessa cadeia como par\u00e2metro.</p> <p>Baixe o arquivo de especifica\u00e7\u00e3o da cadeia de orquestra\u00e7\u00e3o Tanssi executando:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#setup-data-directory","title":"Configurar o diret\u00f3rio de dados","text":"<p>Executar um sequenciador ou um n\u00f3 de appchain exige sincronizar duas cadeias: a cadeia de orquestra\u00e7\u00e3o do Tanssi e a appchain para a qual ele trabalha.</p> <p>Crie o diret\u00f3rio onde o n\u00f3 armazenar\u00e1 os bancos de dados contendo blocos e estados de cadeia:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Set the folder's ownership to the account that will run the Docker image to ensure writing permission:</p> Tanssi MainNetDancelight TestNet <pre><code>chown INSERT_DOCKER_USER /var/lib/tanssi-data\n</code></pre> <pre><code>chown INSERT_DOCKER_USER /var/lib/dancelight-data\n</code></pre> <p>Ou execute o comando abaixo se quiser rodar o sequenciador com o usu\u00e1rio logado:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data\n</code></pre> <p>Move the chain specification file to the folder:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Note</p> <p>O diret\u00f3rio \u00e9 um par\u00e2metro no comando de inicializa\u00e7\u00e3o do Docker. Se optar por criar o diret\u00f3rio em outro lugar, ajuste o comando.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#generate-node-key","title":"Gerar a Chave do N\u00f3","text":"<p>A partir da vers\u00e3o runtime 700, os n\u00f3s sequenciadores do Tanssi n\u00e3o geram as chaves de sess\u00e3o automaticamente na inicializa\u00e7\u00e3o. Para gerar e armazenar em disco as chaves de sess\u00e3o que ser\u00e3o referenciadas no comando de start, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi key generate-node-key --file /data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#start-up-command","title":"Comando de Inicializa\u00e7\u00e3o","text":"<p>Para iniciar seu n\u00f3, voc\u00ea deve executar a imagem Docker com o comando <code>docker run</code>.</p> <p>Observe que o comando cont\u00e9m duas se\u00e7\u00f5es, divididas por <code>-- \\</code>:</p> <ul> <li>Se\u00e7\u00e3o do protocolo Tanssi - cont\u00e9m os flags para executar o n\u00f3 Tanssi</li> <li>Se\u00e7\u00e3o do Sequenciador - cont\u00e9m os flags para executar o n\u00f3 sequenciador. \u00c9 abstrato o suficiente para ser adaptado dinamicamente em tempo de execu\u00e7\u00e3o \u00e0 cadeia espec\u00edfica que o n\u00f3 servir\u00e1</li> </ul> <p>D\u00ea um nome leg\u00edvel a cada se\u00e7\u00e3o, substituindo as tags <code>INSERT_YOUR_TANSSI_NODE_NAME</code> e <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> nos flags <code>--name</code>. Esses nomes ser\u00e3o \u00fateis para conectar as entradas de registro e as m\u00e9tricas com o n\u00f3 que as gera.         ```bash</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/tanssi-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\"\n</code></pre> GenericIntel SkylakeAMD Zen3 <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-skylake solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --entrypoint bash --network=\"host\" -v \"/var/lib/dancelight-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi -c \"/tanssi/tanssi-node-znver3 solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>Os flags usados no comando <code>docker run</code> podem ser ajustados de acordo com suas prefer\u00eancias e configura\u00e7\u00e3o de hardware. Os seguintes s\u00e3o alguns dos mais not\u00e1veis:     ```bash</p> <ul> <li><code>--name INSERT_NAME</code> - nome leg\u00edvel para este n\u00f3</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o n\u00f3 ouve</li> <li><code>--unsafe-rpc-external</code> - exp\u00f5e o servi\u00e7o RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (n\u00f3 atua como completo mantendo todo o estado), <code>archive-canonical</code> (mant\u00e9m apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados ser\u00e3o mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (n\u00f3 completo mantendo todos os blocos), <code>archive-canonical</code> (mant\u00e9m apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita sa\u00edda detalhada de logs</li> </ul> <p>Warning</p> <p>O par\u00e2metro <code>--unsafe-rpc-external</code> permite acesso externo \u00e0 interface RPC do seu n\u00f3, tornando-a acess\u00edvel de qualquer endere\u00e7o IP. Certifique-se de que controles de seguran\u00e7a adequados estejam configurados.</p> <p>Para ver a lista completa de flags dispon\u00edveis, descri\u00e7\u00e3o e valores poss\u00edveis, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>docker run moondancelabs/tanssi --help\n</code></pre> <pre><code>docker run moondancelabs/tanssi --help\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/#syncing-your-node","title":"Sincronizando Seu N\u00f3","text":"<p>A primeira vez que seu n\u00f3 \u00e9 iniciado, o processo de sincroniza\u00e7\u00e3o exibe muitas informa\u00e7\u00f5es de registro da configura\u00e7\u00e3o do n\u00f3 e do pr\u00f3prio n\u00f3. Alguns erros devem ser exibidos no in\u00edcio do processo, desaparecendo assim que a cadeia \u00e9 sincronizada com o \u00faltimo bloco.</p> docker run ....  2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] \ud83d\udca4 Idle (0 peers), best: #0 (0x4a2b\u20267de3), finalized #0 (0x4a2b\u20267de3), \u2b07 0 \u2b06 0      2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] \u2728 Imported #14139635 (0x8c41\u20268df6)          2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] \ud83d\udca4 Idle (8 peers), best: #14139635 (0x8c41\u20268df6), finalized #14139632 (0xa9a8\u2026cab9), \u2b07 32.7kiB/s \u2b06    <p>Quando a sincroniza\u00e7\u00e3o com o orquestrador Tanssi for conclu\u00edda, o n\u00f3 ainda precisar\u00e1 ser sincronizado com a rede a que foi designado. A sincroniza\u00e7\u00e3o com a cadeia servida pelo n\u00f3 sequenciador acontecer\u00e1 toda vez que o sequenciador for rotacionado.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/","title":"Executar um N\u00f3 de Sequenciador com Systemd","text":""},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Uma das principais propostas do Tanssi \u00e9 oferecer produ\u00e7\u00e3o de blocos descentralizada e sem confian\u00e7a para suas redes. O runtime do Tanssi gerencia a atribui\u00e7\u00e3o de sequenciadores para todas as redes ativas no ecossistema.</p> <p>O algoritmo de atribui\u00e7\u00e3o distribui o conjunto dispon\u00edvel de sequenciadores a cada sess\u00e3o, designando-os para uma cadeia aleat\u00f3ria. Assim, eles produzem blocos para a mesma rede por um per\u00edodo relativamente curto, aumentando a seguran\u00e7a geral do ecossistema.</p> <p>Para isso, o bin\u00e1rio do Tanssi (software usado para rodar n\u00f3s) j\u00e1 possui um mecanismo embutido que alterna automaticamente a produ\u00e7\u00e3o de blocos para a cadeia designada sem exigir altera\u00e7\u00f5es do operador. O bin\u00e1rio inclui a l\u00f3gica para sincronizar a nova cadeia e produzir blocos quando a sess\u00e3o muda. Portanto, os sequenciadores precisam executar o bin\u00e1rio do Tanssi, e n\u00e3o o das redes individuais (como fazem os n\u00f3s completos).</p> <p>Neste guia, voc\u00ea aprender\u00e1 como iniciar um sequenciador Tanssi para fazer parte do pool compartilhado de sequenciadores usando o bin\u00e1rio est\u00e1vel mais recente e gerenciando o servi\u00e7o com Systemd em sistemas Linux.</p> <p>O artigo segue a boa pr\u00e1tica de executar o servi\u00e7o com uma conta n\u00e3o root e conceder a essa conta acesso de escrita a um diret\u00f3rio espec\u00edfico. Voc\u00ea pode adaptar as etapas e instru\u00e7\u00f5es deste artigo \u00e0 configura\u00e7\u00e3o da sua infraestrutura, prefer\u00eancias e pol\u00edticas de seguran\u00e7a.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#checking-prerequisites","title":"Verificando os Pr\u00e9-requisitos","text":"<p>Para come\u00e7ar, voc\u00ea precisar\u00e1 de um computador executando Ubuntu Linux com privil\u00e9gios de root. Voc\u00ea tamb\u00e9m precisar\u00e1 de:</p> <ul> <li>Arquivo bin\u00e1rio do n\u00f3 - as instru\u00e7\u00f5es neste guia executam a vers\u00e3o est\u00e1vel mais recente oficial do <code>tanssi-node</code>. No entanto, voc\u00ea pode compilar seu pr\u00f3prio arquivo a partir do c\u00f3digo-fonte</li> <li>Arquivo de especifica\u00e7\u00e3o da rede Tanssi - o arquivo de especifica\u00e7\u00e3o pode ser baixado deste reposit\u00f3rio p\u00fablico do GitHub</li> </ul>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-latest-release","title":"Baixar a \u00daltima Vers\u00e3o","text":"<p>Para come\u00e7ar, fa\u00e7a o download e torne execut\u00e1vel a vers\u00e3o mais recente do bin\u00e1rio executando o seguinte comando:</p> <p>Note</p> <p>Recomenda-se usar as vers\u00f5es bin\u00e1rias otimizadas para as arquiteturas Skylake da Intel ou Zen3 da AMD para melhor desempenho.</p> Tanssi MainNetDancelight TestNet Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#download-tanssi-specs","title":"Baixar o arquivo de especifica\u00e7\u00e3o da cadeia Tanssi","text":"<p>O bin\u00e1rio do n\u00f3 tamb\u00e9m inclui o c\u00f3digo necess\u00e1rio para executar um n\u00f3 da cadeia de orquestra\u00e7\u00e3o do Tanssi. Ao iniciar um sequenciador, \u00e9 necess\u00e1rio fornecer o arquivo de especifica\u00e7\u00e3o dessa cadeia como par\u00e2metro.</p> <p>Baixe o arquivo de especifica\u00e7\u00e3o da cadeia de orquestra\u00e7\u00e3o Tanssi executando:</p> Tanssi MainNetDancelight TestNet <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#setup-systemd-service","title":"Configurar o servi\u00e7o Systemd","text":"<p>O Systemd \u00e9 um sistema de gerenciamento para Linux que controla servi\u00e7os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.</p> <p>Os comandos a seguir configuram uma nova conta, o diret\u00f3rio e movem os arquivos baixados para o local correto.</p> <p>Crie uma nova conta para executar o servi\u00e7o:</p> Tanssi MainNetDancelight TestNet <pre><code>adduser tanssi_service --system --no-create-home\n</code></pre> <pre><code>adduser dancelight_service --system --no-create-home\n</code></pre> <p>Crie um diret\u00f3rio para armazenar os arquivos e dados necess\u00e1rios:</p> Tanssi MainNetDancelight TestNet <pre><code>mkdir /var/lib/tanssi-data\n</code></pre> <pre><code>mkdir /var/lib/dancelight-data\n</code></pre> <p>Defina a propriedade da pasta para a conta que executar\u00e1 o servi\u00e7o, garantindo permiss\u00e3o de escrita:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo chown -R tanssi_service /var/lib/tanssi-data\n</code></pre> <pre><code>sudo chown -R dancelight_service /var/lib/dancelight-data\n</code></pre> <p>Mova o arquivo de especifica\u00e7\u00e3o da cadeia para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./starlight-raw-specs.json /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./dancelight-raw-specs.json /var/lib/dancelight-data\n</code></pre> <p>Por fim, mova o bin\u00e1rio para a pasta:</p> Tanssi MainNetDancelight TestNet <pre><code>mv ./tanssi-node /var/lib/tanssi-data\n</code></pre> <pre><code>mv ./tanssi-node /var/lib/dancelight-data\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#generate-node-key","title":"Gerar a Chave do N\u00f3","text":"<p>A partir da vers\u00e3o runtime 700, os n\u00f3s sequenciadores do Tanssi n\u00e3o geram as chaves de sess\u00e3o automaticamente na inicializa\u00e7\u00e3o. Para gerar e armazenar em disco as chaves de sess\u00e3o que ser\u00e3o referenciadas no comando de start, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node key generate-node-key --file /var/lib/tanssi-data/node-key\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node key generate-node-key --file /var/lib/dancelight-data/node-key\n</code></pre> <p>Note</p> <p>Esta etapa poderia ser evitada usando o par\u00e2metro <code>--unsafe-force-node-key-generation</code> no comando de inicializa\u00e7\u00e3o, embora essa n\u00e3o seja a pr\u00e1tica recomendada.</p>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#create-systemd-configuration","title":"Criar o Arquivo de Configura\u00e7\u00e3o do Systemd","text":"<p>O pr\u00f3ximo passo \u00e9 criar o arquivo de configura\u00e7\u00e3o do Systemd.</p> <p>Voc\u00ea pode criar o arquivo executando o comando:</p> Tanssi MainNetDancelight TestNet <pre><code>sudo touch /etc/systemd/system/tanssi.service\n</code></pre> <pre><code>sudo touch /etc/systemd/system/dancelight.service\n</code></pre> <p>Agora abra o arquivo com seu editor de texto favorito (vim, emacs, nano etc.) e adicione a configura\u00e7\u00e3o do servi\u00e7o, substituindo as tags <code>INSERT_YOUR_TANSSI_NODE_NAME</code> e <code>INSERT_YOUR_SEQUENCER_NODE_NAME</code> por nomes leg\u00edveis nos flags <code>--name</code>. Esses nomes ajudam a conectar entradas de log e m\u00e9tricas ao n\u00f3 que as gera.</p> Tanssi MainNetDancelight TestNet <pre><code>[Unit]\nDescription=\"Tanssi systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=tanssi_service\nSyslogIdentifier=tanssi\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/tanssi-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/tanssi-data/container \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/tanssi-data/starlight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/tanssi-data/relay \\\n--node-key-file=/var/lib/tanssi-data/node-key \\\n--keystore-path=/var/lib/tanssi-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \\\n--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \\\n--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \\\n--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \\\n--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>[Unit]\nDescription=\"Dancelight systemd service\"\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=10\nUser=dancelight_service\nSyslogIdentifier=dancelight\nSyslogFacility=local7\nKillSignal=SIGHUP\nExecStart=/var/lib/dancelight-data/tanssi-node solo-chain \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/var/lib/dancelight-data/container \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/var/lib/dancelight-data/relay \\\n--node-key-file=/var/lib/dancelight-data/node-key \\\n--keystore-path=/var/lib/dancelight-data/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-flags","title":"Flags de Execu\u00e7\u00e3o","text":"<p>Os flags usados no comando <code>ExecStart</code> podem ser ajustados conforme suas prefer\u00eancias e configura\u00e7\u00e3o de hardware. Alguns dos mais importantes s\u00e3o:</p> <ul> <li><code>--name INSERT_NAME</code> - nome leg\u00edvel para este n\u00f3</li> <li><code>--rpc-port INSERT_PORT</code> - define a porta TCP do JSON-RPC na qual o n\u00f3 ouve</li> <li><code>--unsafe-rpc-external</code> - exp\u00f5e o servi\u00e7o RPC em todas as interfaces</li> <li><code>--state-pruning INSERT_STATE_PRUNING_TYPE</code> - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser <code>archive</code> (n\u00f3 atua como completo mantendo todo o estado), <code>archive-canonical</code> (mant\u00e9m apenas estados de blocos finalizados) ou um <code>number</code> (quantidade de blocos cujos estados ser\u00e3o mantidos)</li> <li><code>--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE</code> - define quantos blocos devem ser mantidos no banco de dados. Pode ser <code>archive</code> (n\u00f3 completo mantendo todos os blocos), <code>archive-canonical</code> (mant\u00e9m apenas blocos finalizados) ou um <code>number</code> (quantidade de blocos finalizados a manter)</li> <li><code>--detailed-log-output</code> - habilita sa\u00edda detalhada de logs</li> </ul> <p>Warning</p> <p>O par\u00e2metro <code>--unsafe-rpc-external</code> permite acesso externo \u00e0 interface RPC do seu n\u00f3, tornando-a acess\u00edvel de qualquer endere\u00e7o IP. Certifique-se de que controles de seguran\u00e7a adequados estejam configurados.</p> <p>Para ver a lista completa de flags dispon\u00edveis, descri\u00e7\u00e3o e valores poss\u00edveis, execute:</p> Tanssi MainNetDancelight TestNet <pre><code>/var/lib/tanssi-data/tanssi-node  --help\n</code></pre> <pre><code>/var/lib/dancelight-data/tanssi-node  --help\n</code></pre>"},{"location":"pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/#run-the-service","title":"Executar o Servi\u00e7o","text":"<p>Por fim, habilite o servi\u00e7o e inicie-o pela primeira vez:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl enable tanssi.service &amp;&amp; \\\nsystemctl start tanssi.service\n</code></pre> <pre><code>systemctl enable dancelight.service &amp;&amp; \\\nsystemctl start dancelight.service\n</code></pre> <p>Voc\u00ea pode verificar se o servi\u00e7o est\u00e1 em execu\u00e7\u00e3o corretamente:</p> Tanssi MainNetDancelight TestNet <pre><code>systemctl status tanssi.service\n</code></pre> <pre><code>systemctl status dancelight.service\n</code></pre> <p>Se precisar verificar os logs, use:</p> Tanssi MainNetDancelight TestNet <pre><code>journalctl -f -u tanssi.service\n</code></pre> <pre><code>journalctl -f -u dancelight.service\n</code></pre>"},{"location":"pt/node-operators/sequencers/operational-tasks/","title":"Tarefa Operacional","text":"<p>Manter seu sequenciador em funcionamento \u00e9 mais do que apenas a configura\u00e7\u00e3o - requer manuten\u00e7\u00e3o regular para garantir desempenho consistente e gerenciamento seguro de suas contas. As atualiza\u00e7\u00f5es regulares s\u00e3o essenciais para manter seu n\u00f3 compat\u00edvel com as \u00faltimas mudan\u00e7as do protocolo Tanssi, enquanto ferramentas como contas proxy fornecem uma camada extra de seguran\u00e7a, permitindo que voc\u00ea delegue certas tarefas sem expor suas credenciais de conta prim\u00e1rias. Esta se\u00e7\u00e3o fornece os passos necess\u00e1rios para manter suas opera\u00e7\u00f5es tranquilas, confi\u00e1veis e seguras.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/#explore-esta-secao","title":"Explore esta se\u00e7\u00e3o","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/","title":"Configurar uma Conta Proxy","text":""},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Contas proxy podem ser configuradas para realizar um n\u00famero limitado de a\u00e7\u00f5es em nome de contas prim\u00e1rias e ajudar a manter as contas subjacentes seguras. Como sequenciador no Tanssi, \u00e9 uma boa ideia aproveitar as contas proxy para interagir com a rede em vez de sua conta sequenciadora.</p> <p>O tipo de proxy de staking permite convenientemente que a conta proxy gerencie atividades de staking, como delegar e rotacionar chaves de sess\u00e3o, em nome da conta sequenciadora prim\u00e1ria, transformando-a efetivamente em uma \"hot wallet\" para realizar tarefas regulares de manuten\u00e7\u00e3o em nome de sua conta sequenciadora \"cold wallet\". Para maior seguran\u00e7a, voc\u00ea pode rotacionar regularmente a conta proxy.</p> <p>Contas proxy tamb\u00e9m podem ajud\u00e1-lo a implementar o princ\u00edpio de privil\u00e9gio m\u00ednimo para controle de acesso. Por exemplo, se voc\u00ea tiver v\u00e1rios membros da equipe, poder\u00e1 fornecer a eles o acesso m\u00ednimo necess\u00e1rio para realizar suas tarefas por meio de uma conta proxy espec\u00edfica.</p> <p>Este tutorial ir\u00e1 gui\u00e1-lo pela configura\u00e7\u00e3o de uma conta proxy de staking no Dancelight especificamente para opera\u00e7\u00f5es como um sequenciador. Em seguida, demonstrar\u00e1 como iniciar uma delega\u00e7\u00e3o usando o novo proxy de staking criado.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/#checking-prerequisites","title":"Verificando Pr\u00e9-requisitos","text":"<p>Para acompanhar este tutorial, voc\u00ea precisar\u00e1 ter:</p> <ul> <li>O portal do desenvolvedor aberto e conectado ao Dancelight</li> <li>Criar ou ter duas contas acess\u00edveis no portal do desenvolvedor</li> <li>Ambas as contas precisar\u00e3o ser financiadas, e a conta do sequenciador precisar\u00e1 de pelo menos a autodelega\u00e7\u00e3o m\u00ednima necess\u00e1ria para se tornar um sequenciador ativo (10000 STAR para Dancelight)</li> </ul> <p>Se voc\u00ea precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia Conectando-se ao Portal do Desenvolvedor.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/#creating-a-staking-proxy-account","title":"Criando uma Conta Proxy de Staking","text":"<p>H\u00e1 algumas maneiras de criar contas proxy no portal do desenvolvedor, seja na p\u00e1gina Extrinsics ou na p\u00e1gina Accounts. No entanto, para criar um proxy com atraso de tempo, voc\u00ea precisar\u00e1 usar a p\u00e1gina Extrinsics. Um atraso de tempo fornece uma camada adicional de seguran\u00e7a aos proxies, especificando um per\u00edodo de atraso com base no n\u00famero de blocos. Isso impedir\u00e1 que a conta proxy execute uma transa\u00e7\u00e3o at\u00e9 que o per\u00edodo de atraso termine. O atraso d\u00e1 tempo para que a conta prim\u00e1ria que controla o proxy revise as transa\u00e7\u00f5es pendentes e fornece um per\u00edodo limitado de tempo para cancelar quaisquer a\u00e7\u00f5es.</p> <p>Voc\u00ea tamb\u00e9m tem a op\u00e7\u00e3o de criar um proxy do tipo Any, que concede \u00e0 conta proxy controle total e irrestrito sobre a conta prim\u00e1ria. Isso significa que a conta proxy pode transferir fundos e realizar qualquer a\u00e7\u00e3o arbitr\u00e1ria. A demonstra\u00e7\u00e3o a seguir mostrar\u00e1 como configurar um proxy Staking, que \u00e9 mais restritivo do que um proxy Any, pois limita as fun\u00e7\u00f5es \u00e0s atividades relacionadas ao staking, como delegar, n\u00e3o delegar e mapear chaves de sess\u00e3o.</p> <p>Para come\u00e7ar a criar sua conta proxy, v\u00e1 para a aba Developer e selecione Extrinsics no menu suspenso. Em seguida, voc\u00ea precisar\u00e1 seguir as seguintes etapas:</p> <ol> <li>Selecione a conta prim\u00e1ria</li> <li>No menu suspenso submit the following extrinsic, selecione proxy</li> <li>Escolha a extr\u00ednseca addProxy</li> <li>Escolha Id no menu suspenso AccountIdLookupOf</li> <li>Selecione a conta de delegate para o proxy</li> <li>No menu suspenso proxyType, escolha Staking</li> <li>Opcionalmente, voc\u00ea pode adicionar um atraso de tempo usando um n\u00famero especificado de blocos para adicionar uma camada adicional de seguran\u00e7a para que a conta prim\u00e1ria revise a transa\u00e7\u00e3o pendente</li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Voc\u00ea ser\u00e1 solicitado a autorizar e assinar a transa\u00e7\u00e3o. Clique em Sign and Submit para criar o relacionamento proxy. Depois que a transa\u00e7\u00e3o for enviada com sucesso, voc\u00ea receber\u00e1 algumas notifica\u00e7\u00f5es confirmando a transa\u00e7\u00e3o.</p> <p>Como mencionado anteriormente, voc\u00ea tamb\u00e9m pode criar um proxy na p\u00e1gina Accounts. Para fazer isso, navegue at\u00e9 a p\u00e1gina Accounts e siga as seguintes etapas:</p> <ol> <li>Selecione os tr\u00eas pontos verticais pr\u00f3ximos \u00e0 conta prim\u00e1ria</li> <li>Selecione Add proxy</li> </ol> <p></p> <p>Nota</p> <p>Se a conta j\u00e1 tiver um proxy, Manage proxies ser\u00e1 exibido como uma op\u00e7\u00e3o em vez de Add proxy.</p> <p>Uma janela pop-up aparecer\u00e1 e voc\u00ea poder\u00e1 inserir as informa\u00e7\u00f5es necess\u00e1rias, como a conta proxy/prim\u00e1ria, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em Add proxy.</p> <p></p> <p>Em seguida, siga as seguintes etapas:</p> <ol> <li>Selecione a conta que voc\u00ea gostaria de definir como um proxy</li> <li>Selecione o tipo de proxy</li> <li>Clique em Submit e assine a transa\u00e7\u00e3o</li> </ol> <p></p> <p>Na pr\u00f3xima se\u00e7\u00e3o, voc\u00ea aprender\u00e1 como verificar se sua conta proxy foi configurada com sucesso.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/#verifying-your-proxy-account","title":"Verificando Sua Conta Proxy","text":"<p>Voc\u00ea pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: ou na p\u00e1gina Accounts ou na p\u00e1gina Chain state.</p> <p>Para verificar suas contas proxy na p\u00e1gina Chain state, voc\u00ea pode seguir as seguintes etapas:</p> <ol> <li>No menu suspenso selected state query, selecione proxy</li> <li>Escolha a extr\u00ednseca proxies</li> <li>Selecione sua conta prim\u00e1ria/proxy</li> <li>Clique no bot\u00e3o + para enviar a consulta</li> </ol> <p></p> <p>O resultado aparecer\u00e1 na p\u00e1gina mostrando informa\u00e7\u00f5es sobre todos os seus proxies, incluindo o endere\u00e7o da conta delegate/proxy, o tipo de proxy, o per\u00edodo de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.</p> <p>Voc\u00ea tamb\u00e9m pode verificar suas contas proxy na p\u00e1gina Accounts. Para fazer isso, navegue at\u00e9 a p\u00e1gina Accounts e deve haver um s\u00edmbolo de Proxy ao lado da conta prim\u00e1ria. Passe o mouse sobre o \u00edcone e clique em Manage proxies para revisar seus proxies.</p> <p></p> <p>Uma janela pop-up aparecer\u00e1 onde voc\u00ea pode ver uma vis\u00e3o geral de todas as suas contas proxy.</p> <p></p>"},{"location":"pt/node-operators/sequencers/operational-tasks/proxy-accounts/#executing-a-proxy-transaction","title":"Executando uma Transa\u00e7\u00e3o Proxy","text":"<p>Agora que voc\u00ea criou uma conta proxy e verificou que ela foi configurada com sucesso, voc\u00ea pode executar uma transa\u00e7\u00e3o usando a conta proxy de staking em nome de sua conta sequenciadora, tamb\u00e9m conhecida como conta prim\u00e1ria ou conta que est\u00e1 sendo proxyada. O exemplo a seguir demonstrar\u00e1 como iniciar uma autodelega\u00e7\u00e3o. A configura\u00e7\u00e3o de proxy mostrada \u00e9 um exemplo realista de como voc\u00ea pode ter seu pr\u00f3prio proxy configurado para sua conta prim\u00e1ria do portal do desenvolvedor.</p> <p>Para executar uma transa\u00e7\u00e3o, voc\u00ea pode navegar de volta para a p\u00e1gina Extrinsics e seguir as seguintes etapas:</p> <ol> <li>Selecione a conta proxy para enviar a transa\u00e7\u00e3o no menu suspenso using the select account</li> <li>No menu submit the following extrinsic, selecione proxy</li> <li>Escolha a extr\u00ednseca proxy</li> <li>Escolha Id no menu suspenso AccountIdLookupOf</li> <li>Selecione a conta prim\u00e1ria no menu suspenso real</li> <li>Selecione a chamada pooledStaking</li> <li>Escolha a extr\u00ednseca requestDelegate</li> <li>Digite o endere\u00e7o do candidate, que \u00e9 a conta do sequenciador</li> <li>Selecione AutoCompounding ou ManualRewards no campo pool</li> <li>Digite o valor a ser apostado. Esse valor deve atender ao m\u00ednimo, que, para Dancelight, \u00e9 10000 STAR tokens. Voc\u00ea precisar\u00e1 enviar o valor incluindo as doze casas decimais que a Tanssi Network usa, portanto, para um valor de 10000, voc\u00ea precisar\u00e1 digitar <code>10000000000000000</code></li> <li>Clique em Submit Transaction</li> </ol> <p></p> <p>Uma janela pop-up aparecer\u00e1 para que voc\u00ea autorize e assine a transa\u00e7\u00e3o. Digite sua senha para a conta proxy e clique em Sign and Submit. Para confirmar a solicita\u00e7\u00e3o de delega\u00e7\u00e3o, voc\u00ea precisar\u00e1 executar a solicita\u00e7\u00e3o pendente ap\u00f3s duas sess\u00f5es. Consulte as instru\u00e7\u00f5es para executar solicita\u00e7\u00f5es pendentes para obter um guia passo a passo. Voc\u00ea tamb\u00e9m pode mapear suas chaves de sess\u00e3o para sua conta de sequenciador via proxy.</p> <p>Depois de mapear suas chaves de sess\u00e3o e executar a solicita\u00e7\u00e3o de delega\u00e7\u00e3o pendente, voc\u00ea pode verificar se seu sequenciador est\u00e1 na lista de candidatos eleg\u00edveis.</p> <p>\u00c9 isso! Voc\u00ea executou com sucesso uma transa\u00e7\u00e3o usando uma conta proxy em nome de sua conta sequenciadora prim\u00e1ria.</p>    As informa\u00e7\u00f5es apresentadas aqui foram fornecidas por terceiros e est\u00e3o dispon\u00edveis apenas para fins informativos gerais. A Tanssi n\u00e3o endossa nenhum projeto listado e descrito no Site de Documenta\u00e7\u00e3o da Tanssi (https://docs.tanssi.network/). A Tanssi Foundation n\u00e3o garante a precis\u00e3o, integridade ou utilidade dessas informa\u00e7\u00f5es. Qualquer confian\u00e7a depositada nelas \u00e9 de sua exclusiva responsabilidade. A Tanssi Foundation se exime de toda responsabilidade decorrente de qualquer confian\u00e7a que voc\u00ea ou qualquer outra pessoa possa ter em qualquer parte deste conte\u00fado. Todas as declara\u00e7\u00f5es e/ou opini\u00f5es expressas nesses materiais s\u00e3o de responsabilidade exclusiva da pessoa ou entidade que as fornece e n\u00e3o representam necessariamente a opini\u00e3o da Tanssi Foundation. As informa\u00e7\u00f5es aqui n\u00e3o devem ser interpretadas como aconselhamento profissional ou financeiro de qualquer tipo. Sempre busque orienta\u00e7\u00e3o de um profissional devidamente qualificado em rela\u00e7\u00e3o a qualquer assunto ou circunst\u00e2ncia em particular. As informa\u00e7\u00f5es aqui podem conter links ou integra\u00e7\u00e3o com outros sites operados ou conte\u00fado fornecido por terceiros, e tais sites podem apontar para este site. A Tanssi Foundation n\u00e3o tem controle sobre esses sites ou seu conte\u00fado e n\u00e3o ter\u00e1 responsabilidade decorrente ou relacionada a eles. A exist\u00eancia de qualquer link n\u00e3o constitui endosso desses sites, de seu conte\u00fado ou de seus operadores. Esses links s\u00e3o fornecidos apenas para sua conveni\u00eancia, e voc\u00ea isenta e exonera a Tanssi Foundation de qualquer responsabilidade decorrente do uso dessas informa\u00e7\u00f5es ou das informa\u00e7\u00f5es fornecidas por qualquer site ou servi\u00e7o de terceiros."},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/","title":"Atualizar N\u00f3 de Sequenciadores","text":"<p>A manuten\u00e7\u00e3o do seu n\u00f3 atualizado \u00e9 fundamental para manter a compatibilidade com as \u00faltimas altera\u00e7\u00f5es do protocolo Tanssi e garantir o desempenho ideal. N\u00f3s desatualizados podem levar \u00e0 dessincroniza\u00e7\u00e3o, redu\u00e7\u00e3o da efici\u00eancia ou at\u00e9 mesmo \u00e0 incapacidade de participar da produ\u00e7\u00e3o de blocos. Ao manter-se atualizado com os lan\u00e7amentos de clientes, voc\u00ea pode garantir que seu n\u00f3 opere de forma segura e confi\u00e1vel na rede.</p> <p>Assine as notifica\u00e7\u00f5es de lan\u00e7amento</p> <p>Ficar informado sobre novas vers\u00f5es do cliente \u00e9 essencial para manter o n\u00f3 atualizado. Os mantenedores do n\u00f3 podem assinar as notifica\u00e7\u00f5es do GitHub para serem alertados sobre novas vers\u00f5es.</p> <p>Para assinar, acesse o reposit\u00f3rio Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a op\u00e7\u00e3o Releases.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/#explore-o-que-esta-secao-cobre","title":"Explore o Que Esta Se\u00e7\u00e3o Cobre","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/","title":"Atualize seu N\u00f3 em Execu\u00e7\u00e3o via Docker","text":""},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Manter seu n\u00f3 atualizado \u00e9 uma parte importante de ser um sequencer Tanssi. N\u00e3o s\u00f3 ajuda a garantir que seu n\u00f3 sequencer permane\u00e7a saud\u00e1vel, mas tamb\u00e9m contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualiza\u00e7\u00e3o do seu sequencer Tanssi que foi configurado usando o Docker. Ele pressup\u00f5e que voc\u00ea j\u00e1 configurou sua conta e lan\u00e7ou um sequencer usando Docker.</p> <p>Assine as notifica\u00e7\u00f5es de lan\u00e7amento</p> <p>Ficar informado sobre novas vers\u00f5es do cliente \u00e9 essencial para manter o n\u00f3 atualizado. Os mantenedores do n\u00f3 podem assinar as notifica\u00e7\u00f5es do GitHub para serem alertados sobre novas vers\u00f5es.</p> <p>Para assinar, acesse o reposit\u00f3rio Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a op\u00e7\u00e3o Releases.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#upgrading-docker-nodes","title":"Atualizando N\u00f3s Docker","text":"<p>Se voc\u00ea estiver executando seu sequencer com o Docker, atualizar seu n\u00f3 \u00e9 t\u00e3o simples quanto parar o cont\u00eainer em execu\u00e7\u00e3o e reinici\u00e1-lo com a nova tag de vers\u00e3o.</p> <p>Primeiro, obtenha a ID do cont\u00eainer do seu n\u00f3 sequencer Tanssi com o seguinte comando:</p> <pre><code>docker ps -a\n</code></pre> <p>A ID do cont\u00eainer \u00e9 a primeira coluna e, se voc\u00ea estiver executando v\u00e1rios cont\u00eaineres Docker, pode identific\u00e1-lo pelo nome da imagem de <code>moondancelabs/tanssi</code>. Voc\u00ea pode executar o comando de parada da seguinte forma:</p> <pre><code>docker stop INSERT_YOUR_CONTAINER_ID\n</code></pre> <p>A sua intera\u00e7\u00e3o com o terminal ser\u00e1 semelhante ao seguinte:</p> docker ps -a  CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES      aa751703d6aa moondancelabs/tanssi:v0.6.1 \"/tanssi/tanssi-node\u2026\" 56 seconds ago  Up 56 seconds             focused_chaum      docker stop aa751703d6aa  aa751703d6aa    <p>Para reiniciar o n\u00f3, voc\u00ea pode usar o mesmo comando que usou ao iniciar seu n\u00f3 pela primeira vez. O comando extrai a imagem e o n\u00f3 retomar\u00e1 a sincroniza\u00e7\u00e3o de blocos de onde parou quando o processo Docker foi interrompido.</p> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-skylake\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre> <pre><code>docker run --network=\"host\" -v \"/var/lib/dancebox:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n--entrypoint \"/tanssi/tanssi-node-znver3\" \\\nmoondancelabs/tanssi \\\n--name=INSERT_YOUR_SEQUENCER_NODE_NAME \\\n--base-path=/data/container \\\n--node-key-file=/data/node-key \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--pool-type=fork-aware \\\n--database=paritydb \\\n--rpc-port=9944 \\\n--prometheus-port=9615 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30333 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--db-cache=1024 \\\n--trie-cache-size=1073741824 \\\n--collator \\\n--in-peers=100 \\\n--detailed-log-output \\\n-- \\\n--chain=/data/dancelight-raw-specs.json \\\n--name=INSERT_YOUR_TANSSI_NODE_NAME \\\n--sync=fast \\\n--base-path=/data/relay \\\n--node-key-file=/data/node-key \\\n--keystore-path=/data/keys/session \\\n--database=paritydb \\\n--rpc-port=9945 \\\n--prometheus-port=9616 \\\n--prometheus-external \\\n--listen-addr=/ip4/0.0.0.0/tcp/30334 \\\n--pool-limit=0 \\\n--db-cache=128 \\\n--out-peers=15 \\\n--state-pruning=2000 \\\n--blocks-pruning=2000 \\\n--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \\\n--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \\\n--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \\\n--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT\"\n</code></pre>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/#specifying-a-version-tag","title":"Especificando uma Tag de Vers\u00e3o","text":"<p>Se voc\u00ea quiser especificar uma tag de vers\u00e3o espec\u00edfica, voc\u00ea pode fazer isso substituindo a tag de vers\u00e3o anexada ao nome da imagem. Por exemplo, se voc\u00ea quisesse buscar a vers\u00e3o <code>3</code>, voc\u00ea substituiria o <code>2</code> em <code>moondancelabs/tanssi</code>.</p> <p>E \u00e9 isso! Voc\u00ea atualizou com sucesso seu n\u00f3 Tanssi.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/","title":"Atualize seu N\u00f3 em Execu\u00e7\u00e3o via Systemd","text":""},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#introduction","title":"Introdu\u00e7\u00e3o","text":"<p>Manter seu n\u00f3 atualizado \u00e9 uma parte importante de ser um sequencer Tanssi. Isso n\u00e3o s\u00f3 ajuda a garantir que seu n\u00f3 sequencer permane\u00e7a saud\u00e1vel, como tamb\u00e9m contribui para manter toda a Rede Tanssi funcionando sem problemas.</p> <p>Este tutorial aborda a atualiza\u00e7\u00e3o do seu n\u00f3 sequencer Tanssi que foi configurado usando o Systemd. Ele pressup\u00f5e que voc\u00ea j\u00e1 configurou sua conta e lan\u00e7ou um n\u00f3 sequencer usando Systemd.</p> <p>Assine as notifica\u00e7\u00f5es de lan\u00e7amento</p> <p>Ficar informado sobre novas vers\u00f5es do cliente \u00e9 essencial para manter o n\u00f3 atualizado. Os mantenedores do n\u00f3 podem assinar as notifica\u00e7\u00f5es do GitHub para serem alertados sobre novas vers\u00f5es.</p> <p>Para assinar, acesse o reposit\u00f3rio Tanssi no GitHub e clique em Watch. Selecione Custom notifications e marque a op\u00e7\u00e3o Releases.</p>"},{"location":"pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/#upgrading-your-systemd-node","title":"Atualizando seu N\u00f3 Systemd","text":"<p>Se voc\u00ea estiver executando seu sequencer atrav\u00e9s do servi\u00e7o Systemd, voc\u00ea precisar\u00e1 seguir algumas etapas para atualizar corretamente seu n\u00f3. Em suma, voc\u00ea precisar\u00e1 parar o servi\u00e7o, substituir o bin\u00e1rio Tanssi pela vers\u00e3o atualizada e, em seguida, iniciar o servi\u00e7o.</p> <p>Voc\u00ea pode parar seu servi\u00e7o Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl stop tanssi.service\n</code></pre> <p>Em seguida, navegue at\u00e9 o diret\u00f3rio onde seu bin\u00e1rio Tanssi est\u00e1 armazenado e remova-o.</p> <pre><code>cd /var/lib/tanssi-data\n</code></pre> <p>Seu arquivo bin\u00e1rio Tanssi provavelmente ser\u00e1 nomeado <code>tanssi-node</code>. Caso contr\u00e1rio, voc\u00ea pode substituir <code>tanssi-node</code> abaixo pelo nome correto do seu arquivo bin\u00e1rio Tanssi.</p> <pre><code>rm tanssi-node\n</code></pre> <p>Para baixar a vers\u00e3o mais recente e alterar as permiss\u00f5es para que o servi\u00e7o Tanssi possa us\u00e1-la, execute o seguinte comando que corresponde ao seu ambiente:</p> Gen\u00e9ricoIntel SkylakeAMD Zen3 <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-skylake -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <pre><code>wget https://github.com/moondance-labs/tanssi/releases/download/v0.15.0-para/tanssi-node-znver3 -O tanssi-node &amp;&amp; \\\nchmod +x ./tanssi-node\n</code></pre> <p>Voc\u00ea pode reiniciar seu servi\u00e7o Tanssi Systemd com o seguinte comando:</p> <pre><code>systemctl start tanssi.service\n</code></pre> <p>O n\u00f3 retomar\u00e1 a sincroniza\u00e7\u00e3o de blocos de onde parou quando o servi\u00e7o Systemd foi interrompido. Para verificar se est\u00e1 funcionando corretamente, voc\u00ea pode usar o seguinte comando para verificar os logs:</p> <pre><code>systemctl status tanssi.service\n</code></pre> <p>E \u00e9 isso! Voc\u00ea atualizou seu n\u00f3 Tanssi com sucesso.</p>"}]}